
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 e0 22 04 80 	movabs $0x800422e038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 e0 22 04 80 	movabs $0x800422e000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 1d 01 20 04 80 	movabs $0x800420011d,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 80 e7 22 04 80 	movabs $0x800422e780,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 7c 6d 21 04 80 	movabs $0x8004216d7c,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <test_backtrace>:
static void boot_aps(void);

// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
  800420009d:	48 83 ec 10          	sub    $0x10,%rsp
  80042000a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042000a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000a7:	89 c6                	mov    %eax,%esi
  80042000a9:	48 bf 80 84 21 04 80 	movabs $0x8004218480,%rdi
  80042000b0:	00 00 00 
  80042000b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b8:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042000bf:	00 00 00 
  80042000c2:	ff d2                	callq  *%rdx
	if (x > 0)
  80042000c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042000c8:	7e 16                	jle    80042000e0 <test_backtrace+0x47>
		test_backtrace(x-1);
  80042000ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000cd:	83 e8 01             	sub    $0x1,%eax
  80042000d0:	89 c7                	mov    %eax,%edi
  80042000d2:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  80042000d9:	00 00 00 
  80042000dc:	ff d0                	callq  *%rax
  80042000de:	eb 1b                	jmp    80042000fb <test_backtrace+0x62>
	else
		mon_backtrace(0, 0, 0);
  80042000e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042000e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042000ef:	48 b8 6b 16 20 04 80 	movabs $0x800420166b,%rax
  80042000f6:	00 00 00 
  80042000f9:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  80042000fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000fe:	89 c6                	mov    %eax,%esi
  8004200100:	48 bf 9c 84 21 04 80 	movabs $0x800421849c,%rdi
  8004200107:	00 00 00 
  800420010a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420010f:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004200116:	00 00 00 
  8004200119:	ff d2                	callq  *%rdx
}
  800420011b:	c9                   	leaveq 
  800420011c:	c3                   	retq   

000000800420011d <i386_init>:


void
i386_init(void)
{
  800420011d:	55                   	push   %rbp
  800420011e:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  8004200121:	48 ba 18 00 69 04 80 	movabs $0x8004690018,%rdx
  8004200128:	00 00 00 
  800420012b:	48 b8 72 9b 60 04 80 	movabs $0x8004609b72,%rax
  8004200132:	00 00 00 
  8004200135:	48 29 c2             	sub    %rax,%rdx
  8004200138:	48 89 d0             	mov    %rdx,%rax
  800420013b:	48 89 c2             	mov    %rax,%rdx
  800420013e:	be 00 00 00 00       	mov    $0x0,%esi
  8004200143:	48 bf 72 9b 60 04 80 	movabs $0x8004609b72,%rdi
  800420014a:	00 00 00 
  800420014d:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004200154:	00 00 00 
  8004200157:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200159:	48 b8 0f 12 20 04 80 	movabs $0x800420120f,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200165:	be ac 1a 00 00       	mov    $0x1aac,%esi
  800420016a:	48 bf b7 84 21 04 80 	movabs $0x80042184b7,%rdi
  8004200171:	00 00 00 
  8004200174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200179:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004200180:	00 00 00 
  8004200183:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200185:	48 b8 18 00 69 04 80 	movabs $0x8004690018,%rax
  800420018c:	00 00 00 
  800420018f:	48 89 c6             	mov    %rax,%rsi
  8004200192:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200199:	00 00 00 
  800420019c:	48 b8 75 54 21 04 80 	movabs $0x8004215475,%rax
  80042001a3:	00 00 00 
  80042001a6:	ff d0                	callq  *%rax
  80042001a8:	48 ba 38 d4 60 04 80 	movabs $0x800460d438,%rdx
  80042001af:	00 00 00 
  80042001b2:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001ba:	48 ba 23 27 20 04 80 	movabs $0x8004202723,%rdx
  80042001c1:	00 00 00 
  80042001c4:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  80042001c6:	48 b8 e6 79 20 04 80 	movabs $0x80042079e6,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	trap_init();
  80042001d2:	48 b8 56 8f 20 04 80 	movabs $0x8004208f56,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  80042001de:	48 b8 fd 63 21 04 80 	movabs $0x80042163fd,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax
	lapic_init();
  80042001ea:	48 b8 fa 67 21 04 80 	movabs $0x80042167fa,%rax
  80042001f1:	00 00 00 
  80042001f4:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001f6:	48 b8 de 8a 20 04 80 	movabs $0x8004208ade,%rax
  80042001fd:	00 00 00 
  8004200200:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  8004200202:	48 b8 da 83 21 04 80 	movabs $0x80042183da,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
	pci_init();
  800420020e:	48 b8 9e 83 21 04 80 	movabs $0x800421839e,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	//Starting non-boot CPUs
	lock_kernel();
  800420021a:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200221:	00 00 00 
  8004200224:	ff d0                	callq  *%rax
	boot_aps();
  8004200226:	48 b8 74 02 20 04 80 	movabs $0x8004200274,%rax
  800420022d:	00 00 00 
  8004200230:	ff d0                	callq  *%rax
	// Start fs.
//	ENV_CREATE(fs_fs, ENV_TYPE_FS);

#if !defined(TEST_NO_NS) && !defined(VMM_GUEST)
	// Start ns.
	ENV_CREATE(net_ns, ENV_TYPE_NS);
  8004200232:	be 02 00 00 00       	mov    $0x2,%esi
  8004200237:	48 bf 17 30 4e 04 80 	movabs $0x80044e3017,%rdi
  800420023e:	00 00 00 
  8004200241:	48 b8 aa 80 20 04 80 	movabs $0x80042080aa,%rax
  8004200248:	00 00 00 
  800420024b:	ff d0                	callq  *%rax
#endif

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  800420024d:	be 00 00 00 00       	mov    $0x0,%esi
  8004200252:	48 bf b4 a0 46 04 80 	movabs $0x800446a0b4,%rdi
  8004200259:	00 00 00 
  800420025c:	48 b8 aa 80 20 04 80 	movabs $0x80042080aa,%rax
  8004200263:	00 00 00 
  8004200266:	ff d0                	callq  *%rax
	ENV_CREATE(user_httpd, ENV_TYPE_USER);
	
#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
  8004200268:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420026f:	00 00 00 
  8004200272:	ff d0                	callq  *%rax

0000008004200274 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200274:	55                   	push   %rbp
  8004200275:	48 89 e5             	mov    %rsp,%rbp
  8004200278:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  800420027c:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200283:	00 
  8004200284:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200288:	48 c1 e8 0c          	shr    $0xc,%rax
  800420028c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420028f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200292:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004200299:	00 00 00 
  800420029c:	48 8b 00             	mov    (%rax),%rax
  800420029f:	48 39 c2             	cmp    %rax,%rdx
  80042002a2:	72 32                	jb     80042002d6 <boot_aps+0x62>
  80042002a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002a8:	48 89 c1             	mov    %rax,%rcx
  80042002ab:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  80042002b2:	00 00 00 
  80042002b5:	be 92 00 00 00       	mov    $0x92,%esi
  80042002ba:	48 bf fb 84 21 04 80 	movabs $0x80042184fb,%rdi
  80042002c1:	00 00 00 
  80042002c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042002c9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042002d0:	00 00 00 
  80042002d3:	41 ff d0             	callq  *%r8
  80042002d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042002dd:	00 00 00 
  80042002e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002e4:	48 01 d0             	add    %rdx,%rax
  80042002e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042002eb:	48 ba 26 5f 21 04 80 	movabs $0x8004215f26,%rdx
  80042002f2:	00 00 00 
  80042002f5:	48 b8 40 5e 21 04 80 	movabs $0x8004215e40,%rax
  80042002fc:	00 00 00 
  80042002ff:	48 29 c2             	sub    %rax,%rdx
  8004200302:	48 89 d0             	mov    %rdx,%rax
  8004200305:	48 89 c2             	mov    %rax,%rdx
  8004200308:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420030c:	48 be 40 5e 21 04 80 	movabs $0x8004215e40,%rsi
  8004200313:	00 00 00 
  8004200316:	48 89 c7             	mov    %rax,%rdi
  8004200319:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  8004200320:	00 00 00 
  8004200323:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200325:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420032c:	00 00 00 
  800420032f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004200333:	e9 0b 01 00 00       	jmpq   8004200443 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  8004200338:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420033f:	00 00 00 
  8004200342:	ff d0                	callq  *%rax
  8004200344:	48 98                	cltq   
  8004200346:	48 c1 e0 03          	shl    $0x3,%rax
  800420034a:	48 89 c2             	mov    %rax,%rdx
  800420034d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200351:	48 29 c2             	sub    %rax,%rdx
  8004200354:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420035b:	00 00 00 
  800420035e:	48 01 d0             	add    %rdx,%rax
  8004200361:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200365:	75 05                	jne    800420036c <boot_aps+0xf8>
			continue;
  8004200367:	e9 d2 00 00 00       	jmpq   800420043e <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  800420036c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200370:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  8004200377:	00 00 00 
  800420037a:	48 29 c2             	sub    %rax,%rdx
  800420037d:	48 89 d0             	mov    %rdx,%rax
  8004200380:	48 c1 f8 03          	sar    $0x3,%rax
  8004200384:	48 89 c2             	mov    %rax,%rdx
  8004200387:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  800420038e:	ee ee ee 
  8004200391:	48 0f af c2          	imul   %rdx,%rax
  8004200395:	48 83 c0 01          	add    $0x1,%rax
  8004200399:	48 c1 e0 10          	shl    $0x10,%rax
  800420039d:	48 89 c2             	mov    %rax,%rdx
  80042003a0:	48 b8 00 00 61 04 80 	movabs $0x8004610000,%rax
  80042003a7:	00 00 00 
  80042003aa:	48 01 c2             	add    %rax,%rdx
  80042003ad:	48 b8 48 d4 60 04 80 	movabs $0x800460d448,%rax
  80042003b4:	00 00 00 
  80042003b7:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  80042003ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042003c2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042003c9:	00 00 00 
  80042003cc:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042003d0:	77 32                	ja     8004200404 <boot_aps+0x190>
  80042003d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003d6:	48 89 c1             	mov    %rax,%rcx
  80042003d9:	48 ba 08 85 21 04 80 	movabs $0x8004218508,%rdx
  80042003e0:	00 00 00 
  80042003e3:	be 9c 00 00 00       	mov    $0x9c,%esi
  80042003e8:	48 bf fb 84 21 04 80 	movabs $0x80042184fb,%rdi
  80042003ef:	00 00 00 
  80042003f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003f7:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042003fe:	00 00 00 
  8004200401:	41 ff d0             	callq  *%r8
  8004200404:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420040b:	ff ff ff 
  800420040e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200412:	48 01 d0             	add    %rdx,%rax
  8004200415:	89 c2                	mov    %eax,%edx
  8004200417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420041b:	0f b6 00             	movzbl (%rax),%eax
  800420041e:	0f b6 c0             	movzbl %al,%eax
  8004200421:	89 d6                	mov    %edx,%esi
  8004200423:	89 c7                	mov    %eax,%edi
  8004200425:	48 b8 61 6a 21 04 80 	movabs $0x8004216a61,%rax
  800420042c:	00 00 00 
  800420042f:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200431:	90                   	nop
  8004200432:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200436:	8b 40 04             	mov    0x4(%rax),%eax
  8004200439:	83 f8 01             	cmp    $0x1,%eax
  800420043c:	75 f4                	jne    8004200432 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420043e:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  8004200443:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  800420044a:	00 00 00 
  800420044d:	8b 00                	mov    (%rax),%eax
  800420044f:	48 98                	cltq   
  8004200451:	48 c1 e0 03          	shl    $0x3,%rax
  8004200455:	48 89 c2             	mov    %rax,%rdx
  8004200458:	48 c1 e2 04          	shl    $0x4,%rdx
  800420045c:	48 29 c2             	sub    %rax,%rdx
  800420045f:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  8004200466:	00 00 00 
  8004200469:	48 01 d0             	add    %rdx,%rax
  800420046c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200470:	0f 87 c2 fe ff ff    	ja     8004200338 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  8004200476:	c9                   	leaveq 
  8004200477:	c3                   	retq   

0000008004200478 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  8004200478:	55                   	push   %rbp
  8004200479:	48 89 e5             	mov    %rsp,%rbp
  800420047c:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200480:	48 b8 50 d4 60 04 80 	movabs $0x800460d450,%rax
  8004200487:	00 00 00 
  800420048a:	48 8b 00             	mov    (%rax),%rax
  800420048d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200491:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200495:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200498:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420049f:	00 00 00 
  80042004a2:	ff d0                	callq  *%rax
  80042004a4:	89 c6                	mov    %eax,%esi
  80042004a6:	48 bf 2c 85 21 04 80 	movabs $0x800421852c,%rdi
  80042004ad:	00 00 00 
  80042004b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042004b5:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042004bc:	00 00 00 
  80042004bf:	ff d2                	callq  *%rdx

	lapic_init();
  80042004c1:	48 b8 fa 67 21 04 80 	movabs $0x80042167fa,%rax
  80042004c8:	00 00 00 
  80042004cb:	ff d0                	callq  *%rax
	env_init_percpu();
  80042004cd:	48 b8 d7 7a 20 04 80 	movabs $0x8004207ad7,%rax
  80042004d4:	00 00 00 
  80042004d7:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042004d9:	48 b8 06 b7 20 04 80 	movabs $0x800420b706,%rax
  80042004e0:	00 00 00 
  80042004e3:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042004e5:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042004ec:	00 00 00 
  80042004ef:	ff d0                	callq  *%rax
  80042004f1:	48 98                	cltq   
  80042004f3:	48 c1 e0 03          	shl    $0x3,%rax
  80042004f7:	48 89 c2             	mov    %rax,%rdx
  80042004fa:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004fe:	48 29 c2             	sub    %rax,%rdx
  8004200501:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  8004200508:	00 00 00 
  800420050b:	48 01 d0             	add    %rdx,%rax
  800420050e:	48 83 c0 04          	add    $0x4,%rax
  8004200512:	be 01 00 00 00       	mov    $0x1,%esi
  8004200517:	48 89 c7             	mov    %rax,%rdi
  800420051a:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200521:	00 00 00 
  8004200524:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  8004200526:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  800420052d:	00 00 00 
  8004200530:	ff d0                	callq  *%rax
	sched_yield();
  8004200532:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  8004200539:	00 00 00 
  800420053c:	ff d0                	callq  *%rax

000000800420053e <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  800420053e:	55                   	push   %rbp
  800420053f:	48 89 e5             	mov    %rsp,%rbp
  8004200542:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200549:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200550:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200556:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420055d:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200564:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420056b:	84 c0                	test   %al,%al
  800420056d:	74 20                	je     800420058f <_panic+0x51>
  800420056f:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200573:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200577:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420057b:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420057f:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200583:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200587:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420058b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420058f:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200596:	48 b8 40 d4 60 04 80 	movabs $0x800460d440,%rax
  800420059d:	00 00 00 
  80042005a0:	48 8b 00             	mov    (%rax),%rax
  80042005a3:	48 85 c0             	test   %rax,%rax
  80042005a6:	74 05                	je     80042005ad <_panic+0x6f>
		goto dead;
  80042005a8:	e9 b5 00 00 00       	jmpq   8004200662 <_panic+0x124>
	panicstr = fmt;
  80042005ad:	48 b8 40 d4 60 04 80 	movabs $0x800460d440,%rax
  80042005b4:	00 00 00 
  80042005b7:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042005be:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042005c1:	fa                   	cli    
  80042005c2:	fc                   	cld    

	va_start(ap, fmt);
  80042005c3:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042005ca:	00 00 00 
  80042005cd:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042005d4:	00 00 00 
  80042005d7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042005db:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042005e2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042005e9:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005f0:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042005f7:	00 00 00 
  80042005fa:	ff d0                	callq  *%rax
  80042005fc:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200602:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200609:	89 c6                	mov    %eax,%esi
  800420060b:	48 bf 48 85 21 04 80 	movabs $0x8004218548,%rdi
  8004200612:	00 00 00 
  8004200615:	b8 00 00 00 00       	mov    $0x0,%eax
  800420061a:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  8004200621:	00 00 00 
  8004200624:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200627:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420062e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200635:	48 89 d6             	mov    %rdx,%rsi
  8004200638:	48 89 c7             	mov    %rax,%rdi
  800420063b:	48 b8 7f 8d 20 04 80 	movabs $0x8004208d7f,%rax
  8004200642:	00 00 00 
  8004200645:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200647:	48 bf 6a 85 21 04 80 	movabs $0x800421856a,%rdi
  800420064e:	00 00 00 
  8004200651:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200656:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420065d:	00 00 00 
  8004200660:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200662:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200667:	48 b8 49 1b 20 04 80 	movabs $0x8004201b49,%rax
  800420066e:	00 00 00 
  8004200671:	ff d0                	callq  *%rax
  8004200673:	eb ed                	jmp    8004200662 <_panic+0x124>

0000008004200675 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  8004200675:	55                   	push   %rbp
  8004200676:	48 89 e5             	mov    %rsp,%rbp
  8004200679:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200680:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200687:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420068d:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200694:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420069b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042006a2:	84 c0                	test   %al,%al
  80042006a4:	74 20                	je     80042006c6 <_warn+0x51>
  80042006a6:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042006aa:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042006ae:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042006b2:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042006b6:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042006ba:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042006be:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042006c2:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042006c6:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042006cd:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006d4:	00 00 00 
  80042006d7:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006de:	00 00 00 
  80042006e1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006e5:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006ec:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006f3:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006fa:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200700:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200707:	48 89 c6             	mov    %rax,%rsi
  800420070a:	48 bf 6c 85 21 04 80 	movabs $0x800421856c,%rdi
  8004200711:	00 00 00 
  8004200714:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200719:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004200720:	00 00 00 
  8004200723:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200725:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420072c:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200733:	48 89 d6             	mov    %rdx,%rsi
  8004200736:	48 89 c7             	mov    %rax,%rdi
  8004200739:	48 b8 7f 8d 20 04 80 	movabs $0x8004208d7f,%rax
  8004200740:	00 00 00 
  8004200743:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200745:	48 bf 6a 85 21 04 80 	movabs $0x800421856a,%rdi
  800420074c:	00 00 00 
  800420074f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200754:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420075b:	00 00 00 
  800420075e:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200760:	c9                   	leaveq 
  8004200761:	c3                   	retq   

0000008004200762 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200762:	55                   	push   %rbp
  8004200763:	48 89 e5             	mov    %rsp,%rbp
  8004200766:	48 83 ec 20          	sub    $0x20,%rsp
  800420076a:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200771:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200774:	89 c2                	mov    %eax,%edx
  8004200776:	ec                   	in     (%dx),%al
  8004200777:	88 45 fb             	mov    %al,-0x5(%rbp)
  800420077a:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200781:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200784:	89 c2                	mov    %eax,%edx
  8004200786:	ec                   	in     (%dx),%al
  8004200787:	88 45 f3             	mov    %al,-0xd(%rbp)
  800420078a:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200791:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200794:	89 c2                	mov    %eax,%edx
  8004200796:	ec                   	in     (%dx),%al
  8004200797:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420079a:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  80042007a1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042007a4:	89 c2                	mov    %eax,%edx
  80042007a6:	ec                   	in     (%dx),%al
  80042007a7:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  80042007aa:	c9                   	leaveq 
  80042007ab:	c3                   	retq   

00000080042007ac <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  80042007ac:	55                   	push   %rbp
  80042007ad:	48 89 e5             	mov    %rsp,%rbp
  80042007b0:	48 83 ec 10          	sub    $0x10,%rsp
  80042007b4:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042007bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042007be:	89 c2                	mov    %eax,%edx
  80042007c0:	ec                   	in     (%dx),%al
  80042007c1:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042007c4:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042007c8:	0f b6 c0             	movzbl %al,%eax
  80042007cb:	83 e0 01             	and    $0x1,%eax
  80042007ce:	85 c0                	test   %eax,%eax
  80042007d0:	75 07                	jne    80042007d9 <serial_proc_data+0x2d>
		return -1;
  80042007d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007d7:	eb 17                	jmp    80042007f0 <serial_proc_data+0x44>
  80042007d9:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007e0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007e3:	89 c2                	mov    %eax,%edx
  80042007e5:	ec                   	in     (%dx),%al
  80042007e6:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007e9:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007ed:	0f b6 c0             	movzbl %al,%eax
}
  80042007f0:	c9                   	leaveq 
  80042007f1:	c3                   	retq   

00000080042007f2 <serial_intr>:

void
serial_intr(void)
{
  80042007f2:	55                   	push   %rbp
  80042007f3:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007f6:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  80042007fd:	00 00 00 
  8004200800:	0f b6 00             	movzbl (%rax),%eax
  8004200803:	84 c0                	test   %al,%al
  8004200805:	74 16                	je     800420081d <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200807:	48 bf ac 07 20 04 80 	movabs $0x80042007ac,%rdi
  800420080e:	00 00 00 
  8004200811:	48 b8 92 10 20 04 80 	movabs $0x8004201092,%rax
  8004200818:	00 00 00 
  800420081b:	ff d0                	callq  *%rax
}
  800420081d:	5d                   	pop    %rbp
  800420081e:	c3                   	retq   

000000800420081f <serial_putc>:

static void
serial_putc(int c)
{
  800420081f:	55                   	push   %rbp
  8004200820:	48 89 e5             	mov    %rsp,%rbp
  8004200823:	48 83 ec 28          	sub    $0x28,%rsp
  8004200827:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420082a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200831:	eb 10                	jmp    8004200843 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200833:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  800420083a:	00 00 00 
  800420083d:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  800420083f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200843:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420084a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420084d:	89 c2                	mov    %eax,%edx
  800420084f:	ec                   	in     (%dx),%al
  8004200850:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200853:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200857:	0f b6 c0             	movzbl %al,%eax
  800420085a:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  800420085d:	85 c0                	test   %eax,%eax
  800420085f:	75 09                	jne    800420086a <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200861:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200868:	7e c9                	jle    8004200833 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  800420086a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420086d:	0f b6 c0             	movzbl %al,%eax
  8004200870:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  8004200877:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420087a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420087e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200881:	ee                   	out    %al,(%dx)
}
  8004200882:	c9                   	leaveq 
  8004200883:	c3                   	retq   

0000008004200884 <serial_init>:

static void
serial_init(void)
{
  8004200884:	55                   	push   %rbp
  8004200885:	48 89 e5             	mov    %rsp,%rbp
  8004200888:	48 83 ec 50          	sub    $0x50,%rsp
  800420088c:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200893:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200897:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420089b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420089e:	ee                   	out    %al,(%dx)
  800420089f:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  80042008a6:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  80042008aa:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042008ae:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042008b1:	ee                   	out    %al,(%dx)
  80042008b2:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  80042008b9:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042008bd:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042008c1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042008c4:	ee                   	out    %al,(%dx)
  80042008c5:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008cc:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042008d0:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008d4:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008d7:	ee                   	out    %al,(%dx)
  80042008d8:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042008df:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042008e3:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008e7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008ea:	ee                   	out    %al,(%dx)
  80042008eb:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042008f2:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008f6:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008fa:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042008fd:	ee                   	out    %al,(%dx)
  80042008fe:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200905:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200909:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800420090d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200910:	ee                   	out    %al,(%dx)
  8004200911:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200918:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420091b:	89 c2                	mov    %eax,%edx
  800420091d:	ec                   	in     (%dx),%al
  800420091e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200921:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200925:	3c ff                	cmp    $0xff,%al
  8004200927:	0f 95 c2             	setne  %dl
  800420092a:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  8004200931:	00 00 00 
  8004200934:	88 10                	mov    %dl,(%rax)
  8004200936:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420093d:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200940:	89 c2                	mov    %eax,%edx
  8004200942:	ec                   	in     (%dx),%al
  8004200943:	88 45 bb             	mov    %al,-0x45(%rbp)
  8004200946:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  800420094d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200950:	89 c2                	mov    %eax,%edx
  8004200952:	ec                   	in     (%dx),%al
  8004200953:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  8004200956:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  800420095d:	00 00 00 
  8004200960:	0f b6 00             	movzbl (%rax),%eax
  8004200963:	84 c0                	test   %al,%al
  8004200965:	74 23                	je     800420098a <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200967:	48 b8 92 e6 22 04 80 	movabs $0x800422e692,%rax
  800420096e:	00 00 00 
  8004200971:	0f b7 00             	movzwl (%rax),%eax
  8004200974:	0f b7 c0             	movzwl %ax,%eax
  8004200977:	25 ef ff 00 00       	and    $0xffef,%eax
  800420097c:	89 c7                	mov    %eax,%edi
  800420097e:	48 b8 30 8c 20 04 80 	movabs $0x8004208c30,%rax
  8004200985:	00 00 00 
  8004200988:	ff d0                	callq  *%rax
}
  800420098a:	c9                   	leaveq 
  800420098b:	c3                   	retq   

000000800420098c <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  800420098c:	55                   	push   %rbp
  800420098d:	48 89 e5             	mov    %rsp,%rbp
  8004200990:	48 83 ec 38          	sub    $0x38,%rsp
  8004200994:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200997:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420099e:	eb 10                	jmp    80042009b0 <lpt_putc+0x24>
		delay();
  80042009a0:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  80042009a7:	00 00 00 
  80042009aa:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042009ac:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042009b0:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  80042009b7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042009ba:	89 c2                	mov    %eax,%edx
  80042009bc:	ec                   	in     (%dx),%al
  80042009bd:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042009c0:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042009c4:	84 c0                	test   %al,%al
  80042009c6:	78 09                	js     80042009d1 <lpt_putc+0x45>
  80042009c8:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042009cf:	7e cf                	jle    80042009a0 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042009d1:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042009d4:	0f b6 c0             	movzbl %al,%eax
  80042009d7:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042009de:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009e1:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009e5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009e8:	ee                   	out    %al,(%dx)
  80042009e9:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  80042009f0:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  80042009f4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009f8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009fb:	ee                   	out    %al,(%dx)
  80042009fc:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200a03:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200a07:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200a0b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200a0e:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200a0f:	c9                   	leaveq 
  8004200a10:	c3                   	retq   

0000008004200a11 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200a11:	55                   	push   %rbp
  8004200a12:	48 89 e5             	mov    %rsp,%rbp
  8004200a15:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a19:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200a20:	00 00 00 
  8004200a23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200a27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a2b:	0f b7 00             	movzwl (%rax),%eax
  8004200a2e:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a36:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a3f:	0f b7 00             	movzwl (%rax),%eax
  8004200a42:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a46:	74 20                	je     8004200a68 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a48:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200a4f:	00 00 00 
  8004200a52:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200a56:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200a5d:	00 00 00 
  8004200a60:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a66:	eb 1b                	jmp    8004200a83 <cga_init+0x72>
	} else {
		*cp = was;
  8004200a68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a6c:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a70:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a73:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200a7a:	00 00 00 
  8004200a7d:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a83:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200a8a:	00 00 00 
  8004200a8d:	8b 00                	mov    (%rax),%eax
  8004200a8f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a92:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a96:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a9a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a9d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a9e:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200aa5:	00 00 00 
  8004200aa8:	8b 00                	mov    (%rax),%eax
  8004200aaa:	83 c0 01             	add    $0x1,%eax
  8004200aad:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ab0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200ab3:	89 c2                	mov    %eax,%edx
  8004200ab5:	ec                   	in     (%dx),%al
  8004200ab6:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200ab9:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200abd:	0f b6 c0             	movzbl %al,%eax
  8004200ac0:	c1 e0 08             	shl    $0x8,%eax
  8004200ac3:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200ac6:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200acd:	00 00 00 
  8004200ad0:	8b 00                	mov    (%rax),%eax
  8004200ad2:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200ad5:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ad9:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200add:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200ae0:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200ae1:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200ae8:	00 00 00 
  8004200aeb:	8b 00                	mov    (%rax),%eax
  8004200aed:	83 c0 01             	add    $0x1,%eax
  8004200af0:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200af3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200af6:	89 c2                	mov    %eax,%edx
  8004200af8:	ec                   	in     (%dx),%al
  8004200af9:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200afc:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200b00:	0f b6 c0             	movzbl %al,%eax
  8004200b03:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200b06:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200b0d:	00 00 00 
  8004200b10:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200b14:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200b17:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200b1a:	89 c2                	mov    %eax,%edx
  8004200b1c:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200b23:	00 00 00 
  8004200b26:	66 89 10             	mov    %dx,(%rax)
}
  8004200b29:	c9                   	leaveq 
  8004200b2a:	c3                   	retq   

0000008004200b2b <cga_putc>:



static void
cga_putc(int c)
{
  8004200b2b:	55                   	push   %rbp
  8004200b2c:	48 89 e5             	mov    %rsp,%rbp
  8004200b2f:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b33:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b36:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b39:	b0 00                	mov    $0x0,%al
  8004200b3b:	85 c0                	test   %eax,%eax
  8004200b3d:	75 07                	jne    8004200b46 <cga_putc+0x1b>
		c |= 0x0700;
  8004200b3f:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b46:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b49:	0f b6 c0             	movzbl %al,%eax
  8004200b4c:	83 f8 09             	cmp    $0x9,%eax
  8004200b4f:	0f 84 f6 00 00 00    	je     8004200c4b <cga_putc+0x120>
  8004200b55:	83 f8 09             	cmp    $0x9,%eax
  8004200b58:	7f 0a                	jg     8004200b64 <cga_putc+0x39>
  8004200b5a:	83 f8 08             	cmp    $0x8,%eax
  8004200b5d:	74 18                	je     8004200b77 <cga_putc+0x4c>
  8004200b5f:	e9 3e 01 00 00       	jmpq   8004200ca2 <cga_putc+0x177>
  8004200b64:	83 f8 0a             	cmp    $0xa,%eax
  8004200b67:	74 75                	je     8004200bde <cga_putc+0xb3>
  8004200b69:	83 f8 0d             	cmp    $0xd,%eax
  8004200b6c:	0f 84 89 00 00 00    	je     8004200bfb <cga_putc+0xd0>
  8004200b72:	e9 2b 01 00 00       	jmpq   8004200ca2 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200b77:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200b7e:	00 00 00 
  8004200b81:	0f b7 00             	movzwl (%rax),%eax
  8004200b84:	66 85 c0             	test   %ax,%ax
  8004200b87:	74 50                	je     8004200bd9 <cga_putc+0xae>
			crt_pos--;
  8004200b89:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200b90:	00 00 00 
  8004200b93:	0f b7 00             	movzwl (%rax),%eax
  8004200b96:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b99:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200ba0:	00 00 00 
  8004200ba3:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200ba6:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200bad:	00 00 00 
  8004200bb0:	48 8b 10             	mov    (%rax),%rdx
  8004200bb3:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200bba:	00 00 00 
  8004200bbd:	0f b7 00             	movzwl (%rax),%eax
  8004200bc0:	0f b7 c0             	movzwl %ax,%eax
  8004200bc3:	48 01 c0             	add    %rax,%rax
  8004200bc6:	48 01 c2             	add    %rax,%rdx
  8004200bc9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bcc:	b0 00                	mov    $0x0,%al
  8004200bce:	83 c8 20             	or     $0x20,%eax
  8004200bd1:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200bd4:	e9 04 01 00 00       	jmpq   8004200cdd <cga_putc+0x1b2>
  8004200bd9:	e9 ff 00 00 00       	jmpq   8004200cdd <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200bde:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200be5:	00 00 00 
  8004200be8:	0f b7 00             	movzwl (%rax),%eax
  8004200beb:	8d 50 50             	lea    0x50(%rax),%edx
  8004200bee:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200bf5:	00 00 00 
  8004200bf8:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200bfb:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200c02:	00 00 00 
  8004200c05:	0f b7 30             	movzwl (%rax),%esi
  8004200c08:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200c0f:	00 00 00 
  8004200c12:	0f b7 08             	movzwl (%rax),%ecx
  8004200c15:	0f b7 c1             	movzwl %cx,%eax
  8004200c18:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c1e:	c1 e8 10             	shr    $0x10,%eax
  8004200c21:	89 c2                	mov    %eax,%edx
  8004200c23:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c27:	89 d0                	mov    %edx,%eax
  8004200c29:	c1 e0 02             	shl    $0x2,%eax
  8004200c2c:	01 d0                	add    %edx,%eax
  8004200c2e:	c1 e0 04             	shl    $0x4,%eax
  8004200c31:	29 c1                	sub    %eax,%ecx
  8004200c33:	89 ca                	mov    %ecx,%edx
  8004200c35:	29 d6                	sub    %edx,%esi
  8004200c37:	89 f2                	mov    %esi,%edx
  8004200c39:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200c40:	00 00 00 
  8004200c43:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c46:	e9 92 00 00 00       	jmpq   8004200cdd <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200c4b:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c50:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  8004200c57:	00 00 00 
  8004200c5a:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c5c:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c61:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  8004200c68:	00 00 00 
  8004200c6b:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c6d:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c72:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  8004200c79:	00 00 00 
  8004200c7c:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c7e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c83:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  8004200c8a:	00 00 00 
  8004200c8d:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c8f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c94:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  8004200c9b:	00 00 00 
  8004200c9e:	ff d0                	callq  *%rax
		break;
  8004200ca0:	eb 3b                	jmp    8004200cdd <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200ca2:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200ca9:	00 00 00 
  8004200cac:	48 8b 30             	mov    (%rax),%rsi
  8004200caf:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200cb6:	00 00 00 
  8004200cb9:	0f b7 00             	movzwl (%rax),%eax
  8004200cbc:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200cbf:	48 ba 10 a0 60 04 80 	movabs $0x800460a010,%rdx
  8004200cc6:	00 00 00 
  8004200cc9:	66 89 0a             	mov    %cx,(%rdx)
  8004200ccc:	0f b7 c0             	movzwl %ax,%eax
  8004200ccf:	48 01 c0             	add    %rax,%rax
  8004200cd2:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200cd6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200cd9:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200cdc:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200cdd:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200ce4:	00 00 00 
  8004200ce7:	0f b7 00             	movzwl (%rax),%eax
  8004200cea:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200cee:	0f 86 89 00 00 00    	jbe    8004200d7d <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cf4:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200cfb:	00 00 00 
  8004200cfe:	48 8b 00             	mov    (%rax),%rax
  8004200d01:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200d08:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200d0f:	00 00 00 
  8004200d12:	48 8b 00             	mov    (%rax),%rax
  8004200d15:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d1a:	48 89 ce             	mov    %rcx,%rsi
  8004200d1d:	48 89 c7             	mov    %rax,%rdi
  8004200d20:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  8004200d27:	00 00 00 
  8004200d2a:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d2c:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d33:	eb 22                	jmp    8004200d57 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200d35:	48 b8 08 a0 60 04 80 	movabs $0x800460a008,%rax
  8004200d3c:	00 00 00 
  8004200d3f:	48 8b 00             	mov    (%rax),%rax
  8004200d42:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d45:	48 63 d2             	movslq %edx,%rdx
  8004200d48:	48 01 d2             	add    %rdx,%rdx
  8004200d4b:	48 01 d0             	add    %rdx,%rax
  8004200d4e:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d53:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d57:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d5e:	7e d5                	jle    8004200d35 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d60:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200d67:	00 00 00 
  8004200d6a:	0f b7 00             	movzwl (%rax),%eax
  8004200d6d:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d70:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200d77:	00 00 00 
  8004200d7a:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d7d:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200d84:	00 00 00 
  8004200d87:	8b 00                	mov    (%rax),%eax
  8004200d89:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d8c:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d90:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d94:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d97:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d98:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200d9f:	00 00 00 
  8004200da2:	0f b7 00             	movzwl (%rax),%eax
  8004200da5:	66 c1 e8 08          	shr    $0x8,%ax
  8004200da9:	0f b6 c0             	movzbl %al,%eax
  8004200dac:	48 ba 04 a0 60 04 80 	movabs $0x800460a004,%rdx
  8004200db3:	00 00 00 
  8004200db6:	8b 12                	mov    (%rdx),%edx
  8004200db8:	83 c2 01             	add    $0x1,%edx
  8004200dbb:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200dbe:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200dc1:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200dc5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200dc8:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200dc9:	48 b8 04 a0 60 04 80 	movabs $0x800460a004,%rax
  8004200dd0:	00 00 00 
  8004200dd3:	8b 00                	mov    (%rax),%eax
  8004200dd5:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200dd8:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200ddc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200de0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200de3:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200de4:	48 b8 10 a0 60 04 80 	movabs $0x800460a010,%rax
  8004200deb:	00 00 00 
  8004200dee:	0f b7 00             	movzwl (%rax),%eax
  8004200df1:	0f b6 c0             	movzbl %al,%eax
  8004200df4:	48 ba 04 a0 60 04 80 	movabs $0x800460a004,%rdx
  8004200dfb:	00 00 00 
  8004200dfe:	8b 12                	mov    (%rdx),%edx
  8004200e00:	83 c2 01             	add    $0x1,%edx
  8004200e03:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200e06:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200e09:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200e0d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200e10:	ee                   	out    %al,(%dx)
}
  8004200e11:	c9                   	leaveq 
  8004200e12:	c3                   	retq   

0000008004200e13 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200e13:	55                   	push   %rbp
  8004200e14:	48 89 e5             	mov    %rsp,%rbp
  8004200e17:	48 83 ec 20          	sub    $0x20,%rsp
  8004200e1b:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e22:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200e25:	89 c2                	mov    %eax,%edx
  8004200e27:	ec                   	in     (%dx),%al
  8004200e28:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200e2b:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e2f:	0f b6 c0             	movzbl %al,%eax
  8004200e32:	83 e0 01             	and    $0x1,%eax
  8004200e35:	85 c0                	test   %eax,%eax
  8004200e37:	75 0a                	jne    8004200e43 <kbd_proc_data+0x30>
		return -1;
  8004200e39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e3e:	e9 fc 01 00 00       	jmpq   800420103f <kbd_proc_data+0x22c>
  8004200e43:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e4a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200e4d:	89 c2                	mov    %eax,%edx
  8004200e4f:	ec                   	in     (%dx),%al
  8004200e50:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200e53:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200e57:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200e5a:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e5e:	75 27                	jne    8004200e87 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e60:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200e67:	00 00 00 
  8004200e6a:	8b 00                	mov    (%rax),%eax
  8004200e6c:	83 c8 40             	or     $0x40,%eax
  8004200e6f:	89 c2                	mov    %eax,%edx
  8004200e71:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200e78:	00 00 00 
  8004200e7b:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e82:	e9 b8 01 00 00       	jmpq   800420103f <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e87:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e8b:	84 c0                	test   %al,%al
  8004200e8d:	79 65                	jns    8004200ef4 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e8f:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200e96:	00 00 00 
  8004200e99:	8b 00                	mov    (%rax),%eax
  8004200e9b:	83 e0 40             	and    $0x40,%eax
  8004200e9e:	85 c0                	test   %eax,%eax
  8004200ea0:	75 09                	jne    8004200eab <kbd_proc_data+0x98>
  8004200ea2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ea6:	83 e0 7f             	and    $0x7f,%eax
  8004200ea9:	eb 04                	jmp    8004200eaf <kbd_proc_data+0x9c>
  8004200eab:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eaf:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200eb2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eb6:	48 ba 60 e0 22 04 80 	movabs $0x800422e060,%rdx
  8004200ebd:	00 00 00 
  8004200ec0:	48 98                	cltq   
  8004200ec2:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ec6:	83 c8 40             	or     $0x40,%eax
  8004200ec9:	0f b6 c0             	movzbl %al,%eax
  8004200ecc:	f7 d0                	not    %eax
  8004200ece:	89 c2                	mov    %eax,%edx
  8004200ed0:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200ed7:	00 00 00 
  8004200eda:	8b 00                	mov    (%rax),%eax
  8004200edc:	21 c2                	and    %eax,%edx
  8004200ede:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200ee5:	00 00 00 
  8004200ee8:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200eea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200eef:	e9 4b 01 00 00       	jmpq   800420103f <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200ef4:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200efb:	00 00 00 
  8004200efe:	8b 00                	mov    (%rax),%eax
  8004200f00:	83 e0 40             	and    $0x40,%eax
  8004200f03:	85 c0                	test   %eax,%eax
  8004200f05:	74 21                	je     8004200f28 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200f07:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200f0b:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f12:	00 00 00 
  8004200f15:	8b 00                	mov    (%rax),%eax
  8004200f17:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200f1a:	89 c2                	mov    %eax,%edx
  8004200f1c:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f23:	00 00 00 
  8004200f26:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f28:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f2c:	48 ba 60 e0 22 04 80 	movabs $0x800422e060,%rdx
  8004200f33:	00 00 00 
  8004200f36:	48 98                	cltq   
  8004200f38:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f3c:	0f b6 d0             	movzbl %al,%edx
  8004200f3f:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f46:	00 00 00 
  8004200f49:	8b 00                	mov    (%rax),%eax
  8004200f4b:	09 c2                	or     %eax,%edx
  8004200f4d:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f54:	00 00 00 
  8004200f57:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f59:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f5d:	48 ba 60 e1 22 04 80 	movabs $0x800422e160,%rdx
  8004200f64:	00 00 00 
  8004200f67:	48 98                	cltq   
  8004200f69:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f6d:	0f b6 d0             	movzbl %al,%edx
  8004200f70:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f77:	00 00 00 
  8004200f7a:	8b 00                	mov    (%rax),%eax
  8004200f7c:	31 c2                	xor    %eax,%edx
  8004200f7e:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f85:	00 00 00 
  8004200f88:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f8a:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200f91:	00 00 00 
  8004200f94:	8b 00                	mov    (%rax),%eax
  8004200f96:	83 e0 03             	and    $0x3,%eax
  8004200f99:	89 c2                	mov    %eax,%edx
  8004200f9b:	48 b8 60 e5 22 04 80 	movabs $0x800422e560,%rax
  8004200fa2:	00 00 00 
  8004200fa5:	89 d2                	mov    %edx,%edx
  8004200fa7:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200fab:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200faf:	48 01 d0             	add    %rdx,%rax
  8004200fb2:	0f b6 00             	movzbl (%rax),%eax
  8004200fb5:	0f b6 c0             	movzbl %al,%eax
  8004200fb8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200fbb:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200fc2:	00 00 00 
  8004200fc5:	8b 00                	mov    (%rax),%eax
  8004200fc7:	83 e0 08             	and    $0x8,%eax
  8004200fca:	85 c0                	test   %eax,%eax
  8004200fcc:	74 22                	je     8004200ff0 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200fce:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200fd2:	7e 0c                	jle    8004200fe0 <kbd_proc_data+0x1cd>
  8004200fd4:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200fd8:	7f 06                	jg     8004200fe0 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200fda:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200fde:	eb 10                	jmp    8004200ff0 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200fe0:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200fe4:	7e 0a                	jle    8004200ff0 <kbd_proc_data+0x1dd>
  8004200fe6:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200fea:	7f 04                	jg     8004200ff0 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200fec:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200ff0:	48 b8 28 a2 60 04 80 	movabs $0x800460a228,%rax
  8004200ff7:	00 00 00 
  8004200ffa:	8b 00                	mov    (%rax),%eax
  8004200ffc:	f7 d0                	not    %eax
  8004200ffe:	83 e0 06             	and    $0x6,%eax
  8004201001:	85 c0                	test   %eax,%eax
  8004201003:	75 37                	jne    800420103c <kbd_proc_data+0x229>
  8004201005:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  800420100c:	75 2e                	jne    800420103c <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  800420100e:	48 bf 86 85 21 04 80 	movabs $0x8004218586,%rdi
  8004201015:	00 00 00 
  8004201018:	b8 00 00 00 00       	mov    $0x0,%eax
  800420101d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201024:	00 00 00 
  8004201027:	ff d2                	callq  *%rdx
  8004201029:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004201030:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004201034:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004201038:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420103b:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  800420103c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420103f:	c9                   	leaveq 
  8004201040:	c3                   	retq   

0000008004201041 <kbd_intr>:

void
kbd_intr(void)
{
  8004201041:	55                   	push   %rbp
  8004201042:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201045:	48 bf 13 0e 20 04 80 	movabs $0x8004200e13,%rdi
  800420104c:	00 00 00 
  800420104f:	48 b8 92 10 20 04 80 	movabs $0x8004201092,%rax
  8004201056:	00 00 00 
  8004201059:	ff d0                	callq  *%rax
}
  800420105b:	5d                   	pop    %rbp
  800420105c:	c3                   	retq   

000000800420105d <kbd_init>:

static void
kbd_init(void)
{
  800420105d:	55                   	push   %rbp
  800420105e:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201061:	48 b8 41 10 20 04 80 	movabs $0x8004201041,%rax
  8004201068:	00 00 00 
  800420106b:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  800420106d:	48 b8 92 e6 22 04 80 	movabs $0x800422e692,%rax
  8004201074:	00 00 00 
  8004201077:	0f b7 00             	movzwl (%rax),%eax
  800420107a:	0f b7 c0             	movzwl %ax,%eax
  800420107d:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201082:	89 c7                	mov    %eax,%edi
  8004201084:	48 b8 30 8c 20 04 80 	movabs $0x8004208c30,%rax
  800420108b:	00 00 00 
  800420108e:	ff d0                	callq  *%rax
}
  8004201090:	5d                   	pop    %rbp
  8004201091:	c3                   	retq   

0000008004201092 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201092:	55                   	push   %rbp
  8004201093:	48 89 e5             	mov    %rsp,%rbp
  8004201096:	48 83 ec 20          	sub    $0x20,%rsp
  800420109a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  800420109e:	eb 6a                	jmp    800420110a <cons_intr+0x78>
		if (c == 0)
  80042010a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042010a4:	75 02                	jne    80042010a8 <cons_intr+0x16>
			continue;
  80042010a6:	eb 62                	jmp    800420110a <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  80042010a8:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042010af:	00 00 00 
  80042010b2:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010b8:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010bb:	48 ba 20 a0 60 04 80 	movabs $0x800460a020,%rdx
  80042010c2:	00 00 00 
  80042010c5:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042010cb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010ce:	89 d1                	mov    %edx,%ecx
  80042010d0:	48 ba 20 a0 60 04 80 	movabs $0x800460a020,%rdx
  80042010d7:	00 00 00 
  80042010da:	89 c0                	mov    %eax,%eax
  80042010dc:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042010df:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042010e6:	00 00 00 
  80042010e9:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010ef:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010f4:	75 14                	jne    800420110a <cons_intr+0x78>
			cons.wpos = 0;
  80042010f6:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042010fd:	00 00 00 
  8004201100:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004201107:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420110a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420110e:	ff d0                	callq  *%rax
  8004201110:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201113:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201117:	75 87                	jne    80042010a0 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201119:	c9                   	leaveq 
  800420111a:	c3                   	retq   

000000800420111b <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420111b:	55                   	push   %rbp
  800420111c:	48 89 e5             	mov    %rsp,%rbp
  800420111f:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201123:	48 b8 f2 07 20 04 80 	movabs $0x80042007f2,%rax
  800420112a:	00 00 00 
  800420112d:	ff d0                	callq  *%rax
	kbd_intr();
  800420112f:	48 b8 41 10 20 04 80 	movabs $0x8004201041,%rax
  8004201136:	00 00 00 
  8004201139:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420113b:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004201142:	00 00 00 
  8004201145:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420114b:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004201152:	00 00 00 
  8004201155:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420115b:	39 c2                	cmp    %eax,%edx
  800420115d:	74 69                	je     80042011c8 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  800420115f:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004201166:	00 00 00 
  8004201169:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  800420116f:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201172:	48 ba 20 a0 60 04 80 	movabs $0x800460a020,%rdx
  8004201179:	00 00 00 
  800420117c:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201182:	48 ba 20 a0 60 04 80 	movabs $0x800460a020,%rdx
  8004201189:	00 00 00 
  800420118c:	89 c0                	mov    %eax,%eax
  800420118e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201192:	0f b6 c0             	movzbl %al,%eax
  8004201195:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201198:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420119f:	00 00 00 
  80042011a2:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042011a8:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011ad:	75 14                	jne    80042011c3 <cons_getc+0xa8>
			cons.rpos = 0;
  80042011af:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042011b6:	00 00 00 
  80042011b9:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011c0:	00 00 00 
		return c;
  80042011c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011c6:	eb 05                	jmp    80042011cd <cons_getc+0xb2>
	}
	return 0;
  80042011c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011cd:	c9                   	leaveq 
  80042011ce:	c3                   	retq   

00000080042011cf <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011cf:	55                   	push   %rbp
  80042011d0:	48 89 e5             	mov    %rsp,%rbp
  80042011d3:	48 83 ec 10          	sub    $0x10,%rsp
  80042011d7:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011da:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011dd:	89 c7                	mov    %eax,%edi
  80042011df:	48 b8 1f 08 20 04 80 	movabs $0x800420081f,%rax
  80042011e6:	00 00 00 
  80042011e9:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ee:	89 c7                	mov    %eax,%edi
  80042011f0:	48 b8 8c 09 20 04 80 	movabs $0x800420098c,%rax
  80042011f7:	00 00 00 
  80042011fa:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ff:	89 c7                	mov    %eax,%edi
  8004201201:	48 b8 2b 0b 20 04 80 	movabs $0x8004200b2b,%rax
  8004201208:	00 00 00 
  800420120b:	ff d0                	callq  *%rax
}
  800420120d:	c9                   	leaveq 
  800420120e:	c3                   	retq   

000000800420120f <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  800420120f:	55                   	push   %rbp
  8004201210:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201213:	48 b8 11 0a 20 04 80 	movabs $0x8004200a11,%rax
  800420121a:	00 00 00 
  800420121d:	ff d0                	callq  *%rax
	kbd_init();
  800420121f:	48 b8 5d 10 20 04 80 	movabs $0x800420105d,%rax
  8004201226:	00 00 00 
  8004201229:	ff d0                	callq  *%rax
	serial_init();
  800420122b:	48 b8 84 08 20 04 80 	movabs $0x8004200884,%rax
  8004201232:	00 00 00 
  8004201235:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201237:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  800420123e:	00 00 00 
  8004201241:	0f b6 00             	movzbl (%rax),%eax
  8004201244:	83 f0 01             	xor    $0x1,%eax
  8004201247:	84 c0                	test   %al,%al
  8004201249:	74 1b                	je     8004201266 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420124b:	48 bf 92 85 21 04 80 	movabs $0x8004218592,%rdi
  8004201252:	00 00 00 
  8004201255:	b8 00 00 00 00       	mov    $0x0,%eax
  800420125a:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201261:	00 00 00 
  8004201264:	ff d2                	callq  *%rdx
}
  8004201266:	5d                   	pop    %rbp
  8004201267:	c3                   	retq   

0000008004201268 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004201268:	55                   	push   %rbp
  8004201269:	48 89 e5             	mov    %rsp,%rbp
  800420126c:	48 83 ec 10          	sub    $0x10,%rsp
  8004201270:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201273:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201276:	89 c7                	mov    %eax,%edi
  8004201278:	48 b8 cf 11 20 04 80 	movabs $0x80042011cf,%rax
  800420127f:	00 00 00 
  8004201282:	ff d0                	callq  *%rax
}
  8004201284:	c9                   	leaveq 
  8004201285:	c3                   	retq   

0000008004201286 <getchar>:

int
getchar(void)
{
  8004201286:	55                   	push   %rbp
  8004201287:	48 89 e5             	mov    %rsp,%rbp
  800420128a:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  800420128e:	48 b8 1b 11 20 04 80 	movabs $0x800420111b,%rax
  8004201295:	00 00 00 
  8004201298:	ff d0                	callq  *%rax
  800420129a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420129d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042012a1:	74 eb                	je     800420128e <getchar+0x8>
		/* do nothing */;
	return c;
  80042012a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042012a6:	c9                   	leaveq 
  80042012a7:	c3                   	retq   

00000080042012a8 <iscons>:

int
iscons(int fdnum)
{
  80042012a8:	55                   	push   %rbp
  80042012a9:	48 89 e5             	mov    %rsp,%rbp
  80042012ac:	48 83 ec 04          	sub    $0x4,%rsp
  80042012b0:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042012b3:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012b8:	c9                   	leaveq 
  80042012b9:	c3                   	retq   

00000080042012ba <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012ba:	55                   	push   %rbp
  80042012bb:	48 89 e5             	mov    %rsp,%rbp
  80042012be:	48 83 ec 30          	sub    $0x30,%rsp
  80042012c2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012c5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012c9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012cd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012d4:	eb 6c                	jmp    8004201342 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012d6:	48 b9 80 e5 22 04 80 	movabs $0x800422e580,%rcx
  80042012dd:	00 00 00 
  80042012e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012e3:	48 63 d0             	movslq %eax,%rdx
  80042012e6:	48 89 d0             	mov    %rdx,%rax
  80042012e9:	48 01 c0             	add    %rax,%rax
  80042012ec:	48 01 d0             	add    %rdx,%rax
  80042012ef:	48 c1 e0 03          	shl    $0x3,%rax
  80042012f3:	48 01 c8             	add    %rcx,%rax
  80042012f6:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042012fa:	48 be 80 e5 22 04 80 	movabs $0x800422e580,%rsi
  8004201301:	00 00 00 
  8004201304:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201307:	48 63 d0             	movslq %eax,%rdx
  800420130a:	48 89 d0             	mov    %rdx,%rax
  800420130d:	48 01 c0             	add    %rax,%rax
  8004201310:	48 01 d0             	add    %rdx,%rax
  8004201313:	48 c1 e0 03          	shl    $0x3,%rax
  8004201317:	48 01 f0             	add    %rsi,%rax
  800420131a:	48 8b 00             	mov    (%rax),%rax
  800420131d:	48 89 ca             	mov    %rcx,%rdx
  8004201320:	48 89 c6             	mov    %rax,%rsi
  8004201323:	48 bf 2a 86 21 04 80 	movabs $0x800421862a,%rdi
  800420132a:	00 00 00 
  800420132d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201332:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004201339:	00 00 00 
  800420133c:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  800420133e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201342:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201345:	83 f8 02             	cmp    $0x2,%eax
  8004201348:	76 8c                	jbe    80042012d6 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	cprintf("%d",sizeof(int));	
  800420134a:	be 04 00 00 00       	mov    $0x4,%esi
  800420134f:	48 bf 33 86 21 04 80 	movabs $0x8004218633,%rdi
  8004201356:	00 00 00 
  8004201359:	b8 00 00 00 00       	mov    $0x0,%eax
  800420135e:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201365:	00 00 00 
  8004201368:	ff d2                	callq  *%rdx
	return 0;
  800420136a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420136f:	c9                   	leaveq 
  8004201370:	c3                   	retq   

0000008004201371 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201371:	55                   	push   %rbp
  8004201372:	48 89 e5             	mov    %rsp,%rbp
  8004201375:	48 83 ec 30          	sub    $0x30,%rsp
  8004201379:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420137c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201380:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201384:	48 bf 36 86 21 04 80 	movabs $0x8004218636,%rdi
  800420138b:	00 00 00 
  800420138e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201393:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420139a:	00 00 00 
  800420139d:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  800420139f:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042013a6:	00 00 00 
  80042013a9:	48 bf 50 86 21 04 80 	movabs $0x8004218650,%rdi
  80042013b0:	00 00 00 
  80042013b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013b8:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042013bf:	00 00 00 
  80042013c2:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013c4:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013cb:	00 00 00 
  80042013ce:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013d5:	00 00 00 
  80042013d8:	48 bf 78 86 21 04 80 	movabs $0x8004218678,%rdi
  80042013df:	00 00 00 
  80042013e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013e7:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  80042013ee:	00 00 00 
  80042013f1:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013f3:	48 ba 7d 84 21 00 00 	movabs $0x21847d,%rdx
  80042013fa:	00 00 00 
  80042013fd:	48 be 7d 84 21 04 80 	movabs $0x800421847d,%rsi
  8004201404:	00 00 00 
  8004201407:	48 bf a0 86 21 04 80 	movabs $0x80042186a0,%rdi
  800420140e:	00 00 00 
  8004201411:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201416:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420141d:	00 00 00 
  8004201420:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201422:	48 ba 72 9b 60 00 00 	movabs $0x609b72,%rdx
  8004201429:	00 00 00 
  800420142c:	48 be 72 9b 60 04 80 	movabs $0x8004609b72,%rsi
  8004201433:	00 00 00 
  8004201436:	48 bf c8 86 21 04 80 	movabs $0x80042186c8,%rdi
  800420143d:	00 00 00 
  8004201440:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201445:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420144c:	00 00 00 
  800420144f:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201451:	48 ba 18 00 69 00 00 	movabs $0x690018,%rdx
  8004201458:	00 00 00 
  800420145b:	48 be 18 00 69 04 80 	movabs $0x8004690018,%rsi
  8004201462:	00 00 00 
  8004201465:	48 bf f0 86 21 04 80 	movabs $0x80042186f0,%rdi
  800420146c:	00 00 00 
  800420146f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201474:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420147b:	00 00 00 
  800420147e:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201480:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004201487:	00 
  8004201488:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  800420148f:	00 00 00 
  8004201492:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201496:	48 29 c2             	sub    %rax,%rdx
  8004201499:	48 b8 18 00 69 04 80 	movabs $0x8004690018,%rax
  80042014a0:	00 00 00 
  80042014a3:	48 83 e8 01          	sub    $0x1,%rax
  80042014a7:	48 01 d0             	add    %rdx,%rax
  80042014aa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042014ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014b2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042014b7:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014bb:	48 89 d0             	mov    %rdx,%rax
  80042014be:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014c2:	48 29 c2             	sub    %rax,%rdx
  80042014c5:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014c8:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014cf:	48 85 c0             	test   %rax,%rax
  80042014d2:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014d6:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014da:	48 89 c6             	mov    %rax,%rsi
  80042014dd:	48 bf 18 87 21 04 80 	movabs $0x8004218718,%rdi
  80042014e4:	00 00 00 
  80042014e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014ec:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042014f3:	00 00 00 
  80042014f6:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014fd:	c9                   	leaveq 
  80042014fe:	c3                   	retq   

00000080042014ff <printArgList>:

void printArgList(uint64_t* prbp, struct Ripdebuginfo *info)
{
  80042014ff:	55                   	push   %rbp
  8004201500:	48 89 e5             	mov    %rsp,%rbp
  8004201503:	48 83 ec 30          	sub    $0x30,%rsp
  8004201507:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420150b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t* tprbp = (uint64_t*)(prbp - 4);
  800420150f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201513:	48 83 e8 20          	sub    $0x20,%rax
  8004201517:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int numberArg = info->rip_fn_narg;
  800420151b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420151f:	8b 40 28             	mov    0x28(%rax),%eax
  8004201522:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int i = 0;
  8004201525:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	uint64_t size = 0;
  800420152c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201533:	00 
	if(numberArg <= 0)
  8004201534:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004201538:	7f 20                	jg     800420155a <printArgList+0x5b>
	{
		cprintf("\n");
  800420153a:	48 bf 42 87 21 04 80 	movabs $0x8004218742,%rdi
  8004201541:	00 00 00 
  8004201544:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201549:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201550:	00 00 00 
  8004201553:	ff d2                	callq  *%rdx
		return;
  8004201555:	e9 0f 01 00 00       	jmpq   8004201669 <printArgList+0x16a>
	}
	
	while(numberArg > 0)
  800420155a:	e9 e5 00 00 00       	jmpq   8004201644 <printArgList+0x145>
	{
		//cprintf("size of argument %d is %d %x",i, info->size_fn_arg[i],*prbp);
		size = info->size_fn_arg[i];
  800420155f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201563:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004201566:	48 63 d2             	movslq %edx,%rdx
  8004201569:	48 83 c2 08          	add    $0x8,%rdx
  800420156d:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  8004201571:	48 98                	cltq   
  8004201573:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		cprintf(" ");
  8004201577:	48 bf 44 87 21 04 80 	movabs $0x8004218744,%rdi
  800420157e:	00 00 00 
  8004201581:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201586:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420158d:	00 00 00 
  8004201590:	ff d2                	callq  *%rdx
		switch(size)
  8004201592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201596:	48 83 f8 04          	cmp    $0x4,%rax
  800420159a:	74 43                	je     80042015df <printArgList+0xe0>
  800420159c:	48 83 f8 08          	cmp    $0x8,%rax
  80042015a0:	74 6b                	je     800420160d <printArgList+0x10e>
  80042015a2:	48 83 f8 01          	cmp    $0x1,%rax
  80042015a6:	74 05                	je     80042015ad <printArgList+0xae>
			case 8:
				cprintf("%016x",*(tprbp -1));
				tprbp = tprbp - 1;
				break;
			default:
				break;
  80042015a8:	e9 8f 00 00 00       	jmpq   800420163c <printArgList+0x13d>
		size = info->size_fn_arg[i];
		cprintf(" ");
		switch(size)
		{
			case 1:
				cprintf("%016x",*((char*)tprbp -1));
  80042015ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015b1:	48 83 e8 01          	sub    $0x1,%rax
  80042015b5:	0f b6 00             	movzbl (%rax),%eax
  80042015b8:	0f be c0             	movsbl %al,%eax
  80042015bb:	89 c6                	mov    %eax,%esi
  80042015bd:	48 bf 46 87 21 04 80 	movabs $0x8004218746,%rdi
  80042015c4:	00 00 00 
  80042015c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015cc:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042015d3:	00 00 00 
  80042015d6:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((char*)tprbp - 1);
  80042015d8:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
				break;
  80042015dd:	eb 5d                	jmp    800420163c <printArgList+0x13d>
			case 4:
				cprintf("%016x",*((int*)tprbp -1));
  80042015df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015e3:	48 83 e8 04          	sub    $0x4,%rax
  80042015e7:	8b 00                	mov    (%rax),%eax
  80042015e9:	89 c6                	mov    %eax,%esi
  80042015eb:	48 bf 46 87 21 04 80 	movabs $0x8004218746,%rdi
  80042015f2:	00 00 00 
  80042015f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015fa:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201601:	00 00 00 
  8004201604:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((int*)tprbp - 1);
  8004201606:	48 83 6d f8 04       	subq   $0x4,-0x8(%rbp)
				break;
  800420160b:	eb 2f                	jmp    800420163c <printArgList+0x13d>
			case 8:
				cprintf("%016x",*(tprbp -1));
  800420160d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201611:	48 83 e8 08          	sub    $0x8,%rax
  8004201615:	48 8b 00             	mov    (%rax),%rax
  8004201618:	48 89 c6             	mov    %rax,%rsi
  800420161b:	48 bf 46 87 21 04 80 	movabs $0x8004218746,%rdi
  8004201622:	00 00 00 
  8004201625:	b8 00 00 00 00       	mov    $0x0,%eax
  800420162a:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201631:	00 00 00 
  8004201634:	ff d2                	callq  *%rdx
				tprbp = tprbp - 1;
  8004201636:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
				break;
  800420163b:	90                   	nop
			default:
				break;
		}
		i++;
  800420163c:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
		numberArg--;
  8004201640:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
	{
		cprintf("\n");
		return;
	}
	
	while(numberArg > 0)
  8004201644:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004201648:	0f 8f 11 ff ff ff    	jg     800420155f <printArgList+0x60>
				break;
		}
		i++;
		numberArg--;
	}
	cprintf("\n");
  800420164e:	48 bf 42 87 21 04 80 	movabs $0x8004218742,%rdi
  8004201655:	00 00 00 
  8004201658:	b8 00 00 00 00       	mov    $0x0,%eax
  800420165d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201664:	00 00 00 
  8004201667:	ff d2                	callq  *%rdx
}
  8004201669:	c9                   	leaveq 
  800420166a:	c3                   	retq   

000000800420166b <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  800420166b:	55                   	push   %rbp
  800420166c:	48 89 e5             	mov    %rsp,%rbp
  800420166f:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004201676:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  800420167c:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  8004201683:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	// Your code here.
	uint64_t rbp = 0x0;
  800420168a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004201691:	00 
	uint64_t rip = 0x0;
  8004201692:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201699:	00 
	uint64_t* prbp = NULL;
  800420169a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042016a1:	00 

	struct Ripdebuginfo info;

	cprintf("Stack backtrace:\n");
  80042016a2:	48 bf 4c 87 21 04 80 	movabs $0x800421874c,%rdi
  80042016a9:	00 00 00 
  80042016ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016b1:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042016b8:	00 00 00 
  80042016bb:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042016bd:	48 89 e8             	mov    %rbp,%rax
  80042016c0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	return rbp;
  80042016c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	rbp = read_rbp();
  80042016c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  80042016cc:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042016d3 <mon_backtrace+0x68>
  80042016d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(rbp == 0x0 || rip == 0x0)
  80042016d7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042016dc:	74 07                	je     80042016e5 <mon_backtrace+0x7a>
  80042016de:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016e3:	75 25                	jne    800420170a <mon_backtrace+0x9f>
	{
		cprintf("Not able to show backtrace");
  80042016e5:	48 bf 5e 87 21 04 80 	movabs $0x800421875e,%rdi
  80042016ec:	00 00 00 
  80042016ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016f4:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042016fb:	00 00 00 
  80042016fe:	ff d2                	callq  *%rdx
		return -1;
  8004201700:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004201705:	e9 2c 02 00 00       	jmpq   8004201936 <mon_backtrace+0x2cb>
	}
	prbp = (uint64_t*)(rbp);
  800420170a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420170e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("    rbp %016x  rip %016x\n", prbp, rip);
  8004201712:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201716:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420171a:	48 89 c6             	mov    %rax,%rsi
  800420171d:	48 bf 79 87 21 04 80 	movabs $0x8004218779,%rdi
  8004201724:	00 00 00 
  8004201727:	b8 00 00 00 00       	mov    $0x0,%eax
  800420172c:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004201733:	00 00 00 
  8004201736:	ff d1                	callq  *%rcx
	debuginfo_rip(rip ,&info);
  8004201738:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  800420173f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201743:	48 89 d6             	mov    %rdx,%rsi
  8004201746:	48 89 c7             	mov    %rax,%rdi
  8004201749:	48 b8 bd e6 20 04 80 	movabs $0x800420e6bd,%rax
  8004201750:	00 00 00 
  8004201753:	ff d0                	callq  *%rax
	
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  8004201755:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  800420175b:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201762:	48 89 c6             	mov    %rax,%rsi
  8004201765:	48 bf 93 87 21 04 80 	movabs $0x8004218793,%rdi
  800420176c:	00 00 00 
  800420176f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201774:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420177b:	00 00 00 
  800420177e:	ff d1                	callq  *%rcx
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201780:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  8004201787:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420178b:	48 89 d1             	mov    %rdx,%rcx
  800420178e:	48 29 c1             	sub    %rax,%rcx
  8004201791:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004201798:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  800420179e:	89 c6                	mov    %eax,%esi
  80042017a0:	48 bf a3 87 21 04 80 	movabs $0x80042187a3,%rdi
  80042017a7:	00 00 00 
  80042017aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017af:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  80042017b6:	00 00 00 
  80042017b9:	41 ff d0             	callq  *%r8
	cprintf(" args:%d", info.rip_fn_narg);
  80042017bc:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042017c2:	89 c6                	mov    %eax,%esi
  80042017c4:	48 bf ae 87 21 04 80 	movabs $0x80042187ae,%rdi
  80042017cb:	00 00 00 
  80042017ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017d3:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042017da:	00 00 00 
  80042017dd:	ff d2                	callq  *%rdx
	printArgList(prbp, &info);
  80042017df:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042017e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017ea:	48 89 d6             	mov    %rdx,%rsi
  80042017ed:	48 89 c7             	mov    %rax,%rdi
  80042017f0:	48 b8 ff 14 20 04 80 	movabs $0x80042014ff,%rax
  80042017f7:	00 00 00 
  80042017fa:	ff d0                	callq  *%rax

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042017fc:	e9 09 01 00 00       	jmpq   800420190a <mon_backtrace+0x29f>
	{
		cprintf("    rbp %016x  rip %016x\n",*(prbp),*((prbp) +1));
  8004201801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201805:	48 83 c0 08          	add    $0x8,%rax
  8004201809:	48 8b 10             	mov    (%rax),%rdx
  800420180c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201810:	48 8b 00             	mov    (%rax),%rax
  8004201813:	48 89 c6             	mov    %rax,%rsi
  8004201816:	48 bf 79 87 21 04 80 	movabs $0x8004218779,%rdi
  800420181d:	00 00 00 
  8004201820:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201825:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420182c:	00 00 00 
  800420182f:	ff d1                	callq  *%rcx
		debuginfo_rip(*(prbp+1) ,&info);
  8004201831:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201835:	48 83 c0 08          	add    $0x8,%rax
  8004201839:	48 8b 00             	mov    (%rax),%rax
  800420183c:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201843:	48 89 d6             	mov    %rdx,%rsi
  8004201846:	48 89 c7             	mov    %rax,%rdi
  8004201849:	48 b8 bd e6 20 04 80 	movabs $0x800420e6bd,%rax
  8004201850:	00 00 00 
  8004201853:	ff d0                	callq  *%rax

		cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  8004201855:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  800420185b:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201862:	48 89 c6             	mov    %rax,%rsi
  8004201865:	48 bf 93 87 21 04 80 	movabs $0x8004218793,%rdi
  800420186c:	00 00 00 
  800420186f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201874:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420187b:	00 00 00 
  800420187e:	ff d1                	callq  *%rcx
		cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201880:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  8004201887:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420188b:	48 89 d1             	mov    %rdx,%rcx
  800420188e:	48 29 c1             	sub    %rax,%rcx
  8004201891:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004201898:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  800420189e:	89 c6                	mov    %eax,%esi
  80042018a0:	48 bf a3 87 21 04 80 	movabs $0x80042187a3,%rdi
  80042018a7:	00 00 00 
  80042018aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018af:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  80042018b6:	00 00 00 
  80042018b9:	41 ff d0             	callq  *%r8
		cprintf(" args:%d", info.rip_fn_narg);
  80042018bc:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042018c2:	89 c6                	mov    %eax,%esi
  80042018c4:	48 bf ae 87 21 04 80 	movabs $0x80042187ae,%rdi
  80042018cb:	00 00 00 
  80042018ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018d3:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042018da:	00 00 00 
  80042018dd:	ff d2                	callq  *%rdx
		printArgList((uint64_t*)(*(prbp)), &info);
  80042018df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018e3:	48 8b 00             	mov    (%rax),%rax
  80042018e6:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042018ed:	48 89 d6             	mov    %rdx,%rsi
  80042018f0:	48 89 c7             	mov    %rax,%rdi
  80042018f3:	48 b8 ff 14 20 04 80 	movabs $0x80042014ff,%rax
  80042018fa:	00 00 00 
  80042018fd:	ff d0                	callq  *%rax
		
		prbp = (uint64_t*)(*(prbp)); 
  80042018ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201903:	48 8b 00             	mov    (%rax),%rax
  8004201906:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
	cprintf(" args:%d", info.rip_fn_narg);
	printArgList(prbp, &info);

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  800420190a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420190f:	74 20                	je     8004201931 <mon_backtrace+0x2c6>
  8004201911:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201915:	48 8b 00             	mov    (%rax),%rax
  8004201918:	48 85 c0             	test   %rax,%rax
  800420191b:	74 14                	je     8004201931 <mon_backtrace+0x2c6>
  800420191d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201921:	48 83 c0 08          	add    $0x8,%rax
  8004201925:	48 8b 00             	mov    (%rax),%rax
  8004201928:	48 85 c0             	test   %rax,%rax
  800420192b:	0f 85 d0 fe ff ff    	jne    8004201801 <mon_backtrace+0x196>
		cprintf(" args:%d", info.rip_fn_narg);
		printArgList((uint64_t*)(*(prbp)), &info);
		
		prbp = (uint64_t*)(*(prbp)); 
	}
	return 0;
  8004201931:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201936:	c9                   	leaveq 
  8004201937:	c3                   	retq   

0000008004201938 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201938:	55                   	push   %rbp
  8004201939:	48 89 e5             	mov    %rsp,%rbp
  800420193c:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201943:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420194a:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201951:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201958:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420195b:	48 98                	cltq   
  800420195d:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201964:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201969:	eb 15                	jmp    8004201980 <runcmd+0x48>
			*buf++ = 0;
  800420196b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201972:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004201976:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  800420197d:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201980:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201987:	0f b6 00             	movzbl (%rax),%eax
  800420198a:	84 c0                	test   %al,%al
  800420198c:	74 2a                	je     80042019b8 <runcmd+0x80>
  800420198e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201995:	0f b6 00             	movzbl (%rax),%eax
  8004201998:	0f be c0             	movsbl %al,%eax
  800420199b:	89 c6                	mov    %eax,%esi
  800420199d:	48 bf b7 87 21 04 80 	movabs $0x80042187b7,%rdi
  80042019a4:	00 00 00 
  80042019a7:	48 b8 e2 f9 20 04 80 	movabs $0x800420f9e2,%rax
  80042019ae:	00 00 00 
  80042019b1:	ff d0                	callq  *%rax
  80042019b3:	48 85 c0             	test   %rax,%rax
  80042019b6:	75 b3                	jne    800420196b <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042019b8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019bf:	0f b6 00             	movzbl (%rax),%eax
  80042019c2:	84 c0                	test   %al,%al
  80042019c4:	75 21                	jne    80042019e7 <runcmd+0xaf>
			break;
  80042019c6:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019ca:	48 98                	cltq   
  80042019cc:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019d3:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019dc:	0f 85 a1 00 00 00    	jne    8004201a83 <runcmd+0x14b>
  80042019e2:	e9 92 00 00 00       	jmpq   8004201a79 <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042019e7:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042019eb:	75 2a                	jne    8004201a17 <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042019ed:	be 10 00 00 00       	mov    $0x10,%esi
  80042019f2:	48 bf bc 87 21 04 80 	movabs $0x80042187bc,%rdi
  80042019f9:	00 00 00 
  80042019fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a01:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201a08:	00 00 00 
  8004201a0b:	ff d2                	callq  *%rdx
			return 0;
  8004201a0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a12:	e9 30 01 00 00       	jmpq   8004201b47 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201a17:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a1a:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a1d:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a20:	48 98                	cltq   
  8004201a22:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a29:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a30:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a31:	eb 08                	jmp    8004201a3b <runcmd+0x103>
			buf++;
  8004201a33:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a3a:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a3b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a42:	0f b6 00             	movzbl (%rax),%eax
  8004201a45:	84 c0                	test   %al,%al
  8004201a47:	74 2a                	je     8004201a73 <runcmd+0x13b>
  8004201a49:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a50:	0f b6 00             	movzbl (%rax),%eax
  8004201a53:	0f be c0             	movsbl %al,%eax
  8004201a56:	89 c6                	mov    %eax,%esi
  8004201a58:	48 bf b7 87 21 04 80 	movabs $0x80042187b7,%rdi
  8004201a5f:	00 00 00 
  8004201a62:	48 b8 e2 f9 20 04 80 	movabs $0x800420f9e2,%rax
  8004201a69:	00 00 00 
  8004201a6c:	ff d0                	callq  *%rax
  8004201a6e:	48 85 c0             	test   %rax,%rax
  8004201a71:	74 c0                	je     8004201a33 <runcmd+0xfb>
			buf++;
	}
  8004201a73:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201a74:	e9 07 ff ff ff       	jmpq   8004201980 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201a79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a7e:	e9 c4 00 00 00       	jmpq   8004201b47 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a83:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201a8a:	e9 82 00 00 00       	jmpq   8004201b11 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201a8f:	48 b9 80 e5 22 04 80 	movabs $0x800422e580,%rcx
  8004201a96:	00 00 00 
  8004201a99:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a9c:	48 63 d0             	movslq %eax,%rdx
  8004201a9f:	48 89 d0             	mov    %rdx,%rax
  8004201aa2:	48 01 c0             	add    %rax,%rax
  8004201aa5:	48 01 d0             	add    %rdx,%rax
  8004201aa8:	48 c1 e0 03          	shl    $0x3,%rax
  8004201aac:	48 01 c8             	add    %rcx,%rax
  8004201aaf:	48 8b 10             	mov    (%rax),%rdx
  8004201ab2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201ab9:	48 89 d6             	mov    %rdx,%rsi
  8004201abc:	48 89 c7             	mov    %rax,%rdi
  8004201abf:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004201ac6:	00 00 00 
  8004201ac9:	ff d0                	callq  *%rax
  8004201acb:	85 c0                	test   %eax,%eax
  8004201acd:	75 3e                	jne    8004201b0d <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201acf:	48 b9 80 e5 22 04 80 	movabs $0x800422e580,%rcx
  8004201ad6:	00 00 00 
  8004201ad9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201adc:	48 63 d0             	movslq %eax,%rdx
  8004201adf:	48 89 d0             	mov    %rdx,%rax
  8004201ae2:	48 01 c0             	add    %rax,%rax
  8004201ae5:	48 01 d0             	add    %rdx,%rax
  8004201ae8:	48 c1 e0 03          	shl    $0x3,%rax
  8004201aec:	48 01 c8             	add    %rcx,%rax
  8004201aef:	48 83 c0 10          	add    $0x10,%rax
  8004201af3:	48 8b 00             	mov    (%rax),%rax
  8004201af6:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201afd:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201b04:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201b07:	89 cf                	mov    %ecx,%edi
  8004201b09:	ff d0                	callq  *%rax
  8004201b0b:	eb 3a                	jmp    8004201b47 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201b0d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201b11:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201b14:	83 f8 02             	cmp    $0x2,%eax
  8004201b17:	0f 86 72 ff ff ff    	jbe    8004201a8f <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b1d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b24:	48 89 c6             	mov    %rax,%rsi
  8004201b27:	48 bf d9 87 21 04 80 	movabs $0x80042187d9,%rdi
  8004201b2e:	00 00 00 
  8004201b31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b36:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201b3d:	00 00 00 
  8004201b40:	ff d2                	callq  *%rdx
	return 0;
  8004201b42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b47:	c9                   	leaveq 
  8004201b48:	c3                   	retq   

0000008004201b49 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b49:	55                   	push   %rbp
  8004201b4a:	48 89 e5             	mov    %rsp,%rbp
  8004201b4d:	48 83 ec 20          	sub    $0x20,%rsp
  8004201b51:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201b55:	48 bf f0 87 21 04 80 	movabs $0x80042187f0,%rdi
  8004201b5c:	00 00 00 
  8004201b5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b64:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201b6b:	00 00 00 
  8004201b6e:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201b70:	48 bf 18 88 21 04 80 	movabs $0x8004218818,%rdi
  8004201b77:	00 00 00 
  8004201b7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b7f:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201b86:	00 00 00 
  8004201b89:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201b8b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201b90:	74 13                	je     8004201ba5 <monitor+0x5c>
		print_trapframe(tf);
  8004201b92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201b96:	48 89 c7             	mov    %rax,%rdi
  8004201b99:	48 b8 e7 bd 20 04 80 	movabs $0x800420bde7,%rax
  8004201ba0:	00 00 00 
  8004201ba3:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201ba5:	48 bf 3d 88 21 04 80 	movabs $0x800421883d,%rdi
  8004201bac:	00 00 00 
  8004201baf:	48 b8 fb f5 20 04 80 	movabs $0x800420f5fb,%rax
  8004201bb6:	00 00 00 
  8004201bb9:	ff d0                	callq  *%rax
  8004201bbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201bbf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201bc4:	74 20                	je     8004201be6 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201bc6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201bca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bce:	48 89 d6             	mov    %rdx,%rsi
  8004201bd1:	48 89 c7             	mov    %rax,%rdi
  8004201bd4:	48 b8 38 19 20 04 80 	movabs $0x8004201938,%rax
  8004201bdb:	00 00 00 
  8004201bde:	ff d0                	callq  *%rax
  8004201be0:	85 c0                	test   %eax,%eax
  8004201be2:	79 02                	jns    8004201be6 <monitor+0x9d>
				break;
  8004201be4:	eb 02                	jmp    8004201be8 <monitor+0x9f>
	}
  8004201be6:	eb bd                	jmp    8004201ba5 <monitor+0x5c>
}
  8004201be8:	c9                   	leaveq 
  8004201be9:	c3                   	retq   

0000008004201bea <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201bea:	55                   	push   %rbp
  8004201beb:	48 89 e5             	mov    %rsp,%rbp
  8004201bee:	48 83 ec 08          	sub    $0x8,%rsp
  8004201bf2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201bf6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201bfa:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004201c01:	00 00 00 
  8004201c04:	48 8b 00             	mov    (%rax),%rax
  8004201c07:	48 29 c2             	sub    %rax,%rdx
  8004201c0a:	48 89 d0             	mov    %rdx,%rax
  8004201c0d:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201c11:	c9                   	leaveq 
  8004201c12:	c3                   	retq   

0000008004201c13 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201c13:	55                   	push   %rbp
  8004201c14:	48 89 e5             	mov    %rsp,%rbp
  8004201c17:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c1b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c23:	48 89 c7             	mov    %rax,%rdi
  8004201c26:	48 b8 ea 1b 20 04 80 	movabs $0x8004201bea,%rax
  8004201c2d:	00 00 00 
  8004201c30:	ff d0                	callq  *%rax
  8004201c32:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c36:	c9                   	leaveq 
  8004201c37:	c3                   	retq   

0000008004201c38 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c38:	55                   	push   %rbp
  8004201c39:	48 89 e5             	mov    %rsp,%rbp
  8004201c3c:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c40:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c48:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c4c:	48 89 c2             	mov    %rax,%rdx
  8004201c4f:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004201c56:	00 00 00 
  8004201c59:	48 8b 00             	mov    (%rax),%rax
  8004201c5c:	48 39 c2             	cmp    %rax,%rdx
  8004201c5f:	72 2a                	jb     8004201c8b <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201c61:	48 ba 48 88 21 04 80 	movabs $0x8004218848,%rdx
  8004201c68:	00 00 00 
  8004201c6b:	be 54 00 00 00       	mov    $0x54,%esi
  8004201c70:	48 bf 67 88 21 04 80 	movabs $0x8004218867,%rdi
  8004201c77:	00 00 00 
  8004201c7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c7f:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004201c86:	00 00 00 
  8004201c89:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201c8b:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004201c92:	00 00 00 
  8004201c95:	48 8b 00             	mov    (%rax),%rax
  8004201c98:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c9c:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201ca0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201ca4:	48 01 d0             	add    %rdx,%rax
}
  8004201ca7:	c9                   	leaveq 
  8004201ca8:	c3                   	retq   

0000008004201ca9 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201ca9:	55                   	push   %rbp
  8004201caa:	48 89 e5             	mov    %rsp,%rbp
  8004201cad:	48 83 ec 20          	sub    $0x20,%rsp
  8004201cb1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201cb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201cb9:	48 89 c7             	mov    %rax,%rdi
  8004201cbc:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004201cc3:	00 00 00 
  8004201cc6:	ff d0                	callq  *%rax
  8004201cc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201ccc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cd0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201cd4:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201cd7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201cda:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004201ce1:	00 00 00 
  8004201ce4:	48 8b 00             	mov    (%rax),%rax
  8004201ce7:	48 39 c2             	cmp    %rax,%rdx
  8004201cea:	72 32                	jb     8004201d1e <page2kva+0x75>
  8004201cec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cf0:	48 89 c1             	mov    %rax,%rcx
  8004201cf3:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004201cfa:	00 00 00 
  8004201cfd:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201d02:	48 bf 67 88 21 04 80 	movabs $0x8004218867,%rdi
  8004201d09:	00 00 00 
  8004201d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d11:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004201d18:	00 00 00 
  8004201d1b:	41 ff d0             	callq  *%r8
  8004201d1e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d25:	00 00 00 
  8004201d28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d2c:	48 01 d0             	add    %rdx,%rax
}
  8004201d2f:	c9                   	leaveq 
  8004201d30:	c3                   	retq   

0000008004201d31 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d31:	55                   	push   %rbp
  8004201d32:	48 89 e5             	mov    %rsp,%rbp
  8004201d35:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d39:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d3c:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d3f:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d43:	74 06                	je     8004201d4b <restrictive_type+0x1a>
  8004201d45:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d49:	75 07                	jne    8004201d52 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d4b:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201d50:	eb 3e                	jmp    8004201d90 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201d52:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201d56:	74 06                	je     8004201d5e <restrictive_type+0x2d>
  8004201d58:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201d5c:	75 07                	jne    8004201d65 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201d5e:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201d63:	eb 2b                	jmp    8004201d90 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201d65:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201d69:	74 06                	je     8004201d71 <restrictive_type+0x40>
  8004201d6b:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201d6f:	75 07                	jne    8004201d78 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201d71:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201d76:	eb 18                	jmp    8004201d90 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201d78:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201d7c:	74 06                	je     8004201d84 <restrictive_type+0x53>
  8004201d7e:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201d82:	75 07                	jne    8004201d8b <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201d84:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201d89:	eb 05                	jmp    8004201d90 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201d8b:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201d90:	c9                   	leaveq 
  8004201d91:	c3                   	retq   

0000008004201d92 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201d92:	55                   	push   %rbp
  8004201d93:	48 89 e5             	mov    %rsp,%rbp
  8004201d96:	53                   	push   %rbx
  8004201d97:	48 83 ec 18          	sub    $0x18,%rsp
  8004201d9b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201d9e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201da1:	89 c7                	mov    %eax,%edi
  8004201da3:	48 b8 62 8a 20 04 80 	movabs $0x8004208a62,%rax
  8004201daa:	00 00 00 
  8004201dad:	ff d0                	callq  *%rax
  8004201daf:	89 c3                	mov    %eax,%ebx
  8004201db1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201db4:	83 c0 01             	add    $0x1,%eax
  8004201db7:	89 c7                	mov    %eax,%edi
  8004201db9:	48 b8 62 8a 20 04 80 	movabs $0x8004208a62,%rax
  8004201dc0:	00 00 00 
  8004201dc3:	ff d0                	callq  *%rax
  8004201dc5:	c1 e0 08             	shl    $0x8,%eax
  8004201dc8:	09 d8                	or     %ebx,%eax
}
  8004201dca:	48 83 c4 18          	add    $0x18,%rsp
  8004201dce:	5b                   	pop    %rbx
  8004201dcf:	5d                   	pop    %rbp
  8004201dd0:	c3                   	retq   

0000008004201dd1 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201dd1:	55                   	push   %rbp
  8004201dd2:	48 89 e5             	mov    %rsp,%rbp
  8004201dd5:	41 54                	push   %r12
  8004201dd7:	53                   	push   %rbx
  8004201dd8:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201ddf:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201de6:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201ded:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201df4:	48 89 e0             	mov    %rsp,%rax
  8004201df7:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201dfa:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e01:	8b 40 30             	mov    0x30(%rax),%eax
  8004201e04:	89 c0                	mov    %eax,%eax
  8004201e06:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201e0a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e11:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201e14:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e19:	f7 e2                	mul    %edx
  8004201e1b:	89 d0                	mov    %edx,%eax
  8004201e1d:	c1 e8 04             	shr    $0x4,%eax
  8004201e20:	89 c0                	mov    %eax,%eax
  8004201e22:	48 89 c2             	mov    %rax,%rdx
  8004201e25:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e29:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e2d:	49 89 c0             	mov    %rax,%r8
  8004201e30:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e36:	48 89 c1             	mov    %rax,%rcx
  8004201e39:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201e3e:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e42:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e46:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e4b:	48 83 e8 01          	sub    $0x1,%rax
  8004201e4f:	48 01 d0             	add    %rdx,%rax
  8004201e52:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201e57:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e5c:	48 f7 f3             	div    %rbx
  8004201e5f:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201e63:	48 29 c4             	sub    %rax,%rsp
  8004201e66:	48 89 e0             	mov    %rsp,%rax
  8004201e69:	48 83 c0 07          	add    $0x7,%rax
  8004201e6d:	48 c1 e8 03          	shr    $0x3,%rax
  8004201e71:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e75:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201e79:	48 bf 9b 88 21 04 80 	movabs $0x800421889b,%rdi
  8004201e80:	00 00 00 
  8004201e83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e88:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004201e8f:	00 00 00 
  8004201e92:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e94:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e9b:	e9 6c 01 00 00       	jmpq   800420200c <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201ea0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ea3:	48 63 d0             	movslq %eax,%rdx
  8004201ea6:	48 89 d0             	mov    %rdx,%rax
  8004201ea9:	48 01 c0             	add    %rax,%rax
  8004201eac:	48 01 d0             	add    %rdx,%rax
  8004201eaf:	48 c1 e0 03          	shl    $0x3,%rax
  8004201eb3:	48 89 c2             	mov    %rax,%rdx
  8004201eb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201eba:	48 01 d0             	add    %rdx,%rax
  8004201ebd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201ec1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ec5:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ec8:	89 c0                	mov    %eax,%eax
  8004201eca:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ece:	48 89 c2             	mov    %rax,%rdx
  8004201ed1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ed5:	8b 40 04             	mov    0x4(%rax),%eax
  8004201ed8:	89 c0                	mov    %eax,%eax
  8004201eda:	48 01 d0             	add    %rdx,%rax
  8004201edd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ee1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ee5:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ee8:	89 c0                	mov    %eax,%eax
  8004201eea:	48 c1 e0 20          	shl    $0x20,%rax
  8004201eee:	48 89 c2             	mov    %rax,%rdx
  8004201ef1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ef5:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ef8:	89 c0                	mov    %eax,%eax
  8004201efa:	48 01 d0             	add    %rdx,%rax
  8004201efd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201f01:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f05:	8b 70 14             	mov    0x14(%rax),%esi
  8004201f08:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f0c:	8b 00                	mov    (%rax),%eax
  8004201f0e:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201f12:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201f16:	41 89 f0             	mov    %esi,%r8d
  8004201f19:	89 c6                	mov    %eax,%esi
  8004201f1b:	48 bf b0 88 21 04 80 	movabs $0x80042188b0,%rdi
  8004201f22:	00 00 00 
  8004201f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f2a:	49 b9 de 8d 20 04 80 	movabs $0x8004208dde,%r9
  8004201f31:	00 00 00 
  8004201f34:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f3b:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f3e:	83 f8 05             	cmp    $0x5,%eax
  8004201f41:	77 0b                	ja     8004201f4e <multiboot_read+0x17d>
  8004201f43:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f47:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f4a:	85 c0                	test   %eax,%eax
  8004201f4c:	75 0b                	jne    8004201f59 <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201f4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f52:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201f59:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201f60:	e9 85 00 00 00       	jmpq   8004201fea <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201f65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f69:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f6c:	48 63 d2             	movslq %edx,%rdx
  8004201f6f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f73:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201f77:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f7b:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f7e:	89 c0                	mov    %eax,%eax
  8004201f80:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f84:	48 89 c2             	mov    %rax,%rdx
  8004201f87:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f8b:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f8e:	89 c0                	mov    %eax,%eax
  8004201f90:	48 01 d0             	add    %rdx,%rax
  8004201f93:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201f97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f9b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201f9f:	76 45                	jbe    8004201fe6 <multiboot_read+0x215>
				int last = i+1;
  8004201fa1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201fa4:	83 c0 01             	add    $0x1,%eax
  8004201fa7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201faa:	eb 30                	jmp    8004201fdc <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201fac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fb0:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201fb3:	48 63 d2             	movslq %edx,%rdx
  8004201fb6:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201fba:	48 01 c2             	add    %rax,%rdx
  8004201fbd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fc1:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201fc4:	48 63 c9             	movslq %ecx,%rcx
  8004201fc7:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201fcb:	48 83 e9 08          	sub    $0x8,%rcx
  8004201fcf:	48 01 c8             	add    %rcx,%rax
  8004201fd2:	48 8b 00             	mov    (%rax),%rax
  8004201fd5:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201fd8:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201fdc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201fdf:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201fe2:	75 c8                	jne    8004201fac <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201fe4:	eb 10                	jmp    8004201ff6 <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201fe6:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201fea:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201fed:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201ff0:	0f 8c 6f ff ff ff    	jl     8004201f65 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201ff6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ffa:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201ffd:	48 63 d2             	movslq %edx,%rdx
  8004202000:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202004:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202008:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420200c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420200f:	48 63 c8             	movslq %eax,%rcx
  8004202012:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202019:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420201c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202021:	f7 e2                	mul    %edx
  8004202023:	89 d0                	mov    %edx,%eax
  8004202025:	c1 e8 04             	shr    $0x4,%eax
  8004202028:	89 c0                	mov    %eax,%eax
  800420202a:	48 39 c1             	cmp    %rax,%rcx
  800420202d:	0f 82 6d fe ff ff    	jb     8004201ea0 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004202033:	48 bf e7 88 21 04 80 	movabs $0x80042188e7,%rdi
  800420203a:	00 00 00 
  800420203d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202042:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004202049:	00 00 00 
  800420204c:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420204e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004202055:	e9 93 01 00 00       	jmpq   80042021ed <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  800420205a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420205d:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202060:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202064:	48 63 d2             	movslq %edx,%rdx
  8004202067:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420206b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  800420206f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202073:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202076:	48 63 d2             	movslq %edx,%rdx
  8004202079:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420207d:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202081:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202085:	8b 40 08             	mov    0x8(%rax),%eax
  8004202088:	89 c0                	mov    %eax,%eax
  800420208a:	48 c1 e0 20          	shl    $0x20,%rax
  800420208e:	48 89 c2             	mov    %rax,%rdx
  8004202091:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202095:	8b 40 04             	mov    0x4(%rax),%eax
  8004202098:	89 c0                	mov    %eax,%eax
  800420209a:	48 01 d0             	add    %rdx,%rax
  800420209d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  80042020a1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020a5:	8b 40 08             	mov    0x8(%rax),%eax
  80042020a8:	89 c0                	mov    %eax,%eax
  80042020aa:	48 c1 e0 20          	shl    $0x20,%rax
  80042020ae:	48 89 c2             	mov    %rax,%rdx
  80042020b1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020b5:	8b 40 04             	mov    0x4(%rax),%eax
  80042020b8:	89 c0                	mov    %eax,%eax
  80042020ba:	48 01 d0             	add    %rdx,%rax
  80042020bd:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042020c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020c5:	8b 40 10             	mov    0x10(%rax),%eax
  80042020c8:	89 c0                	mov    %eax,%eax
  80042020ca:	48 c1 e0 20          	shl    $0x20,%rax
  80042020ce:	48 89 c2             	mov    %rax,%rdx
  80042020d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020d5:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020d8:	89 c0                	mov    %eax,%eax
  80042020da:	48 01 d0             	add    %rdx,%rax
  80042020dd:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042020e4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020e8:	8b 40 10             	mov    0x10(%rax),%eax
  80042020eb:	89 c0                	mov    %eax,%eax
  80042020ed:	48 c1 e0 20          	shl    $0x20,%rax
  80042020f1:	48 89 c2             	mov    %rax,%rdx
  80042020f4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020f8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020fb:	89 c0                	mov    %eax,%eax
  80042020fd:	48 01 d0             	add    %rdx,%rax
  8004202100:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004202107:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420210e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202112:	48 01 d0             	add    %rdx,%rax
  8004202115:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202119:	75 7c                	jne    8004202197 <multiboot_read+0x3c6>
  800420211b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420211f:	8b 50 14             	mov    0x14(%rax),%edx
  8004202122:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202126:	8b 40 14             	mov    0x14(%rax),%eax
  8004202129:	39 c2                	cmp    %eax,%edx
  800420212b:	75 6a                	jne    8004202197 <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  800420212d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202134:	89 c2                	mov    %eax,%edx
  8004202136:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420213d:	01 c2                	add    %eax,%edx
  800420213f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202143:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004202146:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420214d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202154:	48 01 d0             	add    %rdx,%rax
  8004202157:	48 c1 e8 20          	shr    $0x20,%rax
  800420215b:	89 c2                	mov    %eax,%edx
  800420215d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202161:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004202164:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202168:	8b 50 04             	mov    0x4(%rax),%edx
  800420216b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420216f:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202172:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202176:	8b 50 08             	mov    0x8(%rax),%edx
  8004202179:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420217d:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202180:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202183:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202186:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420218a:	48 63 d2             	movslq %edx,%rdx
  800420218d:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004202194:	00 
  8004202195:	eb 52                	jmp    80042021e9 <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  8004202197:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420219e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042021a2:	48 01 d0             	add    %rdx,%rax
  80042021a5:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042021a9:	76 3e                	jbe    80042021e9 <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042021ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021af:	8b 50 14             	mov    0x14(%rax),%edx
  80042021b2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021b6:	8b 40 14             	mov    0x14(%rax),%eax
  80042021b9:	89 d6                	mov    %edx,%esi
  80042021bb:	89 c7                	mov    %eax,%edi
  80042021bd:	48 b8 31 1d 20 04 80 	movabs $0x8004201d31,%rax
  80042021c4:	00 00 00 
  80042021c7:	ff d0                	callq  *%rax
  80042021c9:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042021cf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021d3:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021d9:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042021dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021e0:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021e6:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021e9:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042021ed:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021f0:	48 63 c8             	movslq %eax,%rcx
  80042021f3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042021fa:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042021fd:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202202:	f7 e2                	mul    %edx
  8004202204:	89 d0                	mov    %edx,%eax
  8004202206:	c1 e8 04             	shr    $0x4,%eax
  8004202209:	89 c0                	mov    %eax,%eax
  800420220b:	48 39 c1             	cmp    %rax,%rcx
  800420220e:	0f 82 46 fe ff ff    	jb     800420205a <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202214:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420221b:	e9 dc 00 00 00       	jmpq   80042022fc <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202220:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202224:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202227:	48 63 d2             	movslq %edx,%rdx
  800420222a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420222e:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004202235:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800420223c:	00 
  800420223d:	0f 84 b5 00 00 00    	je     80042022f8 <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202243:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420224a:	8b 40 14             	mov    0x14(%rax),%eax
  800420224d:	83 f8 01             	cmp    $0x1,%eax
  8004202250:	74 13                	je     8004202265 <multiboot_read+0x494>
  8004202252:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202259:	8b 40 14             	mov    0x14(%rax),%eax
  800420225c:	83 f8 03             	cmp    $0x3,%eax
  800420225f:	0f 85 93 00 00 00    	jne    80042022f8 <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004202265:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420226c:	8b 40 04             	mov    0x4(%rax),%eax
  800420226f:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004202274:	77 49                	ja     80042022bf <multiboot_read+0x4ee>
  8004202276:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420227d:	8b 40 08             	mov    0x8(%rax),%eax
  8004202280:	85 c0                	test   %eax,%eax
  8004202282:	75 3b                	jne    80042022bf <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202284:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420228b:	48 8b 10             	mov    (%rax),%rdx
  800420228e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202295:	8b 40 10             	mov    0x10(%rax),%eax
  8004202298:	89 c0                	mov    %eax,%eax
  800420229a:	48 c1 e0 20          	shl    $0x20,%rax
  800420229e:	48 89 c1             	mov    %rax,%rcx
  80042022a1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022a8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022ab:	89 c0                	mov    %eax,%eax
  80042022ad:	48 01 c8             	add    %rcx,%rax
  80042022b0:	48 01 c2             	add    %rax,%rdx
  80042022b3:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022ba:	48 89 10             	mov    %rdx,(%rax)
  80042022bd:	eb 39                	jmp    80042022f8 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022bf:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022c6:	48 8b 10             	mov    (%rax),%rdx
  80042022c9:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022d0:	8b 40 10             	mov    0x10(%rax),%eax
  80042022d3:	89 c0                	mov    %eax,%eax
  80042022d5:	48 c1 e0 20          	shl    $0x20,%rax
  80042022d9:	48 89 c1             	mov    %rax,%rcx
  80042022dc:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022e3:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022e6:	89 c0                	mov    %eax,%eax
  80042022e8:	48 01 c8             	add    %rcx,%rax
  80042022eb:	48 01 c2             	add    %rax,%rdx
  80042022ee:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022f5:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042022f8:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042022fc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042022ff:	48 63 c8             	movslq %eax,%rcx
  8004202302:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202309:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420230c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202311:	f7 e2                	mul    %edx
  8004202313:	89 d0                	mov    %edx,%eax
  8004202315:	c1 e8 04             	shr    $0x4,%eax
  8004202318:	89 c0                	mov    %eax,%eax
  800420231a:	48 39 c1             	cmp    %rax,%rcx
  800420231d:	0f 82 fd fe ff ff    	jb     8004202220 <multiboot_read+0x44f>
  8004202323:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202326:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800420232a:	5b                   	pop    %rbx
  800420232b:	41 5c                	pop    %r12
  800420232d:	5d                   	pop    %rbp
  800420232e:	c3                   	retq   

000000800420232f <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  800420232f:	55                   	push   %rbp
  8004202330:	48 89 e5             	mov    %rsp,%rbp
  8004202333:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202337:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420233e:	00 
	size_t extmem = 0;
  800420233f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202346:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202347:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  800420234e:	00 00 00 
  8004202351:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202355:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202359:	48 8b 00             	mov    (%rax),%rax
  800420235c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202360:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202365:	74 2d                	je     8004202394 <i386_detect_memory+0x65>
  8004202367:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420236b:	8b 00                	mov    (%rax),%eax
  800420236d:	83 e0 40             	and    $0x40,%eax
  8004202370:	85 c0                	test   %eax,%eax
  8004202372:	74 20                	je     8004202394 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202374:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004202378:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800420237c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202380:	48 89 ce             	mov    %rcx,%rsi
  8004202383:	48 89 c7             	mov    %rax,%rdi
  8004202386:	48 b8 d1 1d 20 04 80 	movabs $0x8004201dd1,%rax
  800420238d:	00 00 00 
  8004202390:	ff d0                	callq  *%rax
  8004202392:	eb 34                	jmp    80042023c8 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202394:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202399:	48 b8 92 1d 20 04 80 	movabs $0x8004201d92,%rax
  80042023a0:	00 00 00 
  80042023a3:	ff d0                	callq  *%rax
  80042023a5:	c1 e0 0a             	shl    $0xa,%eax
  80042023a8:	48 98                	cltq   
  80042023aa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042023ae:	bf 17 00 00 00       	mov    $0x17,%edi
  80042023b3:	48 b8 92 1d 20 04 80 	movabs $0x8004201d92,%rax
  80042023ba:	00 00 00 
  80042023bd:	ff d0                	callq  *%rax
  80042023bf:	c1 e0 0a             	shl    $0xa,%eax
  80042023c2:	48 98                	cltq   
  80042023c4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042023c8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023cc:	48 85 c0             	test   %rax,%rax
  80042023cf:	75 35                	jne    8004202406 <i386_detect_memory+0xd7>
  80042023d1:	48 b9 e9 88 21 04 80 	movabs $0x80042188e9,%rcx
  80042023d8:	00 00 00 
  80042023db:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042023e2:	00 00 00 
  80042023e5:	be 89 00 00 00       	mov    $0x89,%esi
  80042023ea:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042023f1:	00 00 00 
  80042023f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023f9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202400:	00 00 00 
  8004202403:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202406:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420240a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420240e:	48 89 c2             	mov    %rax,%rdx
  8004202411:	48 b8 30 a2 60 04 80 	movabs $0x800460a230,%rax
  8004202418:	00 00 00 
  800420241b:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  800420241e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202422:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202426:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420242a:	bf 17 00 00 00       	mov    $0x17,%edi
  800420242f:	48 b8 92 1d 20 04 80 	movabs $0x8004201d92,%rax
  8004202436:	00 00 00 
  8004202439:	ff d0                	callq  *%rax
  800420243b:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202440:	75 2c                	jne    800420246e <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202442:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202447:	48 b8 92 1d 20 04 80 	movabs $0x8004201d92,%rax
  800420244e:	00 00 00 
  8004202451:	ff d0                	callq  *%rax
  8004202453:	c1 e0 10             	shl    $0x10,%eax
  8004202456:	48 98                	cltq   
  8004202458:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  800420245c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202460:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202466:	48 c1 e8 0c          	shr    $0xc,%rax
  800420246a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  800420246e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202473:	74 1a                	je     800420248f <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202475:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202479:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202480:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202487:	00 00 00 
  800420248a:	48 89 10             	mov    %rdx,(%rax)
  800420248d:	eb 1a                	jmp    80042024a9 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  800420248f:	48 b8 30 a2 60 04 80 	movabs $0x800460a230,%rax
  8004202496:	00 00 00 
  8004202499:	48 8b 10             	mov    (%rax),%rdx
  800420249c:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042024a3:	00 00 00 
  80042024a6:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024a9:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042024b0:	00 00 00 
  80042024b3:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042024b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024ba:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024be:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024c2:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042024c5:	48 b8 30 a2 60 04 80 	movabs $0x800460a230,%rax
  80042024cc:	00 00 00 
  80042024cf:	48 8b 00             	mov    (%rax),%rax
  80042024d2:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024d6:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024da:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042024dd:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042024e4:	00 00 00 
  80042024e7:	48 8b 00             	mov    (%rax),%rax
  80042024ea:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024ee:	48 c1 e8 14          	shr    $0x14,%rax
  80042024f2:	49 89 f0             	mov    %rsi,%r8
  80042024f5:	48 89 c6             	mov    %rax,%rsi
  80042024f8:	48 bf 18 89 21 04 80 	movabs $0x8004218918,%rdi
  80042024ff:	00 00 00 
  8004202502:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202507:	49 b9 de 8d 20 04 80 	movabs $0x8004208dde,%r9
  800420250e:	00 00 00 
  8004202511:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202514:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420251b:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420251c:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202523:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202524:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202528:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420252c:	48 c1 e8 14          	shr    $0x14,%rax
  8004202530:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202533:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202537:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420253b:	48 c1 e8 14          	shr    $0x14,%rax
  800420253f:	48 89 c6             	mov    %rax,%rsi
  8004202542:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202546:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420254a:	49 89 c8             	mov    %rcx,%r8
  800420254d:	48 89 d1             	mov    %rdx,%rcx
  8004202550:	48 89 f2             	mov    %rsi,%rdx
  8004202553:	48 89 c6             	mov    %rax,%rsi
  8004202556:	48 bf 68 89 21 04 80 	movabs $0x8004218968,%rdi
  800420255d:	00 00 00 
  8004202560:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202565:	49 b9 de 8d 20 04 80 	movabs $0x8004208dde,%r9
  800420256c:	00 00 00 
  800420256f:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202572:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202576:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420257a:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  800420257f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202583:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420258a:	00 00 00 
  800420258d:	48 8b 00             	mov    (%rax),%rax
  8004202590:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202594:	76 3a                	jbe    80042025d0 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  8004202596:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420259a:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042025a1:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042025a8:	00 00 00 
  80042025ab:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042025ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042025b2:	48 89 c6             	mov    %rax,%rsi
  80042025b5:	48 bf d0 89 21 04 80 	movabs $0x80042189d0,%rdi
  80042025bc:	00 00 00 
  80042025bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025c4:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042025cb:	00 00 00 
  80042025ce:	ff d2                	callq  *%rdx
	}
}
  80042025d0:	c9                   	leaveq 
  80042025d1:	c3                   	retq   

00000080042025d2 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042025d2:	55                   	push   %rbp
  80042025d3:	48 89 e5             	mov    %rsp,%rbp
  80042025d6:	48 83 ec 40          	sub    $0x40,%rsp
  80042025da:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042025dd:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  80042025e4:	00 00 00 
  80042025e7:	48 8b 00             	mov    (%rax),%rax
  80042025ea:	48 85 c0             	test   %rax,%rax
  80042025ed:	75 4b                	jne    800420263a <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  80042025ef:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042025f6:	00 
  80042025f7:	48 b8 18 00 69 04 80 	movabs $0x8004690018,%rax
  80042025fe:	00 00 00 
  8004202601:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202605:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202609:	48 01 d0             	add    %rdx,%rax
  800420260c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202610:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202614:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202619:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420261d:	48 89 d0             	mov    %rdx,%rax
  8004202620:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202624:	48 29 c2             	sub    %rax,%rdx
  8004202627:	48 89 d0             	mov    %rdx,%rax
  800420262a:	48 89 c2             	mov    %rax,%rdx
  800420262d:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  8004202634:	00 00 00 
  8004202637:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n == 0) 
  800420263a:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420263e:	75 12                	jne    8004202652 <boot_alloc+0x80>
		return nextfree;
  8004202640:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  8004202647:	00 00 00 
  800420264a:	48 8b 00             	mov    (%rax),%rax
  800420264d:	e9 cf 00 00 00       	jmpq   8004202721 <boot_alloc+0x14f>
	result = nextfree;
  8004202652:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  8004202659:	00 00 00 
  800420265c:	48 8b 00             	mov    (%rax),%rax
  800420265f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = nextfree + n;
  8004202663:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  800420266a:	00 00 00 
  800420266d:	48 8b 10             	mov    (%rax),%rdx
  8004202670:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202673:	48 01 c2             	add    %rax,%rdx
  8004202676:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  800420267d:	00 00 00 
  8004202680:	48 89 10             	mov    %rdx,(%rax)
	nextfree = ROUNDUP(nextfree, PGSIZE);
  8004202683:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420268a:	00 
  800420268b:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  8004202692:	00 00 00 
  8004202695:	48 8b 00             	mov    (%rax),%rax
  8004202698:	48 89 c2             	mov    %rax,%rdx
  800420269b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420269f:	48 01 d0             	add    %rdx,%rax
  80042026a2:	48 83 e8 01          	sub    $0x1,%rax
  80042026a6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042026aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042026ae:	ba 00 00 00 00       	mov    $0x0,%edx
  80042026b3:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042026b7:	48 89 d0             	mov    %rdx,%rax
  80042026ba:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042026be:	48 29 c2             	sub    %rax,%rdx
  80042026c1:	48 89 d0             	mov    %rdx,%rax
  80042026c4:	48 89 c2             	mov    %rax,%rdx
  80042026c7:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  80042026ce:	00 00 00 
  80042026d1:	48 89 10             	mov    %rdx,(%rax)
	//process memory wrap arounds on memory full
	if((uint64_t)nextfree < (uint64_t)end)
  80042026d4:	48 b8 48 a2 60 04 80 	movabs $0x800460a248,%rax
  80042026db:	00 00 00 
  80042026de:	48 8b 00             	mov    (%rax),%rax
  80042026e1:	48 89 c2             	mov    %rax,%rdx
  80042026e4:	48 b8 18 00 69 04 80 	movabs $0x8004690018,%rax
  80042026eb:	00 00 00 
  80042026ee:	48 39 c2             	cmp    %rax,%rdx
  80042026f1:	73 2a                	jae    800420271d <boot_alloc+0x14b>
	{
		panic("we're out of memory");
  80042026f3:	48 ba f9 89 21 04 80 	movabs $0x80042189f9,%rdx
  80042026fa:	00 00 00 
  80042026fd:	be e9 00 00 00       	mov    $0xe9,%esi
  8004202702:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202709:	00 00 00 
  800420270c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202711:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004202718:	00 00 00 
  800420271b:	ff d1                	callq  *%rcx
	}
	return result;
  800420271d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202721:	c9                   	leaveq 
  8004202722:	c3                   	retq   

0000008004202723 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202723:	55                   	push   %rbp
  8004202724:	48 89 e5             	mov    %rsp,%rbp
  8004202727:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  800420272b:	48 b8 2f 23 20 04 80 	movabs $0x800420232f,%rax
  8004202732:	00 00 00 
  8004202735:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202737:	bf 00 10 00 00       	mov    $0x1000,%edi
  800420273c:	48 b8 d2 25 20 04 80 	movabs $0x80042025d2,%rax
  8004202743:	00 00 00 
  8004202746:	ff d0                	callq  *%rax
  8004202748:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  800420274c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202750:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202755:	be 00 00 00 00       	mov    $0x0,%esi
  800420275a:	48 89 c7             	mov    %rax,%rdi
  800420275d:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004202764:	00 00 00 
  8004202767:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202769:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004202770:	00 00 00 
  8004202773:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202777:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  800420277a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420277e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202782:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202789:	00 00 00 
  800420278c:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202790:	77 32                	ja     80042027c4 <x64_vm_init+0xa1>
  8004202792:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202796:	48 89 c1             	mov    %rax,%rcx
  8004202799:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  80042027a0:	00 00 00 
  80042027a3:	be 07 01 00 00       	mov    $0x107,%esi
  80042027a8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042027af:	00 00 00 
  80042027b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027b7:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042027be:	00 00 00 
  80042027c1:	41 ff d0             	callq  *%r8
  80042027c4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042027cb:	ff ff ff 
  80042027ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027d2:	48 01 c2             	add    %rax,%rdx
  80042027d5:	48 b8 50 d4 60 04 80 	movabs $0x800460d450,%rax
  80042027dc:	00 00 00 
  80042027df:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  80042027e2:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042027e9:	00 00 00 
  80042027ec:	48 8b 00             	mov    (%rax),%rax
  80042027ef:	c1 e0 04             	shl    $0x4,%eax
  80042027f2:	89 c7                	mov    %eax,%edi
  80042027f4:	48 b8 d2 25 20 04 80 	movabs $0x80042025d2,%rax
  80042027fb:	00 00 00 
  80042027fe:	ff d0                	callq  *%rax
  8004202800:	48 ba 68 d4 60 04 80 	movabs $0x800460d468,%rdx
  8004202807:	00 00 00 
  800420280a:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
	envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
  800420280d:	bf 00 80 04 00       	mov    $0x48000,%edi
  8004202812:	48 b8 d2 25 20 04 80 	movabs $0x80042025d2,%rax
  8004202819:	00 00 00 
  800420281c:	ff d0                	callq  *%rax
  800420281e:	48 ba 50 a2 60 04 80 	movabs $0x800460a250,%rdx
  8004202825:	00 00 00 
  8004202828:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  800420282b:	48 b8 97 2b 20 04 80 	movabs $0x8004202b97,%rax
  8004202832:	00 00 00 
  8004202835:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
    boot_map_region(pml4e, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U|PTE_P);
  8004202837:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  800420283e:	00 00 00 
  8004202841:	48 8b 00             	mov    (%rax),%rax
  8004202844:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202848:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420284f:	00 00 00 
  8004202852:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202856:	77 32                	ja     800420288a <x64_vm_init+0x167>
  8004202858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420285c:	48 89 c1             	mov    %rax,%rcx
  800420285f:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202866:	00 00 00 
  8004202869:	be 26 01 00 00       	mov    $0x126,%esi
  800420286e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202875:	00 00 00 
  8004202878:	b8 00 00 00 00       	mov    $0x0,%eax
  800420287d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202884:	00 00 00 
  8004202887:	41 ff d0             	callq  *%r8
  800420288a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202891:	ff ff ff 
  8004202894:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202898:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800420289c:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042028a3:	00 00 00 
  80042028a6:	48 8b 00             	mov    (%rax),%rax
  80042028a9:	48 c1 e0 04          	shl    $0x4,%rax
  80042028ad:	48 89 c2             	mov    %rax,%rdx
  80042028b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042028b4:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042028ba:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  80042028c1:	00 00 00 
  80042028c4:	48 89 c7             	mov    %rax,%rdi
  80042028c7:	48 b8 17 37 20 04 80 	movabs $0x8004203717,%rax
  80042028ce:	00 00 00 
  80042028d1:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U|PTE_P);
  80042028d3:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  80042028da:	00 00 00 
  80042028dd:	48 8b 00             	mov    (%rax),%rax
  80042028e0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042028e4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028eb:	00 00 00 
  80042028ee:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042028f2:	77 32                	ja     8004202926 <x64_vm_init+0x203>
  80042028f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028f8:	48 89 c1             	mov    %rax,%rcx
  80042028fb:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202902:	00 00 00 
  8004202905:	be 2f 01 00 00       	mov    $0x12f,%esi
  800420290a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202911:	00 00 00 
  8004202914:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202919:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202920:	00 00 00 
  8004202923:	41 ff d0             	callq  *%r8
  8004202926:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420292d:	ff ff ff 
  8004202930:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202934:	48 01 c2             	add    %rax,%rdx
  8004202937:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420293b:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202941:	48 89 d1             	mov    %rdx,%rcx
  8004202944:	ba 00 80 04 00       	mov    $0x48000,%edx
  8004202949:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202950:	00 00 00 
  8004202953:	48 89 c7             	mov    %rax,%rdi
  8004202956:	48 b8 17 37 20 04 80 	movabs $0x8004203717,%rax
  800420295d:	00 00 00 
  8004202960:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202962:	48 b8 b8 2a 20 04 80 	movabs $0x8004202ab8,%rax
  8004202969:	00 00 00 
  800420296c:	ff d0                	callq  *%rax
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_P|PTE_W);
  800420296e:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202975:	00 00 00 
  8004202978:	48 8b 00             	mov    (%rax),%rax
  800420297b:	48 c1 e0 0c          	shl    $0xc,%rax
  800420297f:	48 89 c2             	mov    %rax,%rdx
  8004202982:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202986:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  800420298c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202991:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202998:	00 00 00 
  800420299b:	48 89 c7             	mov    %rax,%rdi
  800420299e:	48 b8 17 37 20 04 80 	movabs $0x8004203717,%rax
  80042029a5:	00 00 00 
  80042029a8:	ff d0                	callq  *%rax
	//check_boot_pml4e(boot_pml4e);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  80042029aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042029ae:	48 83 c0 08          	add    $0x8,%rax
  80042029b2:	48 8b 00             	mov    (%rax),%rax
  80042029b5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042029bb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042029bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029c3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042029c7:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042029ca:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042029cd:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042029d4:	00 00 00 
  80042029d7:	48 8b 00             	mov    (%rax),%rax
  80042029da:	48 39 c2             	cmp    %rax,%rdx
  80042029dd:	72 32                	jb     8004202a11 <x64_vm_init+0x2ee>
  80042029df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029e3:	48 89 c1             	mov    %rax,%rcx
  80042029e6:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042029ed:	00 00 00 
  80042029f0:	be 4f 01 00 00       	mov    $0x14f,%esi
  80042029f5:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042029fc:	00 00 00 
  80042029ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a04:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202a0b:	00 00 00 
  8004202a0e:	41 ff d0             	callq  *%r8
  8004202a11:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a18:	00 00 00 
  8004202a1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202a1f:	48 01 d0             	add    %rdx,%rax
  8004202a22:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202a26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a2a:	48 8b 00             	mov    (%rax),%rax
  8004202a2d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a33:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a3b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a3f:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202a42:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202a45:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202a4c:	00 00 00 
  8004202a4f:	48 8b 00             	mov    (%rax),%rax
  8004202a52:	48 39 c2             	cmp    %rax,%rdx
  8004202a55:	72 32                	jb     8004202a89 <x64_vm_init+0x366>
  8004202a57:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a5b:	48 89 c1             	mov    %rax,%rcx
  8004202a5e:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004202a65:	00 00 00 
  8004202a68:	be 50 01 00 00       	mov    $0x150,%esi
  8004202a6d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202a74:	00 00 00 
  8004202a77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a7c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202a83:	00 00 00 
  8004202a86:	41 ff d0             	callq  *%r8
  8004202a89:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a90:	00 00 00 
  8004202a93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a97:	48 01 d0             	add    %rdx,%rax
  8004202a9a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004202a9e:	48 b8 50 d4 60 04 80 	movabs $0x800460d450,%rax
  8004202aa5:	00 00 00 
  8004202aa8:	48 8b 00             	mov    (%rax),%rax
  8004202aab:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202aaf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202ab3:	0f 22 d8             	mov    %rax,%cr3

    //check_page_free_list(1);
	//check_page_alloc();
	//page_check();
	//check_page_free_list(0);
}
  8004202ab6:	c9                   	leaveq 
  8004202ab7:	c3                   	retq   

0000008004202ab8 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202ab8:	55                   	push   %rbp
  8004202ab9:	48 89 e5             	mov    %rsp,%rbp
  8004202abc:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
  8004202ac0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint64_t la = KSTACKTOP;
  8004202ac7:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202ace:	00 00 00 
  8004202ad1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(; i < NCPU; i++)
  8004202ad5:	e9 b1 00 00 00       	jmpq   8004202b8b <mem_init_mp+0xd3>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  8004202ada:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202add:	48 98                	cltq   
  8004202adf:	48 c1 e0 10          	shl    $0x10,%rax
  8004202ae3:	48 89 c2             	mov    %rax,%rdx
  8004202ae6:	48 b8 00 00 61 04 80 	movabs $0x8004610000,%rax
  8004202aed:	00 00 00 
  8004202af0:	48 01 d0             	add    %rdx,%rax
  8004202af3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202af7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202afe:	00 00 00 
  8004202b01:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202b05:	77 32                	ja     8004202b39 <mem_init_mp+0x81>
  8004202b07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b0b:	48 89 c1             	mov    %rax,%rcx
  8004202b0e:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202b15:	00 00 00 
  8004202b18:	be 75 01 00 00       	mov    $0x175,%esi
  8004202b1d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202b24:	00 00 00 
  8004202b27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b2c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202b33:	00 00 00 
  8004202b36:	41 ff d0             	callq  *%r8
  8004202b39:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202b40:	ff ff ff 
  8004202b43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b47:	48 01 c2             	add    %rax,%rdx
  8004202b4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202b4e:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202b55:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004202b5c:	00 00 00 
  8004202b5f:	48 8b 00             	mov    (%rax),%rax
  8004202b62:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202b68:	48 89 d1             	mov    %rdx,%rcx
  8004202b6b:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202b70:	48 89 c7             	mov    %rax,%rdi
  8004202b73:	48 b8 17 37 20 04 80 	movabs $0x8004203717,%rax
  8004202b7a:	00 00 00 
  8004202b7d:	ff d0                	callq  *%rax
		la -= (KSTKSIZE + KSTKGAP);
  8004202b7f:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202b86:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
	uint64_t la = KSTACKTOP;
	for(; i < NCPU; i++)
  8004202b87:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202b8b:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202b8f:	0f 8e 45 ff ff ff    	jle    8004202ada <mem_init_mp+0x22>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
		la -= (KSTKSIZE + KSTKGAP);
	}
}
  8004202b95:	c9                   	leaveq 
  8004202b96:	c3                   	retq   

0000008004202b97 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202b97:	55                   	push   %rbp
  8004202b98:	48 89 e5             	mov    %rsp,%rbp
  8004202b9b:	48 83 ec 70          	sub    $0x70,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
  8004202b9f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202ba6:	00 
	for (i = 0; i < npages; i++) {
  8004202ba7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202bae:	00 
  8004202baf:	e9 ab 00 00 00       	jmpq   8004202c5f <page_init+0xc8>
		pages[i].pp_ref = 0;
  8004202bb4:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202bbb:	00 00 00 
  8004202bbe:	48 8b 00             	mov    (%rax),%rax
  8004202bc1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bc5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bc9:	48 01 d0             	add    %rdx,%rax
  8004202bcc:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202bd2:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202bd9:	00 00 00 
  8004202bdc:	48 8b 00             	mov    (%rax),%rax
  8004202bdf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202be3:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202be7:	48 01 d0             	add    %rdx,%rax
  8004202bea:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if(last)
  8004202bf1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202bf6:	74 21                	je     8004202c19 <page_init+0x82>
			last->pp_link = &pages[i];
  8004202bf8:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202bff:	00 00 00 
  8004202c02:	48 8b 00             	mov    (%rax),%rax
  8004202c05:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c09:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c0d:	48 01 c2             	add    %rax,%rdx
  8004202c10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c14:	48 89 10             	mov    %rdx,(%rax)
  8004202c17:	eb 25                	jmp    8004202c3e <page_init+0xa7>
		else
			page_free_list = &pages[i];
  8004202c19:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202c20:	00 00 00 
  8004202c23:	48 8b 00             	mov    (%rax),%rax
  8004202c26:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c2a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c2e:	48 01 c2             	add    %rax,%rdx
  8004202c31:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202c38:	00 00 00 
  8004202c3b:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  8004202c3e:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202c45:	00 00 00 
  8004202c48:	48 8b 00             	mov    (%rax),%rax
  8004202c4b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c4f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c53:	48 01 d0             	add    %rdx,%rax
  8004202c56:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202c5a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202c5f:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202c66:	00 00 00 
  8004202c69:	48 8b 00             	mov    (%rax),%rax
  8004202c6c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c70:	0f 82 3e ff ff ff    	jb     8004202bb4 <page_init+0x1d>
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	//remove page 0 from page list
	page_free_list = page_free_list->pp_link;
  8004202c76:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202c7d:	00 00 00 
  8004202c80:	48 8b 00             	mov    (%rax),%rax
  8004202c83:	48 8b 10             	mov    (%rax),%rdx
  8004202c86:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202c8d:	00 00 00 
  8004202c90:	48 89 10             	mov    %rdx,(%rax)

	//remove entries of holes till current kernel available memory pointer
	holeS = IOPHYSMEM/PGSIZE;
  8004202c93:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004202c9a:	00 
	kernE = PADDR(boot_alloc(0))/PGSIZE;
  8004202c9b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202ca0:	48 b8 d2 25 20 04 80 	movabs $0x80042025d2,%rax
  8004202ca7:	00 00 00 
  8004202caa:	ff d0                	callq  *%rax
  8004202cac:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202cb0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202cb7:	00 00 00 
  8004202cba:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202cbe:	77 32                	ja     8004202cf2 <page_init+0x15b>
  8004202cc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202cc4:	48 89 c1             	mov    %rax,%rcx
  8004202cc7:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202cce:	00 00 00 
  8004202cd1:	be b2 01 00 00       	mov    $0x1b2,%esi
  8004202cd6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202cdd:	00 00 00 
  8004202ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ce5:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202cec:	00 00 00 
  8004202cef:	41 ff d0             	callq  *%r8
  8004202cf2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202cf9:	ff ff ff 
  8004202cfc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d00:	48 01 d0             	add    %rdx,%rax
  8004202d03:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d07:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pages[holeS - 1].pp_link = &pages[kernE];
  8004202d0b:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202d12:	00 00 00 
  8004202d15:	48 8b 00             	mov    (%rax),%rax
  8004202d18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d1c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d20:	48 83 ea 10          	sub    $0x10,%rdx
  8004202d24:	48 01 c2             	add    %rax,%rdx
  8004202d27:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202d2e:	00 00 00 
  8004202d31:	48 8b 00             	mov    (%rax),%rax
  8004202d34:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202d38:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202d3c:	48 01 c8             	add    %rcx,%rax
  8004202d3f:	48 89 02             	mov    %rax,(%rdx)

	bootPTS = PADDR(BOOT_PAGE_TABLE_START)/PGSIZE;	
  8004202d42:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d49:	00 00 00 
  8004202d4c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202d50:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d54:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d58:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202d5b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202d5e:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202d65:	00 00 00 
  8004202d68:	48 8b 00             	mov    (%rax),%rax
  8004202d6b:	48 39 c2             	cmp    %rax,%rdx
  8004202d6e:	72 32                	jb     8004202da2 <page_init+0x20b>
  8004202d70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d74:	48 89 c1             	mov    %rax,%rcx
  8004202d77:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004202d7e:	00 00 00 
  8004202d81:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202d86:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202d8d:	00 00 00 
  8004202d90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d95:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202d9c:	00 00 00 
  8004202d9f:	41 ff d0             	callq  *%r8
  8004202da2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202da9:	00 00 00 
  8004202dac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202db0:	48 01 d0             	add    %rdx,%rax
  8004202db3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202db7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202dbe:	00 00 00 
  8004202dc1:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202dc5:	77 32                	ja     8004202df9 <page_init+0x262>
  8004202dc7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202dcb:	48 89 c1             	mov    %rax,%rcx
  8004202dce:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202dd5:	00 00 00 
  8004202dd8:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202ddd:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202de4:	00 00 00 
  8004202de7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dec:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202df3:	00 00 00 
  8004202df6:	41 ff d0             	callq  *%r8
  8004202df9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202e00:	ff ff ff 
  8004202e03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e07:	48 01 d0             	add    %rdx,%rax
  8004202e0a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e0e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	bootPTE = PADDR(BOOT_PAGE_TABLE_END - 1)/PGSIZE;
  8004202e12:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e19:	00 00 00 
  8004202e1c:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202e22:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202e26:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e2a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e2e:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8004202e31:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202e34:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004202e3b:	00 00 00 
  8004202e3e:	48 8b 00             	mov    (%rax),%rax
  8004202e41:	48 39 c2             	cmp    %rax,%rdx
  8004202e44:	72 32                	jb     8004202e78 <page_init+0x2e1>
  8004202e46:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e4a:	48 89 c1             	mov    %rax,%rcx
  8004202e4d:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004202e54:	00 00 00 
  8004202e57:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202e5c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202e63:	00 00 00 
  8004202e66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e6b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202e72:	00 00 00 
  8004202e75:	41 ff d0             	callq  *%r8
  8004202e78:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e7f:	00 00 00 
  8004202e82:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e86:	48 01 d0             	add    %rdx,%rax
  8004202e89:	48 83 e8 01          	sub    $0x1,%rax
  8004202e8d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202e91:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e98:	00 00 00 
  8004202e9b:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  8004202e9f:	77 32                	ja     8004202ed3 <page_init+0x33c>
  8004202ea1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ea5:	48 89 c1             	mov    %rax,%rcx
  8004202ea8:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004202eaf:	00 00 00 
  8004202eb2:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202eb7:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004202ebe:	00 00 00 
  8004202ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ec6:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004202ecd:	00 00 00 
  8004202ed0:	41 ff d0             	callq  *%r8
  8004202ed3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202eda:	ff ff ff 
  8004202edd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ee1:	48 01 d0             	add    %rdx,%rax
  8004202ee4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ee8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pages[bootPTS - 1].pp_link = &pages[bootPTE + 1];
  8004202eec:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202ef3:	00 00 00 
  8004202ef6:	48 8b 00             	mov    (%rax),%rax
  8004202ef9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202efd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f01:	48 83 ea 10          	sub    $0x10,%rdx
  8004202f05:	48 01 c2             	add    %rax,%rdx
  8004202f08:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202f0f:	00 00 00 
  8004202f12:	48 8b 00             	mov    (%rax),%rax
  8004202f15:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004202f19:	48 83 c1 01          	add    $0x1,%rcx
  8004202f1d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202f21:	48 01 c8             	add    %rcx,%rax
  8004202f24:	48 89 02             	mov    %rax,(%rdx)

	//marking page at MPENTRY_PADDR as being used 
	pages[MPENTRY_PADDR / PGSIZE - 1].pp_link = &pages[MPENTRY_PADDR / PGSIZE + 1];
  8004202f27:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202f2e:	00 00 00 
  8004202f31:	48 8b 00             	mov    (%rax),%rax
  8004202f34:	48 8d 50 60          	lea    0x60(%rax),%rdx
  8004202f38:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004202f3f:	00 00 00 
  8004202f42:	48 8b 00             	mov    (%rax),%rax
  8004202f45:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004202f49:	48 89 02             	mov    %rax,(%rdx)
}
  8004202f4c:	c9                   	leaveq 
  8004202f4d:	c3                   	retq   

0000008004202f4e <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202f4e:	55                   	push   %rbp
  8004202f4f:	48 89 e5             	mov    %rsp,%rbp
  8004202f52:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f56:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo * page = NULL;
  8004202f59:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202f60:	00 
	if(page_free_list)
  8004202f61:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202f68:	00 00 00 
  8004202f6b:	48 8b 00             	mov    (%rax),%rax
  8004202f6e:	48 85 c0             	test   %rax,%rax
  8004202f71:	74 6f                	je     8004202fe2 <page_alloc+0x94>
	{
		page = page_free_list;
  8004202f73:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202f7a:	00 00 00 
  8004202f7d:	48 8b 00             	mov    (%rax),%rax
  8004202f80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		page_free_list = page_free_list->pp_link;
  8004202f84:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202f8b:	00 00 00 
  8004202f8e:	48 8b 00             	mov    (%rax),%rax
  8004202f91:	48 8b 10             	mov    (%rax),%rdx
  8004202f94:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004202f9b:	00 00 00 
  8004202f9e:	48 89 10             	mov    %rdx,(%rax)
		page->pp_link = NULL;
  8004202fa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fa5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
//		cprintf("Umesh: physical addresses =[%x]\n",page);
		if(alloc_flags & ALLOC_ZERO)
  8004202fac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202faf:	83 e0 01             	and    $0x1,%eax
  8004202fb2:	85 c0                	test   %eax,%eax
  8004202fb4:	74 2c                	je     8004202fe2 <page_alloc+0x94>
		{
			memset(page2kva(page), '\0', PGSIZE);
  8004202fb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fba:	48 89 c7             	mov    %rax,%rdi
  8004202fbd:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004202fc4:	00 00 00 
  8004202fc7:	ff d0                	callq  *%rax
  8004202fc9:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202fce:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fd3:	48 89 c7             	mov    %rax,%rdi
  8004202fd6:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004202fdd:	00 00 00 
  8004202fe0:	ff d0                	callq  *%rax
		}
	}
	else{
		//cprintf("page alloc failed\n");
	}
	return page;
  8004202fe2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202fe6:	c9                   	leaveq 
  8004202fe7:	c3                   	retq   

0000008004202fe8 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202fe8:	55                   	push   %rbp
  8004202fe9:	48 89 e5             	mov    %rsp,%rbp
  8004202fec:	48 83 ec 10          	sub    $0x10,%rsp
  8004202ff0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202ff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ff8:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202ffd:	be 00 00 00 00       	mov    $0x0,%esi
  8004203002:	48 89 c7             	mov    %rax,%rdi
  8004203005:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  800420300c:	00 00 00 
  800420300f:	ff d0                	callq  *%rax
}
  8004203011:	c9                   	leaveq 
  8004203012:	c3                   	retq   

0000008004203013 <insertAtBegining>:

void insertAtBegining(struct PageInfo ** list, struct PageInfo * node)
{
  8004203013:	55                   	push   %rbp
  8004203014:	48 89 e5             	mov    %rsp,%rbp
  8004203017:	48 83 ec 10          	sub    $0x10,%rsp
  800420301b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420301f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if(*list == NULL)
  8004203023:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203027:	48 8b 00             	mov    (%rax),%rax
  800420302a:	48 85 c0             	test   %rax,%rax
  800420302d:	75 0d                	jne    800420303c <insertAtBegining+0x29>
	{
		*list = node;
  800420302f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203033:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203037:	48 89 10             	mov    %rdx,(%rax)
  800420303a:	eb 2c                	jmp    8004203068 <insertAtBegining+0x55>
	}
	else if(*list != NULL && node != NULL)
  800420303c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203040:	48 8b 00             	mov    (%rax),%rax
  8004203043:	48 85 c0             	test   %rax,%rax
  8004203046:	74 20                	je     8004203068 <insertAtBegining+0x55>
  8004203048:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420304d:	74 19                	je     8004203068 <insertAtBegining+0x55>
	{
		node->pp_link = *list;
  800420304f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203053:	48 8b 10             	mov    (%rax),%rdx
  8004203056:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420305a:	48 89 10             	mov    %rdx,(%rax)
		*list = node;
  800420305d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203061:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203065:	48 89 10             	mov    %rdx,(%rax)
	}
}
  8004203068:	c9                   	leaveq 
  8004203069:	c3                   	retq   

000000800420306a <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  800420306a:	55                   	push   %rbp
  800420306b:	48 89 e5             	mov    %rsp,%rbp
  800420306e:	48 83 ec 10          	sub    $0x10,%rsp
  8004203072:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0)
  8004203076:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420307a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420307e:	66 85 c0             	test   %ax,%ax
  8004203081:	74 2a                	je     80042030ad <page_free+0x43>
	{	
		panic("pp->pp_ref is nonzero");
  8004203083:	48 ba 34 8a 21 04 80 	movabs $0x8004218a34,%rdx
  800420308a:	00 00 00 
  800420308d:	be 03 02 00 00       	mov    $0x203,%esi
  8004203092:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004203099:	00 00 00 
  800420309c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030a1:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  80042030a8:	00 00 00 
  80042030ab:	ff d1                	callq  *%rcx
	}
	else if(pp->pp_link)
  80042030ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030b1:	48 8b 00             	mov    (%rax),%rax
  80042030b4:	48 85 c0             	test   %rax,%rax
  80042030b7:	74 2a                	je     80042030e3 <page_free+0x79>
	{
		panic("pp->pp_link is not NULL");
  80042030b9:	48 ba 4a 8a 21 04 80 	movabs $0x8004218a4a,%rdx
  80042030c0:	00 00 00 
  80042030c3:	be 07 02 00 00       	mov    $0x207,%esi
  80042030c8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042030cf:	00 00 00 
  80042030d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030d7:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  80042030de:	00 00 00 
  80042030e1:	ff d1                	callq  *%rcx
	}
	else
	{
		//insert node to be freed at the begining of free node list
		insertAtBegining(&page_free_list, pp);
  80042030e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030e7:	48 89 c6             	mov    %rax,%rsi
  80042030ea:	48 bf 38 a2 60 04 80 	movabs $0x800460a238,%rdi
  80042030f1:	00 00 00 
  80042030f4:	48 b8 13 30 20 04 80 	movabs $0x8004203013,%rax
  80042030fb:	00 00 00 
  80042030fe:	ff d0                	callq  *%rax
	}
}
  8004203100:	c9                   	leaveq 
  8004203101:	c3                   	retq   

0000008004203102 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203102:	55                   	push   %rbp
  8004203103:	48 89 e5             	mov    %rsp,%rbp
  8004203106:	48 83 ec 10          	sub    $0x10,%rsp
  800420310a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  800420310e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203112:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203116:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203119:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420311d:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203125:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203129:	66 85 c0             	test   %ax,%ax
  800420312c:	75 13                	jne    8004203141 <page_decref+0x3f>
		page_free(pp);
  800420312e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203132:	48 89 c7             	mov    %rax,%rdi
  8004203135:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  800420313c:	00 00 00 
  800420313f:	ff d0                	callq  *%rax
}
  8004203141:	c9                   	leaveq 
  8004203142:	c3                   	retq   

0000008004203143 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203143:	55                   	push   %rbp
  8004203144:	48 89 e5             	mov    %rsp,%rbp
  8004203147:	53                   	push   %rbx
  8004203148:	48 83 ec 58          	sub    $0x58,%rsp
  800420314c:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203150:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203154:	89 55 ac             	mov    %edx,-0x54(%rbp)
	//Need to return
	pte_t * pml4eIndexPtr = NULL;
  8004203157:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420315e:	00 
	int pml4eIndex;
	int pdpeIndex;
	uint64_t temp;
	struct PageInfo * page = NULL;
  800420315f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203166:	00 
	if(pml4e == NULL)
  8004203167:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420316c:	75 0a                	jne    8004203178 <pml4e_walk+0x35>
	{
		return NULL;
  800420316e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203173:	e9 c5 01 00 00       	jmpq   800420333d <pml4e_walk+0x1fa>
	}
	pml4eIndex = PML4(va);
  8004203178:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420317c:	48 c1 e8 27          	shr    $0x27,%rax
  8004203180:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203185:	89 45 dc             	mov    %eax,-0x24(%rbp)

	if((uint64_t*)pml4e[pml4eIndex] == NULL && create == false)
  8004203188:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420318b:	48 98                	cltq   
  800420318d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203194:	00 
  8004203195:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203199:	48 01 d0             	add    %rdx,%rax
  800420319c:	48 8b 00             	mov    (%rax),%rax
  800420319f:	48 85 c0             	test   %rax,%rax
  80042031a2:	75 10                	jne    80042031b4 <pml4e_walk+0x71>
  80042031a4:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042031a8:	75 0a                	jne    80042031b4 <pml4e_walk+0x71>
	{
		return NULL;
  80042031aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031af:	e9 89 01 00 00       	jmpq   800420333d <pml4e_walk+0x1fa>
	}
	else if((uint64_t*)pml4e[pml4eIndex] == NULL && create == true)
  80042031b4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042031b7:	48 98                	cltq   
  80042031b9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031c0:	00 
  80042031c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042031c5:	48 01 d0             	add    %rdx,%rax
  80042031c8:	48 8b 00             	mov    (%rax),%rax
  80042031cb:	48 85 c0             	test   %rax,%rax
  80042031ce:	75 7a                	jne    800420324a <pml4e_walk+0x107>
  80042031d0:	83 7d ac 01          	cmpl   $0x1,-0x54(%rbp)
  80042031d4:	75 74                	jne    800420324a <pml4e_walk+0x107>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042031d6:	c7 45 d8 07 00 00 00 	movl   $0x7,-0x28(%rbp)
		page = page_alloc(ALLOC_ZERO);
  80042031dd:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031e2:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042031e9:	00 00 00 
  80042031ec:	ff d0                	callq  *%rax
  80042031ee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!page)
  80042031f2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042031f7:	75 0a                	jne    8004203203 <pml4e_walk+0xc0>
			return NULL;
  80042031f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031fe:	e9 3a 01 00 00       	jmpq   800420333d <pml4e_walk+0x1fa>
		page->pp_ref++;
  8004203203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203207:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420320b:	8d 50 01             	lea    0x1(%rax),%edx
  800420320e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203212:	66 89 50 08          	mov    %dx,0x8(%rax)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
		pml4e[pml4eIndex] = page2pa(page) | perm;
  8004203216:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203219:	48 98                	cltq   
  800420321b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203222:	00 
  8004203223:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203227:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420322b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420322f:	48 89 c7             	mov    %rax,%rdi
  8004203232:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203239:	00 00 00 
  800420323c:	ff d0                	callq  *%rax
  800420323e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004203241:	48 63 d2             	movslq %edx,%rdx
  8004203244:	48 09 d0             	or     %rdx,%rax
  8004203247:	48 89 03             	mov    %rax,(%rbx)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
	}
	//pml4e entry with last 12 bits permissions
	temp = pml4e[pml4eIndex];
  800420324a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420324d:	48 98                	cltq   
  800420324f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203256:	00 
  8004203257:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420325b:	48 01 d0             	add    %rdx,%rax
  800420325e:	48 8b 00             	mov    (%rax),%rax
  8004203261:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203265:	48 81 65 d0 00 f0 ff 	andq   $0xfffffffffffff000,-0x30(%rbp)
  800420326c:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  800420326d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203271:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203275:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203279:	48 c1 e8 0c          	shr    $0xc,%rax
  800420327d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203280:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203283:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420328a:	00 00 00 
  800420328d:	48 8b 00             	mov    (%rax),%rax
  8004203290:	48 39 c2             	cmp    %rax,%rdx
  8004203293:	72 32                	jb     80042032c7 <pml4e_walk+0x184>
  8004203295:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203299:	48 89 c1             	mov    %rax,%rcx
  800420329c:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042032a3:	00 00 00 
  80042032a6:	be 57 02 00 00       	mov    $0x257,%esi
  80042032ab:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042032b2:	00 00 00 
  80042032b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032ba:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042032c1:	00 00 00 
  80042032c4:	41 ff d0             	callq  *%r8
  80042032c7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032ce:	00 00 00 
  80042032d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042032d5:	48 01 d0             	add    %rdx,%rax
  80042032d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//increase pgtable index to get index pointer in page table
	pml4eIndexPtr = (pte_t *)pdpe_walk((pte_t *)temp, va, create); 
  80042032dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042032e0:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042032e3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042032e7:	48 89 ce             	mov    %rcx,%rsi
  80042032ea:	48 89 c7             	mov    %rax,%rdi
  80042032ed:	48 b8 44 33 20 04 80 	movabs $0x8004203344,%rax
  80042032f4:	00 00 00 
  80042032f7:	ff d0                	callq  *%rax
  80042032f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//Null check
	if(pml4eIndexPtr == NULL && page != NULL)
  80042032fd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203302:	75 35                	jne    8004203339 <pml4e_walk+0x1f6>
  8004203304:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203309:	74 2e                	je     8004203339 <pml4e_walk+0x1f6>
	{
		page_decref(page);
  800420330b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420330f:	48 89 c7             	mov    %rax,%rdi
  8004203312:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004203319:	00 00 00 
  800420331c:	ff d0                	callq  *%rax
        pml4e[pml4eIndex] = 0;
  800420331e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203321:	48 98                	cltq   
  8004203323:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420332a:	00 
  800420332b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420332f:	48 01 d0             	add    %rdx,%rax
  8004203332:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pml4eIndexPtr;
  8004203339:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  800420333d:	48 83 c4 58          	add    $0x58,%rsp
  8004203341:	5b                   	pop    %rbx
  8004203342:	5d                   	pop    %rbp
  8004203343:	c3                   	retq   

0000008004203344 <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  8004203344:	55                   	push   %rbp
  8004203345:	48 89 e5             	mov    %rsp,%rbp
  8004203348:	53                   	push   %rbx
  8004203349:	48 83 ec 68          	sub    $0x68,%rsp
  800420334d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203351:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203355:	89 55 9c             	mov    %edx,-0x64(%rbp)
	//Need to return
	pte_t * pdpeIndexPtr = NULL;
  8004203358:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420335f:	00 
	int pdpeIndex = 0;
  8004203360:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	int pgdirIndex = 0;
  8004203367:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	uint64_t temp;
	struct PageInfo * page = NULL;
  800420336e:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004203375:	00 
	if(pdpe == NULL)
  8004203376:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420337b:	75 0a                	jne    8004203387 <pdpe_walk+0x43>
	{
		return NULL;
  800420337d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203382:	e9 c5 01 00 00       	jmpq   800420354c <pdpe_walk+0x208>
	}
	pdpeIndex = PDPE(va);
  8004203387:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420338b:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420338f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203394:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if(!(uint64_t*)pdpe[pdpeIndex] && create == false)
  8004203397:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420339a:	48 98                	cltq   
  800420339c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033a3:	00 
  80042033a4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033a8:	48 01 d0             	add    %rdx,%rax
  80042033ab:	48 8b 00             	mov    (%rax),%rax
  80042033ae:	48 85 c0             	test   %rax,%rax
  80042033b1:	75 10                	jne    80042033c3 <pdpe_walk+0x7f>
  80042033b3:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042033b7:	75 0a                	jne    80042033c3 <pdpe_walk+0x7f>
	{
		return NULL;
  80042033b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033be:	e9 89 01 00 00       	jmpq   800420354c <pdpe_walk+0x208>
	}
	else if((uint64_t*)pdpe[pdpeIndex] == NULL && create == true)
  80042033c3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042033c6:	48 98                	cltq   
  80042033c8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033cf:	00 
  80042033d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033d4:	48 01 d0             	add    %rdx,%rax
  80042033d7:	48 8b 00             	mov    (%rax),%rax
  80042033da:	48 85 c0             	test   %rax,%rax
  80042033dd:	75 7a                	jne    8004203459 <pdpe_walk+0x115>
  80042033df:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042033e3:	75 74                	jne    8004203459 <pdpe_walk+0x115>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042033e5:	c7 45 d4 07 00 00 00 	movl   $0x7,-0x2c(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042033ec:	bf 01 00 00 00       	mov    $0x1,%edi
  80042033f1:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042033f8:	00 00 00 
  80042033fb:	ff d0                	callq  *%rax
  80042033fd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(!page)
  8004203401:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004203406:	75 0a                	jne    8004203412 <pdpe_walk+0xce>
			return NULL;
  8004203408:	b8 00 00 00 00       	mov    $0x0,%eax
  800420340d:	e9 3a 01 00 00       	jmpq   800420354c <pdpe_walk+0x208>
		page->pp_ref++;
  8004203412:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203416:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420341a:	8d 50 01             	lea    0x1(%rax),%edx
  800420341d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203421:	66 89 50 08          	mov    %dx,0x8(%rax)
		pdpe[pdpeIndex] = page2pa(page) | perm;
  8004203425:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203428:	48 98                	cltq   
  800420342a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203431:	00 
  8004203432:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203436:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420343a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420343e:	48 89 c7             	mov    %rax,%rdi
  8004203441:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203448:	00 00 00 
  800420344b:	ff d0                	callq  *%rax
  800420344d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203450:	48 63 d2             	movslq %edx,%rdx
  8004203453:	48 09 d0             	or     %rdx,%rax
  8004203456:	48 89 03             	mov    %rax,(%rbx)
	}
	//pdpe entry with last 12 bits permissions
	temp = pdpe[pdpeIndex];
  8004203459:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420345c:	48 98                	cltq   
  800420345e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203465:	00 
  8004203466:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420346a:	48 01 d0             	add    %rdx,%rax
  800420346d:	48 8b 00             	mov    (%rax),%rax
  8004203470:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203474:	48 81 65 c0 00 f0 ff 	andq   $0xfffffffffffff000,-0x40(%rbp)
  800420347b:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  800420347c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203480:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004203484:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203488:	48 c1 e8 0c          	shr    $0xc,%rax
  800420348c:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  800420348f:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004203492:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004203499:	00 00 00 
  800420349c:	48 8b 00             	mov    (%rax),%rax
  800420349f:	48 39 c2             	cmp    %rax,%rdx
  80042034a2:	72 32                	jb     80042034d6 <pdpe_walk+0x192>
  80042034a4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034a8:	48 89 c1             	mov    %rax,%rcx
  80042034ab:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042034b2:	00 00 00 
  80042034b5:	be 88 02 00 00       	mov    $0x288,%esi
  80042034ba:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042034c1:	00 00 00 
  80042034c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034c9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042034d0:	00 00 00 
  80042034d3:	41 ff d0             	callq  *%r8
  80042034d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034dd:	00 00 00 
  80042034e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034e4:	48 01 d0             	add    %rdx,%rax
  80042034e7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//increase pgtable index to get index pointer in page table
	pdpeIndexPtr = (pte_t *)pgdir_walk((pte_t *)temp, va, create);
  80042034eb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034ef:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042034f2:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042034f6:	48 89 ce             	mov    %rcx,%rsi
  80042034f9:	48 89 c7             	mov    %rax,%rdi
  80042034fc:	48 b8 53 35 20 04 80 	movabs $0x8004203553,%rax
  8004203503:	00 00 00 
  8004203506:	ff d0                	callq  *%rax
  8004203508:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//Null check
	if(pdpeIndexPtr == NULL && page != NULL)
  800420350c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203511:	75 35                	jne    8004203548 <pdpe_walk+0x204>
  8004203513:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203518:	74 2e                	je     8004203548 <pdpe_walk+0x204>
	{
        page_decref(page);
  800420351a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420351e:	48 89 c7             	mov    %rax,%rdi
  8004203521:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004203528:	00 00 00 
  800420352b:	ff d0                	callq  *%rax
        pdpe[pdpeIndex] = 0;
  800420352d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203530:	48 98                	cltq   
  8004203532:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203539:	00 
  800420353a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420353e:	48 01 d0             	add    %rdx,%rax
  8004203541:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR(pdpe[pdpeIndex]), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pdpeIndexPtr;
  8004203548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420354c:	48 83 c4 68          	add    $0x68,%rsp
  8004203550:	5b                   	pop    %rbx
  8004203551:	5d                   	pop    %rbp
  8004203552:	c3                   	retq   

0000008004203553 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203553:	55                   	push   %rbp
  8004203554:	48 89 e5             	mov    %rsp,%rbp
  8004203557:	53                   	push   %rbx
  8004203558:	48 83 ec 68          	sub    $0x68,%rsp
  800420355c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203560:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203564:	89 55 9c             	mov    %edx,-0x64(%rbp)
	// Fill this function in
	//Need to return
	pte_t * pgTblIndexPtr = NULL;
  8004203567:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420356e:	00 
	int dirIndex;
	int pgTblIndex;
	uint64_t temp;
	if(pgdir == NULL)
  800420356f:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203574:	75 0a                	jne    8004203580 <pgdir_walk+0x2d>
	{
		return NULL;
  8004203576:	b8 00 00 00 00       	mov    $0x0,%eax
  800420357b:	e9 90 01 00 00       	jmpq   8004203710 <pgdir_walk+0x1bd>
	}
	dirIndex = PDX(va);
  8004203580:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203584:	48 c1 e8 15          	shr    $0x15,%rax
  8004203588:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420358d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	pgTblIndex = PTX(va);
  8004203590:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203594:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203598:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420359d:	89 45 e0             	mov    %eax,-0x20(%rbp)
	if((uint64_t*)pgdir[dirIndex] == NULL && create == false)
  80042035a0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035a3:	48 98                	cltq   
  80042035a5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035ac:	00 
  80042035ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035b1:	48 01 d0             	add    %rdx,%rax
  80042035b4:	48 8b 00             	mov    (%rax),%rax
  80042035b7:	48 85 c0             	test   %rax,%rax
  80042035ba:	75 10                	jne    80042035cc <pgdir_walk+0x79>
  80042035bc:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042035c0:	75 0a                	jne    80042035cc <pgdir_walk+0x79>
	{
		return NULL;
  80042035c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035c7:	e9 44 01 00 00       	jmpq   8004203710 <pgdir_walk+0x1bd>
	}
	else if((uint64_t*)pgdir[dirIndex] == NULL && create == true)
  80042035cc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035cf:	48 98                	cltq   
  80042035d1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035d8:	00 
  80042035d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035dd:	48 01 d0             	add    %rdx,%rax
  80042035e0:	48 8b 00             	mov    (%rax),%rax
  80042035e3:	48 85 c0             	test   %rax,%rax
  80042035e6:	75 7a                	jne    8004203662 <pgdir_walk+0x10f>
  80042035e8:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042035ec:	75 74                	jne    8004203662 <pgdir_walk+0x10f>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042035ee:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042035f5:	bf 01 00 00 00       	mov    $0x1,%edi
  80042035fa:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004203601:	00 00 00 
  8004203604:	ff d0                	callq  *%rax
  8004203606:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!page)
  800420360a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420360f:	75 0a                	jne    800420361b <pgdir_walk+0xc8>
			return NULL;
  8004203611:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203616:	e9 f5 00 00 00       	jmpq   8004203710 <pgdir_walk+0x1bd>
		page->pp_ref++;
  800420361b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420361f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203623:	8d 50 01             	lea    0x1(%rax),%edx
  8004203626:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420362a:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[dirIndex] = page2pa(page) | perm;
  800420362e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203631:	48 98                	cltq   
  8004203633:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420363a:	00 
  800420363b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420363f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203643:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203647:	48 89 c7             	mov    %rax,%rdi
  800420364a:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203651:	00 00 00 
  8004203654:	ff d0                	callq  *%rax
  8004203656:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203659:	48 63 d2             	movslq %edx,%rdx
  800420365c:	48 09 d0             	or     %rdx,%rax
  800420365f:	48 89 03             	mov    %rax,(%rbx)
	}
	//pgdir entry with last 12 bits permissions
	temp = pgdir[dirIndex];
  8004203662:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203665:	48 98                	cltq   
  8004203667:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420366e:	00 
  800420366f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203673:	48 01 d0             	add    %rdx,%rax
  8004203676:	48 8b 00             	mov    (%rax),%rax
  8004203679:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  800420367d:	48 81 65 c8 00 f0 ff 	andq   $0xfffffffffffff000,-0x38(%rbp)
  8004203684:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203685:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203689:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420368d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203691:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203695:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203698:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420369b:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042036a2:	00 00 00 
  80042036a5:	48 8b 00             	mov    (%rax),%rax
  80042036a8:	48 39 c2             	cmp    %rax,%rdx
  80042036ab:	72 32                	jb     80042036df <pgdir_walk+0x18c>
  80042036ad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036b1:	48 89 c1             	mov    %rax,%rcx
  80042036b4:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042036bb:	00 00 00 
  80042036be:	be bb 02 00 00       	mov    $0x2bb,%esi
  80042036c3:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042036ca:	00 00 00 
  80042036cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036d2:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042036d9:	00 00 00 
  80042036dc:	41 ff d0             	callq  *%r8
  80042036df:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036e6:	00 00 00 
  80042036e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036ed:	48 01 d0             	add    %rdx,%rax
  80042036f0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//increase pgtable index to get index pointer in page table
	pgTblIndexPtr = (pte_t *)temp + pgTblIndex;
  80042036f4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036f7:	48 98                	cltq   
  80042036f9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203700:	00 
  8004203701:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203705:	48 01 d0             	add    %rdx,%rax
  8004203708:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR((uint64_t)(pgdir + dirIndex)), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pgTblIndexPtr;
  800420370c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203710:	48 83 c4 68          	add    $0x68,%rsp
  8004203714:	5b                   	pop    %rbx
  8004203715:	5d                   	pop    %rbp
  8004203716:	c3                   	retq   

0000008004203717 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203717:	55                   	push   %rbp
  8004203718:	48 89 e5             	mov    %rsp,%rbp
  800420371b:	48 83 ec 50          	sub    $0x50,%rsp
  800420371f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203723:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004203727:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420372b:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800420372f:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
        // Fill this function in
        pte_t *pte_store = NULL;
  8004203733:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420373a:	00 
        pte_t * pgTblIndexPtr = NULL;
  800420373b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203742:	00 

        int i = 0;
  8004203743:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
        if(pml4e == NULL)
  800420374a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420374f:	75 05                	jne    8004203756 <boot_map_region+0x3f>
        {
                return;
  8004203751:	e9 82 00 00 00       	jmpq   80042037d8 <boot_map_region+0xc1>
        }

        for(; i < size / PGSIZE; i++)
  8004203756:	eb 6e                	jmp    80042037c6 <boot_map_region+0xaf>
        {
        	pgTblIndexPtr = pml4e_walk(pml4e, (void *)la , 1);
  8004203758:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420375c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203760:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203765:	48 89 ce             	mov    %rcx,%rsi
  8004203768:	48 89 c7             	mov    %rax,%rdi
  800420376b:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004203772:	00 00 00 
  8004203775:	ff d0                	callq  *%rax
  8004203777:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        	if(pgTblIndexPtr == NULL)
  800420377b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203780:	75 1d                	jne    800420379f <boot_map_region+0x88>
        	{
        		cprintf("Error: could not bootmap");
  8004203782:	48 bf 62 8a 21 04 80 	movabs $0x8004218a62,%rdi
  8004203789:	00 00 00 
  800420378c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203791:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004203798:	00 00 00 
  800420379b:	ff d2                	callq  *%rdx
        	    continue;
  800420379d:	eb 23                	jmp    80042037c2 <boot_map_region+0xab>
        	}
            *pgTblIndexPtr = pa | perm;
  800420379f:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042037a2:	48 98                	cltq   
  80042037a4:	48 0b 45 c0          	or     -0x40(%rbp),%rax
  80042037a8:	48 89 c2             	mov    %rax,%rdx
  80042037ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037af:	48 89 10             	mov    %rdx,(%rax)
            pa += PGSIZE;
  80042037b2:	48 81 45 c0 00 10 00 	addq   $0x1000,-0x40(%rbp)
  80042037b9:	00 
            la += PGSIZE;
  80042037ba:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  80042037c1:	00 
        if(pml4e == NULL)
        {
                return;
        }

        for(; i < size / PGSIZE; i++)
  80042037c2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042037c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042037c9:	48 98                	cltq   
  80042037cb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042037cf:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042037d3:	48 39 d0             	cmp    %rdx,%rax
  80042037d6:	72 80                	jb     8004203758 <boot_map_region+0x41>
        	}
            *pgTblIndexPtr = pa | perm;
            pa += PGSIZE;
            la += PGSIZE;
        }
}
  80042037d8:	c9                   	leaveq 
  80042037d9:	c3                   	retq   

00000080042037da <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042037da:	55                   	push   %rbp
  80042037db:	48 89 e5             	mov    %rsp,%rbp
  80042037de:	48 83 ec 30          	sub    $0x30,%rsp
  80042037e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042037e6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042037ea:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042037ee:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	if(pml4e == NULL || pp == NULL)
  80042037f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042037f6:	74 07                	je     80042037ff <page_insert+0x25>
  80042037f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042037fd:	75 0a                	jne    8004203809 <page_insert+0x2f>
	{
		return 0;
  80042037ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203804:	e9 2c 01 00 00       	jmpq   8004203935 <page_insert+0x15b>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203809:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420380d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203811:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203816:	48 89 ce             	mov    %rcx,%rsi
  8004203819:	48 89 c7             	mov    %rax,%rdi
  800420381c:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004203823:	00 00 00 
  8004203826:	ff d0                	callq  *%rax
  8004203828:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  800420382c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203831:	75 0a                	jne    800420383d <page_insert+0x63>
	{
		return 	-E_NO_MEM;
  8004203833:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203838:	e9 f8 00 00 00       	jmpq   8004203935 <page_insert+0x15b>
	}
	//set present bit
	perm = perm|PTE_P;
  800420383d:	83 4d d4 01          	orl    $0x1,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & PTE_P;
  8004203841:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203845:	48 8b 00             	mov    (%rax),%rax
  8004203848:	83 e0 01             	and    $0x1,%eax
  800420384b:	48 85 c0             	test   %rax,%rax
  800420384e:	0f 95 c0             	setne  %al
  8004203851:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  8004203854:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8004203858:	74 66                	je     80042038c0 <page_insert+0xe6>
  800420385a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420385e:	48 8b 00             	mov    (%rax),%rax
  8004203861:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203867:	48 89 c7             	mov    %rax,%rdi
  800420386a:	48 b8 38 1c 20 04 80 	movabs $0x8004201c38,%rax
  8004203871:	00 00 00 
  8004203874:	ff d0                	callq  *%rax
  8004203876:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420387a:	75 44                	jne    80042038c0 <page_insert+0xe6>
	{		
		*pgTblIndexPtr = (page2pa(pp) | perm);
  800420387c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203880:	48 89 c7             	mov    %rax,%rdi
  8004203883:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  800420388a:	00 00 00 
  800420388d:	ff d0                	callq  *%rax
  800420388f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203892:	48 63 d2             	movslq %edx,%rdx
  8004203895:	48 09 c2             	or     %rax,%rdx
  8004203898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420389c:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  800420389f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038a7:	48 89 d6             	mov    %rdx,%rsi
  80042038aa:	48 89 c7             	mov    %rax,%rdi
  80042038ad:	48 b8 5f 3a 20 04 80 	movabs $0x8004203a5f,%rax
  80042038b4:	00 00 00 
  80042038b7:	ff d0                	callq  *%rax
		return 0;
  80042038b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038be:	eb 75                	jmp    8004203935 <page_insert+0x15b>
	}
	//check and remove previous existing page
	else if(present)
  80042038c0:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80042038c4:	74 34                	je     80042038fa <page_insert+0x120>
	{
		page_remove(pml4e, va);
  80042038c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038ce:	48 89 d6             	mov    %rdx,%rsi
  80042038d1:	48 89 c7             	mov    %rax,%rdi
  80042038d4:	48 b8 d1 39 20 04 80 	movabs $0x80042039d1,%rax
  80042038db:	00 00 00 
  80042038de:	ff d0                	callq  *%rax
		//invalidate tlb
		tlb_invalidate(pml4e, va);
  80042038e0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038e8:	48 89 d6             	mov    %rdx,%rsi
  80042038eb:	48 89 c7             	mov    %rax,%rdi
  80042038ee:	48 b8 5f 3a 20 04 80 	movabs $0x8004203a5f,%rax
  80042038f5:	00 00 00 
  80042038f8:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  80042038fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038fe:	48 89 c7             	mov    %rax,%rdi
  8004203901:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203908:	00 00 00 
  800420390b:	ff d0                	callq  *%rax
  800420390d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203910:	48 63 d2             	movslq %edx,%rdx
  8004203913:	48 09 c2             	or     %rax,%rdx
  8004203916:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420391a:	48 89 10             	mov    %rdx,(%rax)

	//increment reference
	pp->pp_ref += 1;
  800420391d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203921:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203925:	8d 50 01             	lea    0x1(%rax),%edx
  8004203928:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420392c:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  8004203930:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203935:	c9                   	leaveq 
  8004203936:	c3                   	retq   

0000008004203937 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203937:	55                   	push   %rbp
  8004203938:	48 89 e5             	mov    %rsp,%rbp
  800420393b:	48 83 ec 30          	sub    $0x30,%rsp
  800420393f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203943:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203947:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	struct PageInfo * page = NULL;
  800420394b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203952:	00 
	bool present;

	if(pml4e == NULL)
  8004203953:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203958:	75 06                	jne    8004203960 <page_lookup+0x29>
	{
		return page;
  800420395a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420395e:	eb 6f                	jmp    80042039cf <page_lookup+0x98>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203960:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203968:	ba 01 00 00 00       	mov    $0x1,%edx
  800420396d:	48 89 ce             	mov    %rcx,%rsi
  8004203970:	48 89 c7             	mov    %rax,%rdi
  8004203973:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  800420397a:	00 00 00 
  800420397d:	ff d0                	callq  *%rax
  800420397f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pgTblIndexPtr == NULL)
  8004203983:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203988:	75 06                	jne    8004203990 <page_lookup+0x59>
		return page;
  800420398a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420398e:	eb 3f                	jmp    80042039cf <page_lookup+0x98>
	
	if(*pgTblIndexPtr & PTE_P)
  8004203990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203994:	48 8b 00             	mov    (%rax),%rax
  8004203997:	83 e0 01             	and    $0x1,%eax
  800420399a:	48 85 c0             	test   %rax,%rax
  800420399d:	74 2c                	je     80042039cb <page_lookup+0x94>
	{
		page = pa2page(*pgTblIndexPtr);				
  800420399f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042039a3:	48 8b 00             	mov    (%rax),%rax
  80042039a6:	48 89 c7             	mov    %rax,%rdi
  80042039a9:	48 b8 38 1c 20 04 80 	movabs $0x8004201c38,%rax
  80042039b0:	00 00 00 
  80042039b3:	ff d0                	callq  *%rax
  80042039b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(pte_store)
  80042039b9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042039be:	74 0b                	je     80042039cb <page_lookup+0x94>
		{
			*pte_store = pgTblIndexPtr;
  80042039c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042039c8:	48 89 10             	mov    %rdx,(%rax)
		}
	}
	return page;
  80042039cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042039cf:	c9                   	leaveq 
  80042039d0:	c3                   	retq   

00000080042039d1 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042039d1:	55                   	push   %rbp
  80042039d2:	48 89 e5             	mov    %rsp,%rbp
  80042039d5:	48 83 ec 20          	sub    $0x20,%rsp
  80042039d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042039dd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	
	pte_t *pte_store = NULL;
  80042039e1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042039e8:	00 
	struct PageInfo* page_add = NULL;
  80042039e9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042039f0:	00 
	if(pml4e == NULL)
  80042039f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042039f6:	75 02                	jne    80042039fa <page_remove+0x29>
	{
		return;
  80042039f8:	eb 63                	jmp    8004203a5d <page_remove+0x8c>
	}
	
	page_add =  page_lookup(pml4e, va, &pte_store);
  80042039fa:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80042039fe:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203a02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a06:	48 89 ce             	mov    %rcx,%rsi
  8004203a09:	48 89 c7             	mov    %rax,%rdi
  8004203a0c:	48 b8 37 39 20 04 80 	movabs $0x8004203937,%rax
  8004203a13:	00 00 00 
  8004203a16:	ff d0                	callq  *%rax
  8004203a18:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_add == NULL)
  8004203a1c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a21:	75 02                	jne    8004203a25 <page_remove+0x54>
		return;
  8004203a23:	eb 38                	jmp    8004203a5d <page_remove+0x8c>
	
	tlb_invalidate(pml4e, va);
  8004203a25:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203a29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a2d:	48 89 d6             	mov    %rdx,%rsi
  8004203a30:	48 89 c7             	mov    %rax,%rdi
  8004203a33:	48 b8 5f 3a 20 04 80 	movabs $0x8004203a5f,%rax
  8004203a3a:	00 00 00 
  8004203a3d:	ff d0                	callq  *%rax
	page_decref(page_add);
  8004203a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a43:	48 89 c7             	mov    %rax,%rdi
  8004203a46:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004203a4d:	00 00 00 
  8004203a50:	ff d0                	callq  *%rax
	//The pg table entry corresponding to 'va' should be set to 0.
	*pte_store = 0;
  8004203a52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203a56:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8004203a5d:	c9                   	leaveq 
  8004203a5e:	c3                   	retq   

0000008004203a5f <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203a5f:	55                   	push   %rbp
  8004203a60:	48 89 e5             	mov    %rsp,%rbp
  8004203a63:	48 83 ec 20          	sub    $0x20,%rsp
  8004203a67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203a6b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203a6f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a74:	75 35                	jne    8004203aab <tlb_invalidate+0x4c>
  8004203a76:	48 b9 7b 8a 21 04 80 	movabs $0x8004218a7b,%rcx
  8004203a7d:	00 00 00 
  8004203a80:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004203a87:	00 00 00 
  8004203a8a:	be 80 03 00 00       	mov    $0x380,%esi
  8004203a8f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004203a96:	00 00 00 
  8004203a99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a9e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004203aa5:	00 00 00 
  8004203aa8:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203aab:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004203ab2:	00 00 00 
  8004203ab5:	ff d0                	callq  *%rax
  8004203ab7:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004203abe:	00 00 00 
  8004203ac1:	48 98                	cltq   
  8004203ac3:	48 c1 e0 03          	shl    $0x3,%rax
  8004203ac7:	48 89 c2             	mov    %rax,%rdx
  8004203aca:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203ace:	48 29 c2             	sub    %rax,%rdx
  8004203ad1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203ad5:	48 83 c0 08          	add    $0x8,%rax
  8004203ad9:	48 8b 00             	mov    (%rax),%rax
  8004203adc:	48 85 c0             	test   %rax,%rax
  8004203adf:	74 3e                	je     8004203b1f <tlb_invalidate+0xc0>
  8004203ae1:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004203ae8:	00 00 00 
  8004203aeb:	ff d0                	callq  *%rax
  8004203aed:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004203af4:	00 00 00 
  8004203af7:	48 98                	cltq   
  8004203af9:	48 c1 e0 03          	shl    $0x3,%rax
  8004203afd:	48 89 c2             	mov    %rax,%rdx
  8004203b00:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203b04:	48 29 c2             	sub    %rax,%rdx
  8004203b07:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203b0b:	48 83 c0 08          	add    $0x8,%rax
  8004203b0f:	48 8b 00             	mov    (%rax),%rax
  8004203b12:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203b19:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203b1d:	75 0f                	jne    8004203b2e <tlb_invalidate+0xcf>
  8004203b1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203b27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b2b:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203b2e:	c9                   	leaveq 
  8004203b2f:	c3                   	retq   

0000008004203b30 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203b30:	55                   	push   %rbp
  8004203b31:	48 89 e5             	mov    %rsp,%rbp
  8004203b34:	48 83 ec 30          	sub    $0x30,%rsp
  8004203b38:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203b3c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	uintptr_t base_prev;
	base_prev = base;
  8004203b40:	48 b8 c8 e5 22 04 80 	movabs $0x800422e5c8,%rax
  8004203b47:	00 00 00 
  8004203b4a:	48 8b 00             	mov    (%rax),%rax
  8004203b4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	/* check if base+size < MMIOLIM,roundpu size, do we need to round down/round up pa???? move base to new size,*/
	if((base+size) >= MMIOLIM){
  8004203b51:	48 b8 c8 e5 22 04 80 	movabs $0x800422e5c8,%rax
  8004203b58:	00 00 00 
  8004203b5b:	48 8b 10             	mov    (%rax),%rdx
  8004203b5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b62:	48 01 c2             	add    %rax,%rdx
  8004203b65:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203b6c:	00 00 00 
  8004203b6f:	48 39 c2             	cmp    %rax,%rdx
  8004203b72:	76 2a                	jbe    8004203b9e <mmio_map_region+0x6e>
			panic("Out of bound memory");
  8004203b74:	48 ba 87 8a 21 04 80 	movabs $0x8004218a87,%rdx
  8004203b7b:	00 00 00 
  8004203b7e:	be a9 03 00 00       	mov    $0x3a9,%esi
  8004203b83:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004203b8a:	00 00 00 
  8004203b8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b92:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004203b99:	00 00 00 
  8004203b9c:	ff d1                	callq  *%rcx
	}
	size = ROUNDUP(size, PGSIZE);
  8004203b9e:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203ba5:	00 
  8004203ba6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203baa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203bae:	48 01 d0             	add    %rdx,%rax
  8004203bb1:	48 83 e8 01          	sub    $0x1,%rax
  8004203bb5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203bb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203bbd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203bc2:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203bc6:	48 89 d0             	mov    %rdx,%rax
  8004203bc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203bcd:	48 29 c2             	sub    %rax,%rdx
  8004203bd0:	48 89 d0             	mov    %rdx,%rax
  8004203bd3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	boot_map_region(boot_pml4e, base, size,  pa,  PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004203bd7:	48 b8 c8 e5 22 04 80 	movabs $0x800422e5c8,%rax
  8004203bde:	00 00 00 
  8004203be1:	48 8b 30             	mov    (%rax),%rsi
  8004203be4:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004203beb:	00 00 00 
  8004203bee:	48 8b 00             	mov    (%rax),%rax
  8004203bf1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203bf5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203bf9:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203bff:	48 89 c7             	mov    %rax,%rdi
  8004203c02:	48 b8 17 37 20 04 80 	movabs $0x8004203717,%rax
  8004203c09:	00 00 00 
  8004203c0c:	ff d0                	callq  *%rax
	base+= size;
  8004203c0e:	48 b8 c8 e5 22 04 80 	movabs $0x800422e5c8,%rax
  8004203c15:	00 00 00 
  8004203c18:	48 8b 10             	mov    (%rax),%rdx
  8004203c1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c1f:	48 01 c2             	add    %rax,%rdx
  8004203c22:	48 b8 c8 e5 22 04 80 	movabs $0x800422e5c8,%rax
  8004203c29:	00 00 00 
  8004203c2c:	48 89 10             	mov    %rdx,(%rax)
	return (void*)base_prev;
  8004203c2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");

}
  8004203c33:	c9                   	leaveq 
  8004203c34:	c3                   	retq   

0000008004203c35 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203c35:	55                   	push   %rbp
  8004203c36:	48 89 e5             	mov    %rsp,%rbp
  8004203c39:	48 83 ec 50          	sub    $0x50,%rsp
  8004203c3d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203c41:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203c45:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203c49:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	struct PageInfo * page;
	pte_t *pte_store;
	void * vaT = (void*)va;
  8004203c4c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203c50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
  8004203c54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c58:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203c5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c60:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	vaE = ROUNDUP(vaT + len, PGSIZE);
  8004203c6a:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203c71:	00 
  8004203c72:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c76:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c7a:	48 01 d0             	add    %rdx,%rax
  8004203c7d:	48 89 c2             	mov    %rax,%rdx
  8004203c80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c84:	48 01 d0             	add    %rdx,%rax
  8004203c87:	48 83 e8 01          	sub    $0x1,%rax
  8004203c8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203c8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c93:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203c98:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203c9c:	48 89 d0             	mov    %rdx,%rax
  8004203c9f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203ca3:	48 29 c2             	sub    %rax,%rdx
  8004203ca6:	48 89 d0             	mov    %rdx,%rax
  8004203ca9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203cad:	e9 8c 00 00 00       	jmpq   8004203d3e <user_mem_check+0x109>
	{
		if((uintptr_t)vaT >= ULIM || !page_lookup(env->env_pml4e, vaT, &pte_store) || !pte_store || !(*pte_store & perm))
  8004203cb2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203cb6:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203cbd:	00 00 00 
  8004203cc0:	48 39 c2             	cmp    %rax,%rdx
  8004203cc3:	77 47                	ja     8004203d0c <user_mem_check+0xd7>
  8004203cc5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203cc9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203cd0:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004203cd4:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203cd8:	48 89 ce             	mov    %rcx,%rsi
  8004203cdb:	48 89 c7             	mov    %rax,%rdi
  8004203cde:	48 b8 37 39 20 04 80 	movabs $0x8004203937,%rax
  8004203ce5:	00 00 00 
  8004203ce8:	ff d0                	callq  *%rax
  8004203cea:	48 85 c0             	test   %rax,%rax
  8004203ced:	74 1d                	je     8004203d0c <user_mem_check+0xd7>
  8004203cef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cf3:	48 85 c0             	test   %rax,%rax
  8004203cf6:	74 14                	je     8004203d0c <user_mem_check+0xd7>
  8004203cf8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cfc:	48 8b 10             	mov    (%rax),%rdx
  8004203cff:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203d02:	48 98                	cltq   
  8004203d04:	48 21 d0             	and    %rdx,%rax
  8004203d07:	48 85 c0             	test   %rax,%rax
  8004203d0a:	75 2a                	jne    8004203d36 <user_mem_check+0x101>
		{
			if(vaT < va){
  8004203d0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d10:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203d14:	73 08                	jae    8004203d1e <user_mem_check+0xe9>
				vaT = (void*)va;
  8004203d16:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203d1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			}
			user_mem_check_addr = (uintptr_t)vaT;
  8004203d1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d22:	48 b8 40 a2 60 04 80 	movabs $0x800460a240,%rax
  8004203d29:	00 00 00 
  8004203d2c:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;		
  8004203d2f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203d34:	eb 1b                	jmp    8004203d51 <user_mem_check+0x11c>
	pte_t *pte_store;
	void * vaT = (void*)va;
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
	vaE = ROUNDUP(vaT + len, PGSIZE);
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203d36:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203d3d:	00 
  8004203d3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d42:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203d46:	0f 82 66 ff ff ff    	jb     8004203cb2 <user_mem_check+0x7d>
			}
			user_mem_check_addr = (uintptr_t)vaT;
			return -E_FAULT;		
		}
	}
	return 0;
  8004203d4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203d51:	c9                   	leaveq 
  8004203d52:	c3                   	retq   

0000008004203d53 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203d53:	55                   	push   %rbp
  8004203d54:	48 89 e5             	mov    %rsp,%rbp
  8004203d57:	48 83 ec 20          	sub    $0x20,%rsp
  8004203d5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203d5f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203d63:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203d67:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203d6a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203d6d:	83 c8 04             	or     $0x4,%eax
  8004203d70:	89 c1                	mov    %eax,%ecx
  8004203d72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203d76:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203d7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d7e:	48 89 c7             	mov    %rax,%rdi
  8004203d81:	48 b8 35 3c 20 04 80 	movabs $0x8004203c35,%rax
  8004203d88:	00 00 00 
  8004203d8b:	ff d0                	callq  *%rax
  8004203d8d:	85 c0                	test   %eax,%eax
  8004203d8f:	79 47                	jns    8004203dd8 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203d91:	48 b8 40 a2 60 04 80 	movabs $0x800460a240,%rax
  8004203d98:	00 00 00 
  8004203d9b:	48 8b 10             	mov    (%rax),%rdx
  8004203d9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203da2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203da8:	89 c6                	mov    %eax,%esi
  8004203daa:	48 bf a0 8a 21 04 80 	movabs $0x8004218aa0,%rdi
  8004203db1:	00 00 00 
  8004203db4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203db9:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004203dc0:	00 00 00 
  8004203dc3:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203dc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dc9:	48 89 c7             	mov    %rax,%rdi
  8004203dcc:	48 b8 d4 85 20 04 80 	movabs $0x80042085d4,%rax
  8004203dd3:	00 00 00 
  8004203dd6:	ff d0                	callq  *%rax
	}
}
  8004203dd8:	c9                   	leaveq 
  8004203dd9:	c3                   	retq   

0000008004203dda <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203dda:	55                   	push   %rbp
  8004203ddb:	48 89 e5             	mov    %rsp,%rbp
  8004203dde:	48 83 ec 60          	sub    $0x60,%rsp
  8004203de2:	89 f8                	mov    %edi,%eax
  8004203de4:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203de7:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203deb:	74 07                	je     8004203df4 <check_page_free_list+0x1a>
  8004203ded:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203df2:	eb 05                	jmp    8004203df9 <check_page_free_list+0x1f>
  8004203df4:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203df9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203dfc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203e03:	00 
  8004203e04:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203e0b:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203e0c:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004203e13:	00 00 00 
  8004203e16:	48 8b 00             	mov    (%rax),%rax
  8004203e19:	48 85 c0             	test   %rax,%rax
  8004203e1c:	75 2a                	jne    8004203e48 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203e1e:	48 ba d8 8a 21 04 80 	movabs $0x8004218ad8,%rdx
  8004203e25:	00 00 00 
  8004203e28:	be 02 04 00 00       	mov    $0x402,%esi
  8004203e2d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004203e34:	00 00 00 
  8004203e37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e3c:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004203e43:	00 00 00 
  8004203e46:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203e48:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203e4c:	0f 84 a9 00 00 00    	je     8004203efb <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203e52:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203e56:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203e5a:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203e5e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203e62:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004203e69:	00 00 00 
  8004203e6c:	48 8b 00             	mov    (%rax),%rax
  8004203e6f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e73:	eb 58                	jmp    8004203ecd <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203e75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e79:	48 89 c7             	mov    %rax,%rdi
  8004203e7c:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203e83:	00 00 00 
  8004203e86:	ff d0                	callq  *%rax
  8004203e88:	48 c1 e8 15          	shr    $0x15,%rax
  8004203e8c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203e91:	48 89 c2             	mov    %rax,%rdx
  8004203e94:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203e97:	48 39 c2             	cmp    %rax,%rdx
  8004203e9a:	0f 93 c0             	setae  %al
  8004203e9d:	0f b6 c0             	movzbl %al,%eax
  8004203ea0:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203ea3:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ea6:	48 98                	cltq   
  8004203ea8:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203ead:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203eb1:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203eb4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203eb8:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ebb:	48 98                	cltq   
  8004203ebd:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ec2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ec6:	48 8b 00             	mov    (%rax),%rax
  8004203ec9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203ecd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ed2:	75 a1                	jne    8004203e75 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203ed4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ed8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203edf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ee3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203ee7:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203eea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203eee:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004203ef5:	00 00 00 
  8004203ef8:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203efb:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004203f02:	00 00 00 
  8004203f05:	48 8b 00             	mov    (%rax),%rax
  8004203f08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f0c:	eb 5e                	jmp    8004203f6c <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203f0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f12:	48 89 c7             	mov    %rax,%rdi
  8004203f15:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004203f1c:	00 00 00 
  8004203f1f:	ff d0                	callq  *%rax
  8004203f21:	48 c1 e8 15          	shr    $0x15,%rax
  8004203f25:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203f2a:	48 89 c2             	mov    %rax,%rdx
  8004203f2d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203f30:	48 39 c2             	cmp    %rax,%rdx
  8004203f33:	73 2c                	jae    8004203f61 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203f35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f39:	48 89 c7             	mov    %rax,%rdi
  8004203f3c:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004203f43:	00 00 00 
  8004203f46:	ff d0                	callq  *%rax
  8004203f48:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203f4d:	be 97 00 00 00       	mov    $0x97,%esi
  8004203f52:	48 89 c7             	mov    %rax,%rdi
  8004203f55:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004203f5c:	00 00 00 
  8004203f5f:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203f61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f65:	48 8b 00             	mov    (%rax),%rax
  8004203f68:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f6c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f71:	75 9b                	jne    8004203f0e <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203f73:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203f78:	48 b8 d2 25 20 04 80 	movabs $0x80042025d2,%rax
  8004203f7f:	00 00 00 
  8004203f82:	ff d0                	callq  *%rax
  8004203f84:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203f88:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004203f8f:	00 00 00 
  8004203f92:	48 8b 00             	mov    (%rax),%rax
  8004203f95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f99:	e9 20 03 00 00       	jmpq   80042042be <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203f9e:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004203fa5:	00 00 00 
  8004203fa8:	48 8b 00             	mov    (%rax),%rax
  8004203fab:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203faf:	73 35                	jae    8004203fe6 <check_page_free_list+0x20c>
  8004203fb1:	48 b9 fc 8a 21 04 80 	movabs $0x8004218afc,%rcx
  8004203fb8:	00 00 00 
  8004203fbb:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004203fc2:	00 00 00 
  8004203fc5:	be 1c 04 00 00       	mov    $0x41c,%esi
  8004203fca:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004203fd1:	00 00 00 
  8004203fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fd9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004203fe0:	00 00 00 
  8004203fe3:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203fe6:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004203fed:	00 00 00 
  8004203ff0:	48 8b 10             	mov    (%rax),%rdx
  8004203ff3:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004203ffa:	00 00 00 
  8004203ffd:	48 8b 00             	mov    (%rax),%rax
  8004204000:	48 c1 e0 04          	shl    $0x4,%rax
  8004204004:	48 01 d0             	add    %rdx,%rax
  8004204007:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420400b:	77 35                	ja     8004204042 <check_page_free_list+0x268>
  800420400d:	48 b9 08 8b 21 04 80 	movabs $0x8004218b08,%rcx
  8004204014:	00 00 00 
  8004204017:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420401e:	00 00 00 
  8004204021:	be 1d 04 00 00       	mov    $0x41d,%esi
  8004204026:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420402d:	00 00 00 
  8004204030:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204035:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420403c:	00 00 00 
  800420403f:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204042:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204046:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  800420404d:	00 00 00 
  8004204050:	48 8b 00             	mov    (%rax),%rax
  8004204053:	48 29 c2             	sub    %rax,%rdx
  8004204056:	48 89 d0             	mov    %rdx,%rax
  8004204059:	83 e0 0f             	and    $0xf,%eax
  800420405c:	48 85 c0             	test   %rax,%rax
  800420405f:	74 35                	je     8004204096 <check_page_free_list+0x2bc>
  8004204061:	48 b9 20 8b 21 04 80 	movabs $0x8004218b20,%rcx
  8004204068:	00 00 00 
  800420406b:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204072:	00 00 00 
  8004204075:	be 1e 04 00 00       	mov    $0x41e,%esi
  800420407a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204081:	00 00 00 
  8004204084:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204089:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204090:	00 00 00 
  8004204093:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004204096:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420409a:	48 89 c7             	mov    %rax,%rdi
  800420409d:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042040a4:	00 00 00 
  80042040a7:	ff d0                	callq  *%rax
  80042040a9:	48 85 c0             	test   %rax,%rax
  80042040ac:	75 35                	jne    80042040e3 <check_page_free_list+0x309>
  80042040ae:	48 b9 52 8b 21 04 80 	movabs $0x8004218b52,%rcx
  80042040b5:	00 00 00 
  80042040b8:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042040bf:	00 00 00 
  80042040c2:	be 21 04 00 00       	mov    $0x421,%esi
  80042040c7:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042040ce:	00 00 00 
  80042040d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040d6:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042040dd:	00 00 00 
  80042040e0:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042040e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040e7:	48 89 c7             	mov    %rax,%rdi
  80042040ea:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042040f1:	00 00 00 
  80042040f4:	ff d0                	callq  *%rax
  80042040f6:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042040fc:	75 35                	jne    8004204133 <check_page_free_list+0x359>
  80042040fe:	48 b9 63 8b 21 04 80 	movabs $0x8004218b63,%rcx
  8004204105:	00 00 00 
  8004204108:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420410f:	00 00 00 
  8004204112:	be 22 04 00 00       	mov    $0x422,%esi
  8004204117:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420411e:	00 00 00 
  8004204121:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204126:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420412d:	00 00 00 
  8004204130:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204137:	48 89 c7             	mov    %rax,%rdi
  800420413a:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204141:	00 00 00 
  8004204144:	ff d0                	callq  *%rax
  8004204146:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  800420414c:	75 35                	jne    8004204183 <check_page_free_list+0x3a9>
  800420414e:	48 b9 80 8b 21 04 80 	movabs $0x8004218b80,%rcx
  8004204155:	00 00 00 
  8004204158:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420415f:	00 00 00 
  8004204162:	be 23 04 00 00       	mov    $0x423,%esi
  8004204167:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420416e:	00 00 00 
  8004204171:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204176:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420417d:	00 00 00 
  8004204180:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004204183:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204187:	48 89 c7             	mov    %rax,%rdi
  800420418a:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204191:	00 00 00 
  8004204194:	ff d0                	callq  *%rax
  8004204196:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420419c:	75 35                	jne    80042041d3 <check_page_free_list+0x3f9>
  800420419e:	48 b9 a3 8b 21 04 80 	movabs $0x8004218ba3,%rcx
  80042041a5:	00 00 00 
  80042041a8:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042041af:	00 00 00 
  80042041b2:	be 24 04 00 00       	mov    $0x424,%esi
  80042041b7:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042041be:	00 00 00 
  80042041c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041c6:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042041cd:	00 00 00 
  80042041d0:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  80042041d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041d7:	48 89 c7             	mov    %rax,%rdi
  80042041da:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042041e1:	00 00 00 
  80042041e4:	ff d0                	callq  *%rax
  80042041e6:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042041ec:	76 4e                	jbe    800420423c <check_page_free_list+0x462>
  80042041ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041f2:	48 89 c7             	mov    %rax,%rdi
  80042041f5:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  80042041fc:	00 00 00 
  80042041ff:	ff d0                	callq  *%rax
  8004204201:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204205:	73 35                	jae    800420423c <check_page_free_list+0x462>
  8004204207:	48 b9 c0 8b 21 04 80 	movabs $0x8004218bc0,%rcx
  800420420e:	00 00 00 
  8004204211:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204218:	00 00 00 
  800420421b:	be 25 04 00 00       	mov    $0x425,%esi
  8004204220:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204227:	00 00 00 
  800420422a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420422f:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204236:	00 00 00 
  8004204239:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  800420423c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204240:	48 89 c7             	mov    %rax,%rdi
  8004204243:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  800420424a:	00 00 00 
  800420424d:	ff d0                	callq  *%rax
  800420424f:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004204255:	75 35                	jne    800420428c <check_page_free_list+0x4b2>
  8004204257:	48 b9 05 8c 21 04 80 	movabs $0x8004218c05,%rcx
  800420425e:	00 00 00 
  8004204261:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204268:	00 00 00 
  800420426b:	be 27 04 00 00       	mov    $0x427,%esi
  8004204270:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204277:	00 00 00 
  800420427a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420427f:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204286:	00 00 00 
  8004204289:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  800420428c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204290:	48 89 c7             	mov    %rax,%rdi
  8004204293:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  800420429a:	00 00 00 
  800420429d:	ff d0                	callq  *%rax
  800420429f:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042042a5:	77 07                	ja     80042042ae <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042042a7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042042ac:	eb 05                	jmp    80042042b3 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042042ae:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042042b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042b7:	48 8b 00             	mov    (%rax),%rax
  80042042ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042c3:	0f 85 d5 fc ff ff    	jne    8004203f9e <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042042c9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042042ce:	75 35                	jne    8004204305 <check_page_free_list+0x52b>
  80042042d0:	48 b9 22 8c 21 04 80 	movabs $0x8004218c22,%rcx
  80042042d7:	00 00 00 
  80042042da:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042042e1:	00 00 00 
  80042042e4:	be 2f 04 00 00       	mov    $0x42f,%esi
  80042042e9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042042f0:	00 00 00 
  80042042f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042f8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042042ff:	00 00 00 
  8004204302:	41 ff d0             	callq  *%r8
}
  8004204305:	c9                   	leaveq 
  8004204306:	c3                   	retq   

0000008004204307 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004204307:	55                   	push   %rbp
  8004204308:	48 89 e5             	mov    %rsp,%rbp
  800420430b:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420430f:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004204316:	00 00 00 
  8004204319:	48 8b 00             	mov    (%rax),%rax
  800420431c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204320:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204327:	eb 37                	jmp    8004204360 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004204329:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420432d:	48 89 c7             	mov    %rax,%rdi
  8004204330:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004204337:	00 00 00 
  800420433a:	ff d0                	callq  *%rax
  800420433c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204341:	be 97 00 00 00       	mov    $0x97,%esi
  8004204346:	48 89 c7             	mov    %rax,%rdi
  8004204349:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004204350:	00 00 00 
  8004204353:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204359:	48 8b 00             	mov    (%rax),%rax
  800420435c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204360:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204365:	75 c2                	jne    8004204329 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204367:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  800420436e:	00 00 00 
  8004204371:	48 8b 00             	mov    (%rax),%rax
  8004204374:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204378:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420437f:	e9 ec 01 00 00       	jmpq   8004204570 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004204384:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  800420438b:	00 00 00 
  800420438e:	48 8b 00             	mov    (%rax),%rax
  8004204391:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204395:	73 35                	jae    80042043cc <check_page_alloc+0xc5>
  8004204397:	48 b9 33 8c 21 04 80 	movabs $0x8004218c33,%rcx
  800420439e:	00 00 00 
  80042043a1:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042043a8:	00 00 00 
  80042043ab:	be 48 04 00 00       	mov    $0x448,%esi
  80042043b0:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042043b7:	00 00 00 
  80042043ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043bf:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042043c6:	00 00 00 
  80042043c9:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042043cc:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  80042043d3:	00 00 00 
  80042043d6:	48 8b 10             	mov    (%rax),%rdx
  80042043d9:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042043e0:	00 00 00 
  80042043e3:	48 8b 00             	mov    (%rax),%rax
  80042043e6:	48 c1 e0 04          	shl    $0x4,%rax
  80042043ea:	48 01 d0             	add    %rdx,%rax
  80042043ed:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042043f1:	77 35                	ja     8004204428 <check_page_alloc+0x121>
  80042043f3:	48 b9 40 8c 21 04 80 	movabs $0x8004218c40,%rcx
  80042043fa:	00 00 00 
  80042043fd:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204404:	00 00 00 
  8004204407:	be 49 04 00 00       	mov    $0x449,%esi
  800420440c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204413:	00 00 00 
  8004204416:	b8 00 00 00 00       	mov    $0x0,%eax
  800420441b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204422:	00 00 00 
  8004204425:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204428:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420442c:	48 89 c7             	mov    %rax,%rdi
  800420442f:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204436:	00 00 00 
  8004204439:	ff d0                	callq  *%rax
  800420443b:	48 85 c0             	test   %rax,%rax
  800420443e:	75 35                	jne    8004204475 <check_page_alloc+0x16e>
  8004204440:	48 b9 55 8c 21 04 80 	movabs $0x8004218c55,%rcx
  8004204447:	00 00 00 
  800420444a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204451:	00 00 00 
  8004204454:	be 4c 04 00 00       	mov    $0x44c,%esi
  8004204459:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204460:	00 00 00 
  8004204463:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204468:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420446f:	00 00 00 
  8004204472:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004204475:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204479:	48 89 c7             	mov    %rax,%rdi
  800420447c:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204483:	00 00 00 
  8004204486:	ff d0                	callq  *%rax
  8004204488:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  800420448e:	75 35                	jne    80042044c5 <check_page_alloc+0x1be>
  8004204490:	48 b9 67 8c 21 04 80 	movabs $0x8004218c67,%rcx
  8004204497:	00 00 00 
  800420449a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042044a1:	00 00 00 
  80042044a4:	be 4d 04 00 00       	mov    $0x44d,%esi
  80042044a9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042044b0:	00 00 00 
  80042044b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044b8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042044bf:	00 00 00 
  80042044c2:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042044c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044c9:	48 89 c7             	mov    %rax,%rdi
  80042044cc:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042044d3:	00 00 00 
  80042044d6:	ff d0                	callq  *%rax
  80042044d8:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042044de:	75 35                	jne    8004204515 <check_page_alloc+0x20e>
  80042044e0:	48 b9 88 8c 21 04 80 	movabs $0x8004218c88,%rcx
  80042044e7:	00 00 00 
  80042044ea:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042044f1:	00 00 00 
  80042044f4:	be 4e 04 00 00       	mov    $0x44e,%esi
  80042044f9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204500:	00 00 00 
  8004204503:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204508:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420450f:	00 00 00 
  8004204512:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204515:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204519:	48 89 c7             	mov    %rax,%rdi
  800420451c:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204523:	00 00 00 
  8004204526:	ff d0                	callq  *%rax
  8004204528:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420452e:	75 35                	jne    8004204565 <check_page_alloc+0x25e>
  8004204530:	48 b9 ac 8c 21 04 80 	movabs $0x8004218cac,%rcx
  8004204537:	00 00 00 
  800420453a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204541:	00 00 00 
  8004204544:	be 4f 04 00 00       	mov    $0x44f,%esi
  8004204549:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204550:	00 00 00 
  8004204553:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204558:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420455f:	00 00 00 
  8004204562:	41 ff d0             	callq  *%r8
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204565:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204569:	48 8b 00             	mov    (%rax),%rax
  800420456c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204570:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204575:	0f 85 09 fe ff ff    	jne    8004204384 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  800420457b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204582:	00 
  8004204583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204587:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420458b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420458f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204593:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204598:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  800420459f:	00 00 00 
  80042045a2:	ff d0                	callq  *%rax
  80042045a4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042045a8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042045ad:	75 35                	jne    80042045e4 <check_page_alloc+0x2dd>
  80042045af:	48 b9 c7 8c 21 04 80 	movabs $0x8004218cc7,%rcx
  80042045b6:	00 00 00 
  80042045b9:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042045c0:	00 00 00 
  80042045c3:	be 53 04 00 00       	mov    $0x453,%esi
  80042045c8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042045cf:	00 00 00 
  80042045d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045d7:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042045de:	00 00 00 
  80042045e1:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042045e4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045e9:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042045f0:	00 00 00 
  80042045f3:	ff d0                	callq  *%rax
  80042045f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042045f9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042045fe:	75 35                	jne    8004204635 <check_page_alloc+0x32e>
  8004204600:	48 b9 dd 8c 21 04 80 	movabs $0x8004218cdd,%rcx
  8004204607:	00 00 00 
  800420460a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204611:	00 00 00 
  8004204614:	be 54 04 00 00       	mov    $0x454,%esi
  8004204619:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204620:	00 00 00 
  8004204623:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204628:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420462f:	00 00 00 
  8004204632:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204635:	bf 00 00 00 00       	mov    $0x0,%edi
  800420463a:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004204641:	00 00 00 
  8004204644:	ff d0                	callq  *%rax
  8004204646:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420464a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420464f:	75 35                	jne    8004204686 <check_page_alloc+0x37f>
  8004204651:	48 b9 f3 8c 21 04 80 	movabs $0x8004218cf3,%rcx
  8004204658:	00 00 00 
  800420465b:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204662:	00 00 00 
  8004204665:	be 55 04 00 00       	mov    $0x455,%esi
  800420466a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204671:	00 00 00 
  8004204674:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204679:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204680:	00 00 00 
  8004204683:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204686:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420468b:	75 35                	jne    80042046c2 <check_page_alloc+0x3bb>
  800420468d:	48 b9 09 8d 21 04 80 	movabs $0x8004218d09,%rcx
  8004204694:	00 00 00 
  8004204697:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420469e:	00 00 00 
  80042046a1:	be 56 04 00 00       	mov    $0x456,%esi
  80042046a6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042046ad:	00 00 00 
  80042046b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046b5:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042046bc:	00 00 00 
  80042046bf:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042046c2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042046c7:	74 0a                	je     80042046d3 <check_page_alloc+0x3cc>
  80042046c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046cd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042046d1:	75 35                	jne    8004204708 <check_page_alloc+0x401>
  80042046d3:	48 b9 0d 8d 21 04 80 	movabs $0x8004218d0d,%rcx
  80042046da:	00 00 00 
  80042046dd:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042046e4:	00 00 00 
  80042046e7:	be 57 04 00 00       	mov    $0x457,%esi
  80042046ec:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042046f3:	00 00 00 
  80042046f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046fb:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204702:	00 00 00 
  8004204705:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204708:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420470d:	74 14                	je     8004204723 <check_page_alloc+0x41c>
  800420470f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204713:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204717:	74 0a                	je     8004204723 <check_page_alloc+0x41c>
  8004204719:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420471d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204721:	75 35                	jne    8004204758 <check_page_alloc+0x451>
  8004204723:	48 b9 20 8d 21 04 80 	movabs $0x8004218d20,%rcx
  800420472a:	00 00 00 
  800420472d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204734:	00 00 00 
  8004204737:	be 58 04 00 00       	mov    $0x458,%esi
  800420473c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204743:	00 00 00 
  8004204746:	b8 00 00 00 00       	mov    $0x0,%eax
  800420474b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204752:	00 00 00 
  8004204755:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204758:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420475c:	48 89 c7             	mov    %rax,%rdi
  800420475f:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204766:	00 00 00 
  8004204769:	ff d0                	callq  *%rax
  800420476b:	48 ba 60 d4 60 04 80 	movabs $0x800460d460,%rdx
  8004204772:	00 00 00 
  8004204775:	48 8b 12             	mov    (%rdx),%rdx
  8004204778:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420477c:	48 39 d0             	cmp    %rdx,%rax
  800420477f:	72 35                	jb     80042047b6 <check_page_alloc+0x4af>
  8004204781:	48 b9 40 8d 21 04 80 	movabs $0x8004218d40,%rcx
  8004204788:	00 00 00 
  800420478b:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204792:	00 00 00 
  8004204795:	be 59 04 00 00       	mov    $0x459,%esi
  800420479a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042047a1:	00 00 00 
  80042047a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047a9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042047b0:	00 00 00 
  80042047b3:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042047b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042047ba:	48 89 c7             	mov    %rax,%rdi
  80042047bd:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042047c4:	00 00 00 
  80042047c7:	ff d0                	callq  *%rax
  80042047c9:	48 ba 60 d4 60 04 80 	movabs $0x800460d460,%rdx
  80042047d0:	00 00 00 
  80042047d3:	48 8b 12             	mov    (%rdx),%rdx
  80042047d6:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042047da:	48 39 d0             	cmp    %rdx,%rax
  80042047dd:	72 35                	jb     8004204814 <check_page_alloc+0x50d>
  80042047df:	48 b9 5d 8d 21 04 80 	movabs $0x8004218d5d,%rcx
  80042047e6:	00 00 00 
  80042047e9:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042047f0:	00 00 00 
  80042047f3:	be 5a 04 00 00       	mov    $0x45a,%esi
  80042047f8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042047ff:	00 00 00 
  8004204802:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204807:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420480e:	00 00 00 
  8004204811:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204818:	48 89 c7             	mov    %rax,%rdi
  800420481b:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004204822:	00 00 00 
  8004204825:	ff d0                	callq  *%rax
  8004204827:	48 ba 60 d4 60 04 80 	movabs $0x800460d460,%rdx
  800420482e:	00 00 00 
  8004204831:	48 8b 12             	mov    (%rdx),%rdx
  8004204834:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204838:	48 39 d0             	cmp    %rdx,%rax
  800420483b:	72 35                	jb     8004204872 <check_page_alloc+0x56b>
  800420483d:	48 b9 7a 8d 21 04 80 	movabs $0x8004218d7a,%rcx
  8004204844:	00 00 00 
  8004204847:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420484e:	00 00 00 
  8004204851:	be 5b 04 00 00       	mov    $0x45b,%esi
  8004204856:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420485d:	00 00 00 
  8004204860:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204865:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420486c:	00 00 00 
  800420486f:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204872:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004204879:	00 00 00 
  800420487c:	48 8b 00             	mov    (%rax),%rax
  800420487f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204883:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  800420488a:	00 00 00 
  800420488d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204894:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204899:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042048a0:	00 00 00 
  80042048a3:	ff d0                	callq  *%rax
  80042048a5:	48 85 c0             	test   %rax,%rax
  80042048a8:	74 35                	je     80042048df <check_page_alloc+0x5d8>
  80042048aa:	48 b9 97 8d 21 04 80 	movabs $0x8004218d97,%rcx
  80042048b1:	00 00 00 
  80042048b4:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042048bb:	00 00 00 
  80042048be:	be 62 04 00 00       	mov    $0x462,%esi
  80042048c3:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042048ca:	00 00 00 
  80042048cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048d2:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042048d9:	00 00 00 
  80042048dc:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042048df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048e3:	48 89 c7             	mov    %rax,%rdi
  80042048e6:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  80042048ed:	00 00 00 
  80042048f0:	ff d0                	callq  *%rax
	page_free(pp1);
  80042048f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048f6:	48 89 c7             	mov    %rax,%rdi
  80042048f9:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204900:	00 00 00 
  8004204903:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204909:	48 89 c7             	mov    %rax,%rdi
  800420490c:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204913:	00 00 00 
  8004204916:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204918:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420491f:	00 
  8004204920:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204924:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204928:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420492c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204930:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204935:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  800420493c:	00 00 00 
  800420493f:	ff d0                	callq  *%rax
  8004204941:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204945:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420494a:	75 35                	jne    8004204981 <check_page_alloc+0x67a>
  800420494c:	48 b9 c7 8c 21 04 80 	movabs $0x8004218cc7,%rcx
  8004204953:	00 00 00 
  8004204956:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420495d:	00 00 00 
  8004204960:	be 69 04 00 00       	mov    $0x469,%esi
  8004204965:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420496c:	00 00 00 
  800420496f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204974:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420497b:	00 00 00 
  800420497e:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204981:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204986:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  800420498d:	00 00 00 
  8004204990:	ff d0                	callq  *%rax
  8004204992:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204996:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420499b:	75 35                	jne    80042049d2 <check_page_alloc+0x6cb>
  800420499d:	48 b9 dd 8c 21 04 80 	movabs $0x8004218cdd,%rcx
  80042049a4:	00 00 00 
  80042049a7:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042049ae:	00 00 00 
  80042049b1:	be 6a 04 00 00       	mov    $0x46a,%esi
  80042049b6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042049bd:	00 00 00 
  80042049c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049c5:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042049cc:	00 00 00 
  80042049cf:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042049d2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049d7:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042049de:	00 00 00 
  80042049e1:	ff d0                	callq  *%rax
  80042049e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042049e7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042049ec:	75 35                	jne    8004204a23 <check_page_alloc+0x71c>
  80042049ee:	48 b9 f3 8c 21 04 80 	movabs $0x8004218cf3,%rcx
  80042049f5:	00 00 00 
  80042049f8:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042049ff:	00 00 00 
  8004204a02:	be 6b 04 00 00       	mov    $0x46b,%esi
  8004204a07:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204a0e:	00 00 00 
  8004204a11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a16:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204a1d:	00 00 00 
  8004204a20:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204a23:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a28:	75 35                	jne    8004204a5f <check_page_alloc+0x758>
  8004204a2a:	48 b9 09 8d 21 04 80 	movabs $0x8004218d09,%rcx
  8004204a31:	00 00 00 
  8004204a34:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204a3b:	00 00 00 
  8004204a3e:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004204a43:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204a4a:	00 00 00 
  8004204a4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a52:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204a59:	00 00 00 
  8004204a5c:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204a5f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a64:	74 0a                	je     8004204a70 <check_page_alloc+0x769>
  8004204a66:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a6a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a6e:	75 35                	jne    8004204aa5 <check_page_alloc+0x79e>
  8004204a70:	48 b9 0d 8d 21 04 80 	movabs $0x8004218d0d,%rcx
  8004204a77:	00 00 00 
  8004204a7a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204a81:	00 00 00 
  8004204a84:	be 6d 04 00 00       	mov    $0x46d,%esi
  8004204a89:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204a90:	00 00 00 
  8004204a93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a98:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204a9f:	00 00 00 
  8004204aa2:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204aa5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204aaa:	74 14                	je     8004204ac0 <check_page_alloc+0x7b9>
  8004204aac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ab0:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204ab4:	74 0a                	je     8004204ac0 <check_page_alloc+0x7b9>
  8004204ab6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204aba:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204abe:	75 35                	jne    8004204af5 <check_page_alloc+0x7ee>
  8004204ac0:	48 b9 20 8d 21 04 80 	movabs $0x8004218d20,%rcx
  8004204ac7:	00 00 00 
  8004204aca:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204ad1:	00 00 00 
  8004204ad4:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004204ad9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204ae0:	00 00 00 
  8004204ae3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ae8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204aef:	00 00 00 
  8004204af2:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204af5:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204afa:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004204b01:	00 00 00 
  8004204b04:	ff d0                	callq  *%rax
  8004204b06:	48 85 c0             	test   %rax,%rax
  8004204b09:	74 35                	je     8004204b40 <check_page_alloc+0x839>
  8004204b0b:	48 b9 97 8d 21 04 80 	movabs $0x8004218d97,%rcx
  8004204b12:	00 00 00 
  8004204b15:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204b1c:	00 00 00 
  8004204b1f:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004204b24:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204b2b:	00 00 00 
  8004204b2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b33:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204b3a:	00 00 00 
  8004204b3d:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204b40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b44:	48 89 c7             	mov    %rax,%rdi
  8004204b47:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004204b4e:	00 00 00 
  8004204b51:	ff d0                	callq  *%rax
  8004204b53:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204b58:	be 01 00 00 00       	mov    $0x1,%esi
  8004204b5d:	48 89 c7             	mov    %rax,%rdi
  8004204b60:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004204b67:	00 00 00 
  8004204b6a:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204b6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b70:	48 89 c7             	mov    %rax,%rdi
  8004204b73:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204b7a:	00 00 00 
  8004204b7d:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204b7f:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204b84:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004204b8b:	00 00 00 
  8004204b8e:	ff d0                	callq  *%rax
  8004204b90:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204b94:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204b99:	75 35                	jne    8004204bd0 <check_page_alloc+0x8c9>
  8004204b9b:	48 b9 a6 8d 21 04 80 	movabs $0x8004218da6,%rcx
  8004204ba2:	00 00 00 
  8004204ba5:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204bac:	00 00 00 
  8004204baf:	be 74 04 00 00       	mov    $0x474,%esi
  8004204bb4:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204bbb:	00 00 00 
  8004204bbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bc3:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204bca:	00 00 00 
  8004204bcd:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204bd0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204bd5:	74 0a                	je     8004204be1 <check_page_alloc+0x8da>
  8004204bd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bdb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204bdf:	74 35                	je     8004204c16 <check_page_alloc+0x90f>
  8004204be1:	48 b9 c4 8d 21 04 80 	movabs $0x8004218dc4,%rcx
  8004204be8:	00 00 00 
  8004204beb:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204bf2:	00 00 00 
  8004204bf5:	be 75 04 00 00       	mov    $0x475,%esi
  8004204bfa:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204c01:	00 00 00 
  8004204c04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c09:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204c10:	00 00 00 
  8004204c13:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204c16:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204c1a:	48 89 c7             	mov    %rax,%rdi
  8004204c1d:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004204c24:	00 00 00 
  8004204c27:	ff d0                	callq  *%rax
  8004204c29:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204c2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204c34:	eb 4d                	jmp    8004204c83 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204c36:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204c39:	48 63 d0             	movslq %eax,%rdx
  8004204c3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204c40:	48 01 d0             	add    %rdx,%rax
  8004204c43:	0f b6 00             	movzbl (%rax),%eax
  8004204c46:	84 c0                	test   %al,%al
  8004204c48:	74 35                	je     8004204c7f <check_page_alloc+0x978>
  8004204c4a:	48 b9 d4 8d 21 04 80 	movabs $0x8004218dd4,%rcx
  8004204c51:	00 00 00 
  8004204c54:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204c5b:	00 00 00 
  8004204c5e:	be 78 04 00 00       	mov    $0x478,%esi
  8004204c63:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204c6a:	00 00 00 
  8004204c6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c72:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204c79:	00 00 00 
  8004204c7c:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204c7f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204c83:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204c8a:	7e aa                	jle    8004204c36 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204c8c:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004204c93:	00 00 00 
  8004204c96:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204c9a:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204c9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ca1:	48 89 c7             	mov    %rax,%rdi
  8004204ca4:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204cab:	00 00 00 
  8004204cae:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204cb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204cb4:	48 89 c7             	mov    %rax,%rdi
  8004204cb7:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204cbe:	00 00 00 
  8004204cc1:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204cc7:	48 89 c7             	mov    %rax,%rdi
  8004204cca:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004204cd1:	00 00 00 
  8004204cd4:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204cd6:	48 bf e0 8d 21 04 80 	movabs $0x8004218de0,%rdi
  8004204cdd:	00 00 00 
  8004204ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ce5:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004204cec:	00 00 00 
  8004204cef:	ff d2                	callq  *%rdx
}
  8004204cf1:	c9                   	leaveq 
  8004204cf2:	c3                   	retq   

0000008004204cf3 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204cf3:	55                   	push   %rbp
  8004204cf4:	48 89 e5             	mov    %rsp,%rbp
  8004204cf7:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204cfe:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204d05:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004204d0c:	00 00 00 
  8004204d0f:	48 8b 00             	mov    (%rax),%rax
  8004204d12:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204d16:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204d1d:	00 
  8004204d1e:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004204d25:	00 00 00 
  8004204d28:	48 8b 00             	mov    (%rax),%rax
  8004204d2b:	48 c1 e0 04          	shl    $0x4,%rax
  8004204d2f:	48 89 c2             	mov    %rax,%rdx
  8004204d32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d36:	48 01 d0             	add    %rdx,%rax
  8004204d39:	48 83 e8 01          	sub    $0x1,%rax
  8004204d3d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204d41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d45:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204d4a:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204d4e:	48 89 d0             	mov    %rdx,%rax
  8004204d51:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204d55:	48 29 c2             	sub    %rax,%rdx
  8004204d58:	48 89 d0             	mov    %rdx,%rax
  8004204d5b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204d5f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204d66:	00 
  8004204d67:	e9 d4 00 00 00       	jmpq   8004204e40 <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204d6c:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204d73:	00 00 00 
  8004204d76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d7a:	48 01 c2             	add    %rax,%rdx
  8004204d7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d81:	48 89 d6             	mov    %rdx,%rsi
  8004204d84:	48 89 c7             	mov    %rax,%rdi
  8004204d87:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004204d8e:	00 00 00 
  8004204d91:	ff d0                	callq  *%rax
  8004204d93:	48 ba 68 d4 60 04 80 	movabs $0x800460d468,%rdx
  8004204d9a:	00 00 00 
  8004204d9d:	48 8b 12             	mov    (%rdx),%rdx
  8004204da0:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204da4:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204dab:	00 00 00 
  8004204dae:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204db2:	77 32                	ja     8004204de6 <check_boot_pml4e+0xf3>
  8004204db4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204db8:	48 89 c1             	mov    %rax,%rcx
  8004204dbb:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004204dc2:	00 00 00 
  8004204dc5:	be 97 04 00 00       	mov    $0x497,%esi
  8004204dca:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204dd1:	00 00 00 
  8004204dd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dd9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204de0:	00 00 00 
  8004204de3:	41 ff d0             	callq  *%r8
  8004204de6:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204ded:	ff ff ff 
  8004204df0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204df4:	48 01 d1             	add    %rdx,%rcx
  8004204df7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204dfb:	48 01 ca             	add    %rcx,%rdx
  8004204dfe:	48 39 d0             	cmp    %rdx,%rax
  8004204e01:	74 35                	je     8004204e38 <check_boot_pml4e+0x145>
  8004204e03:	48 b9 00 8e 21 04 80 	movabs $0x8004218e00,%rcx
  8004204e0a:	00 00 00 
  8004204e0d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204e14:	00 00 00 
  8004204e17:	be 97 04 00 00       	mov    $0x497,%esi
  8004204e1c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204e23:	00 00 00 
  8004204e26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e2b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204e32:	00 00 00 
  8004204e35:	41 ff d0             	callq  *%r8
	uint64_t i, n;

	pml4e = boot_pml4e;
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204e38:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204e3f:	00 
  8004204e40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e44:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204e48:	0f 82 1e ff ff ff    	jb     8004204d6c <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204e4e:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204e55:	00 
  8004204e56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e5a:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204e60:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204e64:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204e68:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204e6d:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204e71:	48 89 d0             	mov    %rdx,%rax
  8004204e74:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204e78:	48 29 c2             	sub    %rax,%rdx
  8004204e7b:	48 89 d0             	mov    %rdx,%rax
  8004204e7e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204e82:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204e89:	00 
  8004204e8a:	e9 d4 00 00 00       	jmpq   8004204f63 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204e8f:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204e96:	00 00 00 
  8004204e99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e9d:	48 01 c2             	add    %rax,%rdx
  8004204ea0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ea4:	48 89 d6             	mov    %rdx,%rsi
  8004204ea7:	48 89 c7             	mov    %rax,%rdi
  8004204eaa:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004204eb1:	00 00 00 
  8004204eb4:	ff d0                	callq  *%rax
  8004204eb6:	48 ba 50 a2 60 04 80 	movabs $0x800460a250,%rdx
  8004204ebd:	00 00 00 
  8004204ec0:	48 8b 12             	mov    (%rdx),%rdx
  8004204ec3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004204ec7:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204ece:	00 00 00 
  8004204ed1:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004204ed5:	77 32                	ja     8004204f09 <check_boot_pml4e+0x216>
  8004204ed7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204edb:	48 89 c1             	mov    %rax,%rcx
  8004204ede:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  8004204ee5:	00 00 00 
  8004204ee8:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204eed:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204ef4:	00 00 00 
  8004204ef7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204efc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204f03:	00 00 00 
  8004204f06:	41 ff d0             	callq  *%r8
  8004204f09:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204f10:	ff ff ff 
  8004204f13:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204f17:	48 01 d1             	add    %rdx,%rcx
  8004204f1a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204f1e:	48 01 ca             	add    %rcx,%rdx
  8004204f21:	48 39 d0             	cmp    %rdx,%rax
  8004204f24:	74 35                	je     8004204f5b <check_boot_pml4e+0x268>
  8004204f26:	48 b9 38 8e 21 04 80 	movabs $0x8004218e38,%rcx
  8004204f2d:	00 00 00 
  8004204f30:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204f37:	00 00 00 
  8004204f3a:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204f3f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204f46:	00 00 00 
  8004204f49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f4e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204f55:	00 00 00 
  8004204f58:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204f5b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204f62:	00 
  8004204f63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f67:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204f6b:	0f 82 1e ff ff ff    	jb     8004204e8f <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204f71:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204f78:	00 
  8004204f79:	eb 6a                	jmp    8004204fe5 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204f7b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204f82:	00 00 00 
  8004204f85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f89:	48 01 c2             	add    %rax,%rdx
  8004204f8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f90:	48 89 d6             	mov    %rdx,%rsi
  8004204f93:	48 89 c7             	mov    %rax,%rdi
  8004204f96:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004204f9d:	00 00 00 
  8004204fa0:	ff d0                	callq  *%rax
  8004204fa2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fa6:	74 35                	je     8004204fdd <check_boot_pml4e+0x2ea>
  8004204fa8:	48 b9 70 8e 21 04 80 	movabs $0x8004218e70,%rcx
  8004204faf:	00 00 00 
  8004204fb2:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004204fb9:	00 00 00 
  8004204fbc:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004204fc1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004204fc8:	00 00 00 
  8004204fcb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fd0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004204fd7:	00 00 00 
  8004204fda:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204fdd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204fe4:	00 
  8004204fe5:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004204fec:	00 00 00 
  8004204fef:	48 8b 00             	mov    (%rax),%rax
  8004204ff2:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204ff6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ffa:	0f 87 7b ff ff ff    	ja     8004204f7b <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205000:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004205007:	00 
  8004205008:	e9 a1 01 00 00       	jmpq   80042051ae <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  800420500d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205011:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205015:	48 89 d0             	mov    %rdx,%rax
  8004205018:	48 01 c0             	add    %rax,%rax
  800420501b:	48 01 d0             	add    %rdx,%rax
  800420501e:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205022:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205029:	00 00 00 
  800420502c:	48 29 c2             	sub    %rax,%rdx
  800420502f:	48 89 d0             	mov    %rdx,%rax
  8004205032:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205036:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420503d:	00 
  800420503e:	e9 e0 00 00 00       	jmpq   8004205123 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205043:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205047:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420504b:	48 01 d0             	add    %rdx,%rax
  800420504e:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004205055:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205059:	48 89 d6             	mov    %rdx,%rsi
  800420505c:	48 89 c7             	mov    %rax,%rdi
  800420505f:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004205066:	00 00 00 
  8004205069:	ff d0                	callq  *%rax
  800420506b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420506f:	48 89 d1             	mov    %rdx,%rcx
  8004205072:	48 c1 e1 10          	shl    $0x10,%rcx
  8004205076:	48 ba 00 00 61 04 80 	movabs $0x8004610000,%rdx
  800420507d:	00 00 00 
  8004205080:	48 01 ca             	add    %rcx,%rdx
  8004205083:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004205087:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800420508e:	00 00 00 
  8004205091:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004205095:	77 32                	ja     80042050c9 <check_boot_pml4e+0x3d6>
  8004205097:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420509b:	48 89 c1             	mov    %rax,%rcx
  800420509e:	48 ba 10 8a 21 04 80 	movabs $0x8004218a10,%rdx
  80042050a5:	00 00 00 
  80042050a8:	be a9 04 00 00       	mov    $0x4a9,%esi
  80042050ad:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042050b4:	00 00 00 
  80042050b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050bc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042050c3:	00 00 00 
  80042050c6:	41 ff d0             	callq  *%r8
  80042050c9:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042050d0:	ff ff ff 
  80042050d3:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042050d7:	48 01 d1             	add    %rdx,%rcx
  80042050da:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042050de:	48 01 ca             	add    %rcx,%rdx
  80042050e1:	48 39 d0             	cmp    %rdx,%rax
  80042050e4:	74 35                	je     800420511b <check_boot_pml4e+0x428>
  80042050e6:	48 b9 98 8e 21 04 80 	movabs $0x8004218e98,%rcx
  80042050ed:	00 00 00 
  80042050f0:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042050f7:	00 00 00 
  80042050fa:	be a9 04 00 00       	mov    $0x4a9,%esi
  80042050ff:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205106:	00 00 00 
  8004205109:	b8 00 00 00 00       	mov    $0x0,%eax
  800420510e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205115:	00 00 00 
  8004205118:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420511b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205122:	00 
  8004205123:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420512a:	00 
  800420512b:	0f 86 12 ff ff ff    	jbe    8004205043 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205131:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205138:	00 
  8004205139:	eb 64                	jmp    800420519f <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  800420513b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420513f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205143:	48 01 c2             	add    %rax,%rdx
  8004205146:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420514a:	48 89 d6             	mov    %rdx,%rsi
  800420514d:	48 89 c7             	mov    %rax,%rdi
  8004205150:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004205157:	00 00 00 
  800420515a:	ff d0                	callq  *%rax
  800420515c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205160:	74 35                	je     8004205197 <check_boot_pml4e+0x4a4>
  8004205162:	48 b9 e0 8e 21 04 80 	movabs $0x8004218ee0,%rcx
  8004205169:	00 00 00 
  800420516c:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205173:	00 00 00 
  8004205176:	be ab 04 00 00       	mov    $0x4ab,%esi
  800420517b:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205182:	00 00 00 
  8004205185:	b8 00 00 00 00       	mov    $0x0,%eax
  800420518a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205191:	00 00 00 
  8004205194:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205197:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420519e:	00 
  800420519f:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042051a6:	00 
  80042051a7:	76 92                	jbe    800420513b <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042051a9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042051ae:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  80042051b3:	0f 86 54 fe ff ff    	jbe    800420500d <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042051b9:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042051c0:	00 00 00 
  80042051c3:	48 8b 00             	mov    (%rax),%rax
  80042051c6:	48 83 c0 08          	add    $0x8,%rax
  80042051ca:	48 8b 00             	mov    (%rax),%rax
  80042051cd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051d3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042051d7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051db:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051df:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042051e2:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042051e5:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042051ec:	00 00 00 
  80042051ef:	48 8b 00             	mov    (%rax),%rax
  80042051f2:	48 39 c2             	cmp    %rax,%rdx
  80042051f5:	72 32                	jb     8004205229 <check_boot_pml4e+0x536>
  80042051f7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051fb:	48 89 c1             	mov    %rax,%rcx
  80042051fe:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004205205:	00 00 00 
  8004205208:	be ae 04 00 00       	mov    $0x4ae,%esi
  800420520d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205214:	00 00 00 
  8004205217:	b8 00 00 00 00       	mov    $0x0,%eax
  800420521c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205223:	00 00 00 
  8004205226:	41 ff d0             	callq  *%r8
  8004205229:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205230:	00 00 00 
  8004205233:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205237:	48 01 d0             	add    %rdx,%rax
  800420523a:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  800420523e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205242:	48 8b 00             	mov    (%rax),%rax
  8004205245:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420524b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420524f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205253:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205257:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800420525a:	8b 55 84             	mov    -0x7c(%rbp),%edx
  800420525d:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004205264:	00 00 00 
  8004205267:	48 8b 00             	mov    (%rax),%rax
  800420526a:	48 39 c2             	cmp    %rax,%rdx
  800420526d:	72 32                	jb     80042052a1 <check_boot_pml4e+0x5ae>
  800420526f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205273:	48 89 c1             	mov    %rax,%rcx
  8004205276:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  800420527d:	00 00 00 
  8004205280:	be af 04 00 00       	mov    $0x4af,%esi
  8004205285:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420528c:	00 00 00 
  800420528f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205294:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420529b:	00 00 00 
  800420529e:	41 ff d0             	callq  *%r8
  80042052a1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042052a8:	00 00 00 
  80042052ab:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042052af:	48 01 d0             	add    %rdx,%rax
  80042052b2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042052b9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052c0:	00 
  80042052c1:	e9 50 01 00 00       	jmpq   8004205416 <check_boot_pml4e+0x723>
		switch (i) {
  80042052c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052ca:	48 83 f8 04          	cmp    $0x4,%rax
  80042052ce:	72 67                	jb     8004205337 <check_boot_pml4e+0x644>
  80042052d0:	48 83 f8 05          	cmp    $0x5,%rax
  80042052d4:	76 06                	jbe    80042052dc <check_boot_pml4e+0x5e9>
  80042052d6:	48 83 f8 1f          	cmp    $0x1f,%rax
  80042052da:	75 5b                	jne    8004205337 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  80042052dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052e0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042052e7:	00 
  80042052e8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042052ef:	48 01 d0             	add    %rdx,%rax
  80042052f2:	48 8b 00             	mov    (%rax),%rax
  80042052f5:	83 e0 01             	and    $0x1,%eax
  80042052f8:	48 85 c0             	test   %rax,%rax
  80042052fb:	75 35                	jne    8004205332 <check_boot_pml4e+0x63f>
  80042052fd:	48 b9 03 8f 21 04 80 	movabs $0x8004218f03,%rcx
  8004205304:	00 00 00 
  8004205307:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420530e:	00 00 00 
  8004205311:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004205316:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420531d:	00 00 00 
  8004205320:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205325:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420532c:	00 00 00 
  800420532f:	41 ff d0             	callq  *%r8
			break;
  8004205332:	e9 da 00 00 00       	jmpq   8004205411 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004205337:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  800420533c:	0f 86 ce 00 00 00    	jbe    8004205410 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004205342:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205346:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420534d:	00 
  800420534e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205355:	48 01 d0             	add    %rdx,%rax
  8004205358:	48 8b 00             	mov    (%rax),%rax
  800420535b:	83 e0 01             	and    $0x1,%eax
  800420535e:	48 85 c0             	test   %rax,%rax
  8004205361:	74 5a                	je     80042053bd <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004205363:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205367:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420536e:	00 
  800420536f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205376:	48 01 d0             	add    %rdx,%rax
  8004205379:	48 8b 00             	mov    (%rax),%rax
  800420537c:	83 e0 02             	and    $0x2,%eax
  800420537f:	48 85 c0             	test   %rax,%rax
  8004205382:	0f 85 88 00 00 00    	jne    8004205410 <check_boot_pml4e+0x71d>
  8004205388:	48 b9 14 8f 21 04 80 	movabs $0x8004218f14,%rcx
  800420538f:	00 00 00 
  8004205392:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205399:	00 00 00 
  800420539c:	be bc 04 00 00       	mov    $0x4bc,%esi
  80042053a1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042053a8:	00 00 00 
  80042053ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053b0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042053b7:	00 00 00 
  80042053ba:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042053bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053c1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042053c8:	00 
  80042053c9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053d0:	48 01 d0             	add    %rdx,%rax
  80042053d3:	48 8b 00             	mov    (%rax),%rax
  80042053d6:	48 85 c0             	test   %rax,%rax
  80042053d9:	74 35                	je     8004205410 <check_boot_pml4e+0x71d>
  80042053db:	48 b9 25 8f 21 04 80 	movabs $0x8004218f25,%rcx
  80042053e2:	00 00 00 
  80042053e5:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042053ec:	00 00 00 
  80042053ef:	be be 04 00 00       	mov    $0x4be,%esi
  80042053f4:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042053fb:	00 00 00 
  80042053fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205403:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420540a:	00 00 00 
  800420540d:	41 ff d0             	callq  *%r8
			} 
			break;
  8004205410:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205411:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205416:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  800420541d:	00 
  800420541e:	0f 86 a2 fe ff ff    	jbe    80042052c6 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205424:	48 bf 38 8f 21 04 80 	movabs $0x8004218f38,%rdi
  800420542b:	00 00 00 
  800420542e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205433:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420543a:	00 00 00 
  800420543d:	ff d2                	callq  *%rdx
}
  800420543f:	c9                   	leaveq 
  8004205440:	c3                   	retq   

0000008004205441 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205441:	55                   	push   %rbp
  8004205442:	48 89 e5             	mov    %rsp,%rbp
  8004205445:	48 83 ec 60          	sub    $0x60,%rsp
  8004205449:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420544d:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  8004205451:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205455:	48 c1 e8 27          	shr    $0x27,%rax
  8004205459:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420545e:	48 c1 e0 03          	shl    $0x3,%rax
  8004205462:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	//cprintf("pml4e %x %x \n" , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004205466:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420546a:	48 8b 00             	mov    (%rax),%rax
  800420546d:	83 e0 01             	and    $0x1,%eax
  8004205470:	48 85 c0             	test   %rax,%rax
  8004205473:	75 0c                	jne    8004205481 <check_va2pa+0x40>
		return ~0;
  8004205475:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420547c:	e9 38 02 00 00       	jmpq   80042056b9 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205481:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205485:	48 8b 00             	mov    (%rax),%rax
  8004205488:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420548e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205496:	48 c1 e8 0c          	shr    $0xc,%rax
  800420549a:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420549d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042054a0:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042054a7:	00 00 00 
  80042054aa:	48 8b 00             	mov    (%rax),%rax
  80042054ad:	48 39 c2             	cmp    %rax,%rdx
  80042054b0:	72 32                	jb     80042054e4 <check_va2pa+0xa3>
  80042054b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054b6:	48 89 c1             	mov    %rax,%rcx
  80042054b9:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042054c0:	00 00 00 
  80042054c3:	be d5 04 00 00       	mov    $0x4d5,%esi
  80042054c8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042054cf:	00 00 00 
  80042054d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054d7:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042054de:	00 00 00 
  80042054e1:	41 ff d0             	callq  *%r8
  80042054e4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054eb:	00 00 00 
  80042054ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054f2:	48 01 d0             	add    %rdx,%rax
  80042054f5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("pdpe %x %x \n" , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  80042054f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042054fd:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205501:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205506:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420550d:	00 
  800420550e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205512:	48 01 d0             	add    %rdx,%rax
  8004205515:	48 8b 00             	mov    (%rax),%rax
  8004205518:	83 e0 01             	and    $0x1,%eax
  800420551b:	48 85 c0             	test   %rax,%rax
  800420551e:	75 0c                	jne    800420552c <check_va2pa+0xeb>
		return ~0;
  8004205520:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205527:	e9 8d 01 00 00       	jmpq   80042056b9 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  800420552c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205530:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205534:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205539:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205540:	00 
  8004205541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205545:	48 01 d0             	add    %rdx,%rax
  8004205548:	48 8b 00             	mov    (%rax),%rax
  800420554b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205551:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205555:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205559:	48 c1 e8 0c          	shr    $0xc,%rax
  800420555d:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205560:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205563:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420556a:	00 00 00 
  800420556d:	48 8b 00             	mov    (%rax),%rax
  8004205570:	48 39 c2             	cmp    %rax,%rdx
  8004205573:	72 32                	jb     80042055a7 <check_va2pa+0x166>
  8004205575:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205579:	48 89 c1             	mov    %rax,%rcx
  800420557c:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004205583:	00 00 00 
  8004205586:	be d9 04 00 00       	mov    $0x4d9,%esi
  800420558b:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205592:	00 00 00 
  8004205595:	b8 00 00 00 00       	mov    $0x0,%eax
  800420559a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042055a1:	00 00 00 
  80042055a4:	41 ff d0             	callq  *%r8
  80042055a7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042055ae:	00 00 00 
  80042055b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042055b5:	48 01 d0             	add    %rdx,%rax
  80042055b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf("pde %x %x \n" , pde, *pde);
	pde = &pde[PDX(va)];
  80042055bc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042055c0:	48 c1 e8 15          	shr    $0x15,%rax
  80042055c4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042055c9:	48 c1 e0 03          	shl    $0x3,%rax
  80042055cd:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042055d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055d5:	48 8b 00             	mov    (%rax),%rax
  80042055d8:	83 e0 01             	and    $0x1,%eax
  80042055db:	48 85 c0             	test   %rax,%rax
  80042055de:	75 0c                	jne    80042055ec <check_va2pa+0x1ab>
		return ~0;
  80042055e0:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042055e7:	e9 cd 00 00 00       	jmpq   80042056b9 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042055ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055f0:	48 8b 00             	mov    (%rax),%rax
  80042055f3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055f9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042055fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205601:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205605:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205608:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420560b:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004205612:	00 00 00 
  8004205615:	48 8b 00             	mov    (%rax),%rax
  8004205618:	48 39 c2             	cmp    %rax,%rdx
  800420561b:	72 32                	jb     800420564f <check_va2pa+0x20e>
  800420561d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205621:	48 89 c1             	mov    %rax,%rcx
  8004205624:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  800420562b:	00 00 00 
  800420562e:	be de 04 00 00       	mov    $0x4de,%esi
  8004205633:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420563a:	00 00 00 
  800420563d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205642:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205649:	00 00 00 
  800420564c:	41 ff d0             	callq  *%r8
  800420564f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205656:	00 00 00 
  8004205659:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420565d:	48 01 d0             	add    %rdx,%rax
  8004205660:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf("pte %x %x %x \n" , pte, *pte, pte[PTX(va)]);
	if (!(pte[PTX(va)] & PTE_P))
  8004205664:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205668:	48 c1 e8 0c          	shr    $0xc,%rax
  800420566c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205671:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205678:	00 
  8004205679:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420567d:	48 01 d0             	add    %rdx,%rax
  8004205680:	48 8b 00             	mov    (%rax),%rax
  8004205683:	83 e0 01             	and    $0x1,%eax
  8004205686:	48 85 c0             	test   %rax,%rax
  8004205689:	75 09                	jne    8004205694 <check_va2pa+0x253>
		return ~0;
  800420568b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205692:	eb 25                	jmp    80042056b9 <check_va2pa+0x278>
	//cprintf("page Tale Index %x %x \n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205694:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205698:	48 c1 e8 0c          	shr    $0xc,%rax
  800420569c:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042056a1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042056a8:	00 
  80042056a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042056ad:	48 01 d0             	add    %rdx,%rax
  80042056b0:	48 8b 00             	mov    (%rax),%rax
  80042056b3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042056b9:	c9                   	leaveq 
  80042056ba:	c3                   	retq   

00000080042056bb <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042056bb:	55                   	push   %rbp
  80042056bc:	48 89 e5             	mov    %rsp,%rbp
  80042056bf:	53                   	push   %rbx
  80042056c0:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042056c7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042056ce:	00 
  80042056cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056d3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042056d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042056db:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042056df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056e3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042056e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056eb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042056ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042056f3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  80042056f7:	bf 00 00 00 00       	mov    $0x0,%edi
  80042056fc:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004205703:	00 00 00 
  8004205706:	ff d0                	callq  *%rax
  8004205708:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420570c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205711:	75 35                	jne    8004205748 <page_check+0x8d>
  8004205713:	48 b9 57 8f 21 04 80 	movabs $0x8004218f57,%rcx
  800420571a:	00 00 00 
  800420571d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205724:	00 00 00 
  8004205727:	be f4 04 00 00       	mov    $0x4f4,%esi
  800420572c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205733:	00 00 00 
  8004205736:	b8 00 00 00 00       	mov    $0x0,%eax
  800420573b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205742:	00 00 00 
  8004205745:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205748:	bf 00 00 00 00       	mov    $0x0,%edi
  800420574d:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004205754:	00 00 00 
  8004205757:	ff d0                	callq  *%rax
  8004205759:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420575d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205762:	75 35                	jne    8004205799 <page_check+0xde>
  8004205764:	48 b9 6b 8f 21 04 80 	movabs $0x8004218f6b,%rcx
  800420576b:	00 00 00 
  800420576e:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205775:	00 00 00 
  8004205778:	be f5 04 00 00       	mov    $0x4f5,%esi
  800420577d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205784:	00 00 00 
  8004205787:	b8 00 00 00 00       	mov    $0x0,%eax
  800420578c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205793:	00 00 00 
  8004205796:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205799:	bf 00 00 00 00       	mov    $0x0,%edi
  800420579e:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042057a5:	00 00 00 
  80042057a8:	ff d0                	callq  *%rax
  80042057aa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042057ae:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042057b3:	75 35                	jne    80042057ea <page_check+0x12f>
  80042057b5:	48 b9 7f 8f 21 04 80 	movabs $0x8004218f7f,%rcx
  80042057bc:	00 00 00 
  80042057bf:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042057c6:	00 00 00 
  80042057c9:	be f6 04 00 00       	mov    $0x4f6,%esi
  80042057ce:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042057d5:	00 00 00 
  80042057d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057dd:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042057e4:	00 00 00 
  80042057e7:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042057ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042057ef:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042057f6:	00 00 00 
  80042057f9:	ff d0                	callq  *%rax
  80042057fb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042057ff:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205804:	75 35                	jne    800420583b <page_check+0x180>
  8004205806:	48 b9 93 8f 21 04 80 	movabs $0x8004218f93,%rcx
  800420580d:	00 00 00 
  8004205810:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205817:	00 00 00 
  800420581a:	be f7 04 00 00       	mov    $0x4f7,%esi
  800420581f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205826:	00 00 00 
  8004205829:	b8 00 00 00 00       	mov    $0x0,%eax
  800420582e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205835:	00 00 00 
  8004205838:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  800420583b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205840:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004205847:	00 00 00 
  800420584a:	ff d0                	callq  *%rax
  800420584c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205850:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205855:	75 35                	jne    800420588c <page_check+0x1d1>
  8004205857:	48 b9 a7 8f 21 04 80 	movabs $0x8004218fa7,%rcx
  800420585e:	00 00 00 
  8004205861:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205868:	00 00 00 
  800420586b:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004205870:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205877:	00 00 00 
  800420587a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420587f:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205886:	00 00 00 
  8004205889:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  800420588c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205891:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004205898:	00 00 00 
  800420589b:	ff d0                	callq  *%rax
  800420589d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042058a1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042058a6:	75 35                	jne    80042058dd <page_check+0x222>
  80042058a8:	48 b9 bb 8f 21 04 80 	movabs $0x8004218fbb,%rcx
  80042058af:	00 00 00 
  80042058b2:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042058b9:	00 00 00 
  80042058bc:	be f9 04 00 00       	mov    $0x4f9,%esi
  80042058c1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042058c8:	00 00 00 
  80042058cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058d0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042058d7:	00 00 00 
  80042058da:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042058dd:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042058e2:	75 35                	jne    8004205919 <page_check+0x25e>
  80042058e4:	48 b9 09 8d 21 04 80 	movabs $0x8004218d09,%rcx
  80042058eb:	00 00 00 
  80042058ee:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042058f5:	00 00 00 
  80042058f8:	be fb 04 00 00       	mov    $0x4fb,%esi
  80042058fd:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205904:	00 00 00 
  8004205907:	b8 00 00 00 00       	mov    $0x0,%eax
  800420590c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205913:	00 00 00 
  8004205916:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205919:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420591e:	74 0a                	je     800420592a <page_check+0x26f>
  8004205920:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205924:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205928:	75 35                	jne    800420595f <page_check+0x2a4>
  800420592a:	48 b9 0d 8d 21 04 80 	movabs $0x8004218d0d,%rcx
  8004205931:	00 00 00 
  8004205934:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420593b:	00 00 00 
  800420593e:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004205943:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420594a:	00 00 00 
  800420594d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205952:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205959:	00 00 00 
  800420595c:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420595f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205964:	74 14                	je     800420597a <page_check+0x2bf>
  8004205966:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420596a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420596e:	74 0a                	je     800420597a <page_check+0x2bf>
  8004205970:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205974:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205978:	75 35                	jne    80042059af <page_check+0x2f4>
  800420597a:	48 b9 20 8d 21 04 80 	movabs $0x8004218d20,%rcx
  8004205981:	00 00 00 
  8004205984:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420598b:	00 00 00 
  800420598e:	be fd 04 00 00       	mov    $0x4fd,%esi
  8004205993:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420599a:	00 00 00 
  800420599d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059a2:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042059a9:	00 00 00 
  80042059ac:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042059af:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042059b4:	74 1e                	je     80042059d4 <page_check+0x319>
  80042059b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059ba:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042059be:	74 14                	je     80042059d4 <page_check+0x319>
  80042059c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059c4:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042059c8:	74 0a                	je     80042059d4 <page_check+0x319>
  80042059ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059ce:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042059d2:	75 35                	jne    8004205a09 <page_check+0x34e>
  80042059d4:	48 b9 d0 8f 21 04 80 	movabs $0x8004218fd0,%rcx
  80042059db:	00 00 00 
  80042059de:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042059e5:	00 00 00 
  80042059e8:	be fe 04 00 00       	mov    $0x4fe,%esi
  80042059ed:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042059f4:	00 00 00 
  80042059f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059fc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205a03:	00 00 00 
  8004205a06:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205a09:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205a0e:	74 28                	je     8004205a38 <page_check+0x37d>
  8004205a10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a14:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a18:	74 1e                	je     8004205a38 <page_check+0x37d>
  8004205a1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a1e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a22:	74 14                	je     8004205a38 <page_check+0x37d>
  8004205a24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a28:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a2c:	74 0a                	je     8004205a38 <page_check+0x37d>
  8004205a2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a32:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a36:	75 35                	jne    8004205a6d <page_check+0x3b2>
  8004205a38:	48 b9 00 90 21 04 80 	movabs $0x8004219000,%rcx
  8004205a3f:	00 00 00 
  8004205a42:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205a49:	00 00 00 
  8004205a4c:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004205a51:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205a58:	00 00 00 
  8004205a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a60:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205a67:	00 00 00 
  8004205a6a:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205a6d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205a72:	74 32                	je     8004205aa6 <page_check+0x3eb>
  8004205a74:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a78:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205a7c:	74 28                	je     8004205aa6 <page_check+0x3eb>
  8004205a7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a82:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a86:	74 1e                	je     8004205aa6 <page_check+0x3eb>
  8004205a88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a8c:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a90:	74 14                	je     8004205aa6 <page_check+0x3eb>
  8004205a92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a96:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a9a:	74 0a                	je     8004205aa6 <page_check+0x3eb>
  8004205a9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205aa0:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205aa4:	75 35                	jne    8004205adb <page_check+0x420>
  8004205aa6:	48 b9 40 90 21 04 80 	movabs $0x8004219040,%rcx
  8004205aad:	00 00 00 
  8004205ab0:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205ab7:	00 00 00 
  8004205aba:	be 00 05 00 00       	mov    $0x500,%esi
  8004205abf:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205ac6:	00 00 00 
  8004205ac9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ace:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205ad5:	00 00 00 
  8004205ad8:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205adb:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004205ae2:	00 00 00 
  8004205ae5:	48 8b 00             	mov    (%rax),%rax
  8004205ae8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205aec:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  8004205af3:	00 00 00 
  8004205af6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205afd:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b02:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004205b09:	00 00 00 
  8004205b0c:	ff d0                	callq  *%rax
  8004205b0e:	48 85 c0             	test   %rax,%rax
  8004205b11:	74 35                	je     8004205b48 <page_check+0x48d>
  8004205b13:	48 b9 97 8d 21 04 80 	movabs $0x8004218d97,%rcx
  8004205b1a:	00 00 00 
  8004205b1d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205b24:	00 00 00 
  8004205b27:	be 07 05 00 00       	mov    $0x507,%esi
  8004205b2c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205b33:	00 00 00 
  8004205b36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b3b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205b42:	00 00 00 
  8004205b45:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205b48:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205b4f:	00 00 00 
  8004205b52:	48 8b 00             	mov    (%rax),%rax
  8004205b55:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205b5c:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b61:	48 89 c7             	mov    %rax,%rdi
  8004205b64:	48 b8 37 39 20 04 80 	movabs $0x8004203937,%rax
  8004205b6b:	00 00 00 
  8004205b6e:	ff d0                	callq  *%rax
  8004205b70:	48 85 c0             	test   %rax,%rax
  8004205b73:	74 35                	je     8004205baa <page_check+0x4ef>
  8004205b75:	48 b9 90 90 21 04 80 	movabs $0x8004219090,%rcx
  8004205b7c:	00 00 00 
  8004205b7f:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205b86:	00 00 00 
  8004205b89:	be 0a 05 00 00       	mov    $0x50a,%esi
  8004205b8e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205b95:	00 00 00 
  8004205b98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b9d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205ba4:	00 00 00 
  8004205ba7:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205baa:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205bb1:	00 00 00 
  8004205bb4:	48 8b 00             	mov    (%rax),%rax
  8004205bb7:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205bbb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205bc0:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205bc5:	48 89 c7             	mov    %rax,%rdi
  8004205bc8:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004205bcf:	00 00 00 
  8004205bd2:	ff d0                	callq  *%rax
  8004205bd4:	85 c0                	test   %eax,%eax
  8004205bd6:	78 35                	js     8004205c0d <page_check+0x552>
  8004205bd8:	48 b9 c8 90 21 04 80 	movabs $0x80042190c8,%rcx
  8004205bdf:	00 00 00 
  8004205be2:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205be9:	00 00 00 
  8004205bec:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004205bf1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205bf8:	00 00 00 
  8004205bfb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c00:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205c07:	00 00 00 
  8004205c0a:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205c0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205c11:	48 89 c7             	mov    %rax,%rdi
  8004205c14:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004205c1b:	00 00 00 
  8004205c1e:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205c20:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205c27:	00 00 00 
  8004205c2a:	48 8b 00             	mov    (%rax),%rax
  8004205c2d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205c31:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c36:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205c3b:	48 89 c7             	mov    %rax,%rdi
  8004205c3e:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004205c45:	00 00 00 
  8004205c48:	ff d0                	callq  *%rax
  8004205c4a:	85 c0                	test   %eax,%eax
  8004205c4c:	78 35                	js     8004205c83 <page_check+0x5c8>
  8004205c4e:	48 b9 c8 90 21 04 80 	movabs $0x80042190c8,%rcx
  8004205c55:	00 00 00 
  8004205c58:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205c5f:	00 00 00 
  8004205c62:	be 11 05 00 00       	mov    $0x511,%esi
  8004205c67:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205c6e:	00 00 00 
  8004205c71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c76:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205c7d:	00 00 00 
  8004205c80:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205c83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c87:	48 89 c7             	mov    %rax,%rdi
  8004205c8a:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004205c91:	00 00 00 
  8004205c94:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205c96:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c9a:	48 89 c7             	mov    %rax,%rdi
  8004205c9d:	48 b8 6a 30 20 04 80 	movabs $0x800420306a,%rax
  8004205ca4:	00 00 00 
  8004205ca7:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205ca9:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205cb0:	00 00 00 
  8004205cb3:	48 8b 00             	mov    (%rax),%rax
  8004205cb6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205cba:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205cbf:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205cc4:	48 89 c7             	mov    %rax,%rdi
  8004205cc7:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004205cce:	00 00 00 
  8004205cd1:	ff d0                	callq  *%rax
  8004205cd3:	85 c0                	test   %eax,%eax
  8004205cd5:	74 35                	je     8004205d0c <page_check+0x651>
  8004205cd7:	48 b9 f8 90 21 04 80 	movabs $0x80042190f8,%rcx
  8004205cde:	00 00 00 
  8004205ce1:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205ce8:	00 00 00 
  8004205ceb:	be 17 05 00 00       	mov    $0x517,%esi
  8004205cf0:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205cf7:	00 00 00 
  8004205cfa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cff:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205d06:	00 00 00 
  8004205d09:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205d0c:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205d13:	00 00 00 
  8004205d16:	48 8b 00             	mov    (%rax),%rax
  8004205d19:	48 8b 00             	mov    (%rax),%rax
  8004205d1c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d22:	48 89 c3             	mov    %rax,%rbx
  8004205d25:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205d29:	48 89 c7             	mov    %rax,%rdi
  8004205d2c:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004205d33:	00 00 00 
  8004205d36:	ff d0                	callq  *%rax
  8004205d38:	48 39 c3             	cmp    %rax,%rbx
  8004205d3b:	0f 84 97 00 00 00    	je     8004205dd8 <page_check+0x71d>
  8004205d41:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205d48:	00 00 00 
  8004205d4b:	48 8b 00             	mov    (%rax),%rax
  8004205d4e:	48 8b 00             	mov    (%rax),%rax
  8004205d51:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d57:	48 89 c3             	mov    %rax,%rbx
  8004205d5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205d5e:	48 89 c7             	mov    %rax,%rdi
  8004205d61:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004205d68:	00 00 00 
  8004205d6b:	ff d0                	callq  *%rax
  8004205d6d:	48 39 c3             	cmp    %rax,%rbx
  8004205d70:	74 66                	je     8004205dd8 <page_check+0x71d>
  8004205d72:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205d79:	00 00 00 
  8004205d7c:	48 8b 00             	mov    (%rax),%rax
  8004205d7f:	48 8b 00             	mov    (%rax),%rax
  8004205d82:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d88:	48 89 c3             	mov    %rax,%rbx
  8004205d8b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d8f:	48 89 c7             	mov    %rax,%rdi
  8004205d92:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004205d99:	00 00 00 
  8004205d9c:	ff d0                	callq  *%rax
  8004205d9e:	48 39 c3             	cmp    %rax,%rbx
  8004205da1:	74 35                	je     8004205dd8 <page_check+0x71d>
  8004205da3:	48 b9 28 91 21 04 80 	movabs $0x8004219128,%rcx
  8004205daa:	00 00 00 
  8004205dad:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205db4:	00 00 00 
  8004205db7:	be 18 05 00 00       	mov    $0x518,%esi
  8004205dbc:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205dc3:	00 00 00 
  8004205dc6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dcb:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205dd2:	00 00 00 
  8004205dd5:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205dd8:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205ddf:	00 00 00 
  8004205de2:	48 8b 00             	mov    (%rax),%rax
  8004205de5:	be 00 00 00 00       	mov    $0x0,%esi
  8004205dea:	48 89 c7             	mov    %rax,%rdi
  8004205ded:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004205df4:	00 00 00 
  8004205df7:	ff d0                	callq  *%rax
  8004205df9:	48 89 c3             	mov    %rax,%rbx
  8004205dfc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e00:	48 89 c7             	mov    %rax,%rdi
  8004205e03:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004205e0a:	00 00 00 
  8004205e0d:	ff d0                	callq  *%rax
  8004205e0f:	48 39 c3             	cmp    %rax,%rbx
  8004205e12:	74 35                	je     8004205e49 <page_check+0x78e>
  8004205e14:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  8004205e1b:	00 00 00 
  8004205e1e:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205e25:	00 00 00 
  8004205e28:	be 19 05 00 00       	mov    $0x519,%esi
  8004205e2d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205e34:	00 00 00 
  8004205e37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e3c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205e43:	00 00 00 
  8004205e46:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205e49:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e4d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e51:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e55:	74 35                	je     8004205e8c <page_check+0x7d1>
  8004205e57:	48 b9 dd 91 21 04 80 	movabs $0x80042191dd,%rcx
  8004205e5e:	00 00 00 
  8004205e61:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205e68:	00 00 00 
  8004205e6b:	be 1a 05 00 00       	mov    $0x51a,%esi
  8004205e70:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205e77:	00 00 00 
  8004205e7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e7f:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205e86:	00 00 00 
  8004205e89:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205e8c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205e90:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e94:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e98:	74 35                	je     8004205ecf <page_check+0x814>
  8004205e9a:	48 b9 ee 91 21 04 80 	movabs $0x80042191ee,%rcx
  8004205ea1:	00 00 00 
  8004205ea4:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205eab:	00 00 00 
  8004205eae:	be 1b 05 00 00       	mov    $0x51b,%esi
  8004205eb3:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205eba:	00 00 00 
  8004205ebd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ec2:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205ec9:	00 00 00 
  8004205ecc:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205ecf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ed3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ed7:	66 83 f8 01          	cmp    $0x1,%ax
  8004205edb:	74 35                	je     8004205f12 <page_check+0x857>
  8004205edd:	48 b9 ff 91 21 04 80 	movabs $0x80042191ff,%rcx
  8004205ee4:	00 00 00 
  8004205ee7:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205eee:	00 00 00 
  8004205ef1:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205ef6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205efd:	00 00 00 
  8004205f00:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f05:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205f0c:	00 00 00 
  8004205f0f:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205f12:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205f19:	00 00 00 
  8004205f1c:	48 8b 00             	mov    (%rax),%rax
  8004205f1f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205f23:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f28:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205f2d:	48 89 c7             	mov    %rax,%rdi
  8004205f30:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004205f37:	00 00 00 
  8004205f3a:	ff d0                	callq  *%rax
  8004205f3c:	85 c0                	test   %eax,%eax
  8004205f3e:	74 35                	je     8004205f75 <page_check+0x8ba>
  8004205f40:	48 b9 10 92 21 04 80 	movabs $0x8004219210,%rcx
  8004205f47:	00 00 00 
  8004205f4a:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205f51:	00 00 00 
  8004205f54:	be 1e 05 00 00       	mov    $0x51e,%esi
  8004205f59:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205f60:	00 00 00 
  8004205f63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f68:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205f6f:	00 00 00 
  8004205f72:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205f75:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004205f7c:	00 00 00 
  8004205f7f:	48 8b 00             	mov    (%rax),%rax
  8004205f82:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f87:	48 89 c7             	mov    %rax,%rdi
  8004205f8a:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004205f91:	00 00 00 
  8004205f94:	ff d0                	callq  *%rax
  8004205f96:	48 89 c3             	mov    %rax,%rbx
  8004205f99:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f9d:	48 89 c7             	mov    %rax,%rdi
  8004205fa0:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004205fa7:	00 00 00 
  8004205faa:	ff d0                	callq  *%rax
  8004205fac:	48 39 c3             	cmp    %rax,%rbx
  8004205faf:	74 35                	je     8004205fe6 <page_check+0x92b>
  8004205fb1:	48 b9 48 92 21 04 80 	movabs $0x8004219248,%rcx
  8004205fb8:	00 00 00 
  8004205fbb:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004205fc2:	00 00 00 
  8004205fc5:	be 1f 05 00 00       	mov    $0x51f,%esi
  8004205fca:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004205fd1:	00 00 00 
  8004205fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fd9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004205fe0:	00 00 00 
  8004205fe3:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205fe6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fea:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fee:	66 83 f8 02          	cmp    $0x2,%ax
  8004205ff2:	74 35                	je     8004206029 <page_check+0x96e>
  8004205ff4:	48 b9 78 92 21 04 80 	movabs $0x8004219278,%rcx
  8004205ffb:	00 00 00 
  8004205ffe:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206005:	00 00 00 
  8004206008:	be 20 05 00 00       	mov    $0x520,%esi
  800420600d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206014:	00 00 00 
  8004206017:	b8 00 00 00 00       	mov    $0x0,%eax
  800420601c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206023:	00 00 00 
  8004206026:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004206029:	bf 00 00 00 00       	mov    $0x0,%edi
  800420602e:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004206035:	00 00 00 
  8004206038:	ff d0                	callq  *%rax
  800420603a:	48 85 c0             	test   %rax,%rax
  800420603d:	74 35                	je     8004206074 <page_check+0x9b9>
  800420603f:	48 b9 97 8d 21 04 80 	movabs $0x8004218d97,%rcx
  8004206046:	00 00 00 
  8004206049:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206050:	00 00 00 
  8004206053:	be 23 05 00 00       	mov    $0x523,%esi
  8004206058:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420605f:	00 00 00 
  8004206062:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206067:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420606e:	00 00 00 
  8004206071:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206074:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420607b:	00 00 00 
  800420607e:	48 8b 00             	mov    (%rax),%rax
  8004206081:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206085:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420608a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420608f:	48 89 c7             	mov    %rax,%rdi
  8004206092:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004206099:	00 00 00 
  800420609c:	ff d0                	callq  *%rax
  800420609e:	85 c0                	test   %eax,%eax
  80042060a0:	74 35                	je     80042060d7 <page_check+0xa1c>
  80042060a2:	48 b9 10 92 21 04 80 	movabs $0x8004219210,%rcx
  80042060a9:	00 00 00 
  80042060ac:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042060b3:	00 00 00 
  80042060b6:	be 26 05 00 00       	mov    $0x526,%esi
  80042060bb:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042060c2:	00 00 00 
  80042060c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060ca:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042060d1:	00 00 00 
  80042060d4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042060d7:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042060de:	00 00 00 
  80042060e1:	48 8b 00             	mov    (%rax),%rax
  80042060e4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060e9:	48 89 c7             	mov    %rax,%rdi
  80042060ec:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  80042060f3:	00 00 00 
  80042060f6:	ff d0                	callq  *%rax
  80042060f8:	48 89 c3             	mov    %rax,%rbx
  80042060fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060ff:	48 89 c7             	mov    %rax,%rdi
  8004206102:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004206109:	00 00 00 
  800420610c:	ff d0                	callq  *%rax
  800420610e:	48 39 c3             	cmp    %rax,%rbx
  8004206111:	74 35                	je     8004206148 <page_check+0xa8d>
  8004206113:	48 b9 48 92 21 04 80 	movabs $0x8004219248,%rcx
  800420611a:	00 00 00 
  800420611d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206124:	00 00 00 
  8004206127:	be 27 05 00 00       	mov    $0x527,%esi
  800420612c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206133:	00 00 00 
  8004206136:	b8 00 00 00 00       	mov    $0x0,%eax
  800420613b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206142:	00 00 00 
  8004206145:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206148:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420614c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206150:	66 83 f8 02          	cmp    $0x2,%ax
  8004206154:	74 35                	je     800420618b <page_check+0xad0>
  8004206156:	48 b9 78 92 21 04 80 	movabs $0x8004219278,%rcx
  800420615d:	00 00 00 
  8004206160:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206167:	00 00 00 
  800420616a:	be 28 05 00 00       	mov    $0x528,%esi
  800420616f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206176:	00 00 00 
  8004206179:	b8 00 00 00 00       	mov    $0x0,%eax
  800420617e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206185:	00 00 00 
  8004206188:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  800420618b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206190:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004206197:	00 00 00 
  800420619a:	ff d0                	callq  *%rax
  800420619c:	48 85 c0             	test   %rax,%rax
  800420619f:	74 35                	je     80042061d6 <page_check+0xb1b>
  80042061a1:	48 b9 97 8d 21 04 80 	movabs $0x8004218d97,%rcx
  80042061a8:	00 00 00 
  80042061ab:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042061b2:	00 00 00 
  80042061b5:	be 2c 05 00 00       	mov    $0x52c,%esi
  80042061ba:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042061c1:	00 00 00 
  80042061c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061c9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042061d0:	00 00 00 
  80042061d3:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042061d6:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042061dd:	00 00 00 
  80042061e0:	48 8b 00             	mov    (%rax),%rax
  80042061e3:	48 8b 00             	mov    (%rax),%rax
  80042061e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061ec:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042061f0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061f4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042061f8:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042061fb:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042061fe:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004206205:	00 00 00 
  8004206208:	48 8b 00             	mov    (%rax),%rax
  800420620b:	48 39 c2             	cmp    %rax,%rdx
  800420620e:	72 32                	jb     8004206242 <page_check+0xb87>
  8004206210:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206214:	48 89 c1             	mov    %rax,%rcx
  8004206217:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  800420621e:	00 00 00 
  8004206221:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004206226:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420622d:	00 00 00 
  8004206230:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206235:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420623c:	00 00 00 
  800420623f:	41 ff d0             	callq  *%r8
  8004206242:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206249:	00 00 00 
  800420624c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206250:	48 01 d0             	add    %rdx,%rax
  8004206253:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206257:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420625b:	48 8b 00             	mov    (%rax),%rax
  800420625e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206264:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004206268:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420626c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206270:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004206273:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004206276:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420627d:	00 00 00 
  8004206280:	48 8b 00             	mov    (%rax),%rax
  8004206283:	48 39 c2             	cmp    %rax,%rdx
  8004206286:	72 32                	jb     80042062ba <page_check+0xbff>
  8004206288:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420628c:	48 89 c1             	mov    %rax,%rcx
  800420628f:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004206296:	00 00 00 
  8004206299:	be 2f 05 00 00       	mov    $0x52f,%esi
  800420629e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042062a5:	00 00 00 
  80042062a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062ad:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042062b4:	00 00 00 
  80042062b7:	41 ff d0             	callq  *%r8
  80042062ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042062c1:	00 00 00 
  80042062c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042062c8:	48 01 d0             	add    %rdx,%rax
  80042062cb:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  80042062cf:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042062d3:	48 8b 00             	mov    (%rax),%rax
  80042062d6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062dc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042062e3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062ea:	48 c1 e8 0c          	shr    $0xc,%rax
  80042062ee:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  80042062f4:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  80042062fa:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004206301:	00 00 00 
  8004206304:	48 8b 00             	mov    (%rax),%rax
  8004206307:	48 39 c2             	cmp    %rax,%rdx
  800420630a:	72 35                	jb     8004206341 <page_check+0xc86>
  800420630c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206313:	48 89 c1             	mov    %rax,%rcx
  8004206316:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  800420631d:	00 00 00 
  8004206320:	be 30 05 00 00       	mov    $0x530,%esi
  8004206325:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420632c:	00 00 00 
  800420632f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206334:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420633b:	00 00 00 
  800420633e:	41 ff d0             	callq  *%r8
  8004206341:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206348:	00 00 00 
  800420634b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206352:	48 01 d0             	add    %rdx,%rax
  8004206355:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  800420635c:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206363:	00 00 00 
  8004206366:	48 8b 00             	mov    (%rax),%rax
  8004206369:	ba 00 00 00 00       	mov    $0x0,%edx
  800420636e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206373:	48 89 c7             	mov    %rax,%rdi
  8004206376:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  800420637d:	00 00 00 
  8004206380:	ff d0                	callq  *%rax
  8004206382:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004206389:	48 83 c2 08          	add    $0x8,%rdx
  800420638d:	48 39 d0             	cmp    %rdx,%rax
  8004206390:	74 35                	je     80042063c7 <page_check+0xd0c>
  8004206392:	48 b9 90 92 21 04 80 	movabs $0x8004219290,%rcx
  8004206399:	00 00 00 
  800420639c:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042063a3:	00 00 00 
  80042063a6:	be 31 05 00 00       	mov    $0x531,%esi
  80042063ab:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042063b2:	00 00 00 
  80042063b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063ba:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042063c1:	00 00 00 
  80042063c4:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042063c7:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042063ce:	00 00 00 
  80042063d1:	48 8b 00             	mov    (%rax),%rax
  80042063d4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063d8:	b9 04 00 00 00       	mov    $0x4,%ecx
  80042063dd:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063e2:	48 89 c7             	mov    %rax,%rdi
  80042063e5:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  80042063ec:	00 00 00 
  80042063ef:	ff d0                	callq  *%rax
  80042063f1:	85 c0                	test   %eax,%eax
  80042063f3:	74 35                	je     800420642a <page_check+0xd6f>
  80042063f5:	48 b9 d0 92 21 04 80 	movabs $0x80042192d0,%rcx
  80042063fc:	00 00 00 
  80042063ff:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206406:	00 00 00 
  8004206409:	be 34 05 00 00       	mov    $0x534,%esi
  800420640e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206415:	00 00 00 
  8004206418:	b8 00 00 00 00       	mov    $0x0,%eax
  800420641d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206424:	00 00 00 
  8004206427:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420642a:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206431:	00 00 00 
  8004206434:	48 8b 00             	mov    (%rax),%rax
  8004206437:	be 00 10 00 00       	mov    $0x1000,%esi
  800420643c:	48 89 c7             	mov    %rax,%rdi
  800420643f:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004206446:	00 00 00 
  8004206449:	ff d0                	callq  *%rax
  800420644b:	48 89 c3             	mov    %rax,%rbx
  800420644e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206452:	48 89 c7             	mov    %rax,%rdi
  8004206455:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  800420645c:	00 00 00 
  800420645f:	ff d0                	callq  *%rax
  8004206461:	48 39 c3             	cmp    %rax,%rbx
  8004206464:	74 35                	je     800420649b <page_check+0xde0>
  8004206466:	48 b9 48 92 21 04 80 	movabs $0x8004219248,%rcx
  800420646d:	00 00 00 
  8004206470:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206477:	00 00 00 
  800420647a:	be 35 05 00 00       	mov    $0x535,%esi
  800420647f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206486:	00 00 00 
  8004206489:	b8 00 00 00 00       	mov    $0x0,%eax
  800420648e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206495:	00 00 00 
  8004206498:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420649b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420649f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042064a3:	66 83 f8 02          	cmp    $0x2,%ax
  80042064a7:	74 35                	je     80042064de <page_check+0xe23>
  80042064a9:	48 b9 78 92 21 04 80 	movabs $0x8004219278,%rcx
  80042064b0:	00 00 00 
  80042064b3:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042064ba:	00 00 00 
  80042064bd:	be 36 05 00 00       	mov    $0x536,%esi
  80042064c2:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042064c9:	00 00 00 
  80042064cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064d1:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042064d8:	00 00 00 
  80042064db:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042064de:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042064e5:	00 00 00 
  80042064e8:	48 8b 00             	mov    (%rax),%rax
  80042064eb:	ba 00 00 00 00       	mov    $0x0,%edx
  80042064f0:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064f5:	48 89 c7             	mov    %rax,%rdi
  80042064f8:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  80042064ff:	00 00 00 
  8004206502:	ff d0                	callq  *%rax
  8004206504:	48 8b 00             	mov    (%rax),%rax
  8004206507:	83 e0 04             	and    $0x4,%eax
  800420650a:	48 85 c0             	test   %rax,%rax
  800420650d:	75 35                	jne    8004206544 <page_check+0xe89>
  800420650f:	48 b9 10 93 21 04 80 	movabs $0x8004219310,%rcx
  8004206516:	00 00 00 
  8004206519:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206520:	00 00 00 
  8004206523:	be 37 05 00 00       	mov    $0x537,%esi
  8004206528:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420652f:	00 00 00 
  8004206532:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206537:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420653e:	00 00 00 
  8004206541:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206544:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420654b:	00 00 00 
  800420654e:	48 8b 00             	mov    (%rax),%rax
  8004206551:	48 8b 00             	mov    (%rax),%rax
  8004206554:	83 e0 04             	and    $0x4,%eax
  8004206557:	48 85 c0             	test   %rax,%rax
  800420655a:	75 35                	jne    8004206591 <page_check+0xed6>
  800420655c:	48 b9 43 93 21 04 80 	movabs $0x8004219343,%rcx
  8004206563:	00 00 00 
  8004206566:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420656d:	00 00 00 
  8004206570:	be 38 05 00 00       	mov    $0x538,%esi
  8004206575:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420657c:	00 00 00 
  800420657f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206584:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420658b:	00 00 00 
  800420658e:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206591:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206598:	00 00 00 
  800420659b:	48 8b 00             	mov    (%rax),%rax
  800420659e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042065a2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065a7:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042065ac:	48 89 c7             	mov    %rax,%rdi
  80042065af:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  80042065b6:	00 00 00 
  80042065b9:	ff d0                	callq  *%rax
  80042065bb:	85 c0                	test   %eax,%eax
  80042065bd:	78 35                	js     80042065f4 <page_check+0xf39>
  80042065bf:	48 b9 60 93 21 04 80 	movabs $0x8004219360,%rcx
  80042065c6:	00 00 00 
  80042065c9:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042065d0:	00 00 00 
  80042065d3:	be 3c 05 00 00       	mov    $0x53c,%esi
  80042065d8:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042065df:	00 00 00 
  80042065e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065e7:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042065ee:	00 00 00 
  80042065f1:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042065f4:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042065fb:	00 00 00 
  80042065fe:	48 8b 00             	mov    (%rax),%rax
  8004206601:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206605:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420660a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420660f:	48 89 c7             	mov    %rax,%rdi
  8004206612:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004206619:	00 00 00 
  800420661c:	ff d0                	callq  *%rax
  800420661e:	85 c0                	test   %eax,%eax
  8004206620:	74 35                	je     8004206657 <page_check+0xf9c>
  8004206622:	48 b9 98 93 21 04 80 	movabs $0x8004219398,%rcx
  8004206629:	00 00 00 
  800420662c:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206633:	00 00 00 
  8004206636:	be 3f 05 00 00       	mov    $0x53f,%esi
  800420663b:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206642:	00 00 00 
  8004206645:	b8 00 00 00 00       	mov    $0x0,%eax
  800420664a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206651:	00 00 00 
  8004206654:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206657:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420665e:	00 00 00 
  8004206661:	48 8b 00             	mov    (%rax),%rax
  8004206664:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206669:	be 00 10 00 00       	mov    $0x1000,%esi
  800420666e:	48 89 c7             	mov    %rax,%rdi
  8004206671:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004206678:	00 00 00 
  800420667b:	ff d0                	callq  *%rax
  800420667d:	48 8b 00             	mov    (%rax),%rax
  8004206680:	83 e0 04             	and    $0x4,%eax
  8004206683:	48 85 c0             	test   %rax,%rax
  8004206686:	74 35                	je     80042066bd <page_check+0x1002>
  8004206688:	48 b9 d0 93 21 04 80 	movabs $0x80042193d0,%rcx
  800420668f:	00 00 00 
  8004206692:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206699:	00 00 00 
  800420669c:	be 40 05 00 00       	mov    $0x540,%esi
  80042066a1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042066a8:	00 00 00 
  80042066ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066b0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042066b7:	00 00 00 
  80042066ba:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042066bd:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042066c4:	00 00 00 
  80042066c7:	48 8b 00             	mov    (%rax),%rax
  80042066ca:	be 00 00 00 00       	mov    $0x0,%esi
  80042066cf:	48 89 c7             	mov    %rax,%rdi
  80042066d2:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  80042066d9:	00 00 00 
  80042066dc:	ff d0                	callq  *%rax
  80042066de:	48 89 c3             	mov    %rax,%rbx
  80042066e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042066e5:	48 89 c7             	mov    %rax,%rdi
  80042066e8:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042066ef:	00 00 00 
  80042066f2:	ff d0                	callq  *%rax
  80042066f4:	48 39 c3             	cmp    %rax,%rbx
  80042066f7:	74 35                	je     800420672e <page_check+0x1073>
  80042066f9:	48 b9 08 94 21 04 80 	movabs $0x8004219408,%rcx
  8004206700:	00 00 00 
  8004206703:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420670a:	00 00 00 
  800420670d:	be 43 05 00 00       	mov    $0x543,%esi
  8004206712:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206719:	00 00 00 
  800420671c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206721:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206728:	00 00 00 
  800420672b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  800420672e:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206735:	00 00 00 
  8004206738:	48 8b 00             	mov    (%rax),%rax
  800420673b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206740:	48 89 c7             	mov    %rax,%rdi
  8004206743:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  800420674a:	00 00 00 
  800420674d:	ff d0                	callq  *%rax
  800420674f:	48 89 c3             	mov    %rax,%rbx
  8004206752:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206756:	48 89 c7             	mov    %rax,%rdi
  8004206759:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004206760:	00 00 00 
  8004206763:	ff d0                	callq  *%rax
  8004206765:	48 39 c3             	cmp    %rax,%rbx
  8004206768:	74 35                	je     800420679f <page_check+0x10e4>
  800420676a:	48 b9 38 94 21 04 80 	movabs $0x8004219438,%rcx
  8004206771:	00 00 00 
  8004206774:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420677b:	00 00 00 
  800420677e:	be 44 05 00 00       	mov    $0x544,%esi
  8004206783:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420678a:	00 00 00 
  800420678d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206792:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206799:	00 00 00 
  800420679c:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  800420679f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042067a3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067a7:	66 83 f8 02          	cmp    $0x2,%ax
  80042067ab:	74 35                	je     80042067e2 <page_check+0x1127>
  80042067ad:	48 b9 68 94 21 04 80 	movabs $0x8004219468,%rcx
  80042067b4:	00 00 00 
  80042067b7:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042067be:	00 00 00 
  80042067c1:	be 46 05 00 00       	mov    $0x546,%esi
  80042067c6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042067cd:	00 00 00 
  80042067d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067d5:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042067dc:	00 00 00 
  80042067df:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042067e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067e6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067ea:	66 83 f8 01          	cmp    $0x1,%ax
  80042067ee:	74 35                	je     8004206825 <page_check+0x116a>
  80042067f0:	48 b9 79 94 21 04 80 	movabs $0x8004219479,%rcx
  80042067f7:	00 00 00 
  80042067fa:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206801:	00 00 00 
  8004206804:	be 47 05 00 00       	mov    $0x547,%esi
  8004206809:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206810:	00 00 00 
  8004206813:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206818:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420681f:	00 00 00 
  8004206822:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206825:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420682c:	00 00 00 
  800420682f:	48 8b 00             	mov    (%rax),%rax
  8004206832:	be 00 00 00 00       	mov    $0x0,%esi
  8004206837:	48 89 c7             	mov    %rax,%rdi
  800420683a:	48 b8 d1 39 20 04 80 	movabs $0x80042039d1,%rax
  8004206841:	00 00 00 
  8004206844:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206846:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420684d:	00 00 00 
  8004206850:	48 8b 00             	mov    (%rax),%rax
  8004206853:	be 00 00 00 00       	mov    $0x0,%esi
  8004206858:	48 89 c7             	mov    %rax,%rdi
  800420685b:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004206862:	00 00 00 
  8004206865:	ff d0                	callq  *%rax
  8004206867:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420686b:	74 35                	je     80042068a2 <page_check+0x11e7>
  800420686d:	48 b9 90 94 21 04 80 	movabs $0x8004219490,%rcx
  8004206874:	00 00 00 
  8004206877:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420687e:	00 00 00 
  8004206881:	be 4c 05 00 00       	mov    $0x54c,%esi
  8004206886:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420688d:	00 00 00 
  8004206890:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206895:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420689c:	00 00 00 
  800420689f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042068a2:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042068a9:	00 00 00 
  80042068ac:	48 8b 00             	mov    (%rax),%rax
  80042068af:	be 00 10 00 00       	mov    $0x1000,%esi
  80042068b4:	48 89 c7             	mov    %rax,%rdi
  80042068b7:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  80042068be:	00 00 00 
  80042068c1:	ff d0                	callq  *%rax
  80042068c3:	48 89 c3             	mov    %rax,%rbx
  80042068c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068ca:	48 89 c7             	mov    %rax,%rdi
  80042068cd:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  80042068d4:	00 00 00 
  80042068d7:	ff d0                	callq  *%rax
  80042068d9:	48 39 c3             	cmp    %rax,%rbx
  80042068dc:	74 35                	je     8004206913 <page_check+0x1258>
  80042068de:	48 b9 38 94 21 04 80 	movabs $0x8004219438,%rcx
  80042068e5:	00 00 00 
  80042068e8:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042068ef:	00 00 00 
  80042068f2:	be 4d 05 00 00       	mov    $0x54d,%esi
  80042068f7:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042068fe:	00 00 00 
  8004206901:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206906:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420690d:	00 00 00 
  8004206910:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206913:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206917:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420691b:	66 83 f8 01          	cmp    $0x1,%ax
  800420691f:	74 35                	je     8004206956 <page_check+0x129b>
  8004206921:	48 b9 dd 91 21 04 80 	movabs $0x80042191dd,%rcx
  8004206928:	00 00 00 
  800420692b:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206932:	00 00 00 
  8004206935:	be 4e 05 00 00       	mov    $0x54e,%esi
  800420693a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206941:	00 00 00 
  8004206944:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206949:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206950:	00 00 00 
  8004206953:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206956:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420695a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420695e:	66 83 f8 01          	cmp    $0x1,%ax
  8004206962:	74 35                	je     8004206999 <page_check+0x12de>
  8004206964:	48 b9 79 94 21 04 80 	movabs $0x8004219479,%rcx
  800420696b:	00 00 00 
  800420696e:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206975:	00 00 00 
  8004206978:	be 4f 05 00 00       	mov    $0x54f,%esi
  800420697d:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206984:	00 00 00 
  8004206987:	b8 00 00 00 00       	mov    $0x0,%eax
  800420698c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206993:	00 00 00 
  8004206996:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206999:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042069a0:	00 00 00 
  80042069a3:	48 8b 00             	mov    (%rax),%rax
  80042069a6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042069aa:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042069af:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042069b4:	48 89 c7             	mov    %rax,%rdi
  80042069b7:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  80042069be:	00 00 00 
  80042069c1:	ff d0                	callq  *%rax
  80042069c3:	85 c0                	test   %eax,%eax
  80042069c5:	74 35                	je     80042069fc <page_check+0x1341>
  80042069c7:	48 b9 98 93 21 04 80 	movabs $0x8004219398,%rcx
  80042069ce:	00 00 00 
  80042069d1:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042069d8:	00 00 00 
  80042069db:	be 53 05 00 00       	mov    $0x553,%esi
  80042069e0:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042069e7:	00 00 00 
  80042069ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069ef:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042069f6:	00 00 00 
  80042069f9:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  80042069fc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a00:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a04:	66 85 c0             	test   %ax,%ax
  8004206a07:	75 35                	jne    8004206a3e <page_check+0x1383>
  8004206a09:	48 b9 b3 94 21 04 80 	movabs $0x80042194b3,%rcx
  8004206a10:	00 00 00 
  8004206a13:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206a1a:	00 00 00 
  8004206a1d:	be 54 05 00 00       	mov    $0x554,%esi
  8004206a22:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206a29:	00 00 00 
  8004206a2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a31:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206a38:	00 00 00 
  8004206a3b:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206a3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a42:	48 8b 00             	mov    (%rax),%rax
  8004206a45:	48 85 c0             	test   %rax,%rax
  8004206a48:	74 35                	je     8004206a7f <page_check+0x13c4>
  8004206a4a:	48 b9 bf 94 21 04 80 	movabs $0x80042194bf,%rcx
  8004206a51:	00 00 00 
  8004206a54:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206a5b:	00 00 00 
  8004206a5e:	be 55 05 00 00       	mov    $0x555,%esi
  8004206a63:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206a6a:	00 00 00 
  8004206a6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a72:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206a79:	00 00 00 
  8004206a7c:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206a7f:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206a86:	00 00 00 
  8004206a89:	48 8b 00             	mov    (%rax),%rax
  8004206a8c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a91:	48 89 c7             	mov    %rax,%rdi
  8004206a94:	48 b8 d1 39 20 04 80 	movabs $0x80042039d1,%rax
  8004206a9b:	00 00 00 
  8004206a9e:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206aa0:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206aa7:	00 00 00 
  8004206aaa:	48 8b 00             	mov    (%rax),%rax
  8004206aad:	be 00 00 00 00       	mov    $0x0,%esi
  8004206ab2:	48 89 c7             	mov    %rax,%rdi
  8004206ab5:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004206abc:	00 00 00 
  8004206abf:	ff d0                	callq  *%rax
  8004206ac1:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206ac5:	74 35                	je     8004206afc <page_check+0x1441>
  8004206ac7:	48 b9 90 94 21 04 80 	movabs $0x8004219490,%rcx
  8004206ace:	00 00 00 
  8004206ad1:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206ad8:	00 00 00 
  8004206adb:	be 59 05 00 00       	mov    $0x559,%esi
  8004206ae0:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206ae7:	00 00 00 
  8004206aea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206aef:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206af6:	00 00 00 
  8004206af9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206afc:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206b03:	00 00 00 
  8004206b06:	48 8b 00             	mov    (%rax),%rax
  8004206b09:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206b0e:	48 89 c7             	mov    %rax,%rdi
  8004206b11:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004206b18:	00 00 00 
  8004206b1b:	ff d0                	callq  *%rax
  8004206b1d:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206b21:	74 35                	je     8004206b58 <page_check+0x149d>
  8004206b23:	48 b9 d8 94 21 04 80 	movabs $0x80042194d8,%rcx
  8004206b2a:	00 00 00 
  8004206b2d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206b34:	00 00 00 
  8004206b37:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004206b3c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206b43:	00 00 00 
  8004206b46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b4b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206b52:	00 00 00 
  8004206b55:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206b58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b5c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b60:	66 85 c0             	test   %ax,%ax
  8004206b63:	74 35                	je     8004206b9a <page_check+0x14df>
  8004206b65:	48 b9 fe 94 21 04 80 	movabs $0x80042194fe,%rcx
  8004206b6c:	00 00 00 
  8004206b6f:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206b76:	00 00 00 
  8004206b79:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004206b7e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206b85:	00 00 00 
  8004206b88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b8d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206b94:	00 00 00 
  8004206b97:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206b9a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b9e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ba2:	66 83 f8 01          	cmp    $0x1,%ax
  8004206ba6:	74 35                	je     8004206bdd <page_check+0x1522>
  8004206ba8:	48 b9 79 94 21 04 80 	movabs $0x8004219479,%rcx
  8004206baf:	00 00 00 
  8004206bb2:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206bb9:	00 00 00 
  8004206bbc:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004206bc1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206bc8:	00 00 00 
  8004206bcb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bd0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206bd7:	00 00 00 
  8004206bda:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206bdd:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206be4:	00 00 00 
  8004206be7:	48 8b 00             	mov    (%rax),%rax
  8004206bea:	48 8b 00             	mov    (%rax),%rax
  8004206bed:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bf3:	48 89 c3             	mov    %rax,%rbx
  8004206bf6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206bfa:	48 89 c7             	mov    %rax,%rdi
  8004206bfd:	48 b8 13 1c 20 04 80 	movabs $0x8004201c13,%rax
  8004206c04:	00 00 00 
  8004206c07:	ff d0                	callq  *%rax
  8004206c09:	48 39 c3             	cmp    %rax,%rbx
  8004206c0c:	74 35                	je     8004206c43 <page_check+0x1588>
  8004206c0e:	48 b9 10 95 21 04 80 	movabs $0x8004219510,%rcx
  8004206c15:	00 00 00 
  8004206c18:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206c1f:	00 00 00 
  8004206c22:	be 70 05 00 00       	mov    $0x570,%esi
  8004206c27:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206c2e:	00 00 00 
  8004206c31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c36:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206c3d:	00 00 00 
  8004206c40:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206c43:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206c4a:	00 00 00 
  8004206c4d:	48 8b 00             	mov    (%rax),%rax
  8004206c50:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206c57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c5b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c5f:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c63:	74 35                	je     8004206c9a <page_check+0x15df>
  8004206c65:	48 b9 79 94 21 04 80 	movabs $0x8004219479,%rcx
  8004206c6c:	00 00 00 
  8004206c6f:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206c76:	00 00 00 
  8004206c79:	be 72 05 00 00       	mov    $0x572,%esi
  8004206c7e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206c85:	00 00 00 
  8004206c88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c8d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206c94:	00 00 00 
  8004206c97:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206c9a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c9e:	48 89 c7             	mov    %rax,%rdi
  8004206ca1:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004206ca8:	00 00 00 
  8004206cab:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206cad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206cb1:	48 89 c7             	mov    %rax,%rdi
  8004206cb4:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004206cbb:	00 00 00 
  8004206cbe:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206cc0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206cc4:	48 89 c7             	mov    %rax,%rdi
  8004206cc7:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004206cce:	00 00 00 
  8004206cd1:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206cd3:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206cda:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206cde:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206ce5:	00 00 00 
  8004206ce8:	48 8b 00             	mov    (%rax),%rax
  8004206ceb:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206cf2:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206cf7:	48 89 ce             	mov    %rcx,%rsi
  8004206cfa:	48 89 c7             	mov    %rax,%rdi
  8004206cfd:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004206d04:	00 00 00 
  8004206d07:	ff d0                	callq  *%rax
  8004206d09:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206d10:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206d17:	00 00 00 
  8004206d1a:	48 8b 00             	mov    (%rax),%rax
  8004206d1d:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206d24:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206d28:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206d2e:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206d32:	48 01 d0             	add    %rdx,%rax
  8004206d35:	48 8b 00             	mov    (%rax),%rax
  8004206d38:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d3e:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206d45:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d4c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d50:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206d56:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206d5c:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004206d63:	00 00 00 
  8004206d66:	48 8b 00             	mov    (%rax),%rax
  8004206d69:	48 39 c2             	cmp    %rax,%rdx
  8004206d6c:	72 35                	jb     8004206da3 <page_check+0x16e8>
  8004206d6e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d75:	48 89 c1             	mov    %rax,%rcx
  8004206d78:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004206d7f:	00 00 00 
  8004206d82:	be 79 05 00 00       	mov    $0x579,%esi
  8004206d87:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206d8e:	00 00 00 
  8004206d91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d96:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206d9d:	00 00 00 
  8004206da0:	41 ff d0             	callq  *%r8
  8004206da3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206daa:	00 00 00 
  8004206dad:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206db4:	48 01 d0             	add    %rdx,%rax
  8004206db7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206dbb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206dc2:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206dc6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206dcb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206dd2:	00 
  8004206dd3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206dd7:	48 01 d0             	add    %rdx,%rax
  8004206dda:	48 8b 00             	mov    (%rax),%rax
  8004206ddd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206de3:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206dea:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206df1:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206df5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206dfb:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206e01:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004206e08:	00 00 00 
  8004206e0b:	48 8b 00             	mov    (%rax),%rax
  8004206e0e:	48 39 c2             	cmp    %rax,%rdx
  8004206e11:	72 35                	jb     8004206e48 <page_check+0x178d>
  8004206e13:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e1a:	48 89 c1             	mov    %rax,%rcx
  8004206e1d:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004206e24:	00 00 00 
  8004206e27:	be 7a 05 00 00       	mov    $0x57a,%esi
  8004206e2c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206e33:	00 00 00 
  8004206e36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e3b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206e42:	00 00 00 
  8004206e45:	41 ff d0             	callq  *%r8
  8004206e48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206e4f:	00 00 00 
  8004206e52:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e59:	48 01 d0             	add    %rdx,%rax
  8004206e5c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206e60:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206e67:	48 c1 e8 15          	shr    $0x15,%rax
  8004206e6b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206e70:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206e77:	00 
  8004206e78:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e7c:	48 01 d0             	add    %rdx,%rax
  8004206e7f:	48 8b 00             	mov    (%rax),%rax
  8004206e82:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e88:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206e8f:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206e96:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e9a:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206ea0:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206ea6:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004206ead:	00 00 00 
  8004206eb0:	48 8b 00             	mov    (%rax),%rax
  8004206eb3:	48 39 c2             	cmp    %rax,%rdx
  8004206eb6:	72 35                	jb     8004206eed <page_check+0x1832>
  8004206eb8:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206ebf:	48 89 c1             	mov    %rax,%rcx
  8004206ec2:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004206ec9:	00 00 00 
  8004206ecc:	be 7b 05 00 00       	mov    $0x57b,%esi
  8004206ed1:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206ed8:	00 00 00 
  8004206edb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ee0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206ee7:	00 00 00 
  8004206eea:	41 ff d0             	callq  *%r8
  8004206eed:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206ef4:	00 00 00 
  8004206ef7:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206efe:	48 01 d0             	add    %rdx,%rax
  8004206f01:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206f08:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206f0f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206f13:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206f18:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206f1f:	00 
  8004206f20:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004206f27:	48 01 c2             	add    %rax,%rdx
  8004206f2a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206f31:	48 39 c2             	cmp    %rax,%rdx
  8004206f34:	74 35                	je     8004206f6b <page_check+0x18b0>
  8004206f36:	48 b9 38 95 21 04 80 	movabs $0x8004219538,%rcx
  8004206f3d:	00 00 00 
  8004206f40:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004206f47:	00 00 00 
  8004206f4a:	be 7c 05 00 00       	mov    $0x57c,%esi
  8004206f4f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004206f56:	00 00 00 
  8004206f59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f5e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004206f65:	00 00 00 
  8004206f68:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  8004206f6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f6f:	48 89 c7             	mov    %rax,%rdi
  8004206f72:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004206f79:	00 00 00 
  8004206f7c:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206f7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f82:	48 89 c7             	mov    %rax,%rdi
  8004206f85:	48 b8 a9 1c 20 04 80 	movabs $0x8004201ca9,%rax
  8004206f8c:	00 00 00 
  8004206f8f:	ff d0                	callq  *%rax
  8004206f91:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206f96:	be ff 00 00 00       	mov    $0xff,%esi
  8004206f9b:	48 89 c7             	mov    %rax,%rdi
  8004206f9e:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004206fa5:	00 00 00 
  8004206fa8:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206faa:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206fb1:	00 00 00 
  8004206fb4:	48 8b 00             	mov    (%rax),%rax
  8004206fb7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206fbc:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fc1:	48 89 c7             	mov    %rax,%rdi
  8004206fc4:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004206fcb:	00 00 00 
  8004206fce:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206fd0:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004206fd7:	00 00 00 
  8004206fda:	48 8b 00             	mov    (%rax),%rax
  8004206fdd:	48 8b 00             	mov    (%rax),%rax
  8004206fe0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206fe6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206fed:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206ff4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ff8:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206ffe:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004207004:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420700b:	00 00 00 
  800420700e:	48 8b 00             	mov    (%rax),%rax
  8004207011:	48 39 c2             	cmp    %rax,%rdx
  8004207014:	72 35                	jb     800420704b <page_check+0x1990>
  8004207016:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420701d:	48 89 c1             	mov    %rax,%rcx
  8004207020:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  8004207027:	00 00 00 
  800420702a:	be 82 05 00 00       	mov    $0x582,%esi
  800420702f:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004207036:	00 00 00 
  8004207039:	b8 00 00 00 00       	mov    $0x0,%eax
  800420703e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207045:	00 00 00 
  8004207048:	41 ff d0             	callq  *%r8
  800420704b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207052:	00 00 00 
  8004207055:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420705c:	48 01 d0             	add    %rdx,%rax
  800420705f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207063:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207067:	48 8b 00             	mov    (%rax),%rax
  800420706a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207070:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004207077:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420707e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207082:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004207088:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800420708e:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004207095:	00 00 00 
  8004207098:	48 8b 00             	mov    (%rax),%rax
  800420709b:	48 39 c2             	cmp    %rax,%rdx
  800420709e:	72 35                	jb     80042070d5 <page_check+0x1a1a>
  80042070a0:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070a7:	48 89 c1             	mov    %rax,%rcx
  80042070aa:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  80042070b1:	00 00 00 
  80042070b4:	be 83 05 00 00       	mov    $0x583,%esi
  80042070b9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042070c0:	00 00 00 
  80042070c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070c8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042070cf:	00 00 00 
  80042070d2:	41 ff d0             	callq  *%r8
  80042070d5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042070dc:	00 00 00 
  80042070df:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070e6:	48 01 d0             	add    %rdx,%rax
  80042070e9:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042070ed:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042070f1:	48 8b 00             	mov    (%rax),%rax
  80042070f4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042070fa:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004207101:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207108:	48 c1 e8 0c          	shr    $0xc,%rax
  800420710c:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004207112:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004207118:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420711f:	00 00 00 
  8004207122:	48 8b 00             	mov    (%rax),%rax
  8004207125:	48 39 c2             	cmp    %rax,%rdx
  8004207128:	72 35                	jb     800420715f <page_check+0x1aa4>
  800420712a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207131:	48 89 c1             	mov    %rax,%rcx
  8004207134:	48 ba 78 88 21 04 80 	movabs $0x8004218878,%rdx
  800420713b:	00 00 00 
  800420713e:	be 84 05 00 00       	mov    $0x584,%esi
  8004207143:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420714a:	00 00 00 
  800420714d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207152:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207159:	00 00 00 
  800420715c:	41 ff d0             	callq  *%r8
  800420715f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207166:	00 00 00 
  8004207169:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207170:	48 01 d0             	add    %rdx,%rax
  8004207173:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  800420717a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207181:	eb 58                	jmp    80042071db <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  8004207183:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  800420718a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420718d:	48 63 d2             	movslq %edx,%rdx
  8004207190:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207194:	48 01 d0             	add    %rdx,%rax
  8004207197:	48 8b 00             	mov    (%rax),%rax
  800420719a:	83 e0 01             	and    $0x1,%eax
  800420719d:	48 85 c0             	test   %rax,%rax
  80042071a0:	74 35                	je     80042071d7 <page_check+0x1b1c>
  80042071a2:	48 b9 50 95 21 04 80 	movabs $0x8004219550,%rcx
  80042071a9:	00 00 00 
  80042071ac:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042071b3:	00 00 00 
  80042071b6:	be 86 05 00 00       	mov    $0x586,%esi
  80042071bb:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042071c2:	00 00 00 
  80042071c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071ca:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042071d1:	00 00 00 
  80042071d4:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  80042071d7:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042071db:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042071e2:	7e 9f                	jle    8004207183 <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  80042071e4:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042071eb:	00 00 00 
  80042071ee:	48 8b 00             	mov    (%rax),%rax
  80042071f1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042071f8:	48 b8 38 a2 60 04 80 	movabs $0x800460a238,%rax
  80042071ff:	00 00 00 
  8004207202:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207206:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207209:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420720d:	48 89 c7             	mov    %rax,%rdi
  8004207210:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004207217:	00 00 00 
  800420721a:	ff d0                	callq  *%rax
	page_decref(pp1);
  800420721c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207220:	48 89 c7             	mov    %rax,%rdi
  8004207223:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  800420722a:	00 00 00 
  800420722d:	ff d0                	callq  *%rax
	page_decref(pp2);
  800420722f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207233:	48 89 c7             	mov    %rax,%rdi
  8004207236:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  800420723d:	00 00 00 
  8004207240:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207242:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207247:	bf 00 00 00 00       	mov    $0x0,%edi
  800420724c:	48 b8 30 3b 20 04 80 	movabs $0x8004203b30,%rax
  8004207253:	00 00 00 
  8004207256:	ff d0                	callq  *%rax
  8004207258:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  800420725f:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207264:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207269:	48 b8 30 3b 20 04 80 	movabs $0x8004203b30,%rax
  8004207270:	00 00 00 
  8004207273:	ff d0                	callq  *%rax
  8004207275:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  800420727c:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207283:	00 00 00 
  8004207286:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  800420728d:	76 1d                	jbe    80042072ac <page_check+0x1bf1>
  800420728f:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207296:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  800420729d:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042072a4:	00 00 00 
  80042072a7:	48 39 c2             	cmp    %rax,%rdx
  80042072aa:	76 35                	jbe    80042072e1 <page_check+0x1c26>
  80042072ac:	48 b9 68 95 21 04 80 	movabs $0x8004219568,%rcx
  80042072b3:	00 00 00 
  80042072b6:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042072bd:	00 00 00 
  80042072c0:	be 95 05 00 00       	mov    $0x595,%esi
  80042072c5:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042072cc:	00 00 00 
  80042072cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072d4:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042072db:	00 00 00 
  80042072de:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042072e1:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042072e8:	00 00 00 
  80042072eb:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  80042072f2:	76 1d                	jbe    8004207311 <page_check+0x1c56>
  80042072f4:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042072fb:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207302:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207309:	00 00 00 
  800420730c:	48 39 c2             	cmp    %rax,%rdx
  800420730f:	76 35                	jbe    8004207346 <page_check+0x1c8b>
  8004207311:	48 b9 90 95 21 04 80 	movabs $0x8004219590,%rcx
  8004207318:	00 00 00 
  800420731b:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004207322:	00 00 00 
  8004207325:	be 96 05 00 00       	mov    $0x596,%esi
  800420732a:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004207331:	00 00 00 
  8004207334:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207339:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207340:	00 00 00 
  8004207343:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207346:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420734d:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207352:	48 85 c0             	test   %rax,%rax
  8004207355:	75 11                	jne    8004207368 <page_check+0x1cad>
  8004207357:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420735e:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207363:	48 85 c0             	test   %rax,%rax
  8004207366:	74 35                	je     800420739d <page_check+0x1ce2>
  8004207368:	48 b9 b8 95 21 04 80 	movabs $0x80042195b8,%rcx
  800420736f:	00 00 00 
  8004207372:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004207379:	00 00 00 
  800420737c:	be 98 05 00 00       	mov    $0x598,%esi
  8004207381:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004207388:	00 00 00 
  800420738b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207390:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207397:	00 00 00 
  800420739a:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  800420739d:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042073a4:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  80042073aa:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  80042073b1:	76 35                	jbe    80042073e8 <page_check+0x1d2d>
  80042073b3:	48 b9 df 95 21 04 80 	movabs $0x80042195df,%rcx
  80042073ba:	00 00 00 
  80042073bd:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042073c4:	00 00 00 
  80042073c7:	be 9a 05 00 00       	mov    $0x59a,%esi
  80042073cc:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042073d3:	00 00 00 
  80042073d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073db:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042073e2:	00 00 00 
  80042073e5:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042073e8:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042073ef:	00 00 00 
  80042073f2:	48 8b 00             	mov    (%rax),%rax
  80042073f5:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  80042073fc:	48 89 d6             	mov    %rdx,%rsi
  80042073ff:	48 89 c7             	mov    %rax,%rdi
  8004207402:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004207409:	00 00 00 
  800420740c:	ff d0                	callq  *%rax
  800420740e:	48 85 c0             	test   %rax,%rax
  8004207411:	74 35                	je     8004207448 <page_check+0x1d8d>
  8004207413:	48 b9 f8 95 21 04 80 	movabs $0x80042195f8,%rcx
  800420741a:	00 00 00 
  800420741d:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004207424:	00 00 00 
  8004207427:	be 9d 05 00 00       	mov    $0x59d,%esi
  800420742c:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004207433:	00 00 00 
  8004207436:	b8 00 00 00 00       	mov    $0x0,%eax
  800420743b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207442:	00 00 00 
  8004207445:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207448:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420744f:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207456:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420745d:	00 00 00 
  8004207460:	48 8b 00             	mov    (%rax),%rax
  8004207463:	48 89 d6             	mov    %rdx,%rsi
  8004207466:	48 89 c7             	mov    %rax,%rdi
  8004207469:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  8004207470:	00 00 00 
  8004207473:	ff d0                	callq  *%rax
  8004207475:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  800420747b:	74 35                	je     80042074b2 <page_check+0x1df7>
  800420747d:	48 b9 20 96 21 04 80 	movabs $0x8004219620,%rcx
  8004207484:	00 00 00 
  8004207487:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420748e:	00 00 00 
  8004207491:	be 9e 05 00 00       	mov    $0x59e,%esi
  8004207496:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420749d:	00 00 00 
  80042074a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074a5:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042074ac:	00 00 00 
  80042074af:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  80042074b2:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042074b9:	00 00 00 
  80042074bc:	48 8b 00             	mov    (%rax),%rax
  80042074bf:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042074c6:	48 89 d6             	mov    %rdx,%rsi
  80042074c9:	48 89 c7             	mov    %rax,%rdi
  80042074cc:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  80042074d3:	00 00 00 
  80042074d6:	ff d0                	callq  *%rax
  80042074d8:	48 85 c0             	test   %rax,%rax
  80042074db:	74 35                	je     8004207512 <page_check+0x1e57>
  80042074dd:	48 b9 50 96 21 04 80 	movabs $0x8004219650,%rcx
  80042074e4:	00 00 00 
  80042074e7:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042074ee:	00 00 00 
  80042074f1:	be 9f 05 00 00       	mov    $0x59f,%esi
  80042074f6:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042074fd:	00 00 00 
  8004207500:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207505:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420750c:	00 00 00 
  800420750f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207512:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207519:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207520:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004207527:	00 00 00 
  800420752a:	48 8b 00             	mov    (%rax),%rax
  800420752d:	48 89 d6             	mov    %rdx,%rsi
  8004207530:	48 89 c7             	mov    %rax,%rdi
  8004207533:	48 b8 41 54 20 04 80 	movabs $0x8004205441,%rax
  800420753a:	00 00 00 
  800420753d:	ff d0                	callq  *%rax
  800420753f:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207543:	74 35                	je     800420757a <page_check+0x1ebf>
  8004207545:	48 b9 78 96 21 04 80 	movabs $0x8004219678,%rcx
  800420754c:	00 00 00 
  800420754f:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  8004207556:	00 00 00 
  8004207559:	be a0 05 00 00       	mov    $0x5a0,%esi
  800420755e:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  8004207565:	00 00 00 
  8004207568:	b8 00 00 00 00       	mov    $0x0,%eax
  800420756d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207574:	00 00 00 
  8004207577:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  800420757a:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207581:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004207588:	00 00 00 
  800420758b:	48 8b 00             	mov    (%rax),%rax
  800420758e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207593:	48 89 ce             	mov    %rcx,%rsi
  8004207596:	48 89 c7             	mov    %rax,%rdi
  8004207599:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  80042075a0:	00 00 00 
  80042075a3:	ff d0                	callq  *%rax
  80042075a5:	48 8b 00             	mov    (%rax),%rax
  80042075a8:	83 e0 1a             	and    $0x1a,%eax
  80042075ab:	48 85 c0             	test   %rax,%rax
  80042075ae:	75 35                	jne    80042075e5 <page_check+0x1f2a>
  80042075b0:	48 b9 a8 96 21 04 80 	movabs $0x80042196a8,%rcx
  80042075b7:	00 00 00 
  80042075ba:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  80042075c1:	00 00 00 
  80042075c4:	be a2 05 00 00       	mov    $0x5a2,%esi
  80042075c9:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  80042075d0:	00 00 00 
  80042075d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075d8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042075df:	00 00 00 
  80042075e2:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  80042075e5:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042075ec:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042075f3:	00 00 00 
  80042075f6:	48 8b 00             	mov    (%rax),%rax
  80042075f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042075fe:	48 89 ce             	mov    %rcx,%rsi
  8004207601:	48 89 c7             	mov    %rax,%rdi
  8004207604:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  800420760b:	00 00 00 
  800420760e:	ff d0                	callq  *%rax
  8004207610:	48 8b 00             	mov    (%rax),%rax
  8004207613:	83 e0 04             	and    $0x4,%eax
  8004207616:	48 85 c0             	test   %rax,%rax
  8004207619:	74 35                	je     8004207650 <page_check+0x1f95>
  800420761b:	48 b9 f0 96 21 04 80 	movabs $0x80042196f0,%rcx
  8004207622:	00 00 00 
  8004207625:	48 ba f1 88 21 04 80 	movabs $0x80042188f1,%rdx
  800420762c:	00 00 00 
  800420762f:	be a3 05 00 00       	mov    $0x5a3,%esi
  8004207634:	48 bf 06 89 21 04 80 	movabs $0x8004218906,%rdi
  800420763b:	00 00 00 
  800420763e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207643:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420764a:	00 00 00 
  800420764d:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207650:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207657:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420765e:	00 00 00 
  8004207661:	48 8b 00             	mov    (%rax),%rax
  8004207664:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207669:	48 89 ce             	mov    %rcx,%rsi
  800420766c:	48 89 c7             	mov    %rax,%rdi
  800420766f:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  8004207676:	00 00 00 
  8004207679:	ff d0                	callq  *%rax
  800420767b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207682:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207689:	48 05 00 10 00 00    	add    $0x1000,%rax
  800420768f:	48 89 c1             	mov    %rax,%rcx
  8004207692:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004207699:	00 00 00 
  800420769c:	48 8b 00             	mov    (%rax),%rax
  800420769f:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076a4:	48 89 ce             	mov    %rcx,%rsi
  80042076a7:	48 89 c7             	mov    %rax,%rdi
  80042076aa:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  80042076b1:	00 00 00 
  80042076b4:	ff d0                	callq  *%rax
  80042076b6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042076bd:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042076c4:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  80042076cb:	00 00 00 
  80042076ce:	48 8b 00             	mov    (%rax),%rax
  80042076d1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076d6:	48 89 ce             	mov    %rcx,%rsi
  80042076d9:	48 89 c7             	mov    %rax,%rdi
  80042076dc:	48 b8 43 31 20 04 80 	movabs $0x8004203143,%rax
  80042076e3:	00 00 00 
  80042076e6:	ff d0                	callq  *%rax
  80042076e8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  80042076ef:	48 bf 23 97 21 04 80 	movabs $0x8004219723,%rdi
  80042076f6:	00 00 00 
  80042076f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076fe:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004207705:	00 00 00 
  8004207708:	ff d2                	callq  *%rdx
}
  800420770a:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207711:	5b                   	pop    %rbx
  8004207712:	5d                   	pop    %rbp
  8004207713:	c3                   	retq   

0000008004207714 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207714:	55                   	push   %rbp
  8004207715:	48 89 e5             	mov    %rsp,%rbp
  8004207718:	48 83 ec 08          	sub    $0x8,%rsp
  800420771c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207720:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207724:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  800420772b:	00 00 00 
  800420772e:	48 8b 00             	mov    (%rax),%rax
  8004207731:	48 29 c2             	sub    %rax,%rdx
  8004207734:	48 89 d0             	mov    %rdx,%rax
  8004207737:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420773b:	c9                   	leaveq 
  800420773c:	c3                   	retq   

000000800420773d <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420773d:	55                   	push   %rbp
  800420773e:	48 89 e5             	mov    %rsp,%rbp
  8004207741:	48 83 ec 08          	sub    $0x8,%rsp
  8004207745:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420774d:	48 89 c7             	mov    %rax,%rdi
  8004207750:	48 b8 14 77 20 04 80 	movabs $0x8004207714,%rax
  8004207757:	00 00 00 
  800420775a:	ff d0                	callq  *%rax
  800420775c:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207760:	c9                   	leaveq 
  8004207761:	c3                   	retq   

0000008004207762 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207762:	55                   	push   %rbp
  8004207763:	48 89 e5             	mov    %rsp,%rbp
  8004207766:	48 83 ec 10          	sub    $0x10,%rsp
  800420776a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420776e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207772:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207776:	48 89 c2             	mov    %rax,%rdx
  8004207779:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004207780:	00 00 00 
  8004207783:	48 8b 00             	mov    (%rax),%rax
  8004207786:	48 39 c2             	cmp    %rax,%rdx
  8004207789:	72 2a                	jb     80042077b5 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420778b:	48 ba 40 97 21 04 80 	movabs $0x8004219740,%rdx
  8004207792:	00 00 00 
  8004207795:	be 54 00 00 00       	mov    $0x54,%esi
  800420779a:	48 bf 5f 97 21 04 80 	movabs $0x800421975f,%rdi
  80042077a1:	00 00 00 
  80042077a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077a9:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  80042077b0:	00 00 00 
  80042077b3:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042077b5:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  80042077bc:	00 00 00 
  80042077bf:	48 8b 00             	mov    (%rax),%rax
  80042077c2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042077c6:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042077ca:	48 c1 e2 04          	shl    $0x4,%rdx
  80042077ce:	48 01 d0             	add    %rdx,%rax
}
  80042077d1:	c9                   	leaveq 
  80042077d2:	c3                   	retq   

00000080042077d3 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042077d3:	55                   	push   %rbp
  80042077d4:	48 89 e5             	mov    %rsp,%rbp
  80042077d7:	48 83 ec 20          	sub    $0x20,%rsp
  80042077db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042077df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077e3:	48 89 c7             	mov    %rax,%rdi
  80042077e6:	48 b8 3d 77 20 04 80 	movabs $0x800420773d,%rax
  80042077ed:	00 00 00 
  80042077f0:	ff d0                	callq  *%rax
  80042077f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042077f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077fa:	48 c1 e8 0c          	shr    $0xc,%rax
  80042077fe:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207801:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207804:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  800420780b:	00 00 00 
  800420780e:	48 8b 00             	mov    (%rax),%rax
  8004207811:	48 39 c2             	cmp    %rax,%rdx
  8004207814:	72 32                	jb     8004207848 <page2kva+0x75>
  8004207816:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420781a:	48 89 c1             	mov    %rax,%rcx
  800420781d:	48 ba 70 97 21 04 80 	movabs $0x8004219770,%rdx
  8004207824:	00 00 00 
  8004207827:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420782c:	48 bf 5f 97 21 04 80 	movabs $0x800421975f,%rdi
  8004207833:	00 00 00 
  8004207836:	b8 00 00 00 00       	mov    $0x0,%eax
  800420783b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004207842:	00 00 00 
  8004207845:	41 ff d0             	callq  *%r8
  8004207848:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420784f:	00 00 00 
  8004207852:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207856:	48 01 d0             	add    %rdx,%rax
}
  8004207859:	c9                   	leaveq 
  800420785a:	c3                   	retq   

000000800420785b <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420785b:	55                   	push   %rbp
  800420785c:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420785f:	48 bf 80 e7 22 04 80 	movabs $0x800422e780,%rdi
  8004207866:	00 00 00 
  8004207869:	48 b8 53 6e 21 04 80 	movabs $0x8004216e53,%rax
  8004207870:	00 00 00 
  8004207873:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207875:	f3 90                	pause  
}
  8004207877:	5d                   	pop    %rbp
  8004207878:	c3                   	retq   

0000008004207879 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207879:	55                   	push   %rbp
  800420787a:	48 89 e5             	mov    %rsp,%rbp
  800420787d:	53                   	push   %rbx
  800420787e:	48 83 ec 28          	sub    $0x28,%rsp
  8004207882:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207885:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207889:	89 d0                	mov    %edx,%eax
  800420788b:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  800420788e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207892:	75 42                	jne    80042078d6 <envid2env+0x5d>
		*env_store = curenv;
  8004207894:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420789b:	00 00 00 
  800420789e:	ff d0                	callq  *%rax
  80042078a0:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042078a7:	00 00 00 
  80042078aa:	48 98                	cltq   
  80042078ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042078b0:	48 89 c2             	mov    %rax,%rdx
  80042078b3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042078b7:	48 29 c2             	sub    %rax,%rdx
  80042078ba:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042078be:	48 83 c0 08          	add    $0x8,%rax
  80042078c2:	48 8b 10             	mov    (%rax),%rdx
  80042078c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078c9:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042078cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078d1:	e9 09 01 00 00       	jmpq   80042079df <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042078d6:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  80042078dd:	00 00 00 
  80042078e0:	48 8b 08             	mov    (%rax),%rcx
  80042078e3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042078e6:	48 98                	cltq   
  80042078e8:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042078ed:	48 89 c2             	mov    %rax,%rdx
  80042078f0:	48 89 d0             	mov    %rdx,%rax
  80042078f3:	48 c1 e0 03          	shl    $0x3,%rax
  80042078f7:	48 01 d0             	add    %rdx,%rax
  80042078fa:	48 c1 e0 05          	shl    $0x5,%rax
  80042078fe:	48 01 c8             	add    %rcx,%rax
  8004207901:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207909:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420790f:	85 c0                	test   %eax,%eax
  8004207911:	74 0f                	je     8004207922 <envid2env+0xa9>
  8004207913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207917:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420791d:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207920:	74 15                	je     8004207937 <envid2env+0xbe>
		*env_store = 0;
  8004207922:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207926:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420792d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207932:	e9 a8 00 00 00       	jmpq   80042079df <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207937:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  800420793b:	0f 84 8e 00 00 00    	je     80042079cf <envid2env+0x156>
  8004207941:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004207948:	00 00 00 
  800420794b:	ff d0                	callq  *%rax
  800420794d:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004207954:	00 00 00 
  8004207957:	48 98                	cltq   
  8004207959:	48 c1 e0 03          	shl    $0x3,%rax
  800420795d:	48 89 c2             	mov    %rax,%rdx
  8004207960:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207964:	48 29 c2             	sub    %rax,%rdx
  8004207967:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420796b:	48 83 c0 08          	add    $0x8,%rax
  800420796f:	48 8b 00             	mov    (%rax),%rax
  8004207972:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207976:	74 57                	je     80042079cf <envid2env+0x156>
  8004207978:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420797c:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207982:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004207989:	00 00 00 
  800420798c:	ff d0                	callq  *%rax
  800420798e:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004207995:	00 00 00 
  8004207998:	48 98                	cltq   
  800420799a:	48 c1 e0 03          	shl    $0x3,%rax
  800420799e:	48 89 c2             	mov    %rax,%rdx
  80042079a1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042079a5:	48 29 c2             	sub    %rax,%rdx
  80042079a8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042079ac:	48 83 c0 08          	add    $0x8,%rax
  80042079b0:	48 8b 00             	mov    (%rax),%rax
  80042079b3:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042079b9:	39 c3                	cmp    %eax,%ebx
  80042079bb:	74 12                	je     80042079cf <envid2env+0x156>
		*env_store = 0;
  80042079bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079c1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042079c8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042079cd:	eb 10                	jmp    80042079df <envid2env+0x166>
	}

	*env_store = e;
  80042079cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079d3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042079d7:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042079da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042079df:	48 83 c4 28          	add    $0x28,%rsp
  80042079e3:	5b                   	pop    %rbx
  80042079e4:	5d                   	pop    %rbp
  80042079e5:	c3                   	retq   

00000080042079e6 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042079e6:	55                   	push   %rbp
  80042079e7:	48 89 e5             	mov    %rsp,%rbp
  80042079ea:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  80042079ee:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042079f5:	00 
	memset(envs, 0, NENV * sizeof(struct Env));
  80042079f6:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  80042079fd:	00 00 00 
  8004207a00:	48 8b 00             	mov    (%rax),%rax
  8004207a03:	ba 00 80 04 00       	mov    $0x48000,%edx
  8004207a08:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a0d:	48 89 c7             	mov    %rax,%rdi
  8004207a10:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004207a17:	00 00 00 
  8004207a1a:	ff d0                	callq  *%rax
	for (i = 0; i < NENV; i++) {
  8004207a1c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207a23:	00 
  8004207a24:	e9 92 00 00 00       	jmpq   8004207abb <env_init+0xd5>
		if(last)
  8004207a29:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207a2e:	74 30                	je     8004207a60 <env_init+0x7a>
			last->env_link = &envs[i];
  8004207a30:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  8004207a37:	00 00 00 
  8004207a3a:	48 8b 08             	mov    (%rax),%rcx
  8004207a3d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a41:	48 89 d0             	mov    %rdx,%rax
  8004207a44:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a48:	48 01 d0             	add    %rdx,%rax
  8004207a4b:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a4f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a53:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a57:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004207a5e:	eb 30                	jmp    8004207a90 <env_init+0xaa>
		else
			env_free_list = &envs[i];
  8004207a60:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  8004207a67:	00 00 00 
  8004207a6a:	48 8b 08             	mov    (%rax),%rcx
  8004207a6d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a71:	48 89 d0             	mov    %rdx,%rax
  8004207a74:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a78:	48 01 d0             	add    %rdx,%rax
  8004207a7b:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a7f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a83:	48 b8 58 a2 60 04 80 	movabs $0x800460a258,%rax
  8004207a8a:	00 00 00 
  8004207a8d:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004207a90:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  8004207a97:	00 00 00 
  8004207a9a:	48 8b 08             	mov    (%rax),%rcx
  8004207a9d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207aa1:	48 89 d0             	mov    %rdx,%rax
  8004207aa4:	48 c1 e0 03          	shl    $0x3,%rax
  8004207aa8:	48 01 d0             	add    %rdx,%rax
  8004207aab:	48 c1 e0 05          	shl    $0x5,%rax
  8004207aaf:	48 01 c8             	add    %rcx,%rax
  8004207ab2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	memset(envs, 0, NENV * sizeof(struct Env));
	for (i = 0; i < NENV; i++) {
  8004207ab6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207abb:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004207ac2:	00 
  8004207ac3:	0f 86 60 ff ff ff    	jbe    8004207a29 <env_init+0x43>
		else
			env_free_list = &envs[i];
		last = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207ac9:	48 b8 d7 7a 20 04 80 	movabs $0x8004207ad7,%rax
  8004207ad0:	00 00 00 
  8004207ad3:	ff d0                	callq  *%rax
}
  8004207ad5:	c9                   	leaveq 
  8004207ad6:	c3                   	retq   

0000008004207ad7 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207ad7:	55                   	push   %rbp
  8004207ad8:	48 89 e5             	mov    %rsp,%rbp
  8004207adb:	53                   	push   %rbx
  8004207adc:	48 83 ec 10          	sub    $0x10,%rsp
  8004207ae0:	48 b8 88 e6 22 04 80 	movabs $0x800422e688,%rax
  8004207ae7:	00 00 00 
  8004207aea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004207aee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207af2:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207af5:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207afa:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207afc:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207b01:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207b03:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207b08:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207b0a:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207b0f:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207b11:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207b16:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207b18:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207b1d:	89 c3                	mov    %eax,%ebx
  8004207b1f:	53                   	push   %rbx
  8004207b20:	48 b8 2d 7b 20 04 80 	movabs $0x8004207b2d,%rax
  8004207b27:	00 00 00 
  8004207b2a:	50                   	push   %rax
  8004207b2b:	48 cb                	lretq  
  8004207b2d:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004207b33:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207b37:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207b3a:	48 83 c4 10          	add    $0x10,%rsp
  8004207b3e:	5b                   	pop    %rbx
  8004207b3f:	5d                   	pop    %rbp
  8004207b40:	c3                   	retq   

0000008004207b41 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207b41:	55                   	push   %rbp
  8004207b42:	48 89 e5             	mov    %rsp,%rbp
  8004207b45:	48 83 ec 20          	sub    $0x20,%rsp
  8004207b49:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207b4d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207b54:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207b55:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207b5a:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004207b61:	00 00 00 
  8004207b64:	ff d0                	callq  *%rax
  8004207b66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207b6a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207b6f:	75 0a                	jne    8004207b7b <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207b71:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207b76:	e9 98 00 00 00       	jmpq   8004207c13 <env_setup_vm+0xd2>
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	//Increment page reference here
	p->pp_ref++;
  8004207b7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b7f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207b83:	8d 50 01             	lea    0x1(%rax),%edx
  8004207b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b8a:	66 89 50 08          	mov    %dx,0x8(%rax)

	//fill structure values
	e->env_pml4e = (pml4e_t *)page2kva(p);
  8004207b8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b92:	48 89 c7             	mov    %rax,%rdi
  8004207b95:	48 b8 d3 77 20 04 80 	movabs $0x80042077d3,%rax
  8004207b9c:	00 00 00 
  8004207b9f:	ff d0                	callq  *%rax
  8004207ba1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207ba5:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3= page2pa(p);
  8004207bac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207bb0:	48 89 c7             	mov    %rax,%rdi
  8004207bb3:	48 b8 3d 77 20 04 80 	movabs $0x800420773d,%rax
  8004207bba:	00 00 00 
  8004207bbd:	ff d0                	callq  *%rax
  8004207bbf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207bc3:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	//copy kernel pml4e entries 
    //for (i = PML4(UTOP); i != NPDENTRIES; i++)
    //    e->env_pml4e[i] = boot_pml4e[i]|PTE_USER;
	
	e->env_pml4e[1] = boot_pml4e[1];
  8004207bca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bce:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bd5:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207bd9:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  8004207be0:	00 00 00 
  8004207be3:	48 8b 00             	mov    (%rax),%rax
  8004207be6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207bea:	48 89 02             	mov    %rax,(%rdx)
	//cprintf("envpml4e[0] [%x],envpml4e[1] [%x], env cr3[%x] ,  UTOP [%x] PML4e1 [%x]",e->env_pml4e[0],e->env_pml4e[0], e->env_cr3, UTOP, PML4(UTOP));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 |PTE_P|PTE_W|PTE_U;
  8004207bed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bf1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bf8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207bfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207c00:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207c07:	48 83 c8 07          	or     $0x7,%rax
  8004207c0b:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207c0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207c13:	c9                   	leaveq 
  8004207c14:	c3                   	retq   

0000008004207c15 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207c15:	55                   	push   %rbp
  8004207c16:	48 89 e5             	mov    %rsp,%rbp
  8004207c19:	48 83 ec 30          	sub    $0x30,%rsp
  8004207c1d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207c21:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004207c24:	48 b8 58 a2 60 04 80 	movabs $0x800460a258,%rax
  8004207c2b:	00 00 00 
  8004207c2e:	48 8b 00             	mov    (%rax),%rax
  8004207c31:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207c35:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207c3a:	75 0a                	jne    8004207c46 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207c3c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207c41:	e9 76 01 00 00       	jmpq   8004207dbc <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004207c46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c4a:	48 89 c7             	mov    %rax,%rdi
  8004207c4d:	48 b8 41 7b 20 04 80 	movabs $0x8004207b41,%rax
  8004207c54:	00 00 00 
  8004207c57:	ff d0                	callq  *%rax
  8004207c59:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004207c5c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207c60:	79 08                	jns    8004207c6a <env_alloc+0x55>
		return r;
  8004207c62:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c65:	e9 52 01 00 00       	jmpq   8004207dbc <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207c6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c6e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207c74:	05 00 10 00 00       	add    $0x1000,%eax
  8004207c79:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207c7e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207c81:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207c85:	7f 07                	jg     8004207c8e <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004207c87:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207c8e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207c92:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  8004207c99:	00 00 00 
  8004207c9c:	48 8b 00             	mov    (%rax),%rax
  8004207c9f:	48 29 c2             	sub    %rax,%rdx
  8004207ca2:	48 89 d0             	mov    %rdx,%rax
  8004207ca5:	48 c1 f8 05          	sar    $0x5,%rax
  8004207ca9:	48 89 c2             	mov    %rax,%rdx
  8004207cac:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207cb3:	e3 38 8e 
  8004207cb6:	48 0f af c2          	imul   %rdx,%rax
  8004207cba:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004207cbd:	89 c2                	mov    %eax,%edx
  8004207cbf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cc3:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207cc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ccd:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004207cd0:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207cd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cda:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207ce1:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207ce4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ce8:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207cef:	00 00 00 
	e->env_runs = 0;
  8004207cf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cf6:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207cfd:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207d00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d04:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207d09:	be 00 00 00 00       	mov    $0x0,%esi
  8004207d0e:	48 89 c7             	mov    %rax,%rdi
  8004207d11:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004207d18:	00 00 00 
  8004207d1b:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207d1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d21:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207d28:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207d2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d2e:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207d34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d38:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207d3f:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207d41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d45:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004207d4a:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207d51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d55:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207d5c:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = e->env_tf.tf_eflags |FL_IF;
  8004207d5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d62:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207d69:	80 cc 02             	or     $0x2,%ah
  8004207d6c:	48 89 c2             	mov    %rax,%rdx
  8004207d6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d73:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207d7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d7e:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207d85:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207d89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d8d:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207d94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d98:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207d9f:	48 b8 58 a2 60 04 80 	movabs $0x800460a258,%rax
  8004207da6:	00 00 00 
  8004207da9:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207dac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207db0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207db4:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("env.tf->rsp [%x], e->env_id [%d]\n", e->env_tf.tf_rsp, e->env_id);

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004207db7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207dbc:	c9                   	leaveq 
  8004207dbd:	c3                   	retq   

0000008004207dbe <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207dbe:	55                   	push   %rbp
  8004207dbf:	48 89 e5             	mov    %rsp,%rbp
  8004207dc2:	48 83 ec 40          	sub    $0x40,%rsp
  8004207dc6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207dca:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207dce:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	uint64_t temp = (uint64_t)va;
  8004207dd2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dd6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t lenDown = (uint64_t)va - temp;
  8004207dda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dde:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004207de2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int i = 0;
  8004207de6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	struct PageInfo *p;
	// Address round down
	temp =  (temp / PGSIZE) * PGSIZE;
  8004207ded:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207df1:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207df5:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207df9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// size round up
	len += lenDown;
  8004207dfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e01:	48 01 45 c8          	add    %rax,-0x38(%rbp)
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
  8004207e05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207e09:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207e0f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e13:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207e17:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e1b:	eb 79                	jmp    8004207e96 <region_alloc+0xd8>
	{	
		p = page_alloc(ALLOC_ZERO);
  8004207e1d:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207e22:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004207e29:	00 00 00 
  8004207e2c:	ff d0                	callq  *%rax
  8004207e2e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(p == NULL)
  8004207e32:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207e37:	75 2a                	jne    8004207e63 <region_alloc+0xa5>
		    panic("Page alloc fail\n");
  8004207e39:	48 ba 93 97 21 04 80 	movabs $0x8004219793,%rdx
  8004207e40:	00 00 00 
  8004207e43:	be 4b 01 00 00       	mov    $0x14b,%esi
  8004207e48:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  8004207e4f:	00 00 00 
  8004207e52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e57:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004207e5e:	00 00 00 
  8004207e61:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, (void*)temp, PTE_U|PTE_P|PTE_W);
  8004207e63:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207e6b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207e72:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004207e76:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207e7b:	48 89 c7             	mov    %rax,%rdi
  8004207e7e:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  8004207e85:	00 00 00 
  8004207e88:	ff d0                	callq  *%rax
		temp+=PGSIZE;
  8004207e8a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207e91:	00 
	len += lenDown;
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e92:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207e96:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207e99:	48 98                	cltq   
  8004207e9b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004207e9f:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207ea3:	48 39 d0             	cmp    %rdx,%rax
  8004207ea6:	0f 82 71 ff ff ff    	jb     8004207e1d <region_alloc+0x5f>
		temp+=PGSIZE;
		//cprintf("region_alloc temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);
	}
	//cprintf("region_alloc end temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);

}
  8004207eac:	c9                   	leaveq 
  8004207ead:	c3                   	retq   

0000008004207eae <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207eae:	55                   	push   %rbp
  8004207eaf:	48 89 e5             	mov    %rsp,%rbp
  8004207eb2:	48 83 ec 40          	sub    $0x40,%rsp
  8004207eb6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207eba:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

	struct PageInfo *p;
	struct Elf * elfHeader;
	struct Proghdr *ph, *eph;

	if(e == NULL || binary == NULL)
  8004207ebe:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207ec3:	74 07                	je     8004207ecc <load_icode+0x1e>
  8004207ec5:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004207eca:	75 2a                	jne    8004207ef6 <load_icode+0x48>
		panic("load icode Failed due to NULL input");
  8004207ecc:	48 ba b0 97 21 04 80 	movabs $0x80042197b0,%rdx
  8004207ed3:	00 00 00 
  8004207ed6:	be 95 01 00 00       	mov    $0x195,%esi
  8004207edb:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  8004207ee2:	00 00 00 
  8004207ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207eea:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004207ef1:	00 00 00 
  8004207ef4:	ff d1                	callq  *%rcx


	elfHeader = (struct Elf *) binary;	
  8004207ef6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207efa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is this a valid ELF?
	if (elfHeader->e_magic != ELF_MAGIC)
  8004207efe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f02:	8b 00                	mov    (%rax),%eax
  8004207f04:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207f09:	74 2a                	je     8004207f35 <load_icode+0x87>
		panic("load icode Failed due to Corrupt ELF");
  8004207f0b:	48 ba d8 97 21 04 80 	movabs $0x80042197d8,%rdx
  8004207f12:	00 00 00 
  8004207f15:	be 9b 01 00 00       	mov    $0x19b,%esi
  8004207f1a:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  8004207f21:	00 00 00 
  8004207f24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f29:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004207f30:	00 00 00 
  8004207f33:	ff d1                	callq  *%rcx

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
  8004207f35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f39:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207f41:	48 01 d0             	add    %rdx,%rax
  8004207f44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + elfHeader->e_phnum;
  8004207f48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f4c:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207f50:	0f b7 c0             	movzwl %ax,%eax
  8004207f53:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f57:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f5e:	00 
  8004207f5f:	48 29 c2             	sub    %rax,%rdx
  8004207f62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f66:	48 01 d0             	add    %rdx,%rax
  8004207f69:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  8004207f6d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f71:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f78:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207f7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f80:	0f 22 d8             	mov    %rax,%cr3
	for (;ph < eph; ph++){
  8004207f83:	e9 d3 00 00 00       	jmpq   800420805b <load_icode+0x1ad>
		if(ELF_PROG_LOAD == ph->p_type){
  8004207f88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f8c:	8b 00                	mov    (%rax),%eax
  8004207f8e:	83 f8 01             	cmp    $0x1,%eax
  8004207f91:	0f 85 bf 00 00 00    	jne    8004208056 <load_icode+0x1a8>
			if(ph->p_filesz <= ph->p_memsz){
  8004207f97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f9b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fa3:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004207fa7:	48 39 c2             	cmp    %rax,%rdx
  8004207faa:	0f 87 a6 00 00 00    	ja     8004208056 <load_icode+0x1a8>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004207fb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fb4:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207fb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fbc:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207fc0:	48 89 c1             	mov    %rax,%rcx
  8004207fc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fc7:	48 89 ce             	mov    %rcx,%rsi
  8004207fca:	48 89 c7             	mov    %rax,%rdi
  8004207fcd:	48 b8 be 7d 20 04 80 	movabs $0x8004207dbe,%rax
  8004207fd4:	00 00 00 
  8004207fd7:	ff d0                	callq  *%rax
				size_t a = e->env_pml4e[0];
  8004207fd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fdd:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207fe4:	48 8b 00             	mov    (%rax),%rax
  8004207fe7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				//cprintf("load icode Inter  e->env_pml4e is [%x], PML40 is [%x], PML41 is [%x], ph->p_filesz [%ld]\n",  e->env_pml4e, e->env_pml4e[0],e->env_pml4e[1], ph->p_filesz);

				memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004207feb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fef:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207ff3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ff7:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004207ffb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207fff:	48 01 c1             	add    %rax,%rcx
  8004208002:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208006:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420800a:	48 89 ce             	mov    %rcx,%rsi
  800420800d:	48 89 c7             	mov    %rax,%rdi
  8004208010:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  8004208017:	00 00 00 
  800420801a:	ff d0                	callq  *%rax
				memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
  800420801c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208020:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208028:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420802c:	48 29 c2             	sub    %rax,%rdx
  800420802f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208033:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208037:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420803b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420803f:	48 01 c8             	add    %rcx,%rax
  8004208042:	be 00 00 00 00       	mov    $0x0,%esi
  8004208047:	48 89 c7             	mov    %rax,%rdi
  800420804a:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004208051:	00 00 00 
  8004208054:	ff d0                	callq  *%rax
		panic("load icode Failed due to Corrupt ELF");

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
	eph = ph + elfHeader->e_phnum;
	lcr3(e->env_cr3);
	for (;ph < eph; ph++){
  8004208056:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  800420805b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420805f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208063:	0f 82 1f ff ff ff    	jb     8004207f88 <load_icode+0xda>
		}
	}
	// call the entry point from the ELF header
	// note: does not return!
	
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  8004208069:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420806d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208072:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208077:	48 89 c7             	mov    %rax,%rdi
  800420807a:	48 b8 be 7d 20 04 80 	movabs $0x8004207dbe,%rax
  8004208081:	00 00 00 
  8004208084:	ff d0                	callq  *%rax
	e->env_tf.tf_rip = (uintptr_t)(elfHeader->e_entry);
  8004208086:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420808a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420808e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208092:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->elf = binary;
  8004208099:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420809d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042080a1:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  80042080a8:	c9                   	leaveq 
  80042080a9:	c3                   	retq   

00000080042080aa <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  80042080aa:	55                   	push   %rbp
  80042080ab:	48 89 e5             	mov    %rsp,%rbp
  80042080ae:	48 83 ec 20          	sub    $0x20,%rsp
  80042080b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042080b6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	struct Env *e;
	envid_t parent_id;
	if(env_alloc(&e, 0) != 0)
  80042080b9:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  80042080bd:	be 00 00 00 00       	mov    $0x0,%esi
  80042080c2:	48 89 c7             	mov    %rax,%rdi
  80042080c5:	48 b8 15 7c 20 04 80 	movabs $0x8004207c15,%rax
  80042080cc:	00 00 00 
  80042080cf:	ff d0                	callq  *%rax
  80042080d1:	85 c0                	test   %eax,%eax
  80042080d3:	74 2a                	je     80042080ff <env_create+0x55>
	{
		panic("Failed in env_alloc");
  80042080d5:	48 ba fd 97 21 04 80 	movabs $0x80042197fd,%rdx
  80042080dc:	00 00 00 
  80042080df:	be c8 01 00 00       	mov    $0x1c8,%esi
  80042080e4:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  80042080eb:	00 00 00 
  80042080ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080f3:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  80042080fa:	00 00 00 
  80042080fd:	ff d1                	callq  *%rcx
	}
	e->env_type = type;
  80042080ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208103:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208106:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  800420810c:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8004208110:	75 19                	jne    800420812b <env_create+0x81>
	{
			e->env_tf.tf_eflags |= FL_IOPL_MASK;
  8004208112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208116:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420811a:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004208121:	80 ce 30             	or     $0x30,%dh
  8004208124:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
	load_icode(e, binary);
  800420812b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420812f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208133:	48 89 d6             	mov    %rdx,%rsi
  8004208136:	48 89 c7             	mov    %rax,%rdi
  8004208139:	48 b8 ae 7e 20 04 80 	movabs $0x8004207eae,%rax
  8004208140:	00 00 00 
  8004208143:	ff d0                	callq  *%rax
}
  8004208145:	c9                   	leaveq 
  8004208146:	c3                   	retq   

0000008004208147 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004208147:	55                   	push   %rbp
  8004208148:	48 89 e5             	mov    %rsp,%rbp
  800420814b:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208152:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208159:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004208160:	00 00 00 
  8004208163:	ff d0                	callq  *%rax
  8004208165:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420816c:	00 00 00 
  800420816f:	48 98                	cltq   
  8004208171:	48 c1 e0 03          	shl    $0x3,%rax
  8004208175:	48 89 c2             	mov    %rax,%rdx
  8004208178:	48 c1 e2 04          	shl    $0x4,%rdx
  800420817c:	48 29 c2             	sub    %rax,%rdx
  800420817f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208183:	48 83 c0 08          	add    $0x8,%rax
  8004208187:	48 8b 00             	mov    (%rax),%rax
  800420818a:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208191:	75 18                	jne    80042081ab <env_free+0x64>
		lcr3(boot_cr3);
  8004208193:	48 b8 50 d4 60 04 80 	movabs $0x800460d450,%rax
  800420819a:	00 00 00 
  800420819d:	48 8b 00             	mov    (%rax),%rax
  80042081a0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042081a4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042081a8:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  80042081ab:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042081b2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081b9:	48 8b 00             	mov    (%rax),%rax
  80042081bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042081c2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042081c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081ca:	48 c1 e8 0c          	shr    $0xc,%rax
  80042081ce:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042081d1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042081d4:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042081db:	00 00 00 
  80042081de:	48 8b 00             	mov    (%rax),%rax
  80042081e1:	48 39 c2             	cmp    %rax,%rdx
  80042081e4:	72 32                	jb     8004208218 <env_free+0xd1>
  80042081e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081ea:	48 89 c1             	mov    %rax,%rcx
  80042081ed:	48 ba 70 97 21 04 80 	movabs $0x8004219770,%rdx
  80042081f4:	00 00 00 
  80042081f7:	be e7 01 00 00       	mov    $0x1e7,%esi
  80042081fc:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  8004208203:	00 00 00 
  8004208206:	b8 00 00 00 00       	mov    $0x0,%eax
  800420820b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004208212:	00 00 00 
  8004208215:	41 ff d0             	callq  *%r8
  8004208218:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420821f:	00 00 00 
  8004208222:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208226:	48 01 d0             	add    %rdx,%rax
  8004208229:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  800420822d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208234:	00 
  8004208235:	e9 ab 02 00 00       	jmpq   80042084e5 <env_free+0x39e>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  800420823a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420823e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208245:	00 
  8004208246:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420824a:	48 01 d0             	add    %rdx,%rax
  800420824d:	48 8b 00             	mov    (%rax),%rax
  8004208250:	83 e0 01             	and    $0x1,%eax
  8004208253:	48 85 c0             	test   %rax,%rax
  8004208256:	75 05                	jne    800420825d <env_free+0x116>
			continue;
  8004208258:	e9 83 02 00 00       	jmpq   80042084e0 <env_free+0x399>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  800420825d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208261:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208268:	00 
  8004208269:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420826d:	48 01 d0             	add    %rdx,%rax
  8004208270:	48 8b 00             	mov    (%rax),%rax
  8004208273:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208279:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420827d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208281:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208285:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208288:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420828b:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004208292:	00 00 00 
  8004208295:	48 8b 00             	mov    (%rax),%rax
  8004208298:	48 39 c2             	cmp    %rax,%rdx
  800420829b:	72 32                	jb     80042082cf <env_free+0x188>
  800420829d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082a1:	48 89 c1             	mov    %rax,%rcx
  80042082a4:	48 ba 70 97 21 04 80 	movabs $0x8004219770,%rdx
  80042082ab:	00 00 00 
  80042082ae:	be ef 01 00 00       	mov    $0x1ef,%esi
  80042082b3:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  80042082ba:	00 00 00 
  80042082bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082c2:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042082c9:	00 00 00 
  80042082cc:	41 ff d0             	callq  *%r8
  80042082cf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042082d6:	00 00 00 
  80042082d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082dd:	48 01 d0             	add    %rdx,%rax
  80042082e0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  80042082e4:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042082e9:	75 07                	jne    80042082f2 <env_free+0x1ab>
  80042082eb:	b8 04 00 00 00       	mov    $0x4,%eax
  80042082f0:	eb 05                	jmp    80042082f7 <env_free+0x1b0>
  80042082f2:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  80042082f7:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042082fa:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208301:	00 
  8004208302:	e9 6e 01 00 00       	jmpq   8004208475 <env_free+0x32e>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208307:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420830b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208312:	00 
  8004208313:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208317:	48 01 d0             	add    %rdx,%rax
  800420831a:	48 8b 00             	mov    (%rax),%rax
  800420831d:	83 e0 01             	and    $0x1,%eax
  8004208320:	48 85 c0             	test   %rax,%rax
  8004208323:	75 05                	jne    800420832a <env_free+0x1e3>
				continue;
  8004208325:	e9 46 01 00 00       	jmpq   8004208470 <env_free+0x329>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  800420832a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420832e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208335:	00 
  8004208336:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420833a:	48 01 d0             	add    %rdx,%rax
  800420833d:	48 8b 00             	mov    (%rax),%rax
  8004208340:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208346:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  800420834a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420834e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208352:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208356:	48 c1 e8 0c          	shr    $0xc,%rax
  800420835a:	89 45 9c             	mov    %eax,-0x64(%rbp)
  800420835d:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208360:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004208367:	00 00 00 
  800420836a:	48 8b 00             	mov    (%rax),%rax
  800420836d:	48 39 c2             	cmp    %rax,%rdx
  8004208370:	72 32                	jb     80042083a4 <env_free+0x25d>
  8004208372:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208376:	48 89 c1             	mov    %rax,%rcx
  8004208379:	48 ba 70 97 21 04 80 	movabs $0x8004219770,%rdx
  8004208380:	00 00 00 
  8004208383:	be f9 01 00 00       	mov    $0x1f9,%esi
  8004208388:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  800420838f:	00 00 00 
  8004208392:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208397:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420839e:	00 00 00 
  80042083a1:	41 ff d0             	callq  *%r8
  80042083a4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042083ab:	00 00 00 
  80042083ae:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042083b2:	48 01 d0             	add    %rdx,%rax
  80042083b5:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042083b9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042083c0:	00 
  80042083c1:	eb 67                	jmp    800420842a <env_free+0x2e3>
				if (pt[pteno] & PTE_P){
  80042083c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083c7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042083ce:	00 
  80042083cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042083d3:	48 01 d0             	add    %rdx,%rax
  80042083d6:	48 8b 00             	mov    (%rax),%rax
  80042083d9:	83 e0 01             	and    $0x1,%eax
  80042083dc:	48 85 c0             	test   %rax,%rax
  80042083df:	74 44                	je     8004208425 <env_free+0x2de>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  80042083e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083e5:	48 c1 e0 1e          	shl    $0x1e,%rax
  80042083e9:	48 89 c2             	mov    %rax,%rdx
  80042083ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083f0:	48 c1 e0 15          	shl    $0x15,%rax
  80042083f4:	48 09 c2             	or     %rax,%rdx
  80042083f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083fb:	48 c1 e0 0c          	shl    $0xc,%rax
  80042083ff:	48 09 d0             	or     %rdx,%rax
  8004208402:	48 89 c2             	mov    %rax,%rdx
  8004208405:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420840c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208413:	48 89 d6             	mov    %rdx,%rsi
  8004208416:	48 89 c7             	mov    %rax,%rdi
  8004208419:	48 b8 d1 39 20 04 80 	movabs $0x80042039d1,%rax
  8004208420:	00 00 00 
  8004208423:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208425:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  800420842a:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208431:	00 
  8004208432:	76 8f                	jbe    80042083c3 <env_free+0x27c>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208434:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208438:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420843f:	00 
  8004208440:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208444:	48 01 d0             	add    %rdx,%rax
  8004208447:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  800420844e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208452:	48 89 c7             	mov    %rax,%rdi
  8004208455:	48 b8 62 77 20 04 80 	movabs $0x8004207762,%rax
  800420845c:	00 00 00 
  800420845f:	ff d0                	callq  *%rax
  8004208461:	48 89 c7             	mov    %rax,%rdi
  8004208464:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  800420846b:	00 00 00 
  800420846e:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208470:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208475:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208478:	48 98                	cltq   
  800420847a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420847e:	0f 87 83 fe ff ff    	ja     8004208307 <env_free+0x1c0>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208484:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208488:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420848f:	00 
  8004208490:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208494:	48 01 d0             	add    %rdx,%rax
  8004208497:	48 8b 00             	mov    (%rax),%rax
  800420849a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042084a0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  80042084a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042084a8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042084af:	00 
  80042084b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042084b4:	48 01 d0             	add    %rdx,%rax
  80042084b7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042084be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042084c2:	48 89 c7             	mov    %rax,%rdi
  80042084c5:	48 b8 62 77 20 04 80 	movabs $0x8004207762,%rax
  80042084cc:	00 00 00 
  80042084cf:	ff d0                	callq  *%rax
  80042084d1:	48 89 c7             	mov    %rax,%rdi
  80042084d4:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  80042084db:	00 00 00 
  80042084de:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042084e0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042084e5:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042084ea:	0f 86 4a fd ff ff    	jbe    800420823a <env_free+0xf3>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  80042084f0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042084f7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042084fe:	48 8b 00             	mov    (%rax),%rax
  8004208501:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208507:	48 89 c7             	mov    %rax,%rdi
  800420850a:	48 b8 62 77 20 04 80 	movabs $0x8004207762,%rax
  8004208511:	00 00 00 
  8004208514:	ff d0                	callq  *%rax
  8004208516:	48 89 c7             	mov    %rax,%rdi
  8004208519:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  8004208520:	00 00 00 
  8004208523:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208525:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420852c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208533:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  800420853a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208541:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208548:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  800420854c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208553:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  800420855a:	00 00 00 00 
	e->env_cr3 = 0;
  800420855e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208565:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  800420856c:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208570:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208574:	48 89 c7             	mov    %rax,%rdi
  8004208577:	48 b8 62 77 20 04 80 	movabs $0x8004207762,%rax
  800420857e:	00 00 00 
  8004208581:	ff d0                	callq  *%rax
  8004208583:	48 89 c7             	mov    %rax,%rdi
  8004208586:	48 b8 02 31 20 04 80 	movabs $0x8004203102,%rax
  800420858d:	00 00 00 
  8004208590:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208592:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208599:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042085a0:	00 00 00 
	e->env_link = env_free_list;
  80042085a3:	48 b8 58 a2 60 04 80 	movabs $0x800460a258,%rax
  80042085aa:	00 00 00 
  80042085ad:	48 8b 10             	mov    (%rax),%rdx
  80042085b0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042085b7:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042085be:	48 b8 58 a2 60 04 80 	movabs $0x800460a258,%rax
  80042085c5:	00 00 00 
  80042085c8:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042085cf:	48 89 10             	mov    %rdx,(%rax)
}
  80042085d2:	c9                   	leaveq 
  80042085d3:	c3                   	retq   

00000080042085d4 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  80042085d4:	55                   	push   %rbp
  80042085d5:	48 89 e5             	mov    %rsp,%rbp
  80042085d8:	48 83 ec 10          	sub    $0x10,%rsp
  80042085dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042085e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042085e4:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042085ea:	83 f8 03             	cmp    $0x3,%eax
  80042085ed:	75 4a                	jne    8004208639 <env_destroy+0x65>
  80042085ef:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042085f6:	00 00 00 
  80042085f9:	ff d0                	callq  *%rax
  80042085fb:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208602:	00 00 00 
  8004208605:	48 98                	cltq   
  8004208607:	48 c1 e0 03          	shl    $0x3,%rax
  800420860b:	48 89 c2             	mov    %rax,%rdx
  800420860e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208612:	48 29 c2             	sub    %rax,%rdx
  8004208615:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208619:	48 83 c0 08          	add    $0x8,%rax
  800420861d:	48 8b 00             	mov    (%rax),%rax
  8004208620:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208624:	74 13                	je     8004208639 <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208626:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420862a:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208631:	00 00 00 
		return;
  8004208634:	e9 8b 00 00 00       	jmpq   80042086c4 <env_destroy+0xf0>
	}

	env_free(e);
  8004208639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420863d:	48 89 c7             	mov    %rax,%rdi
  8004208640:	48 b8 47 81 20 04 80 	movabs $0x8004208147,%rax
  8004208647:	00 00 00 
  800420864a:	ff d0                	callq  *%rax
	if (curenv == e) {
  800420864c:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004208653:	00 00 00 
  8004208656:	ff d0                	callq  *%rax
  8004208658:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420865f:	00 00 00 
  8004208662:	48 98                	cltq   
  8004208664:	48 c1 e0 03          	shl    $0x3,%rax
  8004208668:	48 89 c2             	mov    %rax,%rdx
  800420866b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420866f:	48 29 c2             	sub    %rax,%rdx
  8004208672:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208676:	48 83 c0 08          	add    $0x8,%rax
  800420867a:	48 8b 00             	mov    (%rax),%rax
  800420867d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208681:	75 41                	jne    80042086c4 <env_destroy+0xf0>
		curenv = NULL;
  8004208683:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420868a:	00 00 00 
  800420868d:	ff d0                	callq  *%rax
  800420868f:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208696:	00 00 00 
  8004208699:	48 98                	cltq   
  800420869b:	48 c1 e0 03          	shl    $0x3,%rax
  800420869f:	48 89 c2             	mov    %rax,%rdx
  80042086a2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086a6:	48 29 c2             	sub    %rax,%rdx
  80042086a9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086ad:	48 83 c0 08          	add    $0x8,%rax
  80042086b1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  80042086b8:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  80042086bf:	00 00 00 
  80042086c2:	ff d0                	callq  *%rax
	}
}
  80042086c4:	c9                   	leaveq 
  80042086c5:	c3                   	retq   

00000080042086c6 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042086c6:	55                   	push   %rbp
  80042086c7:	48 89 e5             	mov    %rsp,%rbp
  80042086ca:	53                   	push   %rbx
  80042086cb:	48 83 ec 18          	sub    $0x18,%rsp
  80042086cf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042086d3:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042086da:	00 00 00 
  80042086dd:	ff d0                	callq  *%rax
  80042086df:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042086e6:	00 00 00 
  80042086e9:	48 98                	cltq   
  80042086eb:	48 c1 e0 03          	shl    $0x3,%rax
  80042086ef:	48 89 c2             	mov    %rax,%rdx
  80042086f2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086f6:	48 29 c2             	sub    %rax,%rdx
  80042086f9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086fd:	48 83 c0 08          	add    $0x8,%rax
  8004208701:	48 8b 18             	mov    (%rax),%rbx
  8004208704:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420870b:	00 00 00 
  800420870e:	ff d0                	callq  *%rax
  8004208710:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("tf->rsp [%x]\n", tf->tf_rsp);
	__asm __volatile("movq %0,%%rsp\n"
  8004208716:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  800420871a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420871e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208723:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208728:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420872d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208732:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208737:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420873c:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208741:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208746:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420874b:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208750:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208755:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420875a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420875f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208764:	48 83 c4 78          	add    $0x78,%rsp
  8004208768:	8e 04 24             	mov    (%rsp),%es
  800420876b:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  800420876f:	48 83 c4 10          	add    $0x10,%rsp
  8004208773:	48 83 c4 10          	add    $0x10,%rsp
  8004208777:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208779:	48 ba 11 98 21 04 80 	movabs $0x8004219811,%rdx
  8004208780:	00 00 00 
  8004208783:	be 47 02 00 00       	mov    $0x247,%esi
  8004208788:	48 bf a4 97 21 04 80 	movabs $0x80042197a4,%rdi
  800420878f:	00 00 00 
  8004208792:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208797:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  800420879e:	00 00 00 
  80042087a1:	ff d1                	callq  *%rcx

00000080042087a3 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  80042087a3:	55                   	push   %rbp
  80042087a4:	48 89 e5             	mov    %rsp,%rbp
  80042087a7:	48 83 ec 20          	sub    $0x20,%rsp
  80042087ab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	//cprintf("ENV_RUN being called from here: e->env_id [%d]",e->env_id); 
	if(curenv == e){
  80042087af:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042087b6:	00 00 00 
  80042087b9:	ff d0                	callq  *%rax
  80042087bb:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042087c2:	00 00 00 
  80042087c5:	48 98                	cltq   
  80042087c7:	48 c1 e0 03          	shl    $0x3,%rax
  80042087cb:	48 89 c2             	mov    %rax,%rdx
  80042087ce:	48 c1 e2 04          	shl    $0x4,%rdx
  80042087d2:	48 29 c2             	sub    %rax,%rdx
  80042087d5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042087d9:	48 83 c0 08          	add    $0x8,%rax
  80042087dd:	48 8b 00             	mov    (%rax),%rax
  80042087e0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042087e4:	0f 85 8c 00 00 00    	jne    8004208876 <env_run+0xd3>
		curenv->env_runs += 1;
  80042087ea:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042087f1:	00 00 00 
  80042087f4:	ff d0                	callq  *%rax
  80042087f6:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042087fd:	00 00 00 
  8004208800:	48 98                	cltq   
  8004208802:	48 c1 e0 03          	shl    $0x3,%rax
  8004208806:	48 89 c2             	mov    %rax,%rdx
  8004208809:	48 c1 e2 04          	shl    $0x4,%rdx
  800420880d:	48 29 c2             	sub    %rax,%rdx
  8004208810:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208814:	48 83 c0 08          	add    $0x8,%rax
  8004208818:	48 8b 00             	mov    (%rax),%rax
  800420881b:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208821:	83 c2 01             	add    $0x1,%edx
  8004208824:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		unlock_kernel();
  800420882a:	48 b8 5b 78 20 04 80 	movabs $0x800420785b,%rax
  8004208831:	00 00 00 
  8004208834:	ff d0                	callq  *%rax
		env_pop_tf(&curenv->env_tf);
  8004208836:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420883d:	00 00 00 
  8004208840:	ff d0                	callq  *%rax
  8004208842:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208849:	00 00 00 
  800420884c:	48 98                	cltq   
  800420884e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208852:	48 89 c2             	mov    %rax,%rdx
  8004208855:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208859:	48 29 c2             	sub    %rax,%rdx
  800420885c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208860:	48 83 c0 08          	add    $0x8,%rax
  8004208864:	48 8b 00             	mov    (%rax),%rax
  8004208867:	48 89 c7             	mov    %rax,%rdi
  800420886a:	48 b8 c6 86 20 04 80 	movabs $0x80042086c6,%rax
  8004208871:	00 00 00 
  8004208874:	ff d0                	callq  *%rax
	}
	if(curenv) //If this is a context switch
  8004208876:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420887d:	00 00 00 
  8004208880:	ff d0                	callq  *%rax
  8004208882:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208889:	00 00 00 
  800420888c:	48 98                	cltq   
  800420888e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208892:	48 89 c2             	mov    %rax,%rdx
  8004208895:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208899:	48 29 c2             	sub    %rax,%rdx
  800420889c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088a0:	48 83 c0 08          	add    $0x8,%rax
  80042088a4:	48 8b 00             	mov    (%rax),%rax
  80042088a7:	48 85 c0             	test   %rax,%rax
  80042088aa:	74 77                	je     8004208923 <env_run+0x180>
	{
		if(curenv->env_status == ENV_RUNNING)
  80042088ac:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042088b3:	00 00 00 
  80042088b6:	ff d0                	callq  *%rax
  80042088b8:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042088bf:	00 00 00 
  80042088c2:	48 98                	cltq   
  80042088c4:	48 c1 e0 03          	shl    $0x3,%rax
  80042088c8:	48 89 c2             	mov    %rax,%rdx
  80042088cb:	48 c1 e2 04          	shl    $0x4,%rdx
  80042088cf:	48 29 c2             	sub    %rax,%rdx
  80042088d2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088d6:	48 83 c0 08          	add    $0x8,%rax
  80042088da:	48 8b 00             	mov    (%rax),%rax
  80042088dd:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042088e3:	83 f8 03             	cmp    $0x3,%eax
  80042088e6:	75 3b                	jne    8004208923 <env_run+0x180>
		{
			curenv->env_status = ENV_RUNNABLE;	
  80042088e8:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042088ef:	00 00 00 
  80042088f2:	ff d0                	callq  *%rax
  80042088f4:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042088fb:	00 00 00 
  80042088fe:	48 98                	cltq   
  8004208900:	48 c1 e0 03          	shl    $0x3,%rax
  8004208904:	48 89 c2             	mov    %rax,%rdx
  8004208907:	48 c1 e2 04          	shl    $0x4,%rdx
  800420890b:	48 29 c2             	sub    %rax,%rdx
  800420890e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208912:	48 83 c0 08          	add    $0x8,%rax
  8004208916:	48 8b 00             	mov    (%rax),%rax
  8004208919:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208920:	00 00 00 
		}
	}
	//make new enviornment as current enviornment
	
	curenv = e;
  8004208923:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420892a:	00 00 00 
  800420892d:	ff d0                	callq  *%rax
  800420892f:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208936:	00 00 00 
  8004208939:	48 98                	cltq   
  800420893b:	48 c1 e0 03          	shl    $0x3,%rax
  800420893f:	48 89 c2             	mov    %rax,%rdx
  8004208942:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208946:	48 29 c2             	sub    %rax,%rdx
  8004208949:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420894d:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208955:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208958:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420895f:	00 00 00 
  8004208962:	ff d0                	callq  *%rax
  8004208964:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420896b:	00 00 00 
  800420896e:	48 98                	cltq   
  8004208970:	48 c1 e0 03          	shl    $0x3,%rax
  8004208974:	48 89 c2             	mov    %rax,%rdx
  8004208977:	48 c1 e2 04          	shl    $0x4,%rdx
  800420897b:	48 29 c2             	sub    %rax,%rdx
  800420897e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208982:	48 83 c0 08          	add    $0x8,%rax
  8004208986:	48 8b 00             	mov    (%rax),%rax
  8004208989:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004208990:	00 00 00 
	curenv->env_runs += 1;
  8004208993:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420899a:	00 00 00 
  800420899d:	ff d0                	callq  *%rax
  800420899f:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042089a6:	00 00 00 
  80042089a9:	48 98                	cltq   
  80042089ab:	48 c1 e0 03          	shl    $0x3,%rax
  80042089af:	48 89 c2             	mov    %rax,%rdx
  80042089b2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042089b6:	48 29 c2             	sub    %rax,%rdx
  80042089b9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089bd:	48 83 c0 08          	add    $0x8,%rax
  80042089c1:	48 8b 00             	mov    (%rax),%rax
  80042089c4:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042089ca:	83 c2 01             	add    $0x1,%edx
  80042089cd:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  80042089d3:	48 b8 5b 78 20 04 80 	movabs $0x800420785b,%rax
  80042089da:	00 00 00 
  80042089dd:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  80042089df:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042089e6:	00 00 00 
  80042089e9:	ff d0                	callq  *%rax
  80042089eb:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  80042089f2:	00 00 00 
  80042089f5:	48 98                	cltq   
  80042089f7:	48 c1 e0 03          	shl    $0x3,%rax
  80042089fb:	48 89 c2             	mov    %rax,%rdx
  80042089fe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a02:	48 29 c2             	sub    %rax,%rdx
  8004208a05:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a09:	48 83 c0 08          	add    $0x8,%rax
  8004208a0d:	48 8b 00             	mov    (%rax),%rax
  8004208a10:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208a17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208a1f:	0f 22 d8             	mov    %rax,%cr3
	//restore the environment's registers
	//if(curenv->env_runs > 0)
	{
		env_pop_tf(&curenv->env_tf);
  8004208a22:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004208a29:	00 00 00 
  8004208a2c:	ff d0                	callq  *%rax
  8004208a2e:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  8004208a35:	00 00 00 
  8004208a38:	48 98                	cltq   
  8004208a3a:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a3e:	48 89 c2             	mov    %rax,%rdx
  8004208a41:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a45:	48 29 c2             	sub    %rax,%rdx
  8004208a48:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a4c:	48 83 c0 08          	add    $0x8,%rax
  8004208a50:	48 8b 00             	mov    (%rax),%rax
  8004208a53:	48 89 c7             	mov    %rax,%rdi
  8004208a56:	48 b8 c6 86 20 04 80 	movabs $0x80042086c6,%rax
  8004208a5d:	00 00 00 
  8004208a60:	ff d0                	callq  *%rax

0000008004208a62 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208a62:	55                   	push   %rbp
  8004208a63:	48 89 e5             	mov    %rsp,%rbp
  8004208a66:	48 83 ec 14          	sub    $0x14,%rsp
  8004208a6a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208a6d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a70:	0f b6 c0             	movzbl %al,%eax
  8004208a73:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208a7a:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208a7d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208a81:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208a84:	ee                   	out    %al,(%dx)
  8004208a85:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208a8c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208a8f:	89 c2                	mov    %eax,%edx
  8004208a91:	ec                   	in     (%dx),%al
  8004208a92:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004208a95:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208a99:	0f b6 c0             	movzbl %al,%eax
}
  8004208a9c:	c9                   	leaveq 
  8004208a9d:	c3                   	retq   

0000008004208a9e <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208a9e:	55                   	push   %rbp
  8004208a9f:	48 89 e5             	mov    %rsp,%rbp
  8004208aa2:	48 83 ec 18          	sub    $0x18,%rsp
  8004208aa6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208aa9:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208aac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208aaf:	0f b6 c0             	movzbl %al,%eax
  8004208ab2:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208ab9:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208abc:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208ac0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208ac3:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208ac4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208ac7:	0f b6 c0             	movzbl %al,%eax
  8004208aca:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208ad1:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208ad4:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208ad8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208adb:	ee                   	out    %al,(%dx)
}
  8004208adc:	c9                   	leaveq 
  8004208add:	c3                   	retq   

0000008004208ade <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208ade:	55                   	push   %rbp
  8004208adf:	48 89 e5             	mov    %rsp,%rbp
  8004208ae2:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208ae6:	48 b8 60 a2 60 04 80 	movabs $0x800460a260,%rax
  8004208aed:	00 00 00 
  8004208af0:	c6 00 01             	movb   $0x1,(%rax)
  8004208af3:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208afa:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208afe:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208b02:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208b05:	ee                   	out    %al,(%dx)
  8004208b06:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208b0d:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208b11:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208b15:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208b18:	ee                   	out    %al,(%dx)
  8004208b19:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208b20:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208b24:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208b28:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208b2b:	ee                   	out    %al,(%dx)
  8004208b2c:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208b33:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208b37:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208b3b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208b3e:	ee                   	out    %al,(%dx)
  8004208b3f:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208b46:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208b4a:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208b4e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208b51:	ee                   	out    %al,(%dx)
  8004208b52:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208b59:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208b5d:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208b61:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208b64:	ee                   	out    %al,(%dx)
  8004208b65:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208b6c:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208b70:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208b74:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208b77:	ee                   	out    %al,(%dx)
  8004208b78:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208b7f:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208b83:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208b87:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208b8a:	ee                   	out    %al,(%dx)
  8004208b8b:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208b92:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208b96:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208b9a:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208b9d:	ee                   	out    %al,(%dx)
  8004208b9e:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208ba5:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208ba9:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208bad:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208bb0:	ee                   	out    %al,(%dx)
  8004208bb1:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208bb8:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208bbc:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004208bc0:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004208bc3:	ee                   	out    %al,(%dx)
  8004208bc4:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208bcb:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004208bcf:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004208bd3:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208bd6:	ee                   	out    %al,(%dx)
  8004208bd7:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004208bde:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004208be2:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208be6:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208be9:	ee                   	out    %al,(%dx)
  8004208bea:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208bf1:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208bf5:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208bf9:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208bfc:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208bfd:	48 b8 92 e6 22 04 80 	movabs $0x800422e692,%rax
  8004208c04:	00 00 00 
  8004208c07:	0f b7 00             	movzwl (%rax),%eax
  8004208c0a:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208c0e:	74 1e                	je     8004208c2e <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208c10:	48 b8 92 e6 22 04 80 	movabs $0x800422e692,%rax
  8004208c17:	00 00 00 
  8004208c1a:	0f b7 00             	movzwl (%rax),%eax
  8004208c1d:	0f b7 c0             	movzwl %ax,%eax
  8004208c20:	89 c7                	mov    %eax,%edi
  8004208c22:	48 b8 30 8c 20 04 80 	movabs $0x8004208c30,%rax
  8004208c29:	00 00 00 
  8004208c2c:	ff d0                	callq  *%rax
}
  8004208c2e:	c9                   	leaveq 
  8004208c2f:	c3                   	retq   

0000008004208c30 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208c30:	55                   	push   %rbp
  8004208c31:	48 89 e5             	mov    %rsp,%rbp
  8004208c34:	48 83 ec 30          	sub    $0x30,%rsp
  8004208c38:	89 f8                	mov    %edi,%eax
  8004208c3a:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208c3e:	48 b8 92 e6 22 04 80 	movabs $0x800422e692,%rax
  8004208c45:	00 00 00 
  8004208c48:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208c4c:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208c4f:	48 b8 60 a2 60 04 80 	movabs $0x800460a260,%rax
  8004208c56:	00 00 00 
  8004208c59:	0f b6 00             	movzbl (%rax),%eax
  8004208c5c:	83 f0 01             	xor    $0x1,%eax
  8004208c5f:	84 c0                	test   %al,%al
  8004208c61:	74 05                	je     8004208c68 <irq_setmask_8259A+0x38>
		return;
  8004208c63:	e9 b7 00 00 00       	jmpq   8004208d1f <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004208c68:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c6c:	0f b6 c0             	movzbl %al,%eax
  8004208c6f:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208c76:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208c79:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208c7d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208c80:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208c81:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c85:	66 c1 e8 08          	shr    $0x8,%ax
  8004208c89:	0f b6 c0             	movzbl %al,%eax
  8004208c8c:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004208c93:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004208c96:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004208c9a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208c9d:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208c9e:	48 bf 1d 98 21 04 80 	movabs $0x800421981d,%rdi
  8004208ca5:	00 00 00 
  8004208ca8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cad:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004208cb4:	00 00 00 
  8004208cb7:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208cb9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208cc0:	eb 3c                	jmp    8004208cfe <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004208cc2:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208cc6:	f7 d0                	not    %eax
  8004208cc8:	89 c2                	mov    %eax,%edx
  8004208cca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208ccd:	89 c1                	mov    %eax,%ecx
  8004208ccf:	d3 fa                	sar    %cl,%edx
  8004208cd1:	89 d0                	mov    %edx,%eax
  8004208cd3:	83 e0 01             	and    $0x1,%eax
  8004208cd6:	85 c0                	test   %eax,%eax
  8004208cd8:	74 20                	je     8004208cfa <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004208cda:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208cdd:	89 c6                	mov    %eax,%esi
  8004208cdf:	48 bf 31 98 21 04 80 	movabs $0x8004219831,%rdi
  8004208ce6:	00 00 00 
  8004208ce9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cee:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004208cf5:	00 00 00 
  8004208cf8:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208cfa:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208cfe:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208d02:	7e be                	jle    8004208cc2 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208d04:	48 bf 35 98 21 04 80 	movabs $0x8004219835,%rdi
  8004208d0b:	00 00 00 
  8004208d0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d13:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004208d1a:	00 00 00 
  8004208d1d:	ff d2                	callq  *%rdx
}
  8004208d1f:	c9                   	leaveq 
  8004208d20:	c3                   	retq   

0000008004208d21 <irq_eoi>:

void
irq_eoi(void)
{
  8004208d21:	55                   	push   %rbp
  8004208d22:	48 89 e5             	mov    %rsp,%rbp
  8004208d25:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d29:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004208d30:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  8004208d34:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208d38:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208d3b:	ee                   	out    %al,(%dx)
  8004208d3c:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  8004208d43:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  8004208d47:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208d4b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208d4e:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004208d4f:	c9                   	leaveq 
  8004208d50:	c3                   	retq   

0000008004208d51 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208d51:	55                   	push   %rbp
  8004208d52:	48 89 e5             	mov    %rsp,%rbp
  8004208d55:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d59:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208d5c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208d60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d63:	89 c7                	mov    %eax,%edi
  8004208d65:	48 b8 68 12 20 04 80 	movabs $0x8004201268,%rax
  8004208d6c:	00 00 00 
  8004208d6f:	ff d0                	callq  *%rax
	*cnt++;
  8004208d71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208d75:	48 83 c0 04          	add    $0x4,%rax
  8004208d79:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208d7d:	c9                   	leaveq 
  8004208d7e:	c3                   	retq   

0000008004208d7f <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208d7f:	55                   	push   %rbp
  8004208d80:	48 89 e5             	mov    %rsp,%rbp
  8004208d83:	48 83 ec 30          	sub    $0x30,%rsp
  8004208d87:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208d8b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208d8f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208d96:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208d9a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208d9e:	48 8b 0a             	mov    (%rdx),%rcx
  8004208da1:	48 89 08             	mov    %rcx,(%rax)
  8004208da4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208da8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208dac:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208db0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208db4:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208db8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208dbc:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208dc0:	48 89 c6             	mov    %rax,%rsi
  8004208dc3:	48 bf 51 8d 20 04 80 	movabs $0x8004208d51,%rdi
  8004208dca:	00 00 00 
  8004208dcd:	48 b8 65 ee 20 04 80 	movabs $0x800420ee65,%rax
  8004208dd4:	00 00 00 
  8004208dd7:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004208dd9:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208ddc:	c9                   	leaveq 
  8004208ddd:	c3                   	retq   

0000008004208dde <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208dde:	55                   	push   %rbp
  8004208ddf:	48 89 e5             	mov    %rsp,%rbp
  8004208de2:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208de9:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208df0:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208df7:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208dfe:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208e05:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208e0c:	84 c0                	test   %al,%al
  8004208e0e:	74 20                	je     8004208e30 <cprintf+0x52>
  8004208e10:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208e14:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208e18:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208e1c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208e20:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208e24:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208e28:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208e2c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208e30:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208e37:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208e3e:	00 00 00 
  8004208e41:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208e48:	00 00 00 
  8004208e4b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208e4f:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208e56:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208e5d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208e64:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208e6b:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208e72:	48 8b 0a             	mov    (%rdx),%rcx
  8004208e75:	48 89 08             	mov    %rcx,(%rax)
  8004208e78:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208e7c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208e80:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208e84:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208e88:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208e8f:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208e96:	48 89 d6             	mov    %rdx,%rsi
  8004208e99:	48 89 c7             	mov    %rax,%rdi
  8004208e9c:	48 b8 7f 8d 20 04 80 	movabs $0x8004208d7f,%rax
  8004208ea3:	00 00 00 
  8004208ea6:	ff d0                	callq  *%rax
  8004208ea8:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208eae:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208eb4:	c9                   	leaveq 
  8004208eb5:	c3                   	retq   

0000008004208eb6 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208eb6:	55                   	push   %rbp
  8004208eb7:	48 89 e5             	mov    %rsp,%rbp
  8004208eba:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004208ebe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208ec2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208ec5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208ec9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208ecc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004208ed0:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208ed3:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004208ed6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004208ed9:	c9                   	leaveq 
  8004208eda:	c3                   	retq   

0000008004208edb <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208edb:	55                   	push   %rbp
  8004208edc:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208edf:	48 bf 80 e7 22 04 80 	movabs $0x800422e780,%rdi
  8004208ee6:	00 00 00 
  8004208ee9:	48 b8 7c 6d 21 04 80 	movabs $0x8004216d7c,%rax
  8004208ef0:	00 00 00 
  8004208ef3:	ff d0                	callq  *%rax
}
  8004208ef5:	5d                   	pop    %rbp
  8004208ef6:	c3                   	retq   

0000008004208ef7 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208ef7:	55                   	push   %rbp
  8004208ef8:	48 89 e5             	mov    %rsp,%rbp
  8004208efb:	48 83 ec 04          	sub    $0x4,%rsp
  8004208eff:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208f02:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208f05:	83 f8 13             	cmp    $0x13,%eax
  8004208f08:	77 16                	ja     8004208f20 <trapname+0x29>
		return excnames[trapno];
  8004208f0a:	48 b8 80 9c 21 04 80 	movabs $0x8004219c80,%rax
  8004208f11:	00 00 00 
  8004208f14:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208f17:	48 63 d2             	movslq %edx,%rdx
  8004208f1a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208f1e:	eb 34                	jmp    8004208f54 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208f20:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208f24:	75 0c                	jne    8004208f32 <trapname+0x3b>
		return "System call";
  8004208f26:	48 b8 40 98 21 04 80 	movabs $0x8004219840,%rax
  8004208f2d:	00 00 00 
  8004208f30:	eb 22                	jmp    8004208f54 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208f32:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208f36:	7e 12                	jle    8004208f4a <trapname+0x53>
  8004208f38:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208f3c:	7f 0c                	jg     8004208f4a <trapname+0x53>
		return "Hardware Interrupt";
  8004208f3e:	48 b8 4c 98 21 04 80 	movabs $0x800421984c,%rax
  8004208f45:	00 00 00 
  8004208f48:	eb 0a                	jmp    8004208f54 <trapname+0x5d>
	return "(unknown trap)";
  8004208f4a:	48 b8 5f 98 21 04 80 	movabs $0x800421985f,%rax
  8004208f51:	00 00 00 
}
  8004208f54:	c9                   	leaveq 
  8004208f55:	c3                   	retq   

0000008004208f56 <trap_init>:


void
trap_init(void)
{
  8004208f56:	55                   	push   %rbp
  8004208f57:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
    SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRPX_divzero, 0);  
  8004208f5a:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  8004208f61:	00 00 00 
  8004208f64:	89 c2                	mov    %eax,%edx
  8004208f66:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208f6d:	00 00 00 
  8004208f70:	66 89 10             	mov    %dx,(%rax)
  8004208f73:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208f7a:	00 00 00 
  8004208f7d:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208f83:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208f8a:	00 00 00 
  8004208f8d:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208f91:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f94:	88 50 04             	mov    %dl,0x4(%rax)
  8004208f97:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208f9e:	00 00 00 
  8004208fa1:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208fa5:	83 e2 07             	and    $0x7,%edx
  8004208fa8:	88 50 04             	mov    %dl,0x4(%rax)
  8004208fab:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208fb2:	00 00 00 
  8004208fb5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fb9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208fbc:	83 ca 0e             	or     $0xe,%edx
  8004208fbf:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fc2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208fc9:	00 00 00 
  8004208fcc:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fd0:	83 e2 ef             	and    $0xffffffef,%edx
  8004208fd3:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fd6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208fdd:	00 00 00 
  8004208fe0:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fe4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208fe7:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fea:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004208ff1:	00 00 00 
  8004208ff4:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208ff8:	83 ca 80             	or     $0xffffff80,%edx
  8004208ffb:	88 50 05             	mov    %dl,0x5(%rax)
  8004208ffe:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  8004209005:	00 00 00 
  8004209008:	48 c1 e8 10          	shr    $0x10,%rax
  800420900c:	89 c2                	mov    %eax,%edx
  800420900e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209015:	00 00 00 
  8004209018:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420901c:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  8004209023:	00 00 00 
  8004209026:	48 c1 e8 20          	shr    $0x20,%rax
  800420902a:	89 c2                	mov    %eax,%edx
  800420902c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209033:	00 00 00 
  8004209036:	89 50 08             	mov    %edx,0x8(%rax)
  8004209039:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209040:	00 00 00 
  8004209043:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG], 0, GD_KT, XTRPX_Debug, 0);  
  800420904a:	48 b8 d0 cc 20 04 80 	movabs $0x800420ccd0,%rax
  8004209051:	00 00 00 
  8004209054:	89 c2                	mov    %eax,%edx
  8004209056:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420905d:	00 00 00 
  8004209060:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004209064:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420906b:	00 00 00 
  800420906e:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004209074:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420907b:	00 00 00 
  800420907e:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209082:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209085:	88 50 14             	mov    %dl,0x14(%rax)
  8004209088:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420908f:	00 00 00 
  8004209092:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209096:	83 e2 07             	and    $0x7,%edx
  8004209099:	88 50 14             	mov    %dl,0x14(%rax)
  800420909c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042090a3:	00 00 00 
  80042090a6:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090aa:	83 e2 f0             	and    $0xfffffff0,%edx
  80042090ad:	83 ca 0e             	or     $0xe,%edx
  80042090b0:	88 50 15             	mov    %dl,0x15(%rax)
  80042090b3:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042090ba:	00 00 00 
  80042090bd:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090c1:	83 e2 ef             	and    $0xffffffef,%edx
  80042090c4:	88 50 15             	mov    %dl,0x15(%rax)
  80042090c7:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042090ce:	00 00 00 
  80042090d1:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090d5:	83 e2 9f             	and    $0xffffff9f,%edx
  80042090d8:	88 50 15             	mov    %dl,0x15(%rax)
  80042090db:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042090e2:	00 00 00 
  80042090e5:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090e9:	83 ca 80             	or     $0xffffff80,%edx
  80042090ec:	88 50 15             	mov    %dl,0x15(%rax)
  80042090ef:	48 b8 d0 cc 20 04 80 	movabs $0x800420ccd0,%rax
  80042090f6:	00 00 00 
  80042090f9:	48 c1 e8 10          	shr    $0x10,%rax
  80042090fd:	89 c2                	mov    %eax,%edx
  80042090ff:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209106:	00 00 00 
  8004209109:	66 89 50 16          	mov    %dx,0x16(%rax)
  800420910d:	48 b8 d0 cc 20 04 80 	movabs $0x800420ccd0,%rax
  8004209114:	00 00 00 
  8004209117:	48 c1 e8 20          	shr    $0x20,%rax
  800420911b:	89 c2                	mov    %eax,%edx
  800420911d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209124:	00 00 00 
  8004209127:	89 50 18             	mov    %edx,0x18(%rax)
  800420912a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209131:	00 00 00 
  8004209134:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI], 0, GD_KT, XTRPX_NonMaskI, 0);  
  800420913b:	48 b8 da cc 20 04 80 	movabs $0x800420ccda,%rax
  8004209142:	00 00 00 
  8004209145:	89 c2                	mov    %eax,%edx
  8004209147:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420914e:	00 00 00 
  8004209151:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209155:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420915c:	00 00 00 
  800420915f:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209165:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420916c:	00 00 00 
  800420916f:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209173:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209176:	88 50 24             	mov    %dl,0x24(%rax)
  8004209179:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209180:	00 00 00 
  8004209183:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209187:	83 e2 07             	and    $0x7,%edx
  800420918a:	88 50 24             	mov    %dl,0x24(%rax)
  800420918d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209194:	00 00 00 
  8004209197:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420919b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420919e:	83 ca 0e             	or     $0xe,%edx
  80042091a1:	88 50 25             	mov    %dl,0x25(%rax)
  80042091a4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042091ab:	00 00 00 
  80042091ae:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091b2:	83 e2 ef             	and    $0xffffffef,%edx
  80042091b5:	88 50 25             	mov    %dl,0x25(%rax)
  80042091b8:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042091bf:	00 00 00 
  80042091c2:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091c6:	83 e2 9f             	and    $0xffffff9f,%edx
  80042091c9:	88 50 25             	mov    %dl,0x25(%rax)
  80042091cc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042091d3:	00 00 00 
  80042091d6:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091da:	83 ca 80             	or     $0xffffff80,%edx
  80042091dd:	88 50 25             	mov    %dl,0x25(%rax)
  80042091e0:	48 b8 da cc 20 04 80 	movabs $0x800420ccda,%rax
  80042091e7:	00 00 00 
  80042091ea:	48 c1 e8 10          	shr    $0x10,%rax
  80042091ee:	89 c2                	mov    %eax,%edx
  80042091f0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042091f7:	00 00 00 
  80042091fa:	66 89 50 26          	mov    %dx,0x26(%rax)
  80042091fe:	48 b8 da cc 20 04 80 	movabs $0x800420ccda,%rax
  8004209205:	00 00 00 
  8004209208:	48 c1 e8 20          	shr    $0x20,%rax
  800420920c:	89 c2                	mov    %eax,%edx
  800420920e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209215:	00 00 00 
  8004209218:	89 50 28             	mov    %edx,0x28(%rax)
  800420921b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209222:	00 00 00 
  8004209225:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT], 0, GD_KT, XTRPX_Brkpt, 3);  
  800420922c:	48 b8 e4 cc 20 04 80 	movabs $0x800420cce4,%rax
  8004209233:	00 00 00 
  8004209236:	89 c2                	mov    %eax,%edx
  8004209238:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420923f:	00 00 00 
  8004209242:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209246:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420924d:	00 00 00 
  8004209250:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209256:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420925d:	00 00 00 
  8004209260:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209264:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209267:	88 50 34             	mov    %dl,0x34(%rax)
  800420926a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209271:	00 00 00 
  8004209274:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209278:	83 e2 07             	and    $0x7,%edx
  800420927b:	88 50 34             	mov    %dl,0x34(%rax)
  800420927e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209285:	00 00 00 
  8004209288:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420928c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420928f:	83 ca 0e             	or     $0xe,%edx
  8004209292:	88 50 35             	mov    %dl,0x35(%rax)
  8004209295:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420929c:	00 00 00 
  800420929f:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092a3:	83 e2 ef             	and    $0xffffffef,%edx
  80042092a6:	88 50 35             	mov    %dl,0x35(%rax)
  80042092a9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042092b0:	00 00 00 
  80042092b3:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092b7:	83 ca 60             	or     $0x60,%edx
  80042092ba:	88 50 35             	mov    %dl,0x35(%rax)
  80042092bd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042092c4:	00 00 00 
  80042092c7:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092cb:	83 ca 80             	or     $0xffffff80,%edx
  80042092ce:	88 50 35             	mov    %dl,0x35(%rax)
  80042092d1:	48 b8 e4 cc 20 04 80 	movabs $0x800420cce4,%rax
  80042092d8:	00 00 00 
  80042092db:	48 c1 e8 10          	shr    $0x10,%rax
  80042092df:	89 c2                	mov    %eax,%edx
  80042092e1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042092e8:	00 00 00 
  80042092eb:	66 89 50 36          	mov    %dx,0x36(%rax)
  80042092ef:	48 b8 e4 cc 20 04 80 	movabs $0x800420cce4,%rax
  80042092f6:	00 00 00 
  80042092f9:	48 c1 e8 20          	shr    $0x20,%rax
  80042092fd:	89 c2                	mov    %eax,%edx
  80042092ff:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209306:	00 00 00 
  8004209309:	89 50 38             	mov    %edx,0x38(%rax)
  800420930c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209313:	00 00 00 
  8004209316:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW], 0, GD_KT, XTRPX_OFlow, 0);  
  800420931d:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  8004209324:	00 00 00 
  8004209327:	89 c2                	mov    %eax,%edx
  8004209329:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209330:	00 00 00 
  8004209333:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004209337:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420933e:	00 00 00 
  8004209341:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209347:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420934e:	00 00 00 
  8004209351:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209355:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209358:	88 50 44             	mov    %dl,0x44(%rax)
  800420935b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209362:	00 00 00 
  8004209365:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209369:	83 e2 07             	and    $0x7,%edx
  800420936c:	88 50 44             	mov    %dl,0x44(%rax)
  800420936f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209376:	00 00 00 
  8004209379:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420937d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209380:	83 ca 0e             	or     $0xe,%edx
  8004209383:	88 50 45             	mov    %dl,0x45(%rax)
  8004209386:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420938d:	00 00 00 
  8004209390:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209394:	83 e2 ef             	and    $0xffffffef,%edx
  8004209397:	88 50 45             	mov    %dl,0x45(%rax)
  800420939a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042093a1:	00 00 00 
  80042093a4:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093a8:	83 e2 9f             	and    $0xffffff9f,%edx
  80042093ab:	88 50 45             	mov    %dl,0x45(%rax)
  80042093ae:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042093b5:	00 00 00 
  80042093b8:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093bc:	83 ca 80             	or     $0xffffff80,%edx
  80042093bf:	88 50 45             	mov    %dl,0x45(%rax)
  80042093c2:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  80042093c9:	00 00 00 
  80042093cc:	48 c1 e8 10          	shr    $0x10,%rax
  80042093d0:	89 c2                	mov    %eax,%edx
  80042093d2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042093d9:	00 00 00 
  80042093dc:	66 89 50 46          	mov    %dx,0x46(%rax)
  80042093e0:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  80042093e7:	00 00 00 
  80042093ea:	48 c1 e8 20          	shr    $0x20,%rax
  80042093ee:	89 c2                	mov    %eax,%edx
  80042093f0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042093f7:	00 00 00 
  80042093fa:	89 50 48             	mov    %edx,0x48(%rax)
  80042093fd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209404:	00 00 00 
  8004209407:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND], 0, GD_KT, XTRPX_Bound, 0);  
  800420940e:	48 b8 f8 cc 20 04 80 	movabs $0x800420ccf8,%rax
  8004209415:	00 00 00 
  8004209418:	89 c2                	mov    %eax,%edx
  800420941a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209421:	00 00 00 
  8004209424:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004209428:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420942f:	00 00 00 
  8004209432:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004209438:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420943f:	00 00 00 
  8004209442:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209446:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209449:	88 50 54             	mov    %dl,0x54(%rax)
  800420944c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209453:	00 00 00 
  8004209456:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420945a:	83 e2 07             	and    $0x7,%edx
  800420945d:	88 50 54             	mov    %dl,0x54(%rax)
  8004209460:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209467:	00 00 00 
  800420946a:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420946e:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209471:	83 ca 0e             	or     $0xe,%edx
  8004209474:	88 50 55             	mov    %dl,0x55(%rax)
  8004209477:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420947e:	00 00 00 
  8004209481:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209485:	83 e2 ef             	and    $0xffffffef,%edx
  8004209488:	88 50 55             	mov    %dl,0x55(%rax)
  800420948b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209492:	00 00 00 
  8004209495:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209499:	83 e2 9f             	and    $0xffffff9f,%edx
  800420949c:	88 50 55             	mov    %dl,0x55(%rax)
  800420949f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042094a6:	00 00 00 
  80042094a9:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042094ad:	83 ca 80             	or     $0xffffff80,%edx
  80042094b0:	88 50 55             	mov    %dl,0x55(%rax)
  80042094b3:	48 b8 f8 cc 20 04 80 	movabs $0x800420ccf8,%rax
  80042094ba:	00 00 00 
  80042094bd:	48 c1 e8 10          	shr    $0x10,%rax
  80042094c1:	89 c2                	mov    %eax,%edx
  80042094c3:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042094ca:	00 00 00 
  80042094cd:	66 89 50 56          	mov    %dx,0x56(%rax)
  80042094d1:	48 b8 f8 cc 20 04 80 	movabs $0x800420ccf8,%rax
  80042094d8:	00 00 00 
  80042094db:	48 c1 e8 20          	shr    $0x20,%rax
  80042094df:	89 c2                	mov    %eax,%edx
  80042094e1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042094e8:	00 00 00 
  80042094eb:	89 50 58             	mov    %edx,0x58(%rax)
  80042094ee:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042094f5:	00 00 00 
  80042094f8:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP], 0, GD_KT, XTRPX_Illop, 0);  
  80042094ff:	48 b8 02 cd 20 04 80 	movabs $0x800420cd02,%rax
  8004209506:	00 00 00 
  8004209509:	89 c2                	mov    %eax,%edx
  800420950b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209512:	00 00 00 
  8004209515:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004209519:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209520:	00 00 00 
  8004209523:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004209529:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209530:	00 00 00 
  8004209533:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209537:	83 e2 f8             	and    $0xfffffff8,%edx
  800420953a:	88 50 64             	mov    %dl,0x64(%rax)
  800420953d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209544:	00 00 00 
  8004209547:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420954b:	83 e2 07             	and    $0x7,%edx
  800420954e:	88 50 64             	mov    %dl,0x64(%rax)
  8004209551:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209558:	00 00 00 
  800420955b:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420955f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209562:	83 ca 0e             	or     $0xe,%edx
  8004209565:	88 50 65             	mov    %dl,0x65(%rax)
  8004209568:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420956f:	00 00 00 
  8004209572:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209576:	83 e2 ef             	and    $0xffffffef,%edx
  8004209579:	88 50 65             	mov    %dl,0x65(%rax)
  800420957c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209583:	00 00 00 
  8004209586:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420958a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420958d:	88 50 65             	mov    %dl,0x65(%rax)
  8004209590:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209597:	00 00 00 
  800420959a:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420959e:	83 ca 80             	or     $0xffffff80,%edx
  80042095a1:	88 50 65             	mov    %dl,0x65(%rax)
  80042095a4:	48 b8 02 cd 20 04 80 	movabs $0x800420cd02,%rax
  80042095ab:	00 00 00 
  80042095ae:	48 c1 e8 10          	shr    $0x10,%rax
  80042095b2:	89 c2                	mov    %eax,%edx
  80042095b4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042095bb:	00 00 00 
  80042095be:	66 89 50 66          	mov    %dx,0x66(%rax)
  80042095c2:	48 b8 02 cd 20 04 80 	movabs $0x800420cd02,%rax
  80042095c9:	00 00 00 
  80042095cc:	48 c1 e8 20          	shr    $0x20,%rax
  80042095d0:	89 c2                	mov    %eax,%edx
  80042095d2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042095d9:	00 00 00 
  80042095dc:	89 50 68             	mov    %edx,0x68(%rax)
  80042095df:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042095e6:	00 00 00 
  80042095e9:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE], 0, GD_KT, XTRPX_Device, 0);  
  80042095f0:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  80042095f7:	00 00 00 
  80042095fa:	89 c2                	mov    %eax,%edx
  80042095fc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209603:	00 00 00 
  8004209606:	66 89 50 70          	mov    %dx,0x70(%rax)
  800420960a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209611:	00 00 00 
  8004209614:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  800420961a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209621:	00 00 00 
  8004209624:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209628:	83 e2 f8             	and    $0xfffffff8,%edx
  800420962b:	88 50 74             	mov    %dl,0x74(%rax)
  800420962e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209635:	00 00 00 
  8004209638:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420963c:	83 e2 07             	and    $0x7,%edx
  800420963f:	88 50 74             	mov    %dl,0x74(%rax)
  8004209642:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209649:	00 00 00 
  800420964c:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209650:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209653:	83 ca 0e             	or     $0xe,%edx
  8004209656:	88 50 75             	mov    %dl,0x75(%rax)
  8004209659:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209660:	00 00 00 
  8004209663:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209667:	83 e2 ef             	and    $0xffffffef,%edx
  800420966a:	88 50 75             	mov    %dl,0x75(%rax)
  800420966d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209674:	00 00 00 
  8004209677:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420967b:	83 e2 9f             	and    $0xffffff9f,%edx
  800420967e:	88 50 75             	mov    %dl,0x75(%rax)
  8004209681:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209688:	00 00 00 
  800420968b:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420968f:	83 ca 80             	or     $0xffffff80,%edx
  8004209692:	88 50 75             	mov    %dl,0x75(%rax)
  8004209695:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  800420969c:	00 00 00 
  800420969f:	48 c1 e8 10          	shr    $0x10,%rax
  80042096a3:	89 c2                	mov    %eax,%edx
  80042096a5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042096ac:	00 00 00 
  80042096af:	66 89 50 76          	mov    %dx,0x76(%rax)
  80042096b3:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  80042096ba:	00 00 00 
  80042096bd:	48 c1 e8 20          	shr    $0x20,%rax
  80042096c1:	89 c2                	mov    %eax,%edx
  80042096c3:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042096ca:	00 00 00 
  80042096cd:	89 50 78             	mov    %edx,0x78(%rax)
  80042096d0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042096d7:	00 00 00 
  80042096da:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRPX_DblFlt, 0);  
  80042096e1:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  80042096e8:	00 00 00 
  80042096eb:	89 c2                	mov    %eax,%edx
  80042096ed:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042096f4:	00 00 00 
  80042096f7:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  80042096fe:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209705:	00 00 00 
  8004209708:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420970f:	08 00 
  8004209711:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209718:	00 00 00 
  800420971b:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209722:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209725:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420972b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209732:	00 00 00 
  8004209735:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420973c:	83 e2 07             	and    $0x7,%edx
  800420973f:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209745:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420974c:	00 00 00 
  800420974f:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209756:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209759:	83 ca 0e             	or     $0xe,%edx
  800420975c:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209762:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209769:	00 00 00 
  800420976c:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209773:	83 e2 ef             	and    $0xffffffef,%edx
  8004209776:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420977c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209783:	00 00 00 
  8004209786:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420978d:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209790:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209796:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420979d:	00 00 00 
  80042097a0:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042097a7:	83 ca 80             	or     $0xffffff80,%edx
  80042097aa:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042097b0:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  80042097b7:	00 00 00 
  80042097ba:	48 c1 e8 10          	shr    $0x10,%rax
  80042097be:	89 c2                	mov    %eax,%edx
  80042097c0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042097c7:	00 00 00 
  80042097ca:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042097d1:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  80042097d8:	00 00 00 
  80042097db:	48 c1 e8 20          	shr    $0x20,%rax
  80042097df:	89 c2                	mov    %eax,%edx
  80042097e1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042097e8:	00 00 00 
  80042097eb:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  80042097f1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042097f8:	00 00 00 
  80042097fb:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004209802:	00 00 00 
    SETGATE(idt[T_TSS], 0, GD_KT, XTRPX_Tss, 0);  
  8004209805:	48 b8 1e cd 20 04 80 	movabs $0x800420cd1e,%rax
  800420980c:	00 00 00 
  800420980f:	89 c2                	mov    %eax,%edx
  8004209811:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209818:	00 00 00 
  800420981b:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004209822:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209829:	00 00 00 
  800420982c:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209833:	08 00 
  8004209835:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420983c:	00 00 00 
  800420983f:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209846:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209849:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420984f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209856:	00 00 00 
  8004209859:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209860:	83 e2 07             	and    $0x7,%edx
  8004209863:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209869:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209870:	00 00 00 
  8004209873:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420987a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420987d:	83 ca 0e             	or     $0xe,%edx
  8004209880:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209886:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420988d:	00 00 00 
  8004209890:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209897:	83 e2 ef             	and    $0xffffffef,%edx
  800420989a:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098a0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042098a7:	00 00 00 
  80042098aa:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098b1:	83 e2 9f             	and    $0xffffff9f,%edx
  80042098b4:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098ba:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042098c1:	00 00 00 
  80042098c4:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098cb:	83 ca 80             	or     $0xffffff80,%edx
  80042098ce:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098d4:	48 b8 1e cd 20 04 80 	movabs $0x800420cd1e,%rax
  80042098db:	00 00 00 
  80042098de:	48 c1 e8 10          	shr    $0x10,%rax
  80042098e2:	89 c2                	mov    %eax,%edx
  80042098e4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042098eb:	00 00 00 
  80042098ee:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  80042098f5:	48 b8 1e cd 20 04 80 	movabs $0x800420cd1e,%rax
  80042098fc:	00 00 00 
  80042098ff:	48 c1 e8 20          	shr    $0x20,%rax
  8004209903:	89 c2                	mov    %eax,%edx
  8004209905:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420990c:	00 00 00 
  800420990f:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209915:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420991c:	00 00 00 
  800420991f:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209926:	00 00 00 
    SETGATE(idt[T_SEGNP], 0, GD_KT, XTRPX_Segnp, 0);  
  8004209929:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  8004209930:	00 00 00 
  8004209933:	89 c2                	mov    %eax,%edx
  8004209935:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420993c:	00 00 00 
  800420993f:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209946:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420994d:	00 00 00 
  8004209950:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209957:	08 00 
  8004209959:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209960:	00 00 00 
  8004209963:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420996a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420996d:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209973:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420997a:	00 00 00 
  800420997d:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209984:	83 e2 07             	and    $0x7,%edx
  8004209987:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420998d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209994:	00 00 00 
  8004209997:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420999e:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099a1:	83 ca 0e             	or     $0xe,%edx
  80042099a4:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099aa:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042099b1:	00 00 00 
  80042099b4:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099bb:	83 e2 ef             	and    $0xffffffef,%edx
  80042099be:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099c4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042099cb:	00 00 00 
  80042099ce:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099d5:	83 e2 9f             	and    $0xffffff9f,%edx
  80042099d8:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099de:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  80042099e5:	00 00 00 
  80042099e8:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099ef:	83 ca 80             	or     $0xffffff80,%edx
  80042099f2:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099f8:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  80042099ff:	00 00 00 
  8004209a02:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a06:	89 c2                	mov    %eax,%edx
  8004209a08:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a0f:	00 00 00 
  8004209a12:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004209a19:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  8004209a20:	00 00 00 
  8004209a23:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a27:	89 c2                	mov    %eax,%edx
  8004209a29:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a30:	00 00 00 
  8004209a33:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209a39:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a40:	00 00 00 
  8004209a43:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209a4a:	00 00 00 
    SETGATE(idt[T_STACK], 0, GD_KT, XTRPX_Stack, 0);  
  8004209a4d:	48 b8 2e cd 20 04 80 	movabs $0x800420cd2e,%rax
  8004209a54:	00 00 00 
  8004209a57:	89 c2                	mov    %eax,%edx
  8004209a59:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a60:	00 00 00 
  8004209a63:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209a6a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a71:	00 00 00 
  8004209a74:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209a7b:	08 00 
  8004209a7d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a84:	00 00 00 
  8004209a87:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209a8e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a91:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209a97:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209a9e:	00 00 00 
  8004209aa1:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209aa8:	83 e2 07             	and    $0x7,%edx
  8004209aab:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209ab1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ab8:	00 00 00 
  8004209abb:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209ac2:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ac5:	83 ca 0e             	or     $0xe,%edx
  8004209ac8:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209ace:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ad5:	00 00 00 
  8004209ad8:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209adf:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ae2:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209ae8:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209aef:	00 00 00 
  8004209af2:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209af9:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209afc:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b02:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b09:	00 00 00 
  8004209b0c:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209b13:	83 ca 80             	or     $0xffffff80,%edx
  8004209b16:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b1c:	48 b8 2e cd 20 04 80 	movabs $0x800420cd2e,%rax
  8004209b23:	00 00 00 
  8004209b26:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b2a:	89 c2                	mov    %eax,%edx
  8004209b2c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b33:	00 00 00 
  8004209b36:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209b3d:	48 b8 2e cd 20 04 80 	movabs $0x800420cd2e,%rax
  8004209b44:	00 00 00 
  8004209b47:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b4b:	89 c2                	mov    %eax,%edx
  8004209b4d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b54:	00 00 00 
  8004209b57:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209b5d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b64:	00 00 00 
  8004209b67:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209b6e:	00 00 00 
    SETGATE(idt[T_GPFLT], 0, GD_KT, XTRPX_Gpflt, 0);  
  8004209b71:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209b78:	00 00 00 
  8004209b7b:	89 c2                	mov    %eax,%edx
  8004209b7d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b84:	00 00 00 
  8004209b87:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209b8e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209b95:	00 00 00 
  8004209b98:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  8004209b9f:	08 00 
  8004209ba1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ba8:	00 00 00 
  8004209bab:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209bb2:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209bb5:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209bbb:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209bc2:	00 00 00 
  8004209bc5:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209bcc:	83 e2 07             	and    $0x7,%edx
  8004209bcf:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209bd5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209bdc:	00 00 00 
  8004209bdf:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209be6:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209be9:	83 ca 0e             	or     $0xe,%edx
  8004209bec:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bf2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209bf9:	00 00 00 
  8004209bfc:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c03:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c06:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c0c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209c13:	00 00 00 
  8004209c16:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c1d:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c20:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c26:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209c2d:	00 00 00 
  8004209c30:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c37:	83 ca 80             	or     $0xffffff80,%edx
  8004209c3a:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c40:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209c47:	00 00 00 
  8004209c4a:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c4e:	89 c2                	mov    %eax,%edx
  8004209c50:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209c57:	00 00 00 
  8004209c5a:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209c61:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209c68:	00 00 00 
  8004209c6b:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c6f:	89 c2                	mov    %eax,%edx
  8004209c71:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209c78:	00 00 00 
  8004209c7b:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004209c81:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209c88:	00 00 00 
  8004209c8b:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  8004209c92:	00 00 00 
    SETGATE(idt[T_PGFLT], 0, GD_KT, XTRPX_Pgflt, 0);  
  8004209c95:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  8004209c9c:	00 00 00 
  8004209c9f:	89 c2                	mov    %eax,%edx
  8004209ca1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ca8:	00 00 00 
  8004209cab:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  8004209cb2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209cb9:	00 00 00 
  8004209cbc:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  8004209cc3:	08 00 
  8004209cc5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ccc:	00 00 00 
  8004209ccf:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209cd6:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209cd9:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209cdf:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ce6:	00 00 00 
  8004209ce9:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209cf0:	83 e2 07             	and    $0x7,%edx
  8004209cf3:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209cf9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d00:	00 00 00 
  8004209d03:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d0a:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d0d:	83 ca 0e             	or     $0xe,%edx
  8004209d10:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d16:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d1d:	00 00 00 
  8004209d20:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d27:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d2a:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d30:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d37:	00 00 00 
  8004209d3a:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d41:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d44:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d4a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d51:	00 00 00 
  8004209d54:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d5b:	83 ca 80             	or     $0xffffff80,%edx
  8004209d5e:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d64:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  8004209d6b:	00 00 00 
  8004209d6e:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d72:	89 c2                	mov    %eax,%edx
  8004209d74:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d7b:	00 00 00 
  8004209d7e:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209d85:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  8004209d8c:	00 00 00 
  8004209d8f:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d93:	89 c2                	mov    %eax,%edx
  8004209d95:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209d9c:	00 00 00 
  8004209d9f:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209da5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209dac:	00 00 00 
  8004209daf:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209db6:	00 00 00 
    SETGATE(idt[T_FPERR], 0, GD_KT, XTRPX_FpErr, 0);  
  8004209db9:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  8004209dc0:	00 00 00 
  8004209dc3:	89 c2                	mov    %eax,%edx
  8004209dc5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209dcc:	00 00 00 
  8004209dcf:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209dd6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ddd:	00 00 00 
  8004209de0:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209de7:	08 00 
  8004209de9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209df0:	00 00 00 
  8004209df3:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209dfa:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209dfd:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209e03:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e0a:	00 00 00 
  8004209e0d:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209e14:	83 e2 07             	and    $0x7,%edx
  8004209e17:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209e1d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e24:	00 00 00 
  8004209e27:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e2e:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e31:	83 ca 0e             	or     $0xe,%edx
  8004209e34:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e3a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e41:	00 00 00 
  8004209e44:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e4b:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e4e:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e54:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e5b:	00 00 00 
  8004209e5e:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e65:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e68:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e6e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e75:	00 00 00 
  8004209e78:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e7f:	83 ca 80             	or     $0xffffff80,%edx
  8004209e82:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e88:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  8004209e8f:	00 00 00 
  8004209e92:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e96:	89 c2                	mov    %eax,%edx
  8004209e98:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209e9f:	00 00 00 
  8004209ea2:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209ea9:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  8004209eb0:	00 00 00 
  8004209eb3:	48 c1 e8 20          	shr    $0x20,%rax
  8004209eb7:	89 c2                	mov    %eax,%edx
  8004209eb9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ec0:	00 00 00 
  8004209ec3:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209ec9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ed0:	00 00 00 
  8004209ed3:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209eda:	00 00 00 
    SETGATE(idt[T_ALIGN], 0, GD_KT, XTRPX_Align, 0);  
  8004209edd:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  8004209ee4:	00 00 00 
  8004209ee7:	89 c2                	mov    %eax,%edx
  8004209ee9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ef0:	00 00 00 
  8004209ef3:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209efa:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f01:	00 00 00 
  8004209f04:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209f0b:	08 00 
  8004209f0d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f14:	00 00 00 
  8004209f17:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f1e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f21:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f27:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f2e:	00 00 00 
  8004209f31:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f38:	83 e2 07             	and    $0x7,%edx
  8004209f3b:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f41:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f48:	00 00 00 
  8004209f4b:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f52:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f55:	83 ca 0e             	or     $0xe,%edx
  8004209f58:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f5e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f65:	00 00 00 
  8004209f68:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f6f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f72:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f78:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f7f:	00 00 00 
  8004209f82:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f89:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f8c:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f92:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209f99:	00 00 00 
  8004209f9c:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209fa3:	83 ca 80             	or     $0xffffff80,%edx
  8004209fa6:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209fac:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  8004209fb3:	00 00 00 
  8004209fb6:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fba:	89 c2                	mov    %eax,%edx
  8004209fbc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209fc3:	00 00 00 
  8004209fc6:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209fcd:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  8004209fd4:	00 00 00 
  8004209fd7:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fdb:	89 c2                	mov    %eax,%edx
  8004209fdd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209fe4:	00 00 00 
  8004209fe7:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209fed:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  8004209ff4:	00 00 00 
  8004209ff7:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209ffe:	00 00 00 
    SETGATE(idt[T_MCHK], 0, GD_KT, XTRPX_Mchk, 0);  
  800420a001:	48 b8 54 cd 20 04 80 	movabs $0x800420cd54,%rax
  800420a008:	00 00 00 
  800420a00b:	89 c2                	mov    %eax,%edx
  800420a00d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a014:	00 00 00 
  800420a017:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a01e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a025:	00 00 00 
  800420a028:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a02f:	08 00 
  800420a031:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a038:	00 00 00 
  800420a03b:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a042:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a045:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a04b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a052:	00 00 00 
  800420a055:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a05c:	83 e2 07             	and    $0x7,%edx
  800420a05f:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a065:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a06c:	00 00 00 
  800420a06f:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a076:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a079:	83 ca 0e             	or     $0xe,%edx
  800420a07c:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a082:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a089:	00 00 00 
  800420a08c:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a093:	83 e2 ef             	and    $0xffffffef,%edx
  800420a096:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a09c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a0a3:	00 00 00 
  800420a0a6:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0ad:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0b0:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0b6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a0bd:	00 00 00 
  800420a0c0:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0c7:	83 ca 80             	or     $0xffffff80,%edx
  800420a0ca:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0d0:	48 b8 54 cd 20 04 80 	movabs $0x800420cd54,%rax
  800420a0d7:	00 00 00 
  800420a0da:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0de:	89 c2                	mov    %eax,%edx
  800420a0e0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a0e7:	00 00 00 
  800420a0ea:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a0f1:	48 b8 54 cd 20 04 80 	movabs $0x800420cd54,%rax
  800420a0f8:	00 00 00 
  800420a0fb:	48 c1 e8 20          	shr    $0x20,%rax
  800420a0ff:	89 c2                	mov    %eax,%edx
  800420a101:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a108:	00 00 00 
  800420a10b:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a111:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a118:	00 00 00 
  800420a11b:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a122:	00 00 00 
    SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRPX_SimdErr, 0);  
  800420a125:	48 b8 5a cd 20 04 80 	movabs $0x800420cd5a,%rax
  800420a12c:	00 00 00 
  800420a12f:	89 c2                	mov    %eax,%edx
  800420a131:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a138:	00 00 00 
  800420a13b:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a142:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a149:	00 00 00 
  800420a14c:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a153:	08 00 
  800420a155:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a15c:	00 00 00 
  800420a15f:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a166:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a169:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a16f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a176:	00 00 00 
  800420a179:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a180:	83 e2 07             	and    $0x7,%edx
  800420a183:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a189:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a190:	00 00 00 
  800420a193:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a19a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a19d:	83 ca 0e             	or     $0xe,%edx
  800420a1a0:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1a6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a1ad:	00 00 00 
  800420a1b0:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1b7:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1ba:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1c0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a1c7:	00 00 00 
  800420a1ca:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1d1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a1d4:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1da:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a1e1:	00 00 00 
  800420a1e4:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1eb:	83 ca 80             	or     $0xffffff80,%edx
  800420a1ee:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1f4:	48 b8 5a cd 20 04 80 	movabs $0x800420cd5a,%rax
  800420a1fb:	00 00 00 
  800420a1fe:	48 c1 e8 10          	shr    $0x10,%rax
  800420a202:	89 c2                	mov    %eax,%edx
  800420a204:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a20b:	00 00 00 
  800420a20e:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a215:	48 b8 5a cd 20 04 80 	movabs $0x800420cd5a,%rax
  800420a21c:	00 00 00 
  800420a21f:	48 c1 e8 20          	shr    $0x20,%rax
  800420a223:	89 c2                	mov    %eax,%edx
  800420a225:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a22c:	00 00 00 
  800420a22f:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a235:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a23c:	00 00 00 
  800420a23f:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a246:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRPX_Syscall, 3);
  800420a249:	48 b8 60 cd 20 04 80 	movabs $0x800420cd60,%rax
  800420a250:	00 00 00 
  800420a253:	89 c2                	mov    %eax,%edx
  800420a255:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a25c:	00 00 00 
  800420a25f:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a266:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a26d:	00 00 00 
  800420a270:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a277:	08 00 
  800420a279:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a280:	00 00 00 
  800420a283:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a28a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a28d:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a293:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a29a:	00 00 00 
  800420a29d:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a2a4:	83 e2 07             	and    $0x7,%edx
  800420a2a7:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a2ad:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a2b4:	00 00 00 
  800420a2b7:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2be:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2c1:	83 ca 0e             	or     $0xe,%edx
  800420a2c4:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2ca:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a2d1:	00 00 00 
  800420a2d4:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2db:	83 e2 ef             	and    $0xffffffef,%edx
  800420a2de:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2e4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a2eb:	00 00 00 
  800420a2ee:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2f5:	83 ca 60             	or     $0x60,%edx
  800420a2f8:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2fe:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a305:	00 00 00 
  800420a308:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a30f:	83 ca 80             	or     $0xffffff80,%edx
  800420a312:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a318:	48 b8 60 cd 20 04 80 	movabs $0x800420cd60,%rax
  800420a31f:	00 00 00 
  800420a322:	48 c1 e8 10          	shr    $0x10,%rax
  800420a326:	89 c2                	mov    %eax,%edx
  800420a328:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a32f:	00 00 00 
  800420a332:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a339:	48 b8 60 cd 20 04 80 	movabs $0x800420cd60,%rax
  800420a340:	00 00 00 
  800420a343:	48 c1 e8 20          	shr    $0x20,%rax
  800420a347:	89 c2                	mov    %eax,%edx
  800420a349:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a350:	00 00 00 
  800420a353:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a359:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a360:	00 00 00 
  800420a363:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a36a:	00 00 00 
    SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRPX_Default, 0);
  800420a36d:	48 b8 66 cd 20 04 80 	movabs $0x800420cd66,%rax
  800420a374:	00 00 00 
  800420a377:	89 c2                	mov    %eax,%edx
  800420a379:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a380:	00 00 00 
  800420a383:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420a38a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a391:	00 00 00 
  800420a394:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420a39b:	08 00 
  800420a39d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a3a4:	00 00 00 
  800420a3a7:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a3ae:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3b1:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a3b7:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a3be:	00 00 00 
  800420a3c1:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a3c8:	83 e2 07             	and    $0x7,%edx
  800420a3cb:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a3d1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a3d8:	00 00 00 
  800420a3db:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3e2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3e5:	83 ca 0e             	or     $0xe,%edx
  800420a3e8:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3ee:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a3f5:	00 00 00 
  800420a3f8:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3ff:	83 e2 ef             	and    $0xffffffef,%edx
  800420a402:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a408:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a40f:	00 00 00 
  800420a412:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a419:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a41c:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a422:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a429:	00 00 00 
  800420a42c:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a433:	83 ca 80             	or     $0xffffff80,%edx
  800420a436:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a43c:	48 b8 66 cd 20 04 80 	movabs $0x800420cd66,%rax
  800420a443:	00 00 00 
  800420a446:	48 c1 e8 10          	shr    $0x10,%rax
  800420a44a:	89 c2                	mov    %eax,%edx
  800420a44c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a453:	00 00 00 
  800420a456:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420a45d:	48 b8 66 cd 20 04 80 	movabs $0x800420cd66,%rax
  800420a464:	00 00 00 
  800420a467:	48 c1 e8 20          	shr    $0x20,%rax
  800420a46b:	89 c2                	mov    %eax,%edx
  800420a46d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a474:	00 00 00 
  800420a477:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420a47d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a484:	00 00 00 
  800420a487:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420a48e:	00 00 00 
	
    SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRPX_IRQ0, 0);
  800420a491:	48 b8 70 cd 20 04 80 	movabs $0x800420cd70,%rax
  800420a498:	00 00 00 
  800420a49b:	89 c2                	mov    %eax,%edx
  800420a49d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a4a4:	00 00 00 
  800420a4a7:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a4ae:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a4b5:	00 00 00 
  800420a4b8:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a4bf:	08 00 
  800420a4c1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a4c8:	00 00 00 
  800420a4cb:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4d2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a4d5:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a4db:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a4e2:	00 00 00 
  800420a4e5:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4ec:	83 e2 07             	and    $0x7,%edx
  800420a4ef:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a4f5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a4fc:	00 00 00 
  800420a4ff:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a506:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a509:	83 ca 0e             	or     $0xe,%edx
  800420a50c:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a512:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a519:	00 00 00 
  800420a51c:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a523:	83 e2 ef             	and    $0xffffffef,%edx
  800420a526:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a52c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a533:	00 00 00 
  800420a536:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a53d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a540:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a546:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a54d:	00 00 00 
  800420a550:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a557:	83 ca 80             	or     $0xffffff80,%edx
  800420a55a:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a560:	48 b8 70 cd 20 04 80 	movabs $0x800420cd70,%rax
  800420a567:	00 00 00 
  800420a56a:	48 c1 e8 10          	shr    $0x10,%rax
  800420a56e:	89 c2                	mov    %eax,%edx
  800420a570:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a577:	00 00 00 
  800420a57a:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a581:	48 b8 70 cd 20 04 80 	movabs $0x800420cd70,%rax
  800420a588:	00 00 00 
  800420a58b:	48 c1 e8 20          	shr    $0x20,%rax
  800420a58f:	89 c2                	mov    %eax,%edx
  800420a591:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a598:	00 00 00 
  800420a59b:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a5a1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a5a8:	00 00 00 
  800420a5ab:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a5b2:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRPX_IRQ1, 0);
  800420a5b5:	48 b8 76 cd 20 04 80 	movabs $0x800420cd76,%rax
  800420a5bc:	00 00 00 
  800420a5bf:	89 c2                	mov    %eax,%edx
  800420a5c1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a5c8:	00 00 00 
  800420a5cb:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a5d2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a5d9:	00 00 00 
  800420a5dc:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a5e3:	08 00 
  800420a5e5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a5ec:	00 00 00 
  800420a5ef:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a5f6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a5f9:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a5ff:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a606:	00 00 00 
  800420a609:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a610:	83 e2 07             	and    $0x7,%edx
  800420a613:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a619:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a620:	00 00 00 
  800420a623:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a62a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a62d:	83 ca 0e             	or     $0xe,%edx
  800420a630:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a636:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a63d:	00 00 00 
  800420a640:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a647:	83 e2 ef             	and    $0xffffffef,%edx
  800420a64a:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a650:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a657:	00 00 00 
  800420a65a:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a661:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a664:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a66a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a671:	00 00 00 
  800420a674:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a67b:	83 ca 80             	or     $0xffffff80,%edx
  800420a67e:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a684:	48 b8 76 cd 20 04 80 	movabs $0x800420cd76,%rax
  800420a68b:	00 00 00 
  800420a68e:	48 c1 e8 10          	shr    $0x10,%rax
  800420a692:	89 c2                	mov    %eax,%edx
  800420a694:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a69b:	00 00 00 
  800420a69e:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a6a5:	48 b8 76 cd 20 04 80 	movabs $0x800420cd76,%rax
  800420a6ac:	00 00 00 
  800420a6af:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6b3:	89 c2                	mov    %eax,%edx
  800420a6b5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a6bc:	00 00 00 
  800420a6bf:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a6c5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a6cc:	00 00 00 
  800420a6cf:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a6d6:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, XTRPX_IRQ2, 0);
  800420a6d9:	48 b8 7c cd 20 04 80 	movabs $0x800420cd7c,%rax
  800420a6e0:	00 00 00 
  800420a6e3:	89 c2                	mov    %eax,%edx
  800420a6e5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a6ec:	00 00 00 
  800420a6ef:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420a6f6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a6fd:	00 00 00 
  800420a700:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420a707:	08 00 
  800420a709:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a710:	00 00 00 
  800420a713:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a71a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a71d:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a723:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a72a:	00 00 00 
  800420a72d:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a734:	83 e2 07             	and    $0x7,%edx
  800420a737:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a73d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a744:	00 00 00 
  800420a747:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a74e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a751:	83 ca 0e             	or     $0xe,%edx
  800420a754:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a75a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a761:	00 00 00 
  800420a764:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a76b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a76e:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a774:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a77b:	00 00 00 
  800420a77e:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a785:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a788:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a78e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a795:	00 00 00 
  800420a798:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a79f:	83 ca 80             	or     $0xffffff80,%edx
  800420a7a2:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a7a8:	48 b8 7c cd 20 04 80 	movabs $0x800420cd7c,%rax
  800420a7af:	00 00 00 
  800420a7b2:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7b6:	89 c2                	mov    %eax,%edx
  800420a7b8:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a7bf:	00 00 00 
  800420a7c2:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420a7c9:	48 b8 7c cd 20 04 80 	movabs $0x800420cd7c,%rax
  800420a7d0:	00 00 00 
  800420a7d3:	48 c1 e8 20          	shr    $0x20,%rax
  800420a7d7:	89 c2                	mov    %eax,%edx
  800420a7d9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a7e0:	00 00 00 
  800420a7e3:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420a7e9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a7f0:	00 00 00 
  800420a7f3:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a7fa:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, XTRPX_IRQ3, 0);
  800420a7fd:	48 b8 82 cd 20 04 80 	movabs $0x800420cd82,%rax
  800420a804:	00 00 00 
  800420a807:	89 c2                	mov    %eax,%edx
  800420a809:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a810:	00 00 00 
  800420a813:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a81a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a821:	00 00 00 
  800420a824:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a82b:	08 00 
  800420a82d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a834:	00 00 00 
  800420a837:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a83e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a841:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a847:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a84e:	00 00 00 
  800420a851:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a858:	83 e2 07             	and    $0x7,%edx
  800420a85b:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a861:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a868:	00 00 00 
  800420a86b:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a872:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a875:	83 ca 0e             	or     $0xe,%edx
  800420a878:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a87e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a885:	00 00 00 
  800420a888:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a88f:	83 e2 ef             	and    $0xffffffef,%edx
  800420a892:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a898:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a89f:	00 00 00 
  800420a8a2:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a8a9:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8ac:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a8b2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a8b9:	00 00 00 
  800420a8bc:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a8c3:	83 ca 80             	or     $0xffffff80,%edx
  800420a8c6:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a8cc:	48 b8 82 cd 20 04 80 	movabs $0x800420cd82,%rax
  800420a8d3:	00 00 00 
  800420a8d6:	48 c1 e8 10          	shr    $0x10,%rax
  800420a8da:	89 c2                	mov    %eax,%edx
  800420a8dc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a8e3:	00 00 00 
  800420a8e6:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a8ed:	48 b8 82 cd 20 04 80 	movabs $0x800420cd82,%rax
  800420a8f4:	00 00 00 
  800420a8f7:	48 c1 e8 20          	shr    $0x20,%rax
  800420a8fb:	89 c2                	mov    %eax,%edx
  800420a8fd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a904:	00 00 00 
  800420a907:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a90d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a914:	00 00 00 
  800420a917:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a91e:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRPX_IRQ4, 0);
  800420a921:	48 b8 88 cd 20 04 80 	movabs $0x800420cd88,%rax
  800420a928:	00 00 00 
  800420a92b:	89 c2                	mov    %eax,%edx
  800420a92d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a934:	00 00 00 
  800420a937:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a93e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a945:	00 00 00 
  800420a948:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a94f:	08 00 
  800420a951:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a958:	00 00 00 
  800420a95b:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a962:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a965:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a96b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a972:	00 00 00 
  800420a975:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a97c:	83 e2 07             	and    $0x7,%edx
  800420a97f:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a985:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a98c:	00 00 00 
  800420a98f:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a996:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a999:	83 ca 0e             	or     $0xe,%edx
  800420a99c:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9a2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a9a9:	00 00 00 
  800420a9ac:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9b3:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9b6:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9bc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a9c3:	00 00 00 
  800420a9c6:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9cd:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9d0:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9d6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420a9dd:	00 00 00 
  800420a9e0:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9e7:	83 ca 80             	or     $0xffffff80,%edx
  800420a9ea:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9f0:	48 b8 88 cd 20 04 80 	movabs $0x800420cd88,%rax
  800420a9f7:	00 00 00 
  800420a9fa:	48 c1 e8 10          	shr    $0x10,%rax
  800420a9fe:	89 c2                	mov    %eax,%edx
  800420aa00:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa07:	00 00 00 
  800420aa0a:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420aa11:	48 b8 88 cd 20 04 80 	movabs $0x800420cd88,%rax
  800420aa18:	00 00 00 
  800420aa1b:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa1f:	89 c2                	mov    %eax,%edx
  800420aa21:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa28:	00 00 00 
  800420aa2b:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420aa31:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa38:	00 00 00 
  800420aa3b:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420aa42:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, XTRPX_IRQ5, 0);
  800420aa45:	48 b8 8e cd 20 04 80 	movabs $0x800420cd8e,%rax
  800420aa4c:	00 00 00 
  800420aa4f:	89 c2                	mov    %eax,%edx
  800420aa51:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa58:	00 00 00 
  800420aa5b:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420aa62:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa69:	00 00 00 
  800420aa6c:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420aa73:	08 00 
  800420aa75:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa7c:	00 00 00 
  800420aa7f:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aa86:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa89:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aa8f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aa96:	00 00 00 
  800420aa99:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aaa0:	83 e2 07             	and    $0x7,%edx
  800420aaa3:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aaa9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aab0:	00 00 00 
  800420aab3:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aaba:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aabd:	83 ca 0e             	or     $0xe,%edx
  800420aac0:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aac6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aacd:	00 00 00 
  800420aad0:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aad7:	83 e2 ef             	and    $0xffffffef,%edx
  800420aada:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aae0:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aae7:	00 00 00 
  800420aaea:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aaf1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aaf4:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aafa:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab01:	00 00 00 
  800420ab04:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420ab0b:	83 ca 80             	or     $0xffffff80,%edx
  800420ab0e:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420ab14:	48 b8 8e cd 20 04 80 	movabs $0x800420cd8e,%rax
  800420ab1b:	00 00 00 
  800420ab1e:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab22:	89 c2                	mov    %eax,%edx
  800420ab24:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab2b:	00 00 00 
  800420ab2e:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420ab35:	48 b8 8e cd 20 04 80 	movabs $0x800420cd8e,%rax
  800420ab3c:	00 00 00 
  800420ab3f:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab43:	89 c2                	mov    %eax,%edx
  800420ab45:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab4c:	00 00 00 
  800420ab4f:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420ab55:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab5c:	00 00 00 
  800420ab5f:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420ab66:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, XTRPX_IRQ6, 0);
  800420ab69:	48 b8 94 cd 20 04 80 	movabs $0x800420cd94,%rax
  800420ab70:	00 00 00 
  800420ab73:	89 c2                	mov    %eax,%edx
  800420ab75:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab7c:	00 00 00 
  800420ab7f:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420ab86:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ab8d:	00 00 00 
  800420ab90:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420ab97:	08 00 
  800420ab99:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aba0:	00 00 00 
  800420aba3:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420abaa:	83 e2 f8             	and    $0xfffffff8,%edx
  800420abad:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420abb3:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420abba:	00 00 00 
  800420abbd:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420abc4:	83 e2 07             	and    $0x7,%edx
  800420abc7:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420abcd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420abd4:	00 00 00 
  800420abd7:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abde:	83 e2 f0             	and    $0xfffffff0,%edx
  800420abe1:	83 ca 0e             	or     $0xe,%edx
  800420abe4:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abea:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420abf1:	00 00 00 
  800420abf4:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abfb:	83 e2 ef             	and    $0xffffffef,%edx
  800420abfe:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ac04:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ac0b:	00 00 00 
  800420ac0e:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ac15:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac18:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ac1e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ac25:	00 00 00 
  800420ac28:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ac2f:	83 ca 80             	or     $0xffffff80,%edx
  800420ac32:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ac38:	48 b8 94 cd 20 04 80 	movabs $0x800420cd94,%rax
  800420ac3f:	00 00 00 
  800420ac42:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac46:	89 c2                	mov    %eax,%edx
  800420ac48:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ac4f:	00 00 00 
  800420ac52:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420ac59:	48 b8 94 cd 20 04 80 	movabs $0x800420cd94,%rax
  800420ac60:	00 00 00 
  800420ac63:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac67:	89 c2                	mov    %eax,%edx
  800420ac69:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ac70:	00 00 00 
  800420ac73:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420ac79:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ac80:	00 00 00 
  800420ac83:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420ac8a:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRPX_IRQ7, 0);
  800420ac8d:	48 b8 9a cd 20 04 80 	movabs $0x800420cd9a,%rax
  800420ac94:	00 00 00 
  800420ac97:	89 c2                	mov    %eax,%edx
  800420ac99:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aca0:	00 00 00 
  800420aca3:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420acaa:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420acb1:	00 00 00 
  800420acb4:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420acbb:	08 00 
  800420acbd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420acc4:	00 00 00 
  800420acc7:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420acce:	83 e2 f8             	and    $0xfffffff8,%edx
  800420acd1:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420acd7:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420acde:	00 00 00 
  800420ace1:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ace8:	83 e2 07             	and    $0x7,%edx
  800420aceb:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420acf1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420acf8:	00 00 00 
  800420acfb:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad02:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad05:	83 ca 0e             	or     $0xe,%edx
  800420ad08:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad0e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ad15:	00 00 00 
  800420ad18:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad1f:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad22:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad28:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ad2f:	00 00 00 
  800420ad32:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad39:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad3c:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad42:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ad49:	00 00 00 
  800420ad4c:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad53:	83 ca 80             	or     $0xffffff80,%edx
  800420ad56:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad5c:	48 b8 9a cd 20 04 80 	movabs $0x800420cd9a,%rax
  800420ad63:	00 00 00 
  800420ad66:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad6a:	89 c2                	mov    %eax,%edx
  800420ad6c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ad73:	00 00 00 
  800420ad76:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420ad7d:	48 b8 9a cd 20 04 80 	movabs $0x800420cd9a,%rax
  800420ad84:	00 00 00 
  800420ad87:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad8b:	89 c2                	mov    %eax,%edx
  800420ad8d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ad94:	00 00 00 
  800420ad97:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420ad9d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ada4:	00 00 00 
  800420ada7:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420adae:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, XTRPX_IRQ8, 0);
  800420adb1:	48 b8 a0 cd 20 04 80 	movabs $0x800420cda0,%rax
  800420adb8:	00 00 00 
  800420adbb:	89 c2                	mov    %eax,%edx
  800420adbd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420adc4:	00 00 00 
  800420adc7:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420adce:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420add5:	00 00 00 
  800420add8:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420addf:	08 00 
  800420ade1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ade8:	00 00 00 
  800420adeb:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420adf2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420adf5:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420adfb:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae02:	00 00 00 
  800420ae05:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420ae0c:	83 e2 07             	and    $0x7,%edx
  800420ae0f:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420ae15:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae1c:	00 00 00 
  800420ae1f:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae26:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae29:	83 ca 0e             	or     $0xe,%edx
  800420ae2c:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae32:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae39:	00 00 00 
  800420ae3c:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae43:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae46:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae4c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae53:	00 00 00 
  800420ae56:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae5d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae60:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae66:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae6d:	00 00 00 
  800420ae70:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae77:	83 ca 80             	or     $0xffffff80,%edx
  800420ae7a:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae80:	48 b8 a0 cd 20 04 80 	movabs $0x800420cda0,%rax
  800420ae87:	00 00 00 
  800420ae8a:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae8e:	89 c2                	mov    %eax,%edx
  800420ae90:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420ae97:	00 00 00 
  800420ae9a:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420aea1:	48 b8 a0 cd 20 04 80 	movabs $0x800420cda0,%rax
  800420aea8:	00 00 00 
  800420aeab:	48 c1 e8 20          	shr    $0x20,%rax
  800420aeaf:	89 c2                	mov    %eax,%edx
  800420aeb1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aeb8:	00 00 00 
  800420aebb:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420aec1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aec8:	00 00 00 
  800420aecb:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420aed2:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, XTRPX_IRQ9, 0);
  800420aed5:	48 b8 a6 cd 20 04 80 	movabs $0x800420cda6,%rax
  800420aedc:	00 00 00 
  800420aedf:	89 c2                	mov    %eax,%edx
  800420aee1:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aee8:	00 00 00 
  800420aeeb:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420aef2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420aef9:	00 00 00 
  800420aefc:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420af03:	08 00 
  800420af05:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af0c:	00 00 00 
  800420af0f:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420af16:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af19:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420af1f:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af26:	00 00 00 
  800420af29:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420af30:	83 e2 07             	and    $0x7,%edx
  800420af33:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420af39:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af40:	00 00 00 
  800420af43:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af4a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af4d:	83 ca 0e             	or     $0xe,%edx
  800420af50:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af56:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af5d:	00 00 00 
  800420af60:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af67:	83 e2 ef             	and    $0xffffffef,%edx
  800420af6a:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af70:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af77:	00 00 00 
  800420af7a:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af81:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af84:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af8a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420af91:	00 00 00 
  800420af94:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af9b:	83 ca 80             	or     $0xffffff80,%edx
  800420af9e:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420afa4:	48 b8 a6 cd 20 04 80 	movabs $0x800420cda6,%rax
  800420afab:	00 00 00 
  800420afae:	48 c1 e8 10          	shr    $0x10,%rax
  800420afb2:	89 c2                	mov    %eax,%edx
  800420afb4:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420afbb:	00 00 00 
  800420afbe:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420afc5:	48 b8 a6 cd 20 04 80 	movabs $0x800420cda6,%rax
  800420afcc:	00 00 00 
  800420afcf:	48 c1 e8 20          	shr    $0x20,%rax
  800420afd3:	89 c2                	mov    %eax,%edx
  800420afd5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420afdc:	00 00 00 
  800420afdf:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420afe5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420afec:	00 00 00 
  800420afef:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420aff6:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, XTRPX_IRQa, 0);
  800420aff9:	48 b8 ac cd 20 04 80 	movabs $0x800420cdac,%rax
  800420b000:	00 00 00 
  800420b003:	89 c2                	mov    %eax,%edx
  800420b005:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b00c:	00 00 00 
  800420b00f:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b016:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b01d:	00 00 00 
  800420b020:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b027:	08 00 
  800420b029:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b030:	00 00 00 
  800420b033:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b03a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b03d:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b043:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b04a:	00 00 00 
  800420b04d:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b054:	83 e2 07             	and    $0x7,%edx
  800420b057:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b05d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b064:	00 00 00 
  800420b067:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b06e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b071:	83 ca 0e             	or     $0xe,%edx
  800420b074:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b07a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b081:	00 00 00 
  800420b084:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b08b:	83 e2 ef             	and    $0xffffffef,%edx
  800420b08e:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b094:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b09b:	00 00 00 
  800420b09e:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b0a5:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b0a8:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b0ae:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b0b5:	00 00 00 
  800420b0b8:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b0bf:	83 ca 80             	or     $0xffffff80,%edx
  800420b0c2:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b0c8:	48 b8 ac cd 20 04 80 	movabs $0x800420cdac,%rax
  800420b0cf:	00 00 00 
  800420b0d2:	48 c1 e8 10          	shr    $0x10,%rax
  800420b0d6:	89 c2                	mov    %eax,%edx
  800420b0d8:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b0df:	00 00 00 
  800420b0e2:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b0e9:	48 b8 ac cd 20 04 80 	movabs $0x800420cdac,%rax
  800420b0f0:	00 00 00 
  800420b0f3:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0f7:	89 c2                	mov    %eax,%edx
  800420b0f9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b100:	00 00 00 
  800420b103:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b109:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b110:	00 00 00 
  800420b113:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b11a:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, XTRPX_IRQb, 0);
  800420b11d:	48 b8 b2 cd 20 04 80 	movabs $0x800420cdb2,%rax
  800420b124:	00 00 00 
  800420b127:	89 c2                	mov    %eax,%edx
  800420b129:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b130:	00 00 00 
  800420b133:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b13a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b141:	00 00 00 
  800420b144:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b14b:	08 00 
  800420b14d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b154:	00 00 00 
  800420b157:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b15e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b161:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b167:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b16e:	00 00 00 
  800420b171:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b178:	83 e2 07             	and    $0x7,%edx
  800420b17b:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b181:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b188:	00 00 00 
  800420b18b:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b192:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b195:	83 ca 0e             	or     $0xe,%edx
  800420b198:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b19e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b1a5:	00 00 00 
  800420b1a8:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b1af:	83 e2 ef             	and    $0xffffffef,%edx
  800420b1b2:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1b8:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b1bf:	00 00 00 
  800420b1c2:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b1c9:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b1cc:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1d2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b1d9:	00 00 00 
  800420b1dc:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b1e3:	83 ca 80             	or     $0xffffff80,%edx
  800420b1e6:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1ec:	48 b8 b2 cd 20 04 80 	movabs $0x800420cdb2,%rax
  800420b1f3:	00 00 00 
  800420b1f6:	48 c1 e8 10          	shr    $0x10,%rax
  800420b1fa:	89 c2                	mov    %eax,%edx
  800420b1fc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b203:	00 00 00 
  800420b206:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b20d:	48 b8 b2 cd 20 04 80 	movabs $0x800420cdb2,%rax
  800420b214:	00 00 00 
  800420b217:	48 c1 e8 20          	shr    $0x20,%rax
  800420b21b:	89 c2                	mov    %eax,%edx
  800420b21d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b224:	00 00 00 
  800420b227:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b22d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b234:	00 00 00 
  800420b237:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b23e:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, XTRPX_IRQc, 0);
  800420b241:	48 b8 b8 cd 20 04 80 	movabs $0x800420cdb8,%rax
  800420b248:	00 00 00 
  800420b24b:	89 c2                	mov    %eax,%edx
  800420b24d:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b254:	00 00 00 
  800420b257:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b25e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b265:	00 00 00 
  800420b268:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b26f:	08 00 
  800420b271:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b278:	00 00 00 
  800420b27b:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b282:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b285:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b28b:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b292:	00 00 00 
  800420b295:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b29c:	83 e2 07             	and    $0x7,%edx
  800420b29f:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b2a5:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b2ac:	00 00 00 
  800420b2af:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2b6:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b2b9:	83 ca 0e             	or     $0xe,%edx
  800420b2bc:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2c2:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b2c9:	00 00 00 
  800420b2cc:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2d3:	83 e2 ef             	and    $0xffffffef,%edx
  800420b2d6:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2dc:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b2e3:	00 00 00 
  800420b2e6:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2ed:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b2f0:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2f6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b2fd:	00 00 00 
  800420b300:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b307:	83 ca 80             	or     $0xffffff80,%edx
  800420b30a:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b310:	48 b8 b8 cd 20 04 80 	movabs $0x800420cdb8,%rax
  800420b317:	00 00 00 
  800420b31a:	48 c1 e8 10          	shr    $0x10,%rax
  800420b31e:	89 c2                	mov    %eax,%edx
  800420b320:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b327:	00 00 00 
  800420b32a:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b331:	48 b8 b8 cd 20 04 80 	movabs $0x800420cdb8,%rax
  800420b338:	00 00 00 
  800420b33b:	48 c1 e8 20          	shr    $0x20,%rax
  800420b33f:	89 c2                	mov    %eax,%edx
  800420b341:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b348:	00 00 00 
  800420b34b:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b351:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b358:	00 00 00 
  800420b35b:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420b362:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, XTRPX_IRQd, 0);
  800420b365:	48 b8 be cd 20 04 80 	movabs $0x800420cdbe,%rax
  800420b36c:	00 00 00 
  800420b36f:	89 c2                	mov    %eax,%edx
  800420b371:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b378:	00 00 00 
  800420b37b:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420b382:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b389:	00 00 00 
  800420b38c:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420b393:	08 00 
  800420b395:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b39c:	00 00 00 
  800420b39f:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b3a6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b3a9:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b3af:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b3b6:	00 00 00 
  800420b3b9:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b3c0:	83 e2 07             	and    $0x7,%edx
  800420b3c3:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b3c9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b3d0:	00 00 00 
  800420b3d3:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3da:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b3dd:	83 ca 0e             	or     $0xe,%edx
  800420b3e0:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3e6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b3ed:	00 00 00 
  800420b3f0:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3f7:	83 e2 ef             	and    $0xffffffef,%edx
  800420b3fa:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b400:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b407:	00 00 00 
  800420b40a:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b411:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b414:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b41a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b421:	00 00 00 
  800420b424:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b42b:	83 ca 80             	or     $0xffffff80,%edx
  800420b42e:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b434:	48 b8 be cd 20 04 80 	movabs $0x800420cdbe,%rax
  800420b43b:	00 00 00 
  800420b43e:	48 c1 e8 10          	shr    $0x10,%rax
  800420b442:	89 c2                	mov    %eax,%edx
  800420b444:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b44b:	00 00 00 
  800420b44e:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420b455:	48 b8 be cd 20 04 80 	movabs $0x800420cdbe,%rax
  800420b45c:	00 00 00 
  800420b45f:	48 c1 e8 20          	shr    $0x20,%rax
  800420b463:	89 c2                	mov    %eax,%edx
  800420b465:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b46c:	00 00 00 
  800420b46f:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420b475:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b47c:	00 00 00 
  800420b47f:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420b486:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRPX_IRQe, 0);
  800420b489:	48 b8 c4 cd 20 04 80 	movabs $0x800420cdc4,%rax
  800420b490:	00 00 00 
  800420b493:	89 c2                	mov    %eax,%edx
  800420b495:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b49c:	00 00 00 
  800420b49f:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420b4a6:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b4ad:	00 00 00 
  800420b4b0:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420b4b7:	08 00 
  800420b4b9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b4c0:	00 00 00 
  800420b4c3:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b4ca:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b4cd:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b4d3:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b4da:	00 00 00 
  800420b4dd:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b4e4:	83 e2 07             	and    $0x7,%edx
  800420b4e7:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b4ed:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b4f4:	00 00 00 
  800420b4f7:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b4fe:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b501:	83 ca 0e             	or     $0xe,%edx
  800420b504:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b50a:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b511:	00 00 00 
  800420b514:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b51b:	83 e2 ef             	and    $0xffffffef,%edx
  800420b51e:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b524:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b52b:	00 00 00 
  800420b52e:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b535:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b538:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b53e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b545:	00 00 00 
  800420b548:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b54f:	83 ca 80             	or     $0xffffff80,%edx
  800420b552:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b558:	48 b8 c4 cd 20 04 80 	movabs $0x800420cdc4,%rax
  800420b55f:	00 00 00 
  800420b562:	48 c1 e8 10          	shr    $0x10,%rax
  800420b566:	89 c2                	mov    %eax,%edx
  800420b568:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b56f:	00 00 00 
  800420b572:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420b579:	48 b8 c4 cd 20 04 80 	movabs $0x800420cdc4,%rax
  800420b580:	00 00 00 
  800420b583:	48 c1 e8 20          	shr    $0x20,%rax
  800420b587:	89 c2                	mov    %eax,%edx
  800420b589:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b590:	00 00 00 
  800420b593:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420b599:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b5a0:	00 00 00 
  800420b5a3:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420b5aa:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, XTRPX_IRQf, 0);
  800420b5ad:	48 b8 ca cd 20 04 80 	movabs $0x800420cdca,%rax
  800420b5b4:	00 00 00 
  800420b5b7:	89 c2                	mov    %eax,%edx
  800420b5b9:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b5c0:	00 00 00 
  800420b5c3:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420b5ca:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b5d1:	00 00 00 
  800420b5d4:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420b5db:	08 00 
  800420b5dd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b5e4:	00 00 00 
  800420b5e7:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b5ee:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b5f1:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b5f7:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b5fe:	00 00 00 
  800420b601:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b608:	83 e2 07             	and    $0x7,%edx
  800420b60b:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b611:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b618:	00 00 00 
  800420b61b:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b622:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b625:	83 ca 0e             	or     $0xe,%edx
  800420b628:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b62e:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b635:	00 00 00 
  800420b638:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b63f:	83 e2 ef             	and    $0xffffffef,%edx
  800420b642:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b648:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b64f:	00 00 00 
  800420b652:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b659:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b65c:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b662:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b669:	00 00 00 
  800420b66c:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b673:	83 ca 80             	or     $0xffffff80,%edx
  800420b676:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b67c:	48 b8 ca cd 20 04 80 	movabs $0x800420cdca,%rax
  800420b683:	00 00 00 
  800420b686:	48 c1 e8 10          	shr    $0x10,%rax
  800420b68a:	89 c2                	mov    %eax,%edx
  800420b68c:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b693:	00 00 00 
  800420b696:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420b69d:	48 b8 ca cd 20 04 80 	movabs $0x800420cdca,%rax
  800420b6a4:	00 00 00 
  800420b6a7:	48 c1 e8 20          	shr    $0x20,%rax
  800420b6ab:	89 c2                	mov    %eax,%edx
  800420b6ad:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b6b4:	00 00 00 
  800420b6b7:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420b6bd:	48 b8 80 a2 60 04 80 	movabs $0x800460a280,%rax
  800420b6c4:	00 00 00 
  800420b6c7:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420b6ce:	00 00 00 
	
    idt_pd.pd_lim = sizeof(idt)-1;
  800420b6d1:	48 b8 80 b2 60 04 80 	movabs $0x800460b280,%rax
  800420b6d8:	00 00 00 
  800420b6db:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420b6e0:	48 ba 80 a2 60 04 80 	movabs $0x800460a280,%rdx
  800420b6e7:	00 00 00 
  800420b6ea:	48 b8 80 b2 60 04 80 	movabs $0x800460b280,%rax
  800420b6f1:	00 00 00 
  800420b6f4:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420b6f8:	48 b8 06 b7 20 04 80 	movabs $0x800420b706,%rax
  800420b6ff:	00 00 00 
  800420b702:	ff d0                	callq  *%rax
}
  800420b704:	5d                   	pop    %rbp
  800420b705:	c3                   	retq   

000000800420b706 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b706:	55                   	push   %rbp
  800420b707:	48 89 e5             	mov    %rsp,%rbp
  800420b70a:	53                   	push   %rbx
  800420b70b:	48 83 ec 18          	sub    $0x18,%rsp
	// LAB 4: Your code here:


	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + thiscpu->cpu_id * (KSTKSIZE+KSTKGAP);
  800420b70f:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b716:	00 00 00 
  800420b719:	ff d0                	callq  *%rax
  800420b71b:	89 c3                	mov    %eax,%ebx
  800420b71d:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b724:	00 00 00 
  800420b727:	ff d0                	callq  *%rax
  800420b729:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b730:	00 00 00 
  800420b733:	48 98                	cltq   
  800420b735:	48 c1 e0 03          	shl    $0x3,%rax
  800420b739:	48 89 c2             	mov    %rax,%rdx
  800420b73c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b740:	48 29 c2             	sub    %rax,%rdx
  800420b743:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b747:	0f b6 00             	movzbl (%rax),%eax
  800420b74a:	0f b6 d0             	movzbl %al,%edx
  800420b74d:	89 d0                	mov    %edx,%eax
  800420b74f:	01 c0                	add    %eax,%eax
  800420b751:	01 d0                	add    %edx,%eax
  800420b753:	c1 e0 0f             	shl    $0xf,%eax
  800420b756:	48 63 d0             	movslq %eax,%rdx
  800420b759:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420b760:	00 00 00 
  800420b763:	48 01 d0             	add    %rdx,%rax
  800420b766:	48 89 c1             	mov    %rax,%rcx
  800420b769:	48 be 20 f0 60 04 80 	movabs $0x800460f020,%rsi
  800420b770:	00 00 00 
  800420b773:	48 63 c3             	movslq %ebx,%rax
  800420b776:	48 c1 e0 03          	shl    $0x3,%rax
  800420b77a:	48 89 c2             	mov    %rax,%rdx
  800420b77d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b781:	48 29 c2             	sub    %rax,%rdx
  800420b784:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800420b788:	48 83 c0 10          	add    $0x10,%rax
  800420b78c:	48 89 48 04          	mov    %rcx,0x4(%rax)
	//	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *) (&gdt[(GD_TSS0>>3) + (thiscpu->cpu_id*2)]),STS_T64A,
  800420b790:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b797:	00 00 00 
  800420b79a:	ff d0                	callq  *%rax
  800420b79c:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b7a3:	00 00 00 
  800420b7a6:	48 98                	cltq   
  800420b7a8:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7ac:	48 89 c2             	mov    %rax,%rdx
  800420b7af:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b7b3:	48 29 c2             	sub    %rax,%rdx
  800420b7b6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b7ba:	0f b6 00             	movzbl (%rax),%eax
  800420b7bd:	0f b6 c0             	movzbl %al,%eax
  800420b7c0:	01 c0                	add    %eax,%eax
  800420b7c2:	83 c0 05             	add    $0x5,%eax
  800420b7c5:	48 98                	cltq   
  800420b7c7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b7ce:	00 
  800420b7cf:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b7d6:	00 00 00 
  800420b7d9:	48 01 d0             	add    %rdx,%rax
  800420b7dc:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b7e1:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b7e8:	00 00 00 
  800420b7eb:	ff d0                	callq  *%rax
  800420b7ed:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b7f4:	00 00 00 
  800420b7f7:	48 98                	cltq   
  800420b7f9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7fd:	48 89 c2             	mov    %rax,%rdx
  800420b800:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b804:	48 29 c2             	sub    %rax,%rdx
  800420b807:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b80b:	0f b6 00             	movzbl (%rax),%eax
  800420b80e:	0f b6 c0             	movzbl %al,%eax
  800420b811:	01 c0                	add    %eax,%eax
  800420b813:	83 c0 05             	add    $0x5,%eax
  800420b816:	48 98                	cltq   
  800420b818:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b81f:	00 
  800420b820:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b827:	00 00 00 
  800420b82a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b82e:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b835:	00 00 00 
  800420b838:	ff d0                	callq  *%rax
  800420b83a:	48 98                	cltq   
  800420b83c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b840:	48 89 c2             	mov    %rax,%rdx
  800420b843:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b847:	48 29 c2             	sub    %rax,%rdx
  800420b84a:	48 83 c2 10          	add    $0x10,%rdx
  800420b84e:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420b855:	00 00 00 
  800420b858:	48 01 d0             	add    %rdx,%rax
  800420b85b:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420b85f:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b866:	00 00 00 
  800420b869:	ff d0                	callq  *%rax
  800420b86b:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b872:	00 00 00 
  800420b875:	48 98                	cltq   
  800420b877:	48 c1 e0 03          	shl    $0x3,%rax
  800420b87b:	48 89 c2             	mov    %rax,%rdx
  800420b87e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b882:	48 29 c2             	sub    %rax,%rdx
  800420b885:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b889:	0f b6 00             	movzbl (%rax),%eax
  800420b88c:	0f b6 c0             	movzbl %al,%eax
  800420b88f:	01 c0                	add    %eax,%eax
  800420b891:	83 c0 05             	add    $0x5,%eax
  800420b894:	48 98                	cltq   
  800420b896:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b89d:	00 
  800420b89e:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b8a5:	00 00 00 
  800420b8a8:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b8ac:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b8b3:	00 00 00 
  800420b8b6:	ff d0                	callq  *%rax
  800420b8b8:	48 98                	cltq   
  800420b8ba:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8be:	48 89 c2             	mov    %rax,%rdx
  800420b8c1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8c5:	48 29 c2             	sub    %rax,%rdx
  800420b8c8:	48 83 c2 10          	add    $0x10,%rdx
  800420b8cc:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420b8d3:	00 00 00 
  800420b8d6:	48 01 d0             	add    %rdx,%rax
  800420b8d9:	48 c1 e8 10          	shr    $0x10,%rax
  800420b8dd:	88 43 04             	mov    %al,0x4(%rbx)
  800420b8e0:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b8e7:	00 00 00 
  800420b8ea:	ff d0                	callq  *%rax
  800420b8ec:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b8f3:	00 00 00 
  800420b8f6:	48 98                	cltq   
  800420b8f8:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8fc:	48 89 c2             	mov    %rax,%rdx
  800420b8ff:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b903:	48 29 c2             	sub    %rax,%rdx
  800420b906:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b90a:	0f b6 00             	movzbl (%rax),%eax
  800420b90d:	0f b6 c0             	movzbl %al,%eax
  800420b910:	01 c0                	add    %eax,%eax
  800420b912:	83 c0 05             	add    $0x5,%eax
  800420b915:	48 98                	cltq   
  800420b917:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b91e:	00 
  800420b91f:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b926:	00 00 00 
  800420b929:	48 01 d0             	add    %rdx,%rax
  800420b92c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b930:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b933:	83 ca 09             	or     $0x9,%edx
  800420b936:	88 50 05             	mov    %dl,0x5(%rax)
  800420b939:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b940:	00 00 00 
  800420b943:	ff d0                	callq  *%rax
  800420b945:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b94c:	00 00 00 
  800420b94f:	48 98                	cltq   
  800420b951:	48 c1 e0 03          	shl    $0x3,%rax
  800420b955:	48 89 c2             	mov    %rax,%rdx
  800420b958:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b95c:	48 29 c2             	sub    %rax,%rdx
  800420b95f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b963:	0f b6 00             	movzbl (%rax),%eax
  800420b966:	0f b6 c0             	movzbl %al,%eax
  800420b969:	01 c0                	add    %eax,%eax
  800420b96b:	83 c0 05             	add    $0x5,%eax
  800420b96e:	48 98                	cltq   
  800420b970:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b977:	00 
  800420b978:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b97f:	00 00 00 
  800420b982:	48 01 d0             	add    %rdx,%rax
  800420b985:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b989:	83 e2 ef             	and    $0xffffffef,%edx
  800420b98c:	88 50 05             	mov    %dl,0x5(%rax)
  800420b98f:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b996:	00 00 00 
  800420b999:	ff d0                	callq  *%rax
  800420b99b:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b9a2:	00 00 00 
  800420b9a5:	48 98                	cltq   
  800420b9a7:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9ab:	48 89 c2             	mov    %rax,%rdx
  800420b9ae:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9b2:	48 29 c2             	sub    %rax,%rdx
  800420b9b5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b9b9:	0f b6 00             	movzbl (%rax),%eax
  800420b9bc:	0f b6 c0             	movzbl %al,%eax
  800420b9bf:	01 c0                	add    %eax,%eax
  800420b9c1:	83 c0 05             	add    $0x5,%eax
  800420b9c4:	48 98                	cltq   
  800420b9c6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b9cd:	00 
  800420b9ce:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420b9d5:	00 00 00 
  800420b9d8:	48 01 d0             	add    %rdx,%rax
  800420b9db:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b9df:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b9e2:	88 50 05             	mov    %dl,0x5(%rax)
  800420b9e5:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420b9ec:	00 00 00 
  800420b9ef:	ff d0                	callq  *%rax
  800420b9f1:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420b9f8:	00 00 00 
  800420b9fb:	48 98                	cltq   
  800420b9fd:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba01:	48 89 c2             	mov    %rax,%rdx
  800420ba04:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba08:	48 29 c2             	sub    %rax,%rdx
  800420ba0b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba0f:	0f b6 00             	movzbl (%rax),%eax
  800420ba12:	0f b6 c0             	movzbl %al,%eax
  800420ba15:	01 c0                	add    %eax,%eax
  800420ba17:	83 c0 05             	add    $0x5,%eax
  800420ba1a:	48 98                	cltq   
  800420ba1c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba23:	00 
  800420ba24:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420ba2b:	00 00 00 
  800420ba2e:	48 01 d0             	add    %rdx,%rax
  800420ba31:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420ba35:	83 ca 80             	or     $0xffffff80,%edx
  800420ba38:	88 50 05             	mov    %dl,0x5(%rax)
  800420ba3b:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420ba42:	00 00 00 
  800420ba45:	ff d0                	callq  *%rax
  800420ba47:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420ba4e:	00 00 00 
  800420ba51:	48 98                	cltq   
  800420ba53:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba57:	48 89 c2             	mov    %rax,%rdx
  800420ba5a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba5e:	48 29 c2             	sub    %rax,%rdx
  800420ba61:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba65:	0f b6 00             	movzbl (%rax),%eax
  800420ba68:	0f b6 c0             	movzbl %al,%eax
  800420ba6b:	01 c0                	add    %eax,%eax
  800420ba6d:	83 c0 05             	add    $0x5,%eax
  800420ba70:	48 98                	cltq   
  800420ba72:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba79:	00 
  800420ba7a:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420ba81:	00 00 00 
  800420ba84:	48 01 d0             	add    %rdx,%rax
  800420ba87:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ba8b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba8e:	88 50 06             	mov    %dl,0x6(%rax)
  800420ba91:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420ba98:	00 00 00 
  800420ba9b:	ff d0                	callq  *%rax
  800420ba9d:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420baa4:	00 00 00 
  800420baa7:	48 98                	cltq   
  800420baa9:	48 c1 e0 03          	shl    $0x3,%rax
  800420baad:	48 89 c2             	mov    %rax,%rdx
  800420bab0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bab4:	48 29 c2             	sub    %rax,%rdx
  800420bab7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420babb:	0f b6 00             	movzbl (%rax),%eax
  800420babe:	0f b6 c0             	movzbl %al,%eax
  800420bac1:	01 c0                	add    %eax,%eax
  800420bac3:	83 c0 05             	add    $0x5,%eax
  800420bac6:	48 98                	cltq   
  800420bac8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bacf:	00 
  800420bad0:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bad7:	00 00 00 
  800420bada:	48 01 d0             	add    %rdx,%rax
  800420badd:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bae1:	83 e2 ef             	and    $0xffffffef,%edx
  800420bae4:	88 50 06             	mov    %dl,0x6(%rax)
  800420bae7:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420baee:	00 00 00 
  800420baf1:	ff d0                	callq  *%rax
  800420baf3:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bafa:	00 00 00 
  800420bafd:	48 98                	cltq   
  800420baff:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb03:	48 89 c2             	mov    %rax,%rdx
  800420bb06:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb0a:	48 29 c2             	sub    %rax,%rdx
  800420bb0d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb11:	0f b6 00             	movzbl (%rax),%eax
  800420bb14:	0f b6 c0             	movzbl %al,%eax
  800420bb17:	01 c0                	add    %eax,%eax
  800420bb19:	83 c0 05             	add    $0x5,%eax
  800420bb1c:	48 98                	cltq   
  800420bb1e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb25:	00 
  800420bb26:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bb2d:	00 00 00 
  800420bb30:	48 01 d0             	add    %rdx,%rax
  800420bb33:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bb37:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb3a:	88 50 06             	mov    %dl,0x6(%rax)
  800420bb3d:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bb44:	00 00 00 
  800420bb47:	ff d0                	callq  *%rax
  800420bb49:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bb50:	00 00 00 
  800420bb53:	48 98                	cltq   
  800420bb55:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb59:	48 89 c2             	mov    %rax,%rdx
  800420bb5c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb60:	48 29 c2             	sub    %rax,%rdx
  800420bb63:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb67:	0f b6 00             	movzbl (%rax),%eax
  800420bb6a:	0f b6 c0             	movzbl %al,%eax
  800420bb6d:	01 c0                	add    %eax,%eax
  800420bb6f:	83 c0 05             	add    $0x5,%eax
  800420bb72:	48 98                	cltq   
  800420bb74:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb7b:	00 
  800420bb7c:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bb83:	00 00 00 
  800420bb86:	48 01 d0             	add    %rdx,%rax
  800420bb89:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bb8d:	83 e2 7f             	and    $0x7f,%edx
  800420bb90:	88 50 06             	mov    %dl,0x6(%rax)
  800420bb93:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bb9a:	00 00 00 
  800420bb9d:	ff d0                	callq  *%rax
  800420bb9f:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bba6:	00 00 00 
  800420bba9:	48 98                	cltq   
  800420bbab:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbaf:	48 89 c2             	mov    %rax,%rdx
  800420bbb2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbb6:	48 29 c2             	sub    %rax,%rdx
  800420bbb9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bbbd:	0f b6 00             	movzbl (%rax),%eax
  800420bbc0:	0f b6 c0             	movzbl %al,%eax
  800420bbc3:	01 c0                	add    %eax,%eax
  800420bbc5:	83 c0 05             	add    $0x5,%eax
  800420bbc8:	48 98                	cltq   
  800420bbca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bbd1:	00 
  800420bbd2:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bbd9:	00 00 00 
  800420bbdc:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bbe0:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bbe7:	00 00 00 
  800420bbea:	ff d0                	callq  *%rax
  800420bbec:	48 98                	cltq   
  800420bbee:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbf2:	48 89 c2             	mov    %rax,%rdx
  800420bbf5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbf9:	48 29 c2             	sub    %rax,%rdx
  800420bbfc:	48 83 c2 10          	add    $0x10,%rdx
  800420bc00:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420bc07:	00 00 00 
  800420bc0a:	48 01 d0             	add    %rdx,%rax
  800420bc0d:	48 c1 e8 18          	shr    $0x18,%rax
  800420bc11:	88 43 07             	mov    %al,0x7(%rbx)
  800420bc14:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bc1b:	00 00 00 
  800420bc1e:	ff d0                	callq  *%rax
  800420bc20:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bc27:	00 00 00 
  800420bc2a:	48 98                	cltq   
  800420bc2c:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc30:	48 89 c2             	mov    %rax,%rdx
  800420bc33:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc37:	48 29 c2             	sub    %rax,%rdx
  800420bc3a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc3e:	0f b6 00             	movzbl (%rax),%eax
  800420bc41:	0f b6 c0             	movzbl %al,%eax
  800420bc44:	01 c0                	add    %eax,%eax
  800420bc46:	83 c0 05             	add    $0x5,%eax
  800420bc49:	48 98                	cltq   
  800420bc4b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc52:	00 
  800420bc53:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bc5a:	00 00 00 
  800420bc5d:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bc61:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bc68:	00 00 00 
  800420bc6b:	ff d0                	callq  *%rax
  800420bc6d:	48 98                	cltq   
  800420bc6f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc73:	48 89 c2             	mov    %rax,%rdx
  800420bc76:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc7a:	48 29 c2             	sub    %rax,%rdx
  800420bc7d:	48 83 c2 10          	add    $0x10,%rdx
  800420bc81:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420bc88:	00 00 00 
  800420bc8b:	48 01 d0             	add    %rdx,%rax
  800420bc8e:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc92:	89 43 08             	mov    %eax,0x8(%rbx)
  800420bc95:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bc9c:	00 00 00 
  800420bc9f:	ff d0                	callq  *%rax
  800420bca1:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bca8:	00 00 00 
  800420bcab:	48 98                	cltq   
  800420bcad:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcb1:	48 89 c2             	mov    %rax,%rdx
  800420bcb4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bcb8:	48 29 c2             	sub    %rax,%rdx
  800420bcbb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bcbf:	0f b6 00             	movzbl (%rax),%eax
  800420bcc2:	0f b6 c0             	movzbl %al,%eax
  800420bcc5:	01 c0                	add    %eax,%eax
  800420bcc7:	83 c0 05             	add    $0x5,%eax
  800420bcca:	48 98                	cltq   
  800420bccc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bcd3:	00 
  800420bcd4:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bcdb:	00 00 00 
  800420bcde:	48 01 d0             	add    %rdx,%rax
  800420bce1:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420bce5:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bcec:	00 00 00 
  800420bcef:	ff d0                	callq  *%rax
  800420bcf1:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bcf8:	00 00 00 
  800420bcfb:	48 98                	cltq   
  800420bcfd:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd01:	48 89 c2             	mov    %rax,%rdx
  800420bd04:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd08:	48 29 c2             	sub    %rax,%rdx
  800420bd0b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd0f:	0f b6 00             	movzbl (%rax),%eax
  800420bd12:	0f b6 c0             	movzbl %al,%eax
  800420bd15:	01 c0                	add    %eax,%eax
  800420bd17:	83 c0 05             	add    $0x5,%eax
  800420bd1a:	48 98                	cltq   
  800420bd1c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd23:	00 
  800420bd24:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bd2b:	00 00 00 
  800420bd2e:	48 01 d0             	add    %rdx,%rax
  800420bd31:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420bd35:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bd3c:	00 00 00 
  800420bd3f:	ff d0                	callq  *%rax
  800420bd41:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bd48:	00 00 00 
  800420bd4b:	48 98                	cltq   
  800420bd4d:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd51:	48 89 c2             	mov    %rax,%rdx
  800420bd54:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd58:	48 29 c2             	sub    %rax,%rdx
  800420bd5b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd5f:	0f b6 00             	movzbl (%rax),%eax
  800420bd62:	0f b6 c0             	movzbl %al,%eax
  800420bd65:	01 c0                	add    %eax,%eax
  800420bd67:	83 c0 05             	add    $0x5,%eax
  800420bd6a:	48 98                	cltq   
  800420bd6c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd73:	00 
  800420bd74:	48 b8 e0 e5 22 04 80 	movabs $0x800422e5e0,%rax
  800420bd7b:	00 00 00 
  800420bd7e:	48 01 d0             	add    %rdx,%rax
  800420bd81:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
				(uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(((GD_TSS0>>3) + (thiscpu->cpu_id*2))*8);
  800420bd87:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bd8e:	00 00 00 
  800420bd91:	ff d0                	callq  *%rax
  800420bd93:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420bd9a:	00 00 00 
  800420bd9d:	48 98                	cltq   
  800420bd9f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bda3:	48 89 c2             	mov    %rax,%rdx
  800420bda6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bdaa:	48 29 c2             	sub    %rax,%rdx
  800420bdad:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bdb1:	0f b6 00             	movzbl (%rax),%eax
  800420bdb4:	0f b6 c0             	movzbl %al,%eax
  800420bdb7:	c1 e0 04             	shl    $0x4,%eax
  800420bdba:	83 c0 28             	add    $0x28,%eax
  800420bdbd:	0f b7 c0             	movzwl %ax,%eax
  800420bdc0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420bdc4:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420bdc8:	0f 00 d8             	ltr    %ax
  800420bdcb:	48 b8 80 b2 60 04 80 	movabs $0x800460b280,%rax
  800420bdd2:	00 00 00 
  800420bdd5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420bdd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bddd:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420bde0:	48 83 c4 18          	add    $0x18,%rsp
  800420bde4:	5b                   	pop    %rbx
  800420bde5:	5d                   	pop    %rbp
  800420bde6:	c3                   	retq   

000000800420bde7 <print_trapframe>:
void
print_trapframe(struct Trapframe *tf)
{
  800420bde7:	55                   	push   %rbp
  800420bde8:	48 89 e5             	mov    %rsp,%rbp
  800420bdeb:	48 83 ec 20          	sub    $0x20,%rsp
  800420bdef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420bdf3:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420bdfa:	00 00 00 
  800420bdfd:	ff d0                	callq  *%rax
  800420bdff:	89 c2                	mov    %eax,%edx
  800420be01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be05:	48 89 c6             	mov    %rax,%rsi
  800420be08:	48 bf 6e 98 21 04 80 	movabs $0x800421986e,%rdi
  800420be0f:	00 00 00 
  800420be12:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be17:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420be1e:	00 00 00 
  800420be21:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420be23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be27:	48 89 c7             	mov    %rax,%rdi
  800420be2a:	48 b8 f8 c0 20 04 80 	movabs $0x800420c0f8,%rax
  800420be31:	00 00 00 
  800420be34:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420be36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be3a:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420be3e:	0f b7 c0             	movzwl %ax,%eax
  800420be41:	89 c6                	mov    %eax,%esi
  800420be43:	48 bf 8c 98 21 04 80 	movabs $0x800421988c,%rdi
  800420be4a:	00 00 00 
  800420be4d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be52:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420be59:	00 00 00 
  800420be5c:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420be5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be62:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420be69:	0f b7 c0             	movzwl %ax,%eax
  800420be6c:	89 c6                	mov    %eax,%esi
  800420be6e:	48 bf 9f 98 21 04 80 	movabs $0x800421989f,%rdi
  800420be75:	00 00 00 
  800420be78:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be7d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420be84:	00 00 00 
  800420be87:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420be89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be8d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420be94:	89 c7                	mov    %eax,%edi
  800420be96:	48 b8 f7 8e 20 04 80 	movabs $0x8004208ef7,%rax
  800420be9d:	00 00 00 
  800420bea0:	ff d0                	callq  *%rax
  800420bea2:	48 89 c2             	mov    %rax,%rdx
  800420bea5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bea9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420beb0:	48 89 c6             	mov    %rax,%rsi
  800420beb3:	48 bf b2 98 21 04 80 	movabs $0x80042198b2,%rdi
  800420beba:	00 00 00 
  800420bebd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bec2:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420bec9:	00 00 00 
  800420becc:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420bece:	48 b8 90 b2 60 04 80 	movabs $0x800460b290,%rax
  800420bed5:	00 00 00 
  800420bed8:	48 8b 00             	mov    (%rax),%rax
  800420bedb:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420bedf:	75 3a                	jne    800420bf1b <print_trapframe+0x134>
  800420bee1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bee5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420beec:	48 83 f8 0e          	cmp    $0xe,%rax
  800420bef0:	75 29                	jne    800420bf1b <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bef2:	0f 20 d0             	mov    %cr2,%rax
  800420bef5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420bef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420befd:	48 89 c6             	mov    %rax,%rsi
  800420bf00:	48 bf c4 98 21 04 80 	movabs $0x80042198c4,%rdi
  800420bf07:	00 00 00 
  800420bf0a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf0f:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420bf16:	00 00 00 
  800420bf19:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420bf1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf1f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf26:	48 89 c6             	mov    %rax,%rsi
  800420bf29:	48 bf d3 98 21 04 80 	movabs $0x80042198d3,%rdi
  800420bf30:	00 00 00 
  800420bf33:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf38:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420bf3f:	00 00 00 
  800420bf42:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420bf44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf48:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420bf4f:	48 83 f8 0e          	cmp    $0xe,%rax
  800420bf53:	0f 85 9c 00 00 00    	jne    800420bff5 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420bf59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf5d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf64:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf67:	48 85 c0             	test   %rax,%rax
  800420bf6a:	74 0c                	je     800420bf78 <print_trapframe+0x191>
  800420bf6c:	48 b9 e1 98 21 04 80 	movabs $0x80042198e1,%rcx
  800420bf73:	00 00 00 
  800420bf76:	eb 0a                	jmp    800420bf82 <print_trapframe+0x19b>
  800420bf78:	48 b9 ec 98 21 04 80 	movabs $0x80042198ec,%rcx
  800420bf7f:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420bf82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf86:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf8d:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf90:	48 85 c0             	test   %rax,%rax
  800420bf93:	74 0c                	je     800420bfa1 <print_trapframe+0x1ba>
  800420bf95:	48 ba f8 98 21 04 80 	movabs $0x80042198f8,%rdx
  800420bf9c:	00 00 00 
  800420bf9f:	eb 0a                	jmp    800420bfab <print_trapframe+0x1c4>
  800420bfa1:	48 ba fe 98 21 04 80 	movabs $0x80042198fe,%rdx
  800420bfa8:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420bfab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bfaf:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bfb6:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bfb9:	48 85 c0             	test   %rax,%rax
  800420bfbc:	74 0c                	je     800420bfca <print_trapframe+0x1e3>
  800420bfbe:	48 b8 03 99 21 04 80 	movabs $0x8004219903,%rax
  800420bfc5:	00 00 00 
  800420bfc8:	eb 0a                	jmp    800420bfd4 <print_trapframe+0x1ed>
  800420bfca:	48 b8 08 99 21 04 80 	movabs $0x8004219908,%rax
  800420bfd1:	00 00 00 
  800420bfd4:	48 89 c6             	mov    %rax,%rsi
  800420bfd7:	48 bf 0f 99 21 04 80 	movabs $0x800421990f,%rdi
  800420bfde:	00 00 00 
  800420bfe1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfe6:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  800420bfed:	00 00 00 
  800420bff0:	41 ff d0             	callq  *%r8
  800420bff3:	eb 1b                	jmp    800420c010 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420bff5:	48 bf 1e 99 21 04 80 	movabs $0x800421991e,%rdi
  800420bffc:	00 00 00 
  800420bfff:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c004:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c00b:	00 00 00 
  800420c00e:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c010:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c014:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c01b:	48 89 c6             	mov    %rax,%rsi
  800420c01e:	48 bf 20 99 21 04 80 	movabs $0x8004219920,%rdi
  800420c025:	00 00 00 
  800420c028:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c02d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c034:	00 00 00 
  800420c037:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c039:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c03d:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c044:	0f b7 c0             	movzwl %ax,%eax
  800420c047:	89 c6                	mov    %eax,%esi
  800420c049:	48 bf 2f 99 21 04 80 	movabs $0x800421992f,%rdi
  800420c050:	00 00 00 
  800420c053:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c058:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c05f:	00 00 00 
  800420c062:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c064:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c068:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c06f:	48 89 c6             	mov    %rax,%rsi
  800420c072:	48 bf 42 99 21 04 80 	movabs $0x8004219942,%rdi
  800420c079:	00 00 00 
  800420c07c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c081:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c088:	00 00 00 
  800420c08b:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c08d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c091:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c098:	0f b7 c0             	movzwl %ax,%eax
  800420c09b:	83 e0 03             	and    $0x3,%eax
  800420c09e:	85 c0                	test   %eax,%eax
  800420c0a0:	74 54                	je     800420c0f6 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c0a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0a6:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c0ad:	48 89 c6             	mov    %rax,%rsi
  800420c0b0:	48 bf 51 99 21 04 80 	movabs $0x8004219951,%rdi
  800420c0b7:	00 00 00 
  800420c0ba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0bf:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c0c6:	00 00 00 
  800420c0c9:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c0cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0cf:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c0d6:	0f b7 c0             	movzwl %ax,%eax
  800420c0d9:	89 c6                	mov    %eax,%esi
  800420c0db:	48 bf 60 99 21 04 80 	movabs $0x8004219960,%rdi
  800420c0e2:	00 00 00 
  800420c0e5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0ea:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c0f1:	00 00 00 
  800420c0f4:	ff d2                	callq  *%rdx
	}
}
  800420c0f6:	c9                   	leaveq 
  800420c0f7:	c3                   	retq   

000000800420c0f8 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c0f8:	55                   	push   %rbp
  800420c0f9:	48 89 e5             	mov    %rsp,%rbp
  800420c0fc:	48 83 ec 10          	sub    $0x10,%rsp
  800420c100:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c104:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c108:	48 8b 00             	mov    (%rax),%rax
  800420c10b:	48 89 c6             	mov    %rax,%rsi
  800420c10e:	48 bf 73 99 21 04 80 	movabs $0x8004219973,%rdi
  800420c115:	00 00 00 
  800420c118:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c11d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c124:	00 00 00 
  800420c127:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c12d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c131:	48 89 c6             	mov    %rax,%rsi
  800420c134:	48 bf 82 99 21 04 80 	movabs $0x8004219982,%rdi
  800420c13b:	00 00 00 
  800420c13e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c143:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c14a:	00 00 00 
  800420c14d:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c14f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c153:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c157:	48 89 c6             	mov    %rax,%rsi
  800420c15a:	48 bf 91 99 21 04 80 	movabs $0x8004219991,%rdi
  800420c161:	00 00 00 
  800420c164:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c169:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c170:	00 00 00 
  800420c173:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c175:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c179:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c17d:	48 89 c6             	mov    %rax,%rsi
  800420c180:	48 bf a0 99 21 04 80 	movabs $0x80042199a0,%rdi
  800420c187:	00 00 00 
  800420c18a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c18f:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c196:	00 00 00 
  800420c199:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c19b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c19f:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c1a3:	48 89 c6             	mov    %rax,%rsi
  800420c1a6:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  800420c1ad:	00 00 00 
  800420c1b0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1b5:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c1bc:	00 00 00 
  800420c1bf:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c1c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1c5:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c1c9:	48 89 c6             	mov    %rax,%rsi
  800420c1cc:	48 bf be 99 21 04 80 	movabs $0x80042199be,%rdi
  800420c1d3:	00 00 00 
  800420c1d6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1db:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c1e2:	00 00 00 
  800420c1e5:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c1e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1eb:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c1ef:	48 89 c6             	mov    %rax,%rsi
  800420c1f2:	48 bf cd 99 21 04 80 	movabs $0x80042199cd,%rdi
  800420c1f9:	00 00 00 
  800420c1fc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c201:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c208:	00 00 00 
  800420c20b:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c20d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c211:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c215:	48 89 c6             	mov    %rax,%rsi
  800420c218:	48 bf db 99 21 04 80 	movabs $0x80042199db,%rdi
  800420c21f:	00 00 00 
  800420c222:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c227:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c22e:	00 00 00 
  800420c231:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c233:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c237:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c23b:	48 89 c6             	mov    %rax,%rsi
  800420c23e:	48 bf e9 99 21 04 80 	movabs $0x80042199e9,%rdi
  800420c245:	00 00 00 
  800420c248:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c24d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c254:	00 00 00 
  800420c257:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c259:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c25d:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c261:	48 89 c6             	mov    %rax,%rsi
  800420c264:	48 bf f8 99 21 04 80 	movabs $0x80042199f8,%rdi
  800420c26b:	00 00 00 
  800420c26e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c273:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c27a:	00 00 00 
  800420c27d:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c27f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c283:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c287:	48 89 c6             	mov    %rax,%rsi
  800420c28a:	48 bf 07 9a 21 04 80 	movabs $0x8004219a07,%rdi
  800420c291:	00 00 00 
  800420c294:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c299:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c2a0:	00 00 00 
  800420c2a3:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c2a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2a9:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c2ad:	48 89 c6             	mov    %rax,%rsi
  800420c2b0:	48 bf 16 9a 21 04 80 	movabs $0x8004219a16,%rdi
  800420c2b7:	00 00 00 
  800420c2ba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2bf:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c2c6:	00 00 00 
  800420c2c9:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c2cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2cf:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c2d3:	48 89 c6             	mov    %rax,%rsi
  800420c2d6:	48 bf 25 9a 21 04 80 	movabs $0x8004219a25,%rdi
  800420c2dd:	00 00 00 
  800420c2e0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2e5:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c2ec:	00 00 00 
  800420c2ef:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c2f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2f5:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c2f9:	48 89 c6             	mov    %rax,%rsi
  800420c2fc:	48 bf 34 9a 21 04 80 	movabs $0x8004219a34,%rdi
  800420c303:	00 00 00 
  800420c306:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c30b:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c312:	00 00 00 
  800420c315:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c317:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c31b:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c31f:	48 89 c6             	mov    %rax,%rsi
  800420c322:	48 bf 43 9a 21 04 80 	movabs $0x8004219a43,%rdi
  800420c329:	00 00 00 
  800420c32c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c331:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c338:	00 00 00 
  800420c33b:	ff d2                	callq  *%rdx
}
  800420c33d:	c9                   	leaveq 
  800420c33e:	c3                   	retq   

000000800420c33f <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c33f:	55                   	push   %rbp
  800420c340:	48 89 e5             	mov    %rsp,%rbp
  800420c343:	48 83 ec 10          	sub    $0x10,%rsp
  800420c347:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	//print_trapframe(tf);
	if(tf->tf_trapno == T_PGFLT)
  800420c34b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c34f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c356:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c35a:	75 18                	jne    800420c374 <trap_dispatch+0x35>
    {
        page_fault_handler(tf);
  800420c35c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c360:	48 89 c7             	mov    %rax,%rdi
  800420c363:	48 b8 c6 c8 20 04 80 	movabs $0x800420c8c6,%rax
  800420c36a:	00 00 00 
  800420c36d:	ff d0                	callq  *%rax
  800420c36f:	e9 8c 00 00 00       	jmpq   800420c400 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_BRKPT)
  800420c374:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c378:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c37f:	48 83 f8 03          	cmp    $0x3,%rax
  800420c383:	75 15                	jne    800420c39a <trap_dispatch+0x5b>
    {
        monitor(tf);
  800420c385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c389:	48 89 c7             	mov    %rax,%rdi
  800420c38c:	48 b8 49 1b 20 04 80 	movabs $0x8004201b49,%rax
  800420c393:	00 00 00 
  800420c396:	ff d0                	callq  *%rax
  800420c398:	eb 66                	jmp    800420c400 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_SYSCALL)
  800420c39a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c39e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c3a5:	48 83 f8 30          	cmp    $0x30,%rax
  800420c3a9:	75 55                	jne    800420c400 <trap_dispatch+0xc1>
    {
        tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx,
  800420c3ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3af:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c3b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3b7:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c3bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3bf:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c3c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3c7:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c3cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3cf:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c3d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3d7:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c3db:	4d 89 c1             	mov    %r8,%r9
  800420c3de:	49 89 f8             	mov    %rdi,%r8
  800420c3e1:	48 89 c7             	mov    %rax,%rdi
  800420c3e4:	48 b8 00 dd 20 04 80 	movabs $0x800420dd00,%rax
  800420c3eb:	00 00 00 
  800420c3ee:	ff d0                	callq  *%rax
  800420c3f0:	48 89 c2             	mov    %rax,%rdx
  800420c3f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3f7:	48 89 50 70          	mov    %rdx,0x70(%rax)
                        tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx,
                        tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
        return;
  800420c3fb:	e9 5a 01 00 00       	jmpq   800420c55a <trap_dispatch+0x21b>
    }

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c400:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c404:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c40b:	48 83 f8 27          	cmp    $0x27,%rax
  800420c40f:	75 33                	jne    800420c444 <trap_dispatch+0x105>
		cprintf("Spurious interrupt on irq 7\n");
  800420c411:	48 bf 52 9a 21 04 80 	movabs $0x8004219a52,%rdi
  800420c418:	00 00 00 
  800420c41b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c420:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c427:	00 00 00 
  800420c42a:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c42c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c430:	48 89 c7             	mov    %rax,%rdi
  800420c433:	48 b8 e7 bd 20 04 80 	movabs $0x800420bde7,%rax
  800420c43a:	00 00 00 
  800420c43d:	ff d0                	callq  *%rax
		return;
  800420c43f:	e9 16 01 00 00       	jmpq   800420c55a <trap_dispatch+0x21b>
	// triggered on every CPU.
	// LAB 6: Your code here.

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_TIMER))
  800420c444:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c448:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c44f:	48 83 f8 20          	cmp    $0x20,%rax
  800420c453:	75 24                	jne    800420c479 <trap_dispatch+0x13a>
	{
		time_tick();
  800420c455:	48 b8 f0 83 21 04 80 	movabs $0x80042183f0,%rax
  800420c45c:	00 00 00 
  800420c45f:	ff d0                	callq  *%rax
		lapic_eoi();
  800420c461:	48 b8 26 6a 21 04 80 	movabs $0x8004216a26,%rax
  800420c468:	00 00 00 
  800420c46b:	ff d0                	callq  *%rax
		sched_yield();
  800420c46d:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420c474:	00 00 00 
  800420c477:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_KBD))
  800420c479:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c47d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c484:	48 83 f8 21          	cmp    $0x21,%rax
  800420c488:	75 18                	jne    800420c4a2 <trap_dispatch+0x163>
	{
		kbd_intr();
  800420c48a:	48 b8 41 10 20 04 80 	movabs $0x8004201041,%rax
  800420c491:	00 00 00 
  800420c494:	ff d0                	callq  *%rax
		sched_yield();
  800420c496:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420c49d:	00 00 00 
  800420c4a0:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_SERIAL))
  800420c4a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4a6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c4ad:	48 83 f8 24          	cmp    $0x24,%rax
  800420c4b1:	75 18                	jne    800420c4cb <trap_dispatch+0x18c>
	{
		serial_intr();
  800420c4b3:	48 b8 f2 07 20 04 80 	movabs $0x80042007f2,%rax
  800420c4ba:	00 00 00 
  800420c4bd:	ff d0                	callq  *%rax
		sched_yield();
  800420c4bf:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420c4c6:	00 00 00 
  800420c4c9:	ff d0                	callq  *%rax
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420c4cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4cf:	48 89 c7             	mov    %rax,%rdi
  800420c4d2:	48 b8 e7 bd 20 04 80 	movabs $0x800420bde7,%rax
  800420c4d9:	00 00 00 
  800420c4dc:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420c4de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4e2:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c4e9:	66 83 f8 08          	cmp    $0x8,%ax
  800420c4ed:	75 2a                	jne    800420c519 <trap_dispatch+0x1da>
		panic("unhandled trap in kernel");
  800420c4ef:	48 ba 6f 9a 21 04 80 	movabs $0x8004219a6f,%rdx
  800420c4f6:	00 00 00 
  800420c4f9:	be 15 01 00 00       	mov    $0x115,%esi
  800420c4fe:	48 bf 88 9a 21 04 80 	movabs $0x8004219a88,%rdi
  800420c505:	00 00 00 
  800420c508:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c50d:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  800420c514:	00 00 00 
  800420c517:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420c519:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c520:	00 00 00 
  800420c523:	ff d0                	callq  *%rax
  800420c525:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c52c:	00 00 00 
  800420c52f:	48 98                	cltq   
  800420c531:	48 c1 e0 03          	shl    $0x3,%rax
  800420c535:	48 89 c2             	mov    %rax,%rdx
  800420c538:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c53c:	48 29 c2             	sub    %rax,%rdx
  800420c53f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c543:	48 83 c0 08          	add    $0x8,%rax
  800420c547:	48 8b 00             	mov    (%rax),%rax
  800420c54a:	48 89 c7             	mov    %rax,%rdi
  800420c54d:	48 b8 d4 85 20 04 80 	movabs $0x80042085d4,%rax
  800420c554:	00 00 00 
  800420c557:	ff d0                	callq  *%rax
		return;
  800420c559:	90                   	nop
	}
}
  800420c55a:	c9                   	leaveq 
  800420c55b:	c3                   	retq   

000000800420c55c <trap>:

void
trap(struct Trapframe *tf)
{
  800420c55c:	55                   	push   %rbp
  800420c55d:	48 89 e5             	mov    %rsp,%rbp
  800420c560:	48 83 ec 20          	sub    $0x20,%rsp
  800420c564:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environmentmay have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c568:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c569:	48 b8 40 d4 60 04 80 	movabs $0x800460d440,%rax
  800420c570:	00 00 00 
  800420c573:	48 8b 00             	mov    (%rax),%rax
  800420c576:	48 85 c0             	test   %rax,%rax
  800420c579:	74 01                	je     800420c57c <trap+0x20>
		asm volatile("hlt");
  800420c57b:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c57c:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c583:	00 00 00 
  800420c586:	ff d0                	callq  *%rax
  800420c588:	48 98                	cltq   
  800420c58a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c58e:	48 89 c2             	mov    %rax,%rdx
  800420c591:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c595:	48 29 c2             	sub    %rax,%rdx
  800420c598:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420c59f:	00 00 00 
  800420c5a2:	48 01 d0             	add    %rdx,%rax
  800420c5a5:	48 83 c0 04          	add    $0x4,%rax
  800420c5a9:	be 01 00 00 00       	mov    $0x1,%esi
  800420c5ae:	48 89 c7             	mov    %rax,%rdi
  800420c5b1:	48 b8 b6 8e 20 04 80 	movabs $0x8004208eb6,%rax
  800420c5b8:	00 00 00 
  800420c5bb:	ff d0                	callq  *%rax
  800420c5bd:	83 f8 02             	cmp    $0x2,%eax
  800420c5c0:	75 0c                	jne    800420c5ce <trap+0x72>
		lock_kernel();
  800420c5c2:	48 b8 db 8e 20 04 80 	movabs $0x8004208edb,%rax
  800420c5c9:	00 00 00 
  800420c5cc:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c5ce:	9c                   	pushfq 
  800420c5cf:	58                   	pop    %rax
  800420c5d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420c5d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c5d8:	25 00 02 00 00       	and    $0x200,%eax
  800420c5dd:	48 85 c0             	test   %rax,%rax
  800420c5e0:	74 35                	je     800420c617 <trap+0xbb>
  800420c5e2:	48 b9 94 9a 21 04 80 	movabs $0x8004219a94,%rcx
  800420c5e9:	00 00 00 
  800420c5ec:	48 ba ad 9a 21 04 80 	movabs $0x8004219aad,%rdx
  800420c5f3:	00 00 00 
  800420c5f6:	be 30 01 00 00       	mov    $0x130,%esi
  800420c5fb:	48 bf 88 9a 21 04 80 	movabs $0x8004219a88,%rdi
  800420c602:	00 00 00 
  800420c605:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c60a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420c611:	00 00 00 
  800420c614:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c617:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c61b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c622:	0f b7 c0             	movzwl %ax,%eax
  800420c625:	83 e0 03             	and    $0x3,%eax
  800420c628:	83 f8 03             	cmp    $0x3,%eax
  800420c62b:	0f 85 b3 01 00 00    	jne    800420c7e4 <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c631:	48 b8 db 8e 20 04 80 	movabs $0x8004208edb,%rax
  800420c638:	00 00 00 
  800420c63b:	ff d0                	callq  *%rax
		assert(curenv);
  800420c63d:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c644:	00 00 00 
  800420c647:	ff d0                	callq  *%rax
  800420c649:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c650:	00 00 00 
  800420c653:	48 98                	cltq   
  800420c655:	48 c1 e0 03          	shl    $0x3,%rax
  800420c659:	48 89 c2             	mov    %rax,%rdx
  800420c65c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c660:	48 29 c2             	sub    %rax,%rdx
  800420c663:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c667:	48 83 c0 08          	add    $0x8,%rax
  800420c66b:	48 8b 00             	mov    (%rax),%rax
  800420c66e:	48 85 c0             	test   %rax,%rax
  800420c671:	75 35                	jne    800420c6a8 <trap+0x14c>
  800420c673:	48 b9 c2 9a 21 04 80 	movabs $0x8004219ac2,%rcx
  800420c67a:	00 00 00 
  800420c67d:	48 ba ad 9a 21 04 80 	movabs $0x8004219aad,%rdx
  800420c684:	00 00 00 
  800420c687:	be 38 01 00 00       	mov    $0x138,%esi
  800420c68c:	48 bf 88 9a 21 04 80 	movabs $0x8004219a88,%rdi
  800420c693:	00 00 00 
  800420c696:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c69b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420c6a2:	00 00 00 
  800420c6a5:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420c6a8:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c6af:	00 00 00 
  800420c6b2:	ff d0                	callq  *%rax
  800420c6b4:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c6bb:	00 00 00 
  800420c6be:	48 98                	cltq   
  800420c6c0:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6c4:	48 89 c2             	mov    %rax,%rdx
  800420c6c7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6cb:	48 29 c2             	sub    %rax,%rdx
  800420c6ce:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c6d2:	48 83 c0 08          	add    $0x8,%rax
  800420c6d6:	48 8b 00             	mov    (%rax),%rax
  800420c6d9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c6df:	83 f8 01             	cmp    $0x1,%eax
  800420c6e2:	0f 85 81 00 00 00    	jne    800420c769 <trap+0x20d>
			env_free(curenv);
  800420c6e8:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c6ef:	00 00 00 
  800420c6f2:	ff d0                	callq  *%rax
  800420c6f4:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c6fb:	00 00 00 
  800420c6fe:	48 98                	cltq   
  800420c700:	48 c1 e0 03          	shl    $0x3,%rax
  800420c704:	48 89 c2             	mov    %rax,%rdx
  800420c707:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c70b:	48 29 c2             	sub    %rax,%rdx
  800420c70e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c712:	48 83 c0 08          	add    $0x8,%rax
  800420c716:	48 8b 00             	mov    (%rax),%rax
  800420c719:	48 89 c7             	mov    %rax,%rdi
  800420c71c:	48 b8 47 81 20 04 80 	movabs $0x8004208147,%rax
  800420c723:	00 00 00 
  800420c726:	ff d0                	callq  *%rax
			curenv = NULL;
  800420c728:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c72f:	00 00 00 
  800420c732:	ff d0                	callq  *%rax
  800420c734:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c73b:	00 00 00 
  800420c73e:	48 98                	cltq   
  800420c740:	48 c1 e0 03          	shl    $0x3,%rax
  800420c744:	48 89 c2             	mov    %rax,%rdx
  800420c747:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c74b:	48 29 c2             	sub    %rax,%rdx
  800420c74e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c752:	48 83 c0 08          	add    $0x8,%rax
  800420c756:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420c75d:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420c764:	00 00 00 
  800420c767:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420c769:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c770:	00 00 00 
  800420c773:	ff d0                	callq  *%rax
  800420c775:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c77c:	00 00 00 
  800420c77f:	48 98                	cltq   
  800420c781:	48 c1 e0 03          	shl    $0x3,%rax
  800420c785:	48 89 c2             	mov    %rax,%rdx
  800420c788:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c78c:	48 29 c2             	sub    %rax,%rdx
  800420c78f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c793:	48 83 c0 08          	add    $0x8,%rax
  800420c797:	48 8b 10             	mov    (%rax),%rdx
  800420c79a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c79e:	48 89 c6             	mov    %rax,%rsi
  800420c7a1:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c7a6:	48 89 d7             	mov    %rdx,%rdi
  800420c7a9:	48 89 c1             	mov    %rax,%rcx
  800420c7ac:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420c7af:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c7b6:	00 00 00 
  800420c7b9:	ff d0                	callq  *%rax
  800420c7bb:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c7c2:	00 00 00 
  800420c7c5:	48 98                	cltq   
  800420c7c7:	48 c1 e0 03          	shl    $0x3,%rax
  800420c7cb:	48 89 c2             	mov    %rax,%rdx
  800420c7ce:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c7d2:	48 29 c2             	sub    %rax,%rdx
  800420c7d5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c7d9:	48 83 c0 08          	add    $0x8,%rax
  800420c7dd:	48 8b 00             	mov    (%rax),%rax
  800420c7e0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420c7e4:	48 b8 90 b2 60 04 80 	movabs $0x800460b290,%rax
  800420c7eb:	00 00 00 
  800420c7ee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c7f2:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420c7f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7f9:	48 89 c7             	mov    %rax,%rdi
  800420c7fc:	48 b8 3f c3 20 04 80 	movabs $0x800420c33f,%rax
  800420c803:	00 00 00 
  800420c806:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420c808:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c80f:	00 00 00 
  800420c812:	ff d0                	callq  *%rax
  800420c814:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c81b:	00 00 00 
  800420c81e:	48 98                	cltq   
  800420c820:	48 c1 e0 03          	shl    $0x3,%rax
  800420c824:	48 89 c2             	mov    %rax,%rdx
  800420c827:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c82b:	48 29 c2             	sub    %rax,%rdx
  800420c82e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c832:	48 83 c0 08          	add    $0x8,%rax
  800420c836:	48 8b 00             	mov    (%rax),%rax
  800420c839:	48 85 c0             	test   %rax,%rax
  800420c83c:	74 7c                	je     800420c8ba <trap+0x35e>
  800420c83e:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c845:	00 00 00 
  800420c848:	ff d0                	callq  *%rax
  800420c84a:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c851:	00 00 00 
  800420c854:	48 98                	cltq   
  800420c856:	48 c1 e0 03          	shl    $0x3,%rax
  800420c85a:	48 89 c2             	mov    %rax,%rdx
  800420c85d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c861:	48 29 c2             	sub    %rax,%rdx
  800420c864:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c868:	48 83 c0 08          	add    $0x8,%rax
  800420c86c:	48 8b 00             	mov    (%rax),%rax
  800420c86f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c875:	83 f8 03             	cmp    $0x3,%eax
  800420c878:	75 40                	jne    800420c8ba <trap+0x35e>
		env_run(curenv);
  800420c87a:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c881:	00 00 00 
  800420c884:	ff d0                	callq  *%rax
  800420c886:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c88d:	00 00 00 
  800420c890:	48 98                	cltq   
  800420c892:	48 c1 e0 03          	shl    $0x3,%rax
  800420c896:	48 89 c2             	mov    %rax,%rdx
  800420c899:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c89d:	48 29 c2             	sub    %rax,%rdx
  800420c8a0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c8a4:	48 83 c0 08          	add    $0x8,%rax
  800420c8a8:	48 8b 00             	mov    (%rax),%rax
  800420c8ab:	48 89 c7             	mov    %rax,%rdi
  800420c8ae:	48 b8 a3 87 20 04 80 	movabs $0x80042087a3,%rax
  800420c8b5:	00 00 00 
  800420c8b8:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420c8ba:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420c8c1:	00 00 00 
  800420c8c4:	ff d0                	callq  *%rax

000000800420c8c6 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420c8c6:	55                   	push   %rbp
  800420c8c7:	48 89 e5             	mov    %rsp,%rbp
  800420c8ca:	53                   	push   %rbx
  800420c8cb:	48 83 ec 38          	sub    $0x38,%rsp
  800420c8cf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c8d3:	0f 20 d0             	mov    %cr2,%rax
  800420c8d6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420c8da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420c8de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo *pp;

	// Handle kernel-mode page faults.
	
	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0)
  800420c8e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c8e6:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c8ed:	0f b7 c0             	movzwl %ax,%eax
  800420c8f0:	83 e0 03             	and    $0x3,%eax
  800420c8f3:	85 c0                	test   %eax,%eax
  800420c8f5:	75 5f                	jne    800420c956 <page_fault_handler+0x90>
	{
		cprintf("fault_va is [%x]",fault_va);
  800420c8f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8fb:	48 89 c6             	mov    %rax,%rsi
  800420c8fe:	48 bf c9 9a 21 04 80 	movabs $0x8004219ac9,%rdi
  800420c905:	00 00 00 
  800420c908:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c90d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420c914:	00 00 00 
  800420c917:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c919:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c91d:	48 89 c7             	mov    %rax,%rdi
  800420c920:	48 b8 e7 bd 20 04 80 	movabs $0x800420bde7,%rax
  800420c927:	00 00 00 
  800420c92a:	ff d0                	callq  *%rax
		panic("Page fault hapened in kernel mode");
  800420c92c:	48 ba e0 9a 21 04 80 	movabs $0x8004219ae0,%rdx
  800420c933:	00 00 00 
  800420c936:	be 6b 01 00 00       	mov    $0x16b,%esi
  800420c93b:	48 bf 88 9a 21 04 80 	movabs $0x8004219a88,%rdi
  800420c942:	00 00 00 
  800420c945:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c94a:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  800420c951:	00 00 00 
  800420c954:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.
	
	/*check if user env has registered a pg fault upcall.*/
		//cprintf("hello1");
	//cprintf("hello2");
    if(curenv->env_pgfault_upcall){
  800420c956:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c95d:	00 00 00 
  800420c960:	ff d0                	callq  *%rax
  800420c962:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c969:	00 00 00 
  800420c96c:	48 98                	cltq   
  800420c96e:	48 c1 e0 03          	shl    $0x3,%rax
  800420c972:	48 89 c2             	mov    %rax,%rdx
  800420c975:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c979:	48 29 c2             	sub    %rax,%rdx
  800420c97c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c980:	48 83 c0 08          	add    $0x8,%rax
  800420c984:	48 8b 00             	mov    (%rax),%rax
  800420c987:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420c98e:	48 85 c0             	test   %rax,%rax
  800420c991:	0f 84 6e 02 00 00    	je     800420cc05 <page_fault_handler+0x33f>
		//user_mem_assert(curenv,(const void *)curenv->env_pgfault_upcall,8,PTE_P|PTE_U);
		user_mem_assert(curenv,(const void *)UXSTACKTOP-PGSIZE,PGSIZE, PTE_W | PTE_U | PTE_P);
  800420c997:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420c99e:	00 00 00 
  800420c9a1:	ff d0                	callq  *%rax
  800420c9a3:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420c9aa:	00 00 00 
  800420c9ad:	48 98                	cltq   
  800420c9af:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9b3:	48 89 c2             	mov    %rax,%rdx
  800420c9b6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9ba:	48 29 c2             	sub    %rax,%rdx
  800420c9bd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c9c1:	48 83 c0 08          	add    $0x8,%rax
  800420c9c5:	48 8b 00             	mov    (%rax),%rax
  800420c9c8:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420c9cd:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420c9d2:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  800420c9d7:	48 89 c7             	mov    %rax,%rdi
  800420c9da:	48 b8 53 3d 20 04 80 	movabs $0x8004203d53,%rax
  800420c9e1:	00 00 00 
  800420c9e4:	ff d0                	callq  *%rax
		/*If user mem assert returns , then the address is valid for the env*/	
		if(!(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp > UXSTACKTOP-PGSIZE)){
  800420c9e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9ea:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420c9f1:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420c9f6:	48 39 c2             	cmp    %rax,%rdx
  800420c9f9:	77 15                	ja     800420ca10 <page_fault_handler+0x14a>
  800420c9fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9ff:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ca06:	b8 00 f0 7f ef       	mov    $0xef7ff000,%eax
  800420ca0b:	48 39 c2             	cmp    %rax,%rdx
  800420ca0e:	77 0b                	ja     800420ca1b <page_fault_handler+0x155>
			/*1st Page Fault*/
			utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420ca10:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420ca15:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420ca19:	eb 73                	jmp    800420ca8e <page_fault_handler+0x1c8>
		}else{
			if(tf->tf_rsp - sizeof(struct UTrapframe) - 8 < (UXSTACKTOP-PGSIZE)){
  800420ca1b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca1f:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ca26:	48 8d 90 58 ff ff ff 	lea    -0xa8(%rax),%rdx
  800420ca2d:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420ca32:	48 39 c2             	cmp    %rax,%rdx
  800420ca35:	77 42                	ja     800420ca79 <page_fault_handler+0x1b3>
				env_destroy(curenv);
  800420ca37:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420ca3e:	00 00 00 
  800420ca41:	ff d0                	callq  *%rax
  800420ca43:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420ca4a:	00 00 00 
  800420ca4d:	48 98                	cltq   
  800420ca4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca53:	48 89 c2             	mov    %rax,%rdx
  800420ca56:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca5a:	48 29 c2             	sub    %rax,%rdx
  800420ca5d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca61:	48 83 c0 08          	add    $0x8,%rax
  800420ca65:	48 8b 00             	mov    (%rax),%rax
  800420ca68:	48 89 c7             	mov    %rax,%rdi
  800420ca6b:	48 b8 d4 85 20 04 80 	movabs $0x80042085d4,%rax
  800420ca72:	00 00 00 
  800420ca75:	ff d0                	callq  *%rax
  800420ca77:	eb 15                	jmp    800420ca8e <page_fault_handler+0x1c8>
			}
			else
			{
				utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420ca79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca7d:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ca84:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420ca8a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			/*Nested Page Fault*/
			
		}
		/*Populate the Utrapframe*/
		//user_mem_assert(curenv,(const void *)utf,sizeof(struct UTrapframe),PTE_W|PTE_U);
		utf->utf_eflags = tf->tf_eflags;
  800420ca8e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca92:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ca99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca9d:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_err = tf->tf_err;
  800420caa4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420caa8:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420caaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cab3:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420cab7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cabb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cabf:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420cac2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cac6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420caca:	48 8b 0a             	mov    (%rdx),%rcx
  800420cacd:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420cad1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420cad5:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420cad9:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420cadd:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420cae1:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420cae5:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420cae9:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420caed:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420caf1:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420caf5:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420caf9:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420cafd:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cb01:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420cb05:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420cb09:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420cb0d:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cb11:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cb15:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cb19:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420cb1d:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420cb21:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420cb25:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420cb29:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cb2d:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cb31:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cb35:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cb39:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420cb3d:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420cb44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb48:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420cb4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb53:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420cb5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb5e:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cb65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb69:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420cb70:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cb77:	00 00 00 
  800420cb7a:	ff d0                	callq  *%rax
  800420cb7c:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cb83:	00 00 00 
  800420cb86:	48 98                	cltq   
  800420cb88:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb8c:	48 89 c2             	mov    %rax,%rdx
  800420cb8f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb93:	48 29 c2             	sub    %rax,%rdx
  800420cb96:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb9a:	48 83 c0 08          	add    $0x8,%rax
  800420cb9e:	48 8b 00             	mov    (%rax),%rax
  800420cba1:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cba8:	48 89 c2             	mov    %rax,%rdx
  800420cbab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbaf:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utf;
  800420cbb6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cbba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbbe:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		

		
		env_run(curenv);
  800420cbc5:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cbcc:	00 00 00 
  800420cbcf:	ff d0                	callq  *%rax
  800420cbd1:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cbd8:	00 00 00 
  800420cbdb:	48 98                	cltq   
  800420cbdd:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbe1:	48 89 c2             	mov    %rax,%rdx
  800420cbe4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbe8:	48 29 c2             	sub    %rax,%rdx
  800420cbeb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cbef:	48 83 c0 08          	add    $0x8,%rax
  800420cbf3:	48 8b 00             	mov    (%rax),%rax
  800420cbf6:	48 89 c7             	mov    %rax,%rdi
  800420cbf9:	48 b8 a3 87 20 04 80 	movabs $0x80042087a3,%rax
  800420cc00:	00 00 00 
  800420cc03:	ff d0                	callq  *%rax
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cc05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc09:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420cc10:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cc17:	00 00 00 
  800420cc1a:	ff d0                	callq  *%rax
  800420cc1c:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cc23:	00 00 00 
  800420cc26:	48 98                	cltq   
  800420cc28:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc2c:	48 89 c2             	mov    %rax,%rdx
  800420cc2f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc33:	48 29 c2             	sub    %rax,%rdx
  800420cc36:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc3a:	48 83 c0 08          	add    $0x8,%rax
  800420cc3e:	48 8b 00             	mov    (%rax),%rax
		
		env_run(curenv);
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cc41:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cc47:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cc4b:	48 89 d9             	mov    %rbx,%rcx
  800420cc4e:	89 c6                	mov    %eax,%esi
  800420cc50:	48 bf 08 9b 21 04 80 	movabs $0x8004219b08,%rdi
  800420cc57:	00 00 00 
  800420cc5a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc5f:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  800420cc66:	00 00 00 
  800420cc69:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420cc6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc70:	48 89 c7             	mov    %rax,%rdi
  800420cc73:	48 b8 e7 bd 20 04 80 	movabs $0x800420bde7,%rax
  800420cc7a:	00 00 00 
  800420cc7d:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420cc7f:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cc86:	00 00 00 
  800420cc89:	ff d0                	callq  *%rax
  800420cc8b:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cc92:	00 00 00 
  800420cc95:	48 98                	cltq   
  800420cc97:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc9b:	48 89 c2             	mov    %rax,%rdx
  800420cc9e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cca2:	48 29 c2             	sub    %rax,%rdx
  800420cca5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cca9:	48 83 c0 08          	add    $0x8,%rax
  800420ccad:	48 8b 00             	mov    (%rax),%rax
  800420ccb0:	48 89 c7             	mov    %rax,%rdi
  800420ccb3:	48 b8 d4 85 20 04 80 	movabs $0x80042085d4,%rax
  800420ccba:	00 00 00 
  800420ccbd:	ff d0                	callq  *%rax
    }
}
  800420ccbf:	48 83 c4 38          	add    $0x38,%rsp
  800420ccc3:	5b                   	pop    %rbx
  800420ccc4:	5d                   	pop    %rbp
  800420ccc5:	c3                   	retq   

000000800420ccc6 <XTRPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRPX_divzero, T_DIVIDE)
  800420ccc6:	6a 00                	pushq  $0x0
  800420ccc8:	6a 00                	pushq  $0x0
  800420ccca:	e9 01 01 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cccf:	90                   	nop

000000800420ccd0 <XTRPX_Debug>:
	TRAPHANDLER_NOEC(XTRPX_Debug, T_DEBUG)
  800420ccd0:	6a 00                	pushq  $0x0
  800420ccd2:	6a 01                	pushq  $0x1
  800420ccd4:	e9 f7 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420ccd9:	90                   	nop

000000800420ccda <XTRPX_NonMaskI>:
	TRAPHANDLER_NOEC(XTRPX_NonMaskI, T_NMI)
  800420ccda:	6a 00                	pushq  $0x0
  800420ccdc:	6a 02                	pushq  $0x2
  800420ccde:	e9 ed 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cce3:	90                   	nop

000000800420cce4 <XTRPX_Brkpt>:
	TRAPHANDLER_NOEC(XTRPX_Brkpt, T_BRKPT)
  800420cce4:	6a 00                	pushq  $0x0
  800420cce6:	6a 03                	pushq  $0x3
  800420cce8:	e9 e3 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cced:	90                   	nop

000000800420ccee <XTRPX_OFlow>:
	TRAPHANDLER_NOEC(XTRPX_OFlow, T_OFLOW)
  800420ccee:	6a 00                	pushq  $0x0
  800420ccf0:	6a 04                	pushq  $0x4
  800420ccf2:	e9 d9 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420ccf7:	90                   	nop

000000800420ccf8 <XTRPX_Bound>:
	TRAPHANDLER_NOEC(XTRPX_Bound, T_BOUND)
  800420ccf8:	6a 00                	pushq  $0x0
  800420ccfa:	6a 05                	pushq  $0x5
  800420ccfc:	e9 cf 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd01:	90                   	nop

000000800420cd02 <XTRPX_Illop>:
	TRAPHANDLER_NOEC(XTRPX_Illop, T_ILLOP)
  800420cd02:	6a 00                	pushq  $0x0
  800420cd04:	6a 06                	pushq  $0x6
  800420cd06:	e9 c5 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd0b:	90                   	nop

000000800420cd0c <XTRPX_Device>:
	TRAPHANDLER_NOEC(XTRPX_Device, T_DEVICE)
  800420cd0c:	6a 00                	pushq  $0x0
  800420cd0e:	6a 07                	pushq  $0x7
  800420cd10:	e9 bb 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd15:	90                   	nop

000000800420cd16 <XTRPX_DblFlt>:
	TRAPHANDLER(XTRPX_DblFlt, T_DBLFLT)
  800420cd16:	6a 08                	pushq  $0x8
  800420cd18:	e9 b3 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd1d:	90                   	nop

000000800420cd1e <XTRPX_Tss>:
	TRAPHANDLER(XTRPX_Tss, T_TSS)
  800420cd1e:	6a 0a                	pushq  $0xa
  800420cd20:	e9 ab 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd25:	90                   	nop

000000800420cd26 <XTRPX_Segnp>:
	TRAPHANDLER(XTRPX_Segnp, T_SEGNP)
  800420cd26:	6a 0b                	pushq  $0xb
  800420cd28:	e9 a3 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd2d:	90                   	nop

000000800420cd2e <XTRPX_Stack>:
	TRAPHANDLER(XTRPX_Stack, T_STACK)
  800420cd2e:	6a 0c                	pushq  $0xc
  800420cd30:	e9 9b 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd35:	90                   	nop

000000800420cd36 <XTRPX_Gpflt>:
	TRAPHANDLER(XTRPX_Gpflt, T_GPFLT)
  800420cd36:	6a 0d                	pushq  $0xd
  800420cd38:	e9 93 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd3d:	90                   	nop

000000800420cd3e <XTRPX_Pgflt>:
	TRAPHANDLER(XTRPX_Pgflt, T_PGFLT)
  800420cd3e:	6a 0e                	pushq  $0xe
  800420cd40:	e9 8b 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd45:	90                   	nop

000000800420cd46 <XTRPX_FpErr>:
	TRAPHANDLER_NOEC(XTRPX_FpErr, T_FPERR)
  800420cd46:	6a 00                	pushq  $0x0
  800420cd48:	6a 10                	pushq  $0x10
  800420cd4a:	e9 81 00 00 00       	jmpq   800420cdd0 <_alltraps>
  800420cd4f:	90                   	nop

000000800420cd50 <XTRPX_Align>:
	TRAPHANDLER(XTRPX_Align, T_ALIGN)
  800420cd50:	6a 11                	pushq  $0x11
  800420cd52:	eb 7c                	jmp    800420cdd0 <_alltraps>

000000800420cd54 <XTRPX_Mchk>:
	TRAPHANDLER_NOEC(XTRPX_Mchk, T_MCHK)
  800420cd54:	6a 00                	pushq  $0x0
  800420cd56:	6a 12                	pushq  $0x12
  800420cd58:	eb 76                	jmp    800420cdd0 <_alltraps>

000000800420cd5a <XTRPX_SimdErr>:
	TRAPHANDLER_NOEC(XTRPX_SimdErr, T_SIMDERR)
  800420cd5a:	6a 00                	pushq  $0x0
  800420cd5c:	6a 13                	pushq  $0x13
  800420cd5e:	eb 70                	jmp    800420cdd0 <_alltraps>

000000800420cd60 <XTRPX_Syscall>:
	TRAPHANDLER_NOEC(XTRPX_Syscall, T_SYSCALL)
  800420cd60:	6a 00                	pushq  $0x0
  800420cd62:	6a 30                	pushq  $0x30
  800420cd64:	eb 6a                	jmp    800420cdd0 <_alltraps>

000000800420cd66 <XTRPX_Default>:
	TRAPHANDLER_NOEC(XTRPX_Default, T_DEFAULT)
  800420cd66:	6a 00                	pushq  $0x0
  800420cd68:	68 f4 01 00 00       	pushq  $0x1f4
  800420cd6d:	eb 61                	jmp    800420cdd0 <_alltraps>
  800420cd6f:	90                   	nop

000000800420cd70 <XTRPX_IRQ0>:
	TRAPHANDLER_NOEC(XTRPX_IRQ0, IRQ_OFFSET+IRQ_TIMER)
  800420cd70:	6a 00                	pushq  $0x0
  800420cd72:	6a 20                	pushq  $0x20
  800420cd74:	eb 5a                	jmp    800420cdd0 <_alltraps>

000000800420cd76 <XTRPX_IRQ1>:
	TRAPHANDLER_NOEC(XTRPX_IRQ1, IRQ_OFFSET+IRQ_KBD)
  800420cd76:	6a 00                	pushq  $0x0
  800420cd78:	6a 21                	pushq  $0x21
  800420cd7a:	eb 54                	jmp    800420cdd0 <_alltraps>

000000800420cd7c <XTRPX_IRQ2>:
	TRAPHANDLER_NOEC(XTRPX_IRQ2, IRQ_OFFSET+2)
  800420cd7c:	6a 00                	pushq  $0x0
  800420cd7e:	6a 22                	pushq  $0x22
  800420cd80:	eb 4e                	jmp    800420cdd0 <_alltraps>

000000800420cd82 <XTRPX_IRQ3>:
	TRAPHANDLER_NOEC(XTRPX_IRQ3, IRQ_OFFSET+3)
  800420cd82:	6a 00                	pushq  $0x0
  800420cd84:	6a 23                	pushq  $0x23
  800420cd86:	eb 48                	jmp    800420cdd0 <_alltraps>

000000800420cd88 <XTRPX_IRQ4>:
	TRAPHANDLER_NOEC(XTRPX_IRQ4, IRQ_OFFSET+IRQ_SERIAL)
  800420cd88:	6a 00                	pushq  $0x0
  800420cd8a:	6a 24                	pushq  $0x24
  800420cd8c:	eb 42                	jmp    800420cdd0 <_alltraps>

000000800420cd8e <XTRPX_IRQ5>:
	TRAPHANDLER_NOEC(XTRPX_IRQ5, IRQ_OFFSET+5)
  800420cd8e:	6a 00                	pushq  $0x0
  800420cd90:	6a 25                	pushq  $0x25
  800420cd92:	eb 3c                	jmp    800420cdd0 <_alltraps>

000000800420cd94 <XTRPX_IRQ6>:
	TRAPHANDLER_NOEC(XTRPX_IRQ6, IRQ_OFFSET+6)
  800420cd94:	6a 00                	pushq  $0x0
  800420cd96:	6a 26                	pushq  $0x26
  800420cd98:	eb 36                	jmp    800420cdd0 <_alltraps>

000000800420cd9a <XTRPX_IRQ7>:
	TRAPHANDLER_NOEC(XTRPX_IRQ7, IRQ_OFFSET+IRQ_SPURIOUS)
  800420cd9a:	6a 00                	pushq  $0x0
  800420cd9c:	6a 27                	pushq  $0x27
  800420cd9e:	eb 30                	jmp    800420cdd0 <_alltraps>

000000800420cda0 <XTRPX_IRQ8>:
	TRAPHANDLER_NOEC(XTRPX_IRQ8, IRQ_OFFSET+8)
  800420cda0:	6a 00                	pushq  $0x0
  800420cda2:	6a 28                	pushq  $0x28
  800420cda4:	eb 2a                	jmp    800420cdd0 <_alltraps>

000000800420cda6 <XTRPX_IRQ9>:
	TRAPHANDLER_NOEC(XTRPX_IRQ9, IRQ_OFFSET+9)
  800420cda6:	6a 00                	pushq  $0x0
  800420cda8:	6a 29                	pushq  $0x29
  800420cdaa:	eb 24                	jmp    800420cdd0 <_alltraps>

000000800420cdac <XTRPX_IRQa>:
	TRAPHANDLER_NOEC(XTRPX_IRQa, IRQ_OFFSET+10)
  800420cdac:	6a 00                	pushq  $0x0
  800420cdae:	6a 2a                	pushq  $0x2a
  800420cdb0:	eb 1e                	jmp    800420cdd0 <_alltraps>

000000800420cdb2 <XTRPX_IRQb>:
	TRAPHANDLER_NOEC(XTRPX_IRQb, IRQ_OFFSET+11)
  800420cdb2:	6a 00                	pushq  $0x0
  800420cdb4:	6a 2b                	pushq  $0x2b
  800420cdb6:	eb 18                	jmp    800420cdd0 <_alltraps>

000000800420cdb8 <XTRPX_IRQc>:
	TRAPHANDLER_NOEC(XTRPX_IRQc, IRQ_OFFSET+12)
  800420cdb8:	6a 00                	pushq  $0x0
  800420cdba:	6a 2c                	pushq  $0x2c
  800420cdbc:	eb 12                	jmp    800420cdd0 <_alltraps>

000000800420cdbe <XTRPX_IRQd>:
	TRAPHANDLER_NOEC(XTRPX_IRQd, IRQ_OFFSET+13)
  800420cdbe:	6a 00                	pushq  $0x0
  800420cdc0:	6a 2d                	pushq  $0x2d
  800420cdc2:	eb 0c                	jmp    800420cdd0 <_alltraps>

000000800420cdc4 <XTRPX_IRQe>:
	TRAPHANDLER_NOEC(XTRPX_IRQe, IRQ_OFFSET+IRQ_IDE)
  800420cdc4:	6a 00                	pushq  $0x0
  800420cdc6:	6a 2e                	pushq  $0x2e
  800420cdc8:	eb 06                	jmp    800420cdd0 <_alltraps>

000000800420cdca <XTRPX_IRQf>:
	TRAPHANDLER_NOEC(XTRPX_IRQf, IRQ_OFFSET+15)
  800420cdca:	6a 00                	pushq  $0x0
  800420cdcc:	6a 2f                	pushq  $0x2f
  800420cdce:	eb 00                	jmp    800420cdd0 <_alltraps>

000000800420cdd0 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
    _alltraps:
    	/* Since ES and DS registers can't be pushed in x86-64. So moving them to r15 first */
		xor %r15, %r15
  800420cdd0:	4d 31 ff             	xor    %r15,%r15
		movw %ds,%r15 
  800420cdd3:	66 41 8c df          	mov    %ds,%r15w
		pushq %r15
  800420cdd7:	41 57                	push   %r15
		movw %es, %r15
  800420cdd9:	66 41 8c c7          	mov    %es,%r15w
		pushq %r15
  800420cddd:	41 57                	push   %r15
		/* Now push all registers onto the stack */
		PUSHA
  800420cddf:	48 83 ec 78          	sub    $0x78,%rsp
  800420cde3:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420cde8:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420cded:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420cdf2:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420cdf7:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420cdfc:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420ce01:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420ce06:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420ce0b:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420ce10:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420ce15:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420ce1a:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420ce1f:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420ce24:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420ce29:	4c 89 3c 24          	mov    %r15,(%rsp)
		/* Far pointer addressing*/
		mov %rsp, %rdi
  800420ce2d:	48 89 e7             	mov    %rsp,%rdi
		/* filling es and ds now */
		xor %r15, %r15
  800420ce30:	4d 31 ff             	xor    %r15,%r15
		movw $(GD_KD), %r15
  800420ce33:	66 41 c7 c7 10 00    	mov    $0x10,%r15w
		movw %r15, %es
  800420ce39:	41 8e c7             	mov    %r15d,%es
		movw %r15, %ds
  800420ce3c:	41 8e df             	mov    %r15d,%ds
		call trap
  800420ce3f:	e8 18 f7 ff ff       	callq  800420c55c <trap>
		POPA_
  800420ce44:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420ce48:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420ce4d:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420ce52:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420ce57:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420ce5c:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420ce61:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420ce66:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420ce6b:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420ce70:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420ce75:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420ce7a:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420ce7f:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420ce84:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420ce89:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420ce8e:	48 83 c4 78          	add    $0x78,%rsp
		/*Now make the stack same as we got from CPU*/
		xor %r15, %r15
  800420ce92:	4d 31 ff             	xor    %r15,%r15
		popq %r15
  800420ce95:	41 5f                	pop    %r15
		movw %r15, %es
  800420ce97:	41 8e c7             	mov    %r15d,%es
		popq %r15
  800420ce9a:	41 5f                	pop    %r15
		movw %r15, %ds
  800420ce9c:	41 8e df             	mov    %r15d,%ds
		iret 
  800420ce9f:	cf                   	iret   

000000800420cea0 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420cea0:	55                   	push   %rbp
  800420cea1:	48 89 e5             	mov    %rsp,%rbp
  800420cea4:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420cea8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ceac:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420ceaf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ceb3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ceb6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ceba:	f0 87 02             	lock xchg %eax,(%rdx)
  800420cebd:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420cec0:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420cec3:	c9                   	leaveq 
  800420cec4:	c3                   	retq   

000000800420cec5 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420cec5:	55                   	push   %rbp
  800420cec6:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420cec9:	48 bf 80 e7 22 04 80 	movabs $0x800422e780,%rdi
  800420ced0:	00 00 00 
  800420ced3:	48 b8 53 6e 21 04 80 	movabs $0x8004216e53,%rax
  800420ceda:	00 00 00 
  800420cedd:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420cedf:	f3 90                	pause  
}
  800420cee1:	5d                   	pop    %rbp
  800420cee2:	c3                   	retq   

000000800420cee3 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
	{
  800420cee3:	55                   	push   %rbp
  800420cee4:	48 89 e5             	mov    %rsp,%rbp
  800420cee7:	48 83 ec 10          	sub    $0x10,%rsp
		// no runnable environments, simply drop through to the code
		// below to halt the cpu.	
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
  800420ceeb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420cef2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420cef9:	e9 a7 00 00 00       	jmpq   800420cfa5 <sched_yield+0xc2>
			if(envs[(env_counter+i)%NENV].env_status == ENV_RUNNABLE){
  800420cefe:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  800420cf05:	00 00 00 
  800420cf08:	48 8b 08             	mov    (%rax),%rcx
  800420cf0b:	48 b8 98 b2 60 04 80 	movabs $0x800460b298,%rax
  800420cf12:	00 00 00 
  800420cf15:	8b 10                	mov    (%rax),%edx
  800420cf17:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cf1a:	01 d0                	add    %edx,%eax
  800420cf1c:	89 c0                	mov    %eax,%eax
  800420cf1e:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420cf23:	48 89 c2             	mov    %rax,%rdx
  800420cf26:	48 89 d0             	mov    %rdx,%rax
  800420cf29:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf2d:	48 01 d0             	add    %rdx,%rax
  800420cf30:	48 c1 e0 05          	shl    $0x5,%rax
  800420cf34:	48 01 c8             	add    %rcx,%rax
  800420cf37:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cf3d:	83 f8 02             	cmp    $0x2,%eax
  800420cf40:	75 5f                	jne    800420cfa1 <sched_yield+0xbe>
				env_counter = (env_counter+i)%NENV;
  800420cf42:	48 b8 98 b2 60 04 80 	movabs $0x800460b298,%rax
  800420cf49:	00 00 00 
  800420cf4c:	8b 10                	mov    (%rax),%edx
  800420cf4e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cf51:	01 d0                	add    %edx,%eax
  800420cf53:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420cf58:	89 c2                	mov    %eax,%edx
  800420cf5a:	48 b8 98 b2 60 04 80 	movabs $0x800460b298,%rax
  800420cf61:	00 00 00 
  800420cf64:	89 10                	mov    %edx,(%rax)
				//cprintf("going to run now = [%d],status is [%d]\n",env_counter,envs[env_counter].env_status);
				env_run(&envs[env_counter]);
  800420cf66:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  800420cf6d:	00 00 00 
  800420cf70:	48 8b 08             	mov    (%rax),%rcx
  800420cf73:	48 b8 98 b2 60 04 80 	movabs $0x800460b298,%rax
  800420cf7a:	00 00 00 
  800420cf7d:	8b 00                	mov    (%rax),%eax
  800420cf7f:	89 c2                	mov    %eax,%edx
  800420cf81:	48 89 d0             	mov    %rdx,%rax
  800420cf84:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf88:	48 01 d0             	add    %rdx,%rax
  800420cf8b:	48 c1 e0 05          	shl    $0x5,%rax
  800420cf8f:	48 01 c8             	add    %rcx,%rax
  800420cf92:	48 89 c7             	mov    %rax,%rdi
  800420cf95:	48 b8 a3 87 20 04 80 	movabs $0x80042087a3,%rax
  800420cf9c:	00 00 00 
  800420cf9f:	ff d0                	callq  *%rax
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420cfa1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420cfa5:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420cfac:	0f 86 4c ff ff ff    	jbe    800420cefe <sched_yield+0x1b>
				env_run(&envs[env_counter]);
				break;
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
  800420cfb2:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cfb9:	00 00 00 
  800420cfbc:	ff d0                	callq  *%rax
  800420cfbe:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cfc5:	00 00 00 
  800420cfc8:	48 98                	cltq   
  800420cfca:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfce:	48 89 c2             	mov    %rax,%rdx
  800420cfd1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cfd5:	48 29 c2             	sub    %rax,%rdx
  800420cfd8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cfdc:	48 83 c0 08          	add    $0x8,%rax
  800420cfe0:	48 8b 00             	mov    (%rax),%rax
  800420cfe3:	48 85 c0             	test   %rax,%rax
  800420cfe6:	74 7c                	je     800420d064 <sched_yield+0x181>
  800420cfe8:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420cfef:	00 00 00 
  800420cff2:	ff d0                	callq  *%rax
  800420cff4:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420cffb:	00 00 00 
  800420cffe:	48 98                	cltq   
  800420d000:	48 c1 e0 03          	shl    $0x3,%rax
  800420d004:	48 89 c2             	mov    %rax,%rdx
  800420d007:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d00b:	48 29 c2             	sub    %rax,%rdx
  800420d00e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d012:	48 83 c0 08          	add    $0x8,%rax
  800420d016:	48 8b 00             	mov    (%rax),%rax
  800420d019:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d01f:	83 f8 03             	cmp    $0x3,%eax
  800420d022:	75 40                	jne    800420d064 <sched_yield+0x181>
			env_run(curenv);
  800420d024:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d02b:	00 00 00 
  800420d02e:	ff d0                	callq  *%rax
  800420d030:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d037:	00 00 00 
  800420d03a:	48 98                	cltq   
  800420d03c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d040:	48 89 c2             	mov    %rax,%rdx
  800420d043:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d047:	48 29 c2             	sub    %rax,%rdx
  800420d04a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d04e:	48 83 c0 08          	add    $0x8,%rax
  800420d052:	48 8b 00             	mov    (%rax),%rax
  800420d055:	48 89 c7             	mov    %rax,%rdi
  800420d058:	48 b8 a3 87 20 04 80 	movabs $0x80042087a3,%rax
  800420d05f:	00 00 00 
  800420d062:	ff d0                	callq  *%rax
			
		}else{
			sched_halt();	
  800420d064:	48 b8 72 d0 20 04 80 	movabs $0x800420d072,%rax
  800420d06b:	00 00 00 
  800420d06e:	ff d0                	callq  *%rax
		}
	}
  800420d070:	c9                   	leaveq 
  800420d071:	c3                   	retq   

000000800420d072 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
	{
  800420d072:	55                   	push   %rbp
  800420d073:	48 89 e5             	mov    %rsp,%rbp
  800420d076:	48 83 ec 20          	sub    $0x20,%rsp
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d07a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d081:	e9 91 00 00 00       	jmpq   800420d117 <sched_halt+0xa5>
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d086:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  800420d08d:	00 00 00 
  800420d090:	48 8b 08             	mov    (%rax),%rcx
  800420d093:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d096:	48 63 d0             	movslq %eax,%rdx
  800420d099:	48 89 d0             	mov    %rdx,%rax
  800420d09c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0a0:	48 01 d0             	add    %rdx,%rax
  800420d0a3:	48 c1 e0 05          	shl    $0x5,%rax
  800420d0a7:	48 01 c8             	add    %rcx,%rax
  800420d0aa:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d0b0:	83 f8 02             	cmp    $0x2,%eax
  800420d0b3:	74 6f                	je     800420d124 <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
  800420d0b5:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  800420d0bc:	00 00 00 
  800420d0bf:	48 8b 08             	mov    (%rax),%rcx
  800420d0c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0c5:	48 63 d0             	movslq %eax,%rdx
  800420d0c8:	48 89 d0             	mov    %rdx,%rax
  800420d0cb:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0cf:	48 01 d0             	add    %rdx,%rax
  800420d0d2:	48 c1 e0 05          	shl    $0x5,%rax
  800420d0d6:	48 01 c8             	add    %rcx,%rax
  800420d0d9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d0df:	83 f8 03             	cmp    $0x3,%eax
  800420d0e2:	74 40                	je     800420d124 <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
  800420d0e4:	48 b8 50 a2 60 04 80 	movabs $0x800460a250,%rax
  800420d0eb:	00 00 00 
  800420d0ee:	48 8b 08             	mov    (%rax),%rcx
  800420d0f1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0f4:	48 63 d0             	movslq %eax,%rdx
  800420d0f7:	48 89 d0             	mov    %rdx,%rax
  800420d0fa:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0fe:	48 01 d0             	add    %rdx,%rax
  800420d101:	48 c1 e0 05          	shl    $0x5,%rax
  800420d105:	48 01 c8             	add    %rcx,%rax
  800420d108:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
  800420d10e:	83 f8 01             	cmp    $0x1,%eax
  800420d111:	74 11                	je     800420d124 <sched_halt+0xb2>
	{
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d113:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d117:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d11e:	0f 8e 62 ff ff ff    	jle    800420d086 <sched_halt+0x14>
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
				break;
		}
		if (i == NENV) {
  800420d124:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d12b:	75 2e                	jne    800420d15b <sched_halt+0xe9>
			cprintf("No runnable environments in the system!\n");
  800420d12d:	48 bf 20 9d 21 04 80 	movabs $0x8004219d20,%rdi
  800420d134:	00 00 00 
  800420d137:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d13c:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420d143:	00 00 00 
  800420d146:	ff d2                	callq  *%rdx
			while (1)
				monitor(NULL);
  800420d148:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d14d:	48 b8 49 1b 20 04 80 	movabs $0x8004201b49,%rax
  800420d154:	00 00 00 
  800420d157:	ff d0                	callq  *%rax
  800420d159:	eb ed                	jmp    800420d148 <sched_halt+0xd6>
		}
	
		// Mark that no environment is running on this CPU
		curenv = NULL;
  800420d15b:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d162:	00 00 00 
  800420d165:	ff d0                	callq  *%rax
  800420d167:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d16e:	00 00 00 
  800420d171:	48 98                	cltq   
  800420d173:	48 c1 e0 03          	shl    $0x3,%rax
  800420d177:	48 89 c2             	mov    %rax,%rdx
  800420d17a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d17e:	48 29 c2             	sub    %rax,%rdx
  800420d181:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d185:	48 83 c0 08          	add    $0x8,%rax
  800420d189:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		lcr3(PADDR(boot_pml4e));
  800420d190:	48 b8 58 d4 60 04 80 	movabs $0x800460d458,%rax
  800420d197:	00 00 00 
  800420d19a:	48 8b 00             	mov    (%rax),%rax
  800420d19d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d1a1:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d1a8:	00 00 00 
  800420d1ab:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d1af:	77 32                	ja     800420d1e3 <sched_halt+0x171>
  800420d1b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1b5:	48 89 c1             	mov    %rax,%rcx
  800420d1b8:	48 ba 50 9d 21 04 80 	movabs $0x8004219d50,%rdx
  800420d1bf:	00 00 00 
  800420d1c2:	be 4e 00 00 00       	mov    $0x4e,%esi
  800420d1c7:	48 bf 74 9d 21 04 80 	movabs $0x8004219d74,%rdi
  800420d1ce:	00 00 00 
  800420d1d1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d1d6:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420d1dd:	00 00 00 
  800420d1e0:	41 ff d0             	callq  *%r8
  800420d1e3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d1ea:	ff ff ff 
  800420d1ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1f1:	48 01 d0             	add    %rdx,%rax
  800420d1f4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d1f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1fc:	0f 22 d8             	mov    %rax,%cr3
	
		// Mark that this CPU is in the HALT state, so that when
		// timer interupts come in, we know we should re-acquire the
		// big kernel lock
		xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d1ff:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d206:	00 00 00 
  800420d209:	ff d0                	callq  *%rax
  800420d20b:	48 98                	cltq   
  800420d20d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d211:	48 89 c2             	mov    %rax,%rdx
  800420d214:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d218:	48 29 c2             	sub    %rax,%rdx
  800420d21b:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  800420d222:	00 00 00 
  800420d225:	48 01 d0             	add    %rdx,%rax
  800420d228:	48 83 c0 04          	add    $0x4,%rax
  800420d22c:	be 02 00 00 00       	mov    $0x2,%esi
  800420d231:	48 89 c7             	mov    %rax,%rdi
  800420d234:	48 b8 a0 ce 20 04 80 	movabs $0x800420cea0,%rax
  800420d23b:	00 00 00 
  800420d23e:	ff d0                	callq  *%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
  800420d240:	48 b8 c5 ce 20 04 80 	movabs $0x800420cec5,%rax
  800420d247:	00 00 00 
  800420d24a:	ff d0                	callq  *%rax
			"movq %0, %%rsp\n"
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d24c:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d253:	00 00 00 
  800420d256:	ff d0                	callq  *%rax
  800420d258:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d25f:	00 00 00 
  800420d262:	48 98                	cltq   
  800420d264:	48 c1 e0 03          	shl    $0x3,%rax
  800420d268:	48 89 c2             	mov    %rax,%rdx
  800420d26b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d26f:	48 29 c2             	sub    %rax,%rdx
  800420d272:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d276:	48 83 c0 10          	add    $0x10,%rax
  800420d27a:	48 8b 40 04          	mov    0x4(%rax),%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
	
		// Reset stack pointer, enable interrupts and then halt.
		asm volatile (
  800420d27e:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d285:	48 89 c4             	mov    %rax,%rsp
  800420d288:	6a 00                	pushq  $0x0
  800420d28a:	6a 00                	pushq  $0x0
  800420d28c:	fb                   	sti    
  800420d28d:	f4                   	hlt    
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
	}
  800420d28e:	c9                   	leaveq 
  800420d28f:	c3                   	retq   

000000800420d290 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d290:	55                   	push   %rbp
  800420d291:	48 89 e5             	mov    %rsp,%rbp
  800420d294:	48 83 ec 10          	sub    $0x10,%rsp
  800420d298:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d29c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U );
  800420d2a0:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d2a7:	00 00 00 
  800420d2aa:	ff d0                	callq  *%rax
  800420d2ac:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d2b3:	00 00 00 
  800420d2b6:	48 98                	cltq   
  800420d2b8:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2bc:	48 89 c2             	mov    %rax,%rdx
  800420d2bf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d2c3:	48 29 c2             	sub    %rax,%rdx
  800420d2c6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d2ca:	48 83 c0 08          	add    $0x8,%rax
  800420d2ce:	48 8b 00             	mov    (%rax),%rax
  800420d2d1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d2d5:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d2d9:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d2de:	48 89 c7             	mov    %rax,%rdi
  800420d2e1:	48 b8 53 3d 20 04 80 	movabs $0x8004203d53,%rax
  800420d2e8:	00 00 00 
  800420d2eb:	ff d0                	callq  *%rax
	
	// Print the string supplied by the user.
	
	cprintf("%.*s", len, s);
  800420d2ed:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d2f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2f5:	48 89 c6             	mov    %rax,%rsi
  800420d2f8:	48 bf 88 9d 21 04 80 	movabs $0x8004219d88,%rdi
  800420d2ff:	00 00 00 
  800420d302:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d307:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  800420d30e:	00 00 00 
  800420d311:	ff d1                	callq  *%rcx
}
  800420d313:	c9                   	leaveq 
  800420d314:	c3                   	retq   

000000800420d315 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d315:	55                   	push   %rbp
  800420d316:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d319:	48 b8 1b 11 20 04 80 	movabs $0x800420111b,%rax
  800420d320:	00 00 00 
  800420d323:	ff d0                	callq  *%rax
}
  800420d325:	5d                   	pop    %rbp
  800420d326:	c3                   	retq   

000000800420d327 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d327:	55                   	push   %rbp
  800420d328:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420d32b:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d332:	00 00 00 
  800420d335:	ff d0                	callq  *%rax
  800420d337:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d33e:	00 00 00 
  800420d341:	48 98                	cltq   
  800420d343:	48 c1 e0 03          	shl    $0x3,%rax
  800420d347:	48 89 c2             	mov    %rax,%rdx
  800420d34a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d34e:	48 29 c2             	sub    %rax,%rdx
  800420d351:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d355:	48 83 c0 08          	add    $0x8,%rax
  800420d359:	48 8b 00             	mov    (%rax),%rax
  800420d35c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d362:	5d                   	pop    %rbp
  800420d363:	c3                   	retq   

000000800420d364 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d364:	55                   	push   %rbp
  800420d365:	48 89 e5             	mov    %rsp,%rbp
  800420d368:	48 83 ec 20          	sub    $0x20,%rsp
  800420d36c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d36f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d373:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d376:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d37b:	48 89 ce             	mov    %rcx,%rsi
  800420d37e:	89 c7                	mov    %eax,%edi
  800420d380:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d387:	00 00 00 
  800420d38a:	ff d0                	callq  *%rax
  800420d38c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d38f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d393:	79 05                	jns    800420d39a <sys_env_destroy+0x36>
		return r;
  800420d395:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d398:	eb 18                	jmp    800420d3b2 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420d39a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d39e:	48 89 c7             	mov    %rax,%rdi
  800420d3a1:	48 b8 d4 85 20 04 80 	movabs $0x80042085d4,%rax
  800420d3a8:	00 00 00 
  800420d3ab:	ff d0                	callq  *%rax
	return 0;
  800420d3ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d3b2:	c9                   	leaveq 
  800420d3b3:	c3                   	retq   

000000800420d3b4 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d3b4:	55                   	push   %rbp
  800420d3b5:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420d3b8:	48 b8 e3 ce 20 04 80 	movabs $0x800420cee3,%rax
  800420d3bf:	00 00 00 
  800420d3c2:	ff d0                	callq  *%rax

000000800420d3c4 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d3c4:	55                   	push   %rbp
  800420d3c5:	48 89 e5             	mov    %rsp,%rbp
  800420d3c8:	53                   	push   %rbx
  800420d3c9:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *newenv_store;
	uint32_t  result = 0;
  800420d3cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	result= env_alloc(&newenv_store, curenv->env_id);
  800420d3d4:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d3db:	00 00 00 
  800420d3de:	ff d0                	callq  *%rax
  800420d3e0:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d3e7:	00 00 00 
  800420d3ea:	48 98                	cltq   
  800420d3ec:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3f0:	48 89 c2             	mov    %rax,%rdx
  800420d3f3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d3f7:	48 29 c2             	sub    %rax,%rdx
  800420d3fa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d3fe:	48 83 c0 08          	add    $0x8,%rax
  800420d402:	48 8b 00             	mov    (%rax),%rax
  800420d405:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d40b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420d40f:	89 d6                	mov    %edx,%esi
  800420d411:	48 89 c7             	mov    %rax,%rdi
  800420d414:	48 b8 15 7c 20 04 80 	movabs $0x8004207c15,%rax
  800420d41b:	00 00 00 
  800420d41e:	ff d0                	callq  *%rax
  800420d420:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if(result != 0)
  800420d423:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d427:	74 05                	je     800420d42e <sys_exofork+0x6a>
		return result;
  800420d429:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d42c:	eb 6d                	jmp    800420d49b <sys_exofork+0xd7>
	//cprintf("curenv->env_id [%d], newenv_store->env_parent_id [%d],  newenv_store->env_id [%d]\n",curenv->env_id, newenv_store->env_parent_id,newenv_store->env_id);

	newenv_store->env_status = ENV_NOT_RUNNABLE;
  800420d42e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d432:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d439:	00 00 00 
	newenv_store->env_tf = curenv->env_tf;
  800420d43c:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420d440:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420d447:	00 00 00 
  800420d44a:	ff d0                	callq  *%rax
  800420d44c:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420d453:	00 00 00 
  800420d456:	48 98                	cltq   
  800420d458:	48 c1 e0 03          	shl    $0x3,%rax
  800420d45c:	48 89 c2             	mov    %rax,%rdx
  800420d45f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d463:	48 29 c2             	sub    %rax,%rdx
  800420d466:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d46a:	48 83 c0 08          	add    $0x8,%rax
  800420d46e:	48 8b 00             	mov    (%rax),%rax
  800420d471:	48 89 da             	mov    %rbx,%rdx
  800420d474:	48 89 c6             	mov    %rax,%rsi
  800420d477:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d47c:	48 89 d7             	mov    %rdx,%rdi
  800420d47f:	48 89 c1             	mov    %rax,%rcx
  800420d482:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	newenv_store->env_tf.tf_regs.reg_rax = 0x00;
  800420d485:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d489:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d490:	00 
	return newenv_store->env_id;
  800420d491:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d495:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420d49b:	48 83 c4 18          	add    $0x18,%rsp
  800420d49f:	5b                   	pop    %rbx
  800420d4a0:	5d                   	pop    %rbp
  800420d4a1:	c3                   	retq   

000000800420d4a2 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d4a2:	55                   	push   %rbp
  800420d4a3:	48 89 e5             	mov    %rsp,%rbp
  800420d4a6:	48 83 ec 20          	sub    $0x20,%rsp
  800420d4aa:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d4ad:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d4b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d4b7:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d4bb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d4be:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d4c3:	48 89 ce             	mov    %rcx,%rsi
  800420d4c6:	89 c7                	mov    %eax,%edi
  800420d4c8:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d4cf:	00 00 00 
  800420d4d2:	ff d0                	callq  *%rax
  800420d4d4:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d4d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d4db:	74 05                	je     800420d4e2 <sys_env_set_status+0x40>
		return result;
  800420d4dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4e0:	eb 23                	jmp    800420d505 <sys_env_set_status+0x63>
	if(status< 0 || status >4)
  800420d4e2:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420d4e6:	78 06                	js     800420d4ee <sys_env_set_status+0x4c>
  800420d4e8:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d4ec:	7e 07                	jle    800420d4f5 <sys_env_set_status+0x53>
		return -E_INVAL;
  800420d4ee:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d4f3:	eb 10                	jmp    800420d505 <sys_env_set_status+0x63>
	
	env_store->env_status = status;
  800420d4f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4f9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d4fc:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return result;
  800420d502:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_env_set_status not implemented");
}
  800420d505:	c9                   	leaveq 
  800420d506:	c3                   	retq   

000000800420d507 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
	{
  800420d507:	55                   	push   %rbp
  800420d508:	48 89 e5             	mov    %rsp,%rbp
  800420d50b:	48 83 ec 20          	sub    $0x20,%rsp
  800420d50f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d512:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
		// LAB 5: Your code here.
		// Remember to check whether the user has supplied us with a good
		// address!
		//panic("sys_env_set_trapframe not implemented");
		uint32_t  result = 0;
  800420d516:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		struct Env *env_store;
		if(!tf)
  800420d51d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d522:	75 07                	jne    800420d52b <sys_env_set_trapframe+0x24>
			return -E_BAD_ENV;
  800420d524:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d529:	eb 73                	jmp    800420d59e <sys_env_set_trapframe+0x97>
		result = envid2env(envid,&env_store,1);
  800420d52b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d52f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d532:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d537:	48 89 ce             	mov    %rcx,%rsi
  800420d53a:	89 c7                	mov    %eax,%edi
  800420d53c:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d543:	00 00 00 
  800420d546:	ff d0                	callq  *%rax
  800420d548:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result < 0)
			return result;
		//user_mem_assert(env_store, tf, sizeof(struct Trapframe), PTE_U|PTE_P);
		tf->tf_cs |= 0x3;
  800420d54b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d54f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d556:	83 c8 03             	or     $0x3,%eax
  800420d559:	89 c2                	mov    %eax,%edx
  800420d55b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d55f:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
		tf->tf_eflags |= FL_IF;
  800420d566:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d56a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420d571:	80 cc 02             	or     $0x2,%ah
  800420d574:	48 89 c2             	mov    %rax,%rdx
  800420d577:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d57b:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_store->env_tf = *tf;
  800420d582:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d586:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d58a:	48 89 c6             	mov    %rax,%rsi
  800420d58d:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d592:	48 89 d7             	mov    %rdx,%rdi
  800420d595:	48 89 c1             	mov    %rax,%rcx
  800420d598:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		return result;
  800420d59b:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}
  800420d59e:	c9                   	leaveq 
  800420d59f:	c3                   	retq   

000000800420d5a0 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420d5a0:	55                   	push   %rbp
  800420d5a1:	48 89 e5             	mov    %rsp,%rbp
  800420d5a4:	48 83 ec 20          	sub    $0x20,%rsp
  800420d5a8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d5ab:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	
	uint32_t  result =0;
  800420d5af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d5b6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d5ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d5bd:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d5c2:	48 89 ce             	mov    %rcx,%rsi
  800420d5c5:	89 c7                	mov    %eax,%edi
  800420d5c7:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d5ce:	00 00 00 
  800420d5d1:	ff d0                	callq  *%rax
  800420d5d3:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d5d6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d5da:	74 05                	je     800420d5e1 <sys_env_set_pgfault_upcall+0x41>
		return result;
  800420d5dc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d5df:	eb 14                	jmp    800420d5f5 <sys_env_set_pgfault_upcall+0x55>

	env_store->env_pgfault_upcall = func;
  800420d5e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d5e5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d5e9:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420d5f0:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420d5f5:	c9                   	leaveq 
  800420d5f6:	c3                   	retq   

000000800420d5f7 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420d5f7:	55                   	push   %rbp
  800420d5f8:	48 89 e5             	mov    %rsp,%rbp
  800420d5fb:	48 83 ec 30          	sub    $0x30,%rsp
  800420d5ff:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d602:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420d606:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d609:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	struct PageInfo * pp;
	pte_t *pte_store;
	//cprintf("sys page alloc [%d]",result);
	result = envid2env(envid,&env_store,1);
  800420d610:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d614:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d617:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d61c:	48 89 ce             	mov    %rcx,%rsi
  800420d61f:	89 c7                	mov    %eax,%edi
  800420d621:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d628:	00 00 00 
  800420d62b:	ff d0                	callq  *%rax
  800420d62d:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d630:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d634:	74 08                	je     800420d63e <sys_page_alloc+0x47>
		return result;
  800420d636:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d639:	e9 a2 00 00 00       	jmpq   800420d6e0 <sys_page_alloc+0xe9>

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d63e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d641:	83 e0 04             	and    $0x4,%eax
  800420d644:	85 c0                	test   %eax,%eax
  800420d646:	74 16                	je     800420d65e <sys_page_alloc+0x67>
  800420d648:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d64b:	83 e0 01             	and    $0x1,%eax
  800420d64e:	85 c0                	test   %eax,%eax
  800420d650:	74 0c                	je     800420d65e <sys_page_alloc+0x67>
  800420d652:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d655:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d65a:	85 c0                	test   %eax,%eax
  800420d65c:	74 07                	je     800420d665 <sys_page_alloc+0x6e>
		return -E_INVAL;
  800420d65e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d663:	eb 7b                	jmp    800420d6e0 <sys_page_alloc+0xe9>

	if(((uint64_t)va%PGSIZE !=0) ||((uint64_t)va> UTOP))
  800420d665:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d669:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d66e:	48 85 c0             	test   %rax,%rax
  800420d671:	75 13                	jne    800420d686 <sys_page_alloc+0x8f>
  800420d673:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d677:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d67e:	00 00 00 
  800420d681:	48 39 c2             	cmp    %rax,%rdx
  800420d684:	76 07                	jbe    800420d68d <sys_page_alloc+0x96>
		return -E_INVAL;
  800420d686:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d68b:	eb 53                	jmp    800420d6e0 <sys_page_alloc+0xe9>
	
    pp = page_alloc(0);
  800420d68d:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d692:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  800420d699:	00 00 00 
  800420d69c:	ff d0                	callq  *%rax
  800420d69e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!pp)
  800420d6a2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d6a7:	75 07                	jne    800420d6b0 <sys_page_alloc+0xb9>
		return -E_NO_MEM;
  800420d6a9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420d6ae:	eb 30                	jmp    800420d6e0 <sys_page_alloc+0xe9>
	

	result = page_insert(env_store->env_pml4e,pp,va,perm|PTE_P);
  800420d6b0:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d6b3:	83 c8 01             	or     $0x1,%eax
  800420d6b6:	89 c1                	mov    %eax,%ecx
  800420d6b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6bc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d6c3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d6c7:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d6cb:	48 89 c7             	mov    %rax,%rdi
  800420d6ce:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  800420d6d5:	00 00 00 
  800420d6d8:	ff d0                	callq  *%rax
  800420d6da:	89 45 fc             	mov    %eax,-0x4(%rbp)
	//cprintf("sys page alloc [%d]",result);
	return result;
  800420d6dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_alloc not implemented");
}
  800420d6e0:	c9                   	leaveq 
  800420d6e1:	c3                   	retq   

000000800420d6e2 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420d6e2:	55                   	push   %rbp
  800420d6e3:	48 89 e5             	mov    %rsp,%rbp
  800420d6e6:	48 83 ec 50          	sub    $0x50,%rsp
  800420d6ea:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420d6ed:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420d6f1:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420d6f4:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420d6f8:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.

	
	uint32_t  result =0;
  800420d6fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_dst;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420d703:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d707:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d70a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d70f:	48 89 ce             	mov    %rcx,%rsi
  800420d712:	89 c7                	mov    %eax,%edi
  800420d714:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d71b:	00 00 00 
  800420d71e:	ff d0                	callq  *%rax
  800420d720:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0){
  800420d723:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d727:	74 08                	je     800420d731 <sys_page_map+0x4f>
		//cprintf("need 1stcheckperm to be 0\n");
		return result;
  800420d729:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d72c:	e9 1c 01 00 00       	jmpq   800420d84d <sys_page_map+0x16b>
	}
	result = envid2env(dstenvid,&env_store_dst,0);
  800420d731:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420d735:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420d738:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d73d:	48 89 ce             	mov    %rcx,%rsi
  800420d740:	89 c7                	mov    %eax,%edi
  800420d742:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d749:	00 00 00 
  800420d74c:	ff d0                	callq  *%rax
  800420d74e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420d751:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d755:	74 08                	je     800420d75f <sys_page_map+0x7d>
		//cprintf("need 2ndcheckperm to be 0\n");
		return result;
  800420d757:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d75a:	e9 ee 00 00 00       	jmpq   800420d84d <sys_page_map+0x16b>
	}

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d75f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d762:	83 e0 04             	and    $0x4,%eax
  800420d765:	85 c0                	test   %eax,%eax
  800420d767:	74 16                	je     800420d77f <sys_page_map+0x9d>
  800420d769:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d76c:	83 e0 01             	and    $0x1,%eax
  800420d76f:	85 c0                	test   %eax,%eax
  800420d771:	74 0c                	je     800420d77f <sys_page_map+0x9d>
  800420d773:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d776:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d77b:	85 c0                	test   %eax,%eax
  800420d77d:	74 0a                	je     800420d789 <sys_page_map+0xa7>
		return -E_INVAL;
  800420d77f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d784:	e9 c4 00 00 00       	jmpq   800420d84d <sys_page_map+0x16b>

	
	if(((uint64_t)dstva%PGSIZE !=0 || (uint64_t)dstva> UTOP)||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva> UTOP))
  800420d789:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420d78d:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d792:	48 85 c0             	test   %rax,%rax
  800420d795:	75 34                	jne    800420d7cb <sys_page_map+0xe9>
  800420d797:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d79b:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d7a2:	00 00 00 
  800420d7a5:	48 39 c2             	cmp    %rax,%rdx
  800420d7a8:	77 21                	ja     800420d7cb <sys_page_map+0xe9>
  800420d7aa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420d7ae:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d7b3:	48 85 c0             	test   %rax,%rax
  800420d7b6:	75 13                	jne    800420d7cb <sys_page_map+0xe9>
  800420d7b8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d7bc:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d7c3:	00 00 00 
  800420d7c6:	48 39 c2             	cmp    %rax,%rdx
  800420d7c9:	76 07                	jbe    800420d7d2 <sys_page_map+0xf0>
		return -E_INVAL;
  800420d7cb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d7d0:	eb 7b                	jmp    800420d84d <sys_page_map+0x16b>
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420d7d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7d6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d7dd:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420d7e1:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420d7e5:	48 89 ce             	mov    %rcx,%rsi
  800420d7e8:	48 89 c7             	mov    %rax,%rdi
  800420d7eb:	48 b8 37 39 20 04 80 	movabs $0x8004203937,%rax
  800420d7f2:	00 00 00 
  800420d7f5:	ff d0                	callq  *%rax
  800420d7f7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0)))
  800420d7fb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d800:	74 19                	je     800420d81b <sys_page_map+0x139>
  800420d802:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d806:	48 8b 00             	mov    (%rax),%rax
  800420d809:	83 e0 02             	and    $0x2,%eax
  800420d80c:	48 85 c0             	test   %rax,%rax
  800420d80f:	75 11                	jne    800420d822 <sys_page_map+0x140>
  800420d811:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d814:	83 e0 02             	and    $0x2,%eax
  800420d817:	85 c0                	test   %eax,%eax
  800420d819:	74 07                	je     800420d822 <sys_page_map+0x140>
		return -E_INVAL;	
  800420d81b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d820:	eb 2b                	jmp    800420d84d <sys_page_map+0x16b>

	
	result = page_insert(env_store_dst->env_pml4e,pp,dstva,perm);
  800420d822:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d826:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d82d:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420d830:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d834:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d838:	48 89 c7             	mov    %rax,%rdi
  800420d83b:	48 b8 da 37 20 04 80 	movabs $0x80042037da,%rax
  800420d842:	00 00 00 
  800420d845:	ff d0                	callq  *%rax
  800420d847:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	return result;
  800420d84a:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_map not implemented");
}
  800420d84d:	c9                   	leaveq 
  800420d84e:	c3                   	retq   

000000800420d84f <sys_page_unmap>:
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.

static int
sys_page_unmap(envid_t envid, void *va)
{
  800420d84f:	55                   	push   %rbp
  800420d850:	48 89 e5             	mov    %rsp,%rbp
  800420d853:	48 83 ec 20          	sub    $0x20,%rsp
  800420d857:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d85a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(envid, &env,1) != 0)
  800420d85e:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d862:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d865:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d86a:	48 89 ce             	mov    %rcx,%rsi
  800420d86d:	89 c7                	mov    %eax,%edi
  800420d86f:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d876:	00 00 00 
  800420d879:	ff d0                	callq  *%rax
  800420d87b:	85 c0                	test   %eax,%eax
  800420d87d:	74 07                	je     800420d886 <sys_page_unmap+0x37>
	{
		return -E_BAD_ENV;
  800420d87f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d884:	eb 55                	jmp    800420d8db <sys_page_unmap+0x8c>
	}
	if(va == NULL || (uint64_t)va >= UTOP || (uint64_t)va  % PGSIZE != 0)
  800420d886:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d88b:	74 21                	je     800420d8ae <sys_page_unmap+0x5f>
  800420d88d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d891:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d898:	00 00 00 
  800420d89b:	48 39 c2             	cmp    %rax,%rdx
  800420d89e:	77 0e                	ja     800420d8ae <sys_page_unmap+0x5f>
  800420d8a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d8a4:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d8a9:	48 85 c0             	test   %rax,%rax
  800420d8ac:	74 07                	je     800420d8b5 <sys_page_unmap+0x66>
	{
		return -E_INVAL;
  800420d8ae:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d8b3:	eb 26                	jmp    800420d8db <sys_page_unmap+0x8c>
	}
	page_remove(env->env_pml4e, va);
  800420d8b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d8b9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d8c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d8c4:	48 89 d6             	mov    %rdx,%rsi
  800420d8c7:	48 89 c7             	mov    %rax,%rdi
  800420d8ca:	48 b8 d1 39 20 04 80 	movabs $0x80042039d1,%rax
  800420d8d1:	00 00 00 
  800420d8d4:	ff d0                	callq  *%rax
	return 0;
  800420d8d6:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420d8db:	c9                   	leaveq 
  800420d8dc:	c3                   	retq   

000000800420d8dd <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420d8dd:	55                   	push   %rbp
  800420d8de:	48 89 e5             	mov    %rsp,%rbp
  800420d8e1:	48 83 ec 40          	sub    $0x40,%rsp
  800420d8e5:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d8e8:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420d8eb:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420d8ef:	89 4d cc             	mov    %ecx,-0x34(%rbp)
	// LAB 4: Your code here.
	struct Env* dstenv;
	struct Env* srcenv;
	pte_t* pte_store;
	int srcperm;
	perm|= PTE_P;
  800420d8f2:	83 4d cc 01          	orl    $0x1,-0x34(%rbp)
	if(envid2env(envid, &dstenv,0) != 0)
  800420d8f6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d8fa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d8fd:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d902:	48 89 ce             	mov    %rcx,%rsi
  800420d905:	89 c7                	mov    %eax,%edi
  800420d907:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d90e:	00 00 00 
  800420d911:	ff d0                	callq  *%rax
  800420d913:	85 c0                	test   %eax,%eax
  800420d915:	74 0a                	je     800420d921 <sys_ipc_try_send+0x44>
		return -E_BAD_ENV;
  800420d917:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d91c:	e9 19 02 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>

	if(envid2env(0, &srcenv,0) != 0)
  800420d921:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420d925:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d92a:	48 89 c6             	mov    %rax,%rsi
  800420d92d:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d932:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420d939:	00 00 00 
  800420d93c:	ff d0                	callq  *%rax
  800420d93e:	85 c0                	test   %eax,%eax
  800420d940:	74 0a                	je     800420d94c <sys_ipc_try_send+0x6f>
		return -E_BAD_ENV;
  800420d942:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d947:	e9 ee 01 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>
	
	if(!dstenv->env_ipc_recving)
  800420d94c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d950:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420d957:	83 f0 01             	xor    $0x1,%eax
  800420d95a:	84 c0                	test   %al,%al
  800420d95c:	74 0a                	je     800420d968 <sys_ipc_try_send+0x8b>
		return -E_IPC_NOT_RECV;
  800420d95e:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420d963:	e9 d2 01 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>

	if(!page_lookup(srcenv->env_pml4e,srcva,&pte_store))
  800420d968:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d96c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d973:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420d977:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420d97b:	48 89 ce             	mov    %rcx,%rsi
  800420d97e:	48 89 c7             	mov    %rax,%rdi
  800420d981:	48 b8 37 39 20 04 80 	movabs $0x8004203937,%rax
  800420d988:	00 00 00 
  800420d98b:	ff d0                	callq  *%rax
  800420d98d:	48 85 c0             	test   %rax,%rax
  800420d990:	75 1a                	jne    800420d9ac <sys_ipc_try_send+0xcf>
		if(srcva <(void*)UTOP)
  800420d992:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d999:	00 00 00 
  800420d99c:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9a0:	77 0a                	ja     800420d9ac <sys_ipc_try_send+0xcf>
			return -E_INVAL;
  800420d9a2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9a7:	e9 8e 01 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>
	srcperm = *pte_store&PTE_SYSCALL;
  800420d9ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d9b0:	48 8b 00             	mov    (%rax),%rax
  800420d9b3:	25 07 0e 00 00       	and    $0xe07,%eax
  800420d9b8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(srcva <(void*)UTOP)
  800420d9bb:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9c2:	00 00 00 
  800420d9c5:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9c9:	77 23                	ja     800420d9ee <sys_ipc_try_send+0x111>
		if((((uint64_t)srcva)%PGSIZE!=0) || ((srcperm & (PTE_U | PTE_P))!=(PTE_U | PTE_P)))
  800420d9cb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d9cf:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d9d4:	48 85 c0             	test   %rax,%rax
  800420d9d7:	75 0b                	jne    800420d9e4 <sys_ipc_try_send+0x107>
  800420d9d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d9dc:	83 e0 05             	and    $0x5,%eax
  800420d9df:	83 f8 05             	cmp    $0x5,%eax
  800420d9e2:	74 0a                	je     800420d9ee <sys_ipc_try_send+0x111>
			return -E_INVAL;
  800420d9e4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9e9:	e9 4c 01 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>
	if((srcva <(void*)UTOP) && ((perm & PTE_W) !=0) &&(((srcperm& PTE_W) == 0)))
  800420d9ee:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9f5:	00 00 00 
  800420d9f8:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9fc:	77 1e                	ja     800420da1c <sys_ipc_try_send+0x13f>
  800420d9fe:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420da01:	83 e0 02             	and    $0x2,%eax
  800420da04:	85 c0                	test   %eax,%eax
  800420da06:	74 14                	je     800420da1c <sys_ipc_try_send+0x13f>
  800420da08:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420da0b:	83 e0 02             	and    $0x2,%eax
  800420da0e:	85 c0                	test   %eax,%eax
  800420da10:	75 0a                	jne    800420da1c <sys_ipc_try_send+0x13f>
		return -E_INVAL;
  800420da12:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420da17:	e9 1e 01 00 00       	jmpq   800420db3a <sys_ipc_try_send+0x25d>

	if(envid == curenv->env_id)
  800420da1c:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420da23:	00 00 00 
  800420da26:	ff d0                	callq  *%rax
  800420da28:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420da2f:	00 00 00 
  800420da32:	48 98                	cltq   
  800420da34:	48 c1 e0 03          	shl    $0x3,%rax
  800420da38:	48 89 c2             	mov    %rax,%rdx
  800420da3b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420da3f:	48 29 c2             	sub    %rax,%rdx
  800420da42:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420da46:	48 83 c0 08          	add    $0x8,%rax
  800420da4a:	48 8b 00             	mov    (%rax),%rax
  800420da4d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420da53:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420da56:	75 2a                	jne    800420da82 <sys_ipc_try_send+0x1a5>
		panic("what the hell. how can this be????");
  800420da58:	48 ba 90 9d 21 04 80 	movabs $0x8004219d90,%rdx
  800420da5f:	00 00 00 
  800420da62:	be 96 01 00 00       	mov    $0x196,%esi
  800420da67:	48 bf b3 9d 21 04 80 	movabs $0x8004219db3,%rdi
  800420da6e:	00 00 00 
  800420da71:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da76:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  800420da7d:	00 00 00 
  800420da80:	ff d1                	callq  *%rcx

	dstenv->env_ipc_recving = 0;
  800420da82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da86:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	dstenv->env_ipc_from = srcenv->env_id;
  800420da8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da95:	8b 92 c8 00 00 00    	mov    0xc8(%rdx),%edx
  800420da9b:	89 90 0c 01 00 00    	mov    %edx,0x10c(%rax)
	dstenv->env_ipc_value = value;
  800420daa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420daa5:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420daa8:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	//cprintf("dstenv -> envID is:[%d]\n",dstenv->env_id);
	if(srcva <(void*)UTOP && dstenv->env_ipc_dstva <(void*)UTOP){
  800420daae:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dab5:	00 00 00 
  800420dab8:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420dabc:	77 69                	ja     800420db27 <sys_ipc_try_send+0x24a>
  800420dabe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dac2:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420dac9:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dad0:	00 00 00 
  800420dad3:	48 39 c2             	cmp    %rax,%rdx
  800420dad6:	77 4f                	ja     800420db27 <sys_ipc_try_send+0x24a>
		dstenv->env_ipc_perm = perm;
  800420dad8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dadc:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420dadf:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
		if(0< sys_page_map(srcenv->env_id,srcva,dstenv->env_id,dstenv->env_ipc_dstva,perm))
  800420dae5:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420dae8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420daec:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
  800420daf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420daf7:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420dafd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db01:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420db07:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420db0b:	41 89 f8             	mov    %edi,%r8d
  800420db0e:	89 c7                	mov    %eax,%edi
  800420db10:	48 b8 e2 d6 20 04 80 	movabs $0x800420d6e2,%rax
  800420db17:	00 00 00 
  800420db1a:	ff d0                	callq  *%rax
  800420db1c:	85 c0                	test   %eax,%eax
  800420db1e:	7e 07                	jle    800420db27 <sys_ipc_try_send+0x24a>
			return -E_NO_MEM;
  800420db20:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420db25:	eb 13                	jmp    800420db3a <sys_ipc_try_send+0x25d>
	}
	dstenv->env_status = ENV_RUNNABLE;
  800420db27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420db2b:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420db32:	00 00 00 
	return 0;
  800420db35:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420db3a:	c9                   	leaveq 
  800420db3b:	c3                   	retq   

000000800420db3c <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420db3c:	55                   	push   %rbp
  800420db3d:	48 89 e5             	mov    %rsp,%rbp
  800420db40:	48 83 ec 20          	sub    $0x20,%rsp
  800420db44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(0, &env,0) != 0)
  800420db48:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800420db4c:	ba 00 00 00 00       	mov    $0x0,%edx
  800420db51:	48 89 c6             	mov    %rax,%rsi
  800420db54:	bf 00 00 00 00       	mov    $0x0,%edi
  800420db59:	48 b8 79 78 20 04 80 	movabs $0x8004207879,%rax
  800420db60:	00 00 00 
  800420db63:	ff d0                	callq  *%rax
  800420db65:	85 c0                	test   %eax,%eax
  800420db67:	74 07                	je     800420db70 <sys_ipc_recv+0x34>
	{
		return -E_BAD_ENV;
  800420db69:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420db6e:	eb 7a                	jmp    800420dbea <sys_ipc_recv+0xae>
	}
	if(dstva <(void*)UTOP && (uint64_t)dstva%PGSIZE!=0)
  800420db70:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db77:	00 00 00 
  800420db7a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420db7e:	77 15                	ja     800420db95 <sys_ipc_recv+0x59>
  800420db80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db84:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db89:	48 85 c0             	test   %rax,%rax
  800420db8c:	74 07                	je     800420db95 <sys_ipc_recv+0x59>
		return -E_INVAL;
  800420db8e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db93:	eb 55                	jmp    800420dbea <sys_ipc_recv+0xae>
	if(dstva <(void*)UTOP)
  800420db95:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db9c:	00 00 00 
  800420db9f:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420dba3:	77 0f                	ja     800420dbb4 <sys_ipc_recv+0x78>
		env->env_ipc_dstva = dstva;
  800420dba5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dba9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dbad:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)

	env->env_ipc_recving = 1;
  800420dbb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dbb8:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)

	env->env_status = ENV_NOT_RUNNABLE;
  800420dbbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dbc3:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420dbca:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420dbcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dbd1:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420dbd8:	00 
	sys_yield();
  800420dbd9:	48 b8 b4 d3 20 04 80 	movabs $0x800420d3b4,%rax
  800420dbe0:	00 00 00 
  800420dbe3:	ff d0                	callq  *%rax
	
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420dbe5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dbea:	c9                   	leaveq 
  800420dbeb:	c3                   	retq   

000000800420dbec <sys_time_msec>:

// Return the current time.
static int
sys_time_msec(void)
{
  800420dbec:	55                   	push   %rbp
  800420dbed:	48 89 e5             	mov    %rsp,%rbp
        // LAB 6: Your code here.
        return time_msec();
  800420dbf0:	48 b8 62 84 21 04 80 	movabs $0x8004218462,%rax
  800420dbf7:	00 00 00 
  800420dbfa:	ff d0                	callq  *%rax
        panic("sys_time_msec not implemented");
}
  800420dbfc:	5d                   	pop    %rbp
  800420dbfd:	c3                   	retq   

000000800420dbfe <sys_net_rx>:

static int
sys_net_rx(void * buf)
{
  800420dbfe:	55                   	push   %rbp
  800420dbff:	48 89 e5             	mov    %rsp,%rbp
  800420dc02:	48 83 ec 20          	sub    $0x20,%rsp
  800420dc06:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int result = 0;
  800420dc0a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	user_mem_assert(curenv, (const void *)buf, PGSIZE, PTE_U);
  800420dc11:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420dc18:	00 00 00 
  800420dc1b:	ff d0                	callq  *%rax
  800420dc1d:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420dc24:	00 00 00 
  800420dc27:	48 98                	cltq   
  800420dc29:	48 c1 e0 03          	shl    $0x3,%rax
  800420dc2d:	48 89 c2             	mov    %rax,%rdx
  800420dc30:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dc34:	48 29 c2             	sub    %rax,%rdx
  800420dc37:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420dc3b:	48 83 c0 08          	add    $0x8,%rax
  800420dc3f:	48 8b 00             	mov    (%rax),%rax
  800420dc42:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420dc46:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420dc4b:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420dc50:	48 89 c7             	mov    %rax,%rdi
  800420dc53:	48 b8 53 3d 20 04 80 	movabs $0x8004203d53,%rax
  800420dc5a:	00 00 00 
  800420dc5d:	ff d0                	callq  *%rax
	result = pci_receive_packet(buf);
  800420dc5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc63:	48 89 c7             	mov    %rax,%rdi
  800420dc66:	48 b8 94 74 21 04 80 	movabs $0x8004217494,%rax
  800420dc6d:	00 00 00 
  800420dc70:	ff d0                	callq  *%rax
  800420dc72:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return result;
  800420dc75:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420dc78:	c9                   	leaveq 
  800420dc79:	c3                   	retq   

000000800420dc7a <sys_net_tx>:

static int
sys_net_tx(void * buf, size_t size)
{
  800420dc7a:	55                   	push   %rbp
  800420dc7b:	48 89 e5             	mov    %rsp,%rbp
  800420dc7e:	48 83 ec 20          	sub    $0x20,%rsp
  800420dc82:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dc86:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	//check for user buffer permissions and address
	int result = -1;
  800420dc8a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	user_mem_assert(curenv, (const void *)buf, size, PTE_U);
  800420dc91:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420dc98:	00 00 00 
  800420dc9b:	ff d0                	callq  *%rax
  800420dc9d:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420dca4:	00 00 00 
  800420dca7:	48 98                	cltq   
  800420dca9:	48 c1 e0 03          	shl    $0x3,%rax
  800420dcad:	48 89 c2             	mov    %rax,%rdx
  800420dcb0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dcb4:	48 29 c2             	sub    %rax,%rdx
  800420dcb7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420dcbb:	48 83 c0 08          	add    $0x8,%rax
  800420dcbf:	48 8b 00             	mov    (%rax),%rax
  800420dcc2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420dcc6:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420dcca:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420dccf:	48 89 c7             	mov    %rax,%rdi
  800420dcd2:	48 b8 53 3d 20 04 80 	movabs $0x8004203d53,%rax
  800420dcd9:	00 00 00 
  800420dcdc:	ff d0                	callq  *%rax
	result = pci_transmit_packet(buf ,size);
  800420dcde:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420dce2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dce6:	48 89 d6             	mov    %rdx,%rsi
  800420dce9:	48 89 c7             	mov    %rax,%rdi
  800420dcec:	48 b8 fc 72 21 04 80 	movabs $0x80042172fc,%rax
  800420dcf3:	00 00 00 
  800420dcf6:	ff d0                	callq  *%rax
  800420dcf8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return result;
  800420dcfb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420dcfe:	c9                   	leaveq 
  800420dcff:	c3                   	retq   

000000800420dd00 <syscall>:

// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420dd00:	55                   	push   %rbp
  800420dd01:	48 89 e5             	mov    %rsp,%rbp
  800420dd04:	48 83 ec 40          	sub    $0x40,%rsp
  800420dd08:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dd0c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dd10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dd14:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420dd18:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420dd1c:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	int64_t result = -E_NO_SYS;
  800420dd20:	48 c7 45 f8 f9 ff ff 	movq   $0xfffffffffffffff9,-0x8(%rbp)
  800420dd27:	ff 

	switch (syscallno) 
  800420dd28:	48 83 7d e8 10       	cmpq   $0x10,-0x18(%rbp)
  800420dd2d:	0f 87 15 02 00 00    	ja     800420df48 <syscall+0x248>
  800420dd33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd37:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420dd3e:	00 
  800420dd3f:	48 b8 c8 9d 21 04 80 	movabs $0x8004219dc8,%rax
  800420dd46:	00 00 00 
  800420dd49:	48 01 d0             	add    %rdx,%rax
  800420dd4c:	48 8b 00             	mov    (%rax),%rax
  800420dd4f:	ff e0                	jmpq   *%rax
	{
		case SYS_cputs:
			sys_cputs((const char *)a1, a2);
  800420dd51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd55:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dd59:	48 89 d6             	mov    %rdx,%rsi
  800420dd5c:	48 89 c7             	mov    %rax,%rdi
  800420dd5f:	48 b8 90 d2 20 04 80 	movabs $0x800420d290,%rax
  800420dd66:	00 00 00 
  800420dd69:	ff d0                	callq  *%rax
			result = 0;
  800420dd6b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dd72:	00 
			break;
  800420dd73:	e9 d9 01 00 00       	jmpq   800420df51 <syscall+0x251>
		case SYS_cgetc:
			result = sys_cgetc();
  800420dd78:	48 b8 15 d3 20 04 80 	movabs $0x800420d315,%rax
  800420dd7f:	00 00 00 
  800420dd82:	ff d0                	callq  *%rax
  800420dd84:	48 98                	cltq   
  800420dd86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dd8a:	e9 c2 01 00 00       	jmpq   800420df51 <syscall+0x251>
		case SYS_getenvid:
			result = sys_getenvid();
  800420dd8f:	48 b8 27 d3 20 04 80 	movabs $0x800420d327,%rax
  800420dd96:	00 00 00 
  800420dd99:	ff d0                	callq  *%rax
  800420dd9b:	48 98                	cltq   
  800420dd9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dda1:	e9 ab 01 00 00       	jmpq   800420df51 <syscall+0x251>
		case SYS_env_destroy:
			result = sys_env_destroy(a1);
  800420dda6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddaa:	89 c7                	mov    %eax,%edi
  800420ddac:	48 b8 64 d3 20 04 80 	movabs $0x800420d364,%rax
  800420ddb3:	00 00 00 
  800420ddb6:	ff d0                	callq  *%rax
  800420ddb8:	48 98                	cltq   
  800420ddba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420ddbe:	e9 8e 01 00 00       	jmpq   800420df51 <syscall+0x251>
		case SYS_yield:
			sys_yield();
  800420ddc3:	48 b8 b4 d3 20 04 80 	movabs $0x800420d3b4,%rax
  800420ddca:	00 00 00 
  800420ddcd:	ff d0                	callq  *%rax
			result = 0;
  800420ddcf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ddd6:	00 
			break;
  800420ddd7:	e9 75 01 00 00       	jmpq   800420df51 <syscall+0x251>
		case SYS_exofork:
			return sys_exofork();
  800420dddc:	48 b8 c4 d3 20 04 80 	movabs $0x800420d3c4,%rax
  800420dde3:	00 00 00 
  800420dde6:	ff d0                	callq  *%rax
  800420dde8:	48 98                	cltq   
  800420ddea:	e9 66 01 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420ddef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddf3:	89 c2                	mov    %eax,%edx
  800420ddf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddf9:	89 d6                	mov    %edx,%esi
  800420ddfb:	89 c7                	mov    %eax,%edi
  800420ddfd:	48 b8 a2 d4 20 04 80 	movabs $0x800420d4a2,%rax
  800420de04:	00 00 00 
  800420de07:	ff d0                	callq  *%rax
  800420de09:	48 98                	cltq   
  800420de0b:	e9 45 01 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall(a1, (void*)a2);
  800420de10:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420de14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de18:	48 89 d6             	mov    %rdx,%rsi
  800420de1b:	89 c7                	mov    %eax,%edi
  800420de1d:	48 b8 a0 d5 20 04 80 	movabs $0x800420d5a0,%rax
  800420de24:	00 00 00 
  800420de27:	ff d0                	callq  *%rax
  800420de29:	48 98                	cltq   
  800420de2b:	e9 25 01 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_ipc_try_send:
			return sys_ipc_try_send(a1, a2, (void*)a3, a4);
  800420de30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420de34:	89 c1                	mov    %eax,%ecx
  800420de36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420de3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de3e:	89 c6                	mov    %eax,%esi
  800420de40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de44:	89 c7                	mov    %eax,%edi
  800420de46:	48 b8 dd d8 20 04 80 	movabs $0x800420d8dd,%rax
  800420de4d:	00 00 00 
  800420de50:	ff d0                	callq  *%rax
  800420de52:	48 98                	cltq   
  800420de54:	e9 fc 00 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420de59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de5d:	48 89 c7             	mov    %rax,%rdi
  800420de60:	48 b8 3c db 20 04 80 	movabs $0x800420db3c,%rax
  800420de67:	00 00 00 
  800420de6a:	ff d0                	callq  *%rax
  800420de6c:	48 98                	cltq   
  800420de6e:	e9 e2 00 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void*)a2, a3);
  800420de73:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420de77:	89 c2                	mov    %eax,%edx
  800420de79:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420de7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de81:	48 89 ce             	mov    %rcx,%rsi
  800420de84:	89 c7                	mov    %eax,%edi
  800420de86:	48 b8 f7 d5 20 04 80 	movabs $0x800420d5f7,%rax
  800420de8d:	00 00 00 
  800420de90:	ff d0                	callq  *%rax
  800420de92:	48 98                	cltq   
  800420de94:	e9 bc 00 00 00       	jmpq   800420df55 <syscall+0x255>
			break;	
		case SYS_page_map:
			return sys_page_map(a1, (void*)a2, a3, (void*)a4, a5);
  800420de99:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420de9d:	89 c7                	mov    %eax,%edi
  800420de9f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420dea3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dea7:	89 c2                	mov    %eax,%edx
  800420dea9:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420dead:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420deb1:	41 89 f8             	mov    %edi,%r8d
  800420deb4:	89 c7                	mov    %eax,%edi
  800420deb6:	48 b8 e2 d6 20 04 80 	movabs $0x800420d6e2,%rax
  800420debd:	00 00 00 
  800420dec0:	ff d0                	callq  *%rax
  800420dec2:	48 98                	cltq   
  800420dec4:	e9 8c 00 00 00       	jmpq   800420df55 <syscall+0x255>
			break;
		case SYS_page_unmap:
			return sys_page_unmap(a1, (void*)a2);
  800420dec9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420decd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ded1:	48 89 d6             	mov    %rdx,%rsi
  800420ded4:	89 c7                	mov    %eax,%edi
  800420ded6:	48 b8 4f d8 20 04 80 	movabs $0x800420d84f,%rax
  800420dedd:	00 00 00 
  800420dee0:	ff d0                	callq  *%rax
  800420dee2:	48 98                	cltq   
  800420dee4:	eb 6f                	jmp    800420df55 <syscall+0x255>
			break;
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe(a1, (struct Trapframe *)a2);
  800420dee6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420deea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420deee:	48 89 d6             	mov    %rdx,%rsi
  800420def1:	89 c7                	mov    %eax,%edi
  800420def3:	48 b8 07 d5 20 04 80 	movabs $0x800420d507,%rax
  800420defa:	00 00 00 
  800420defd:	ff d0                	callq  *%rax
  800420deff:	48 98                	cltq   
  800420df01:	eb 52                	jmp    800420df55 <syscall+0x255>
		case SYS_net_rx:
			return sys_net_rx((void *)a1);
  800420df03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df07:	48 89 c7             	mov    %rax,%rdi
  800420df0a:	48 b8 fe db 20 04 80 	movabs $0x800420dbfe,%rax
  800420df11:	00 00 00 
  800420df14:	ff d0                	callq  *%rax
  800420df16:	48 98                	cltq   
  800420df18:	eb 3b                	jmp    800420df55 <syscall+0x255>
		case SYS_net_tx:
			return sys_net_tx((void *)a1, (size_t)a2);
  800420df1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df1e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420df22:	48 89 d6             	mov    %rdx,%rsi
  800420df25:	48 89 c7             	mov    %rax,%rdi
  800420df28:	48 b8 7a dc 20 04 80 	movabs $0x800420dc7a,%rax
  800420df2f:	00 00 00 
  800420df32:	ff d0                	callq  *%rax
  800420df34:	48 98                	cltq   
  800420df36:	eb 1d                	jmp    800420df55 <syscall+0x255>
		case SYS_time_msec:
			return sys_time_msec();
  800420df38:	48 b8 ec db 20 04 80 	movabs $0x800420dbec,%rax
  800420df3f:	00 00 00 
  800420df42:	ff d0                	callq  *%rax
  800420df44:	48 98                	cltq   
  800420df46:	eb 0d                	jmp    800420df55 <syscall+0x255>
		default:		
			return -E_NO_SYS;
  800420df48:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420df4f:	eb 04                	jmp    800420df55 <syscall+0x255>
	}
	return result;	
  800420df51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420df55:	c9                   	leaveq 
  800420df56:	c3                   	retq   

000000800420df57 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420df57:	55                   	push   %rbp
  800420df58:	48 89 e5             	mov    %rsp,%rbp
  800420df5b:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420df62:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420df69:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420df70:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420df77:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df7e:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420df85:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420df89:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df90:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420df97:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420df9b:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420dfa2:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420dfa9:	48 89 d1             	mov    %rdx,%rcx
  800420dfac:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420dfb1:	48 89 ce             	mov    %rcx,%rsi
  800420dfb4:	48 89 c7             	mov    %rax,%rdi
  800420dfb7:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  800420dfbe:	00 00 00 
  800420dfc1:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420dfc3:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420dfca:	00 
	uint64_t ret_offset=0;
  800420dfcb:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420dfd2:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420dfd3:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dfda:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dfde:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420dfe2:	74 0a                	je     800420dfee <list_func_die+0x97>
		return 0;
  800420dfe4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dfe9:	e9 cd 06 00 00       	jmpq   800420e6bb <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420dfee:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420dff5:	ba 38 00 00 00       	mov    $0x38,%edx
  800420dffa:	be 00 00 00 00       	mov    $0x0,%esi
  800420dfff:	48 89 c7             	mov    %rax,%rdi
  800420e002:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  800420e009:	00 00 00 
  800420e00c:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420e00e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e015:	be 11 00 00 00       	mov    $0x11,%esi
  800420e01a:	48 89 c7             	mov    %rax,%rdi
  800420e01d:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e024:	00 00 00 
  800420e027:	ff d0                	callq  *%rax
  800420e029:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420e02d:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e034:	be 12 00 00 00       	mov    $0x12,%esi
  800420e039:	48 89 c7             	mov    %rax,%rdi
  800420e03c:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e043:	00 00 00 
  800420e046:	ff d0                	callq  *%rax
  800420e048:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420e04c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e051:	0f 84 5f 06 00 00    	je     800420e6b6 <list_func_die+0x75f>
  800420e057:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e05b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e05f:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420e066:	0f 83 4a 06 00 00    	jae    800420e6b6 <list_func_die+0x75f>
  800420e06c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e071:	0f 84 3f 06 00 00    	je     800420e6b6 <list_func_die+0x75f>
  800420e077:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e07b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e07f:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420e086:	0f 86 2a 06 00 00    	jbe    800420e6b6 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420e08c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e093:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e09a:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e0a1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0a8:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420e0ab:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e0b2:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e0b9:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0c0:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420e0c4:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e0cb:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420e0d2:	48 89 c7             	mov    %rax,%rdi
  800420e0d5:	48 b8 50 f7 20 04 80 	movabs $0x800420f750,%rax
  800420e0dc:	00 00 00 
  800420e0df:	ff d0                	callq  *%rax
  800420e0e1:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420e0e8:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420e0eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e0ef:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420e0f3:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0fa:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420e0fe:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e105:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e10c:	48 85 c0             	test   %rax,%rax
  800420e10f:	75 35                	jne    800420e146 <list_func_die+0x1ef>
  800420e111:	48 b9 80 a1 21 04 80 	movabs $0x800421a180,%rcx
  800420e118:	00 00 00 
  800420e11b:	48 ba 8c a1 21 04 80 	movabs $0x800421a18c,%rdx
  800420e122:	00 00 00 
  800420e125:	be 91 00 00 00       	mov    $0x91,%esi
  800420e12a:	48 bf a1 a1 21 04 80 	movabs $0x800421a1a1,%rdi
  800420e131:	00 00 00 
  800420e134:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e139:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420e140:	00 00 00 
  800420e143:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420e146:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e14d:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e154:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420e15b:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420e162:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e167:	48 89 c7             	mov    %rax,%rdi
  800420e16a:	48 b8 b1 4f 21 04 80 	movabs $0x8004214fb1,%rax
  800420e171:	00 00 00 
  800420e174:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420e176:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420e17d:	89 c2                	mov    %eax,%edx
  800420e17f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e186:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420e189:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e190:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420e197:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e19e:	00 00 00 
  800420e1a1:	48 8b 00             	mov    (%rax),%rax
  800420e1a4:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e1ab:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e1b2:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e1b6:	48 89 c7             	mov    %rax,%rdi
  800420e1b9:	48 b8 61 1c 21 04 80 	movabs $0x8004211c61,%rax
  800420e1c0:	00 00 00 
  800420e1c3:	ff d0                	callq  *%rax
  800420e1c5:	83 f8 04             	cmp    $0x4,%eax
  800420e1c8:	0f 84 e1 04 00 00    	je     800420e6af <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420e1ce:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e1d5:	48 83 f8 05          	cmp    $0x5,%rax
  800420e1d9:	74 05                	je     800420e1e0 <list_func_die+0x289>
				goto last;
  800420e1db:	e9 cf 04 00 00       	jmpq   800420e6af <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e1e0:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e1e7:	be 49 00 00 00       	mov    $0x49,%esi
  800420e1ec:	48 89 c7             	mov    %rax,%rdi
  800420e1ef:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e1f6:	00 00 00 
  800420e1f9:	ff d0                	callq  *%rax
  800420e1fb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420e1ff:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e204:	0f 84 d7 00 00 00    	je     800420e2e1 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e20a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e20e:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e212:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e216:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e21a:	48 01 d0             	add    %rdx,%rax
  800420e21d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420e221:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e228:	00 00 00 
  800420e22b:	48 8b 08             	mov    (%rax),%rcx
  800420e22e:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e235:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e239:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e23d:	48 8b 38             	mov    (%rax),%rdi
  800420e240:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e244:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e248:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e24d:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e251:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e256:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e25a:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e25f:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e263:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e268:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e26c:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e271:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e275:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e27a:	48 89 cf             	mov    %rcx,%rdi
  800420e27d:	48 b8 87 18 21 04 80 	movabs $0x8004211887,%rax
  800420e284:	00 00 00 
  800420e287:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e289:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e290:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e295:	48 89 c7             	mov    %rax,%rdi
  800420e298:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e29f:	00 00 00 
  800420e2a2:	ff d0                	callq  *%rax
  800420e2a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420e2a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e2ad:	74 0e                	je     800420e2bd <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420e2af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e2b3:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e2b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e2bb:	eb 24                	jmp    800420e2e1 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420e2bd:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e2c4:	be 49 00 00 00       	mov    $0x49,%esi
  800420e2c9:	48 89 c7             	mov    %rax,%rdi
  800420e2cc:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e2d3:	00 00 00 
  800420e2d6:	ff d0                	callq  *%rax
  800420e2d8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420e2dc:	e9 1e ff ff ff       	jmpq   800420e1ff <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420e2e1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e2e8:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e2e9:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e2f0:	be 02 00 00 00       	mov    $0x2,%esi
  800420e2f5:	48 89 c7             	mov    %rax,%rdi
  800420e2f8:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e2ff:	00 00 00 
  800420e302:	ff d0                	callq  *%rax
  800420e304:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420e308:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e30d:	0f 84 a2 00 00 00    	je     800420e3b5 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e313:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e317:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e31b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e31f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e323:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e327:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420e32b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e32f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e333:	48 83 f8 03          	cmp    $0x3,%rax
  800420e337:	72 7c                	jb     800420e3b5 <list_func_die+0x45e>
  800420e339:	48 83 f8 04          	cmp    $0x4,%rax
  800420e33d:	76 06                	jbe    800420e345 <list_func_die+0x3ee>
  800420e33f:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e343:	75 70                	jne    800420e3b5 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420e345:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e34c:	00 
						atom = *(loc_ptr++);
  800420e34d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e351:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e355:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e359:	0f b6 00             	movzbl (%rax),%eax
  800420e35c:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420e35f:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420e364:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420e368:	75 4a                	jne    800420e3b4 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420e36a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e36e:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420e375:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420e37c:	48 89 c7             	mov    %rax,%rdi
  800420e37f:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  800420e386:	00 00 00 
  800420e389:	ff d0                	callq  *%rax
  800420e38b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420e38f:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e396:	48 89 c2             	mov    %rax,%rdx
  800420e399:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e39d:	48 29 c2             	sub    %rax,%rdx
  800420e3a0:	48 89 d0             	mov    %rdx,%rax
  800420e3a3:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420e3a7:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e3ae:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420e3b2:	eb 00                	jmp    800420e3b4 <list_func_die+0x45d>
  800420e3b4:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420e3b5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3bc:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e3bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e3c3:	89 c2                	mov    %eax,%edx
  800420e3c5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3cc:	48 63 c9             	movslq %ecx,%rcx
  800420e3cf:	48 83 c1 08          	add    $0x8,%rcx
  800420e3d3:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420e3d7:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3de:	8b 50 28             	mov    0x28(%rax),%edx
  800420e3e1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3e8:	48 63 d2             	movslq %edx,%rdx
  800420e3eb:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e3ef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e3f3:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420e3f8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3ff:	8b 40 28             	mov    0x28(%rax),%eax
  800420e402:	8d 50 01             	lea    0x1(%rax),%edx
  800420e405:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e40c:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420e40f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e416:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e41d:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e422:	48 89 ce             	mov    %rcx,%rsi
  800420e425:	48 89 c7             	mov    %rax,%rdi
  800420e428:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  800420e42f:	00 00 00 
  800420e432:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e434:	e9 40 02 00 00       	jmpq   800420e679 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420e439:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e440:	48 83 f8 05          	cmp    $0x5,%rax
  800420e444:	74 05                	je     800420e44b <list_func_die+0x4f4>
					break;
  800420e446:	e9 64 02 00 00       	jmpq   800420e6af <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e44b:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e452:	be 49 00 00 00       	mov    $0x49,%esi
  800420e457:	48 89 c7             	mov    %rax,%rdi
  800420e45a:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e461:	00 00 00 
  800420e464:	ff d0                	callq  *%rax
  800420e466:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420e46a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e46f:	0f 84 b1 00 00 00    	je     800420e526 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e475:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e479:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e47d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e481:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e485:	48 01 d0             	add    %rdx,%rax
  800420e488:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420e48c:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e493:	00 00 00 
  800420e496:	48 8b 08             	mov    (%rax),%rcx
  800420e499:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e4a0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e4a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4a8:	48 8b 38             	mov    (%rax),%rdi
  800420e4ab:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e4af:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e4b3:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e4b8:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e4bc:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e4c1:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e4c5:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e4ca:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e4ce:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e4d3:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e4d7:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e4dc:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e4e0:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e4e5:	48 89 cf             	mov    %rcx,%rdi
  800420e4e8:	48 b8 87 18 21 04 80 	movabs $0x8004211887,%rax
  800420e4ef:	00 00 00 
  800420e4f2:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e4f4:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e4fb:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e500:	48 89 c7             	mov    %rax,%rdi
  800420e503:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e50a:	00 00 00 
  800420e50d:	ff d0                	callq  *%rax
  800420e50f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420e513:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e518:	74 0c                	je     800420e526 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420e51a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e51e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e522:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420e526:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e52d:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e52e:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e535:	be 02 00 00 00       	mov    $0x2,%esi
  800420e53a:	48 89 c7             	mov    %rax,%rdi
  800420e53d:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800420e544:	00 00 00 
  800420e547:	ff d0                	callq  *%rax
  800420e549:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420e54d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e552:	0f 84 a2 00 00 00    	je     800420e5fa <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e55c:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e560:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e564:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e568:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e56c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420e570:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e574:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e578:	48 83 f8 03          	cmp    $0x3,%rax
  800420e57c:	72 7c                	jb     800420e5fa <list_func_die+0x6a3>
  800420e57e:	48 83 f8 04          	cmp    $0x4,%rax
  800420e582:	76 06                	jbe    800420e58a <list_func_die+0x633>
  800420e584:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e588:	75 70                	jne    800420e5fa <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420e58a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e591:	00 
							atom = *(loc_ptr++);
  800420e592:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e596:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e59a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e59e:	0f b6 00             	movzbl (%rax),%eax
  800420e5a1:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420e5a4:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420e5a9:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420e5ad:	75 4a                	jne    800420e5f9 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420e5af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e5b3:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420e5ba:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420e5c1:	48 89 c7             	mov    %rax,%rdi
  800420e5c4:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  800420e5cb:	00 00 00 
  800420e5ce:	ff d0                	callq  *%rax
  800420e5d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420e5d4:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e5db:	48 89 c2             	mov    %rax,%rdx
  800420e5de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e5e2:	48 29 c2             	sub    %rax,%rdx
  800420e5e5:	48 89 d0             	mov    %rdx,%rax
  800420e5e8:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420e5ec:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e5f3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420e5f7:	eb 00                	jmp    800420e5f9 <list_func_die+0x6a2>
  800420e5f9:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420e5fa:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e601:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e608:	89 c2                	mov    %eax,%edx
  800420e60a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e611:	48 63 c9             	movslq %ecx,%rcx
  800420e614:	48 83 c1 08          	add    $0x8,%rcx
  800420e618:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420e61c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e623:	8b 50 28             	mov    0x28(%rax),%edx
  800420e626:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e62d:	48 63 d2             	movslq %edx,%rdx
  800420e630:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e634:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e638:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420e63d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e644:	8b 40 28             	mov    0x28(%rax),%eax
  800420e647:	8d 50 01             	lea    0x1(%rax),%edx
  800420e64a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e651:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420e654:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e65b:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e662:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e667:	48 89 ce             	mov    %rcx,%rsi
  800420e66a:	48 89 c7             	mov    %rax,%rdi
  800420e66d:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  800420e674:	00 00 00 
  800420e677:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e679:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e680:	00 00 00 
  800420e683:	48 8b 00             	mov    (%rax),%rax
  800420e686:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420e68a:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420e691:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420e698:	48 89 c7             	mov    %rax,%rdi
  800420e69b:	48 b8 1d 1a 21 04 80 	movabs $0x8004211a1d,%rax
  800420e6a2:	00 00 00 
  800420e6a5:	ff d0                	callq  *%rax
  800420e6a7:	85 c0                	test   %eax,%eax
  800420e6a9:	0f 84 8a fd ff ff    	je     800420e439 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420e6af:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e6b4:	eb 05                	jmp    800420e6bb <list_func_die+0x764>
	}

	return 0;
  800420e6b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e6bb:	c9                   	leaveq 
  800420e6bc:	c3                   	retq   

000000800420e6bd <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420e6bd:	55                   	push   %rbp
  800420e6be:	48 89 e5             	mov    %rsp,%rbp
  800420e6c1:	53                   	push   %rbx
  800420e6c2:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420e6c9:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420e6d0:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420e6d7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420e6de:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420e6df:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420e6e6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420e6ea:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e6f1:	48 bb af a1 21 04 80 	movabs $0x800421a1af,%rbx
  800420e6f8:	00 00 00 
  800420e6fb:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420e6fe:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e705:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420e70c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e713:	48 bb af a1 21 04 80 	movabs $0x800421a1af,%rbx
  800420e71a:	00 00 00 
  800420e71d:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420e721:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e728:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420e72f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e736:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e73d:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420e741:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e748:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420e74f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420e756:	00 00 00 
  800420e759:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420e760:	76 13                	jbe    800420e775 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420e762:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420e769:	00 00 00 
  800420e76c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e770:	e9 08 01 00 00       	jmpq   800420e87d <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420e775:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420e77c:	00 00 00 
  800420e77f:	ff d0                	callq  *%rax
  800420e781:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420e788:	00 00 00 
  800420e78b:	48 98                	cltq   
  800420e78d:	48 c1 e0 03          	shl    $0x3,%rax
  800420e791:	48 89 c2             	mov    %rax,%rdx
  800420e794:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e798:	48 29 c2             	sub    %rax,%rdx
  800420e79b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e79f:	48 83 c0 08          	add    $0x8,%rax
  800420e7a3:	48 8b 10             	mov    (%rax),%rdx
  800420e7a6:	48 b8 a0 b2 60 04 80 	movabs $0x800460b2a0,%rax
  800420e7ad:	00 00 00 
  800420e7b0:	48 8b 00             	mov    (%rax),%rax
  800420e7b3:	48 39 c2             	cmp    %rax,%rdx
  800420e7b6:	0f 84 85 00 00 00    	je     800420e841 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420e7bc:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420e7c3:	00 00 00 
  800420e7c6:	ff d0                	callq  *%rax
  800420e7c8:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420e7cf:	00 00 00 
  800420e7d2:	48 98                	cltq   
  800420e7d4:	48 c1 e0 03          	shl    $0x3,%rax
  800420e7d8:	48 89 c2             	mov    %rax,%rdx
  800420e7db:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e7df:	48 29 c2             	sub    %rax,%rdx
  800420e7e2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e7e6:	48 83 c0 08          	add    $0x8,%rax
  800420e7ea:	48 8b 00             	mov    (%rax),%rax
  800420e7ed:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e7f4:	48 89 c7             	mov    %rax,%rdi
  800420e7f7:	48 b8 ac 51 21 04 80 	movabs $0x80042151ac,%rax
  800420e7fe:	00 00 00 
  800420e801:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420e803:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420e80a:	00 00 00 
  800420e80d:	ff d0                	callq  *%rax
  800420e80f:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420e816:	00 00 00 
  800420e819:	48 98                	cltq   
  800420e81b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e81f:	48 89 c2             	mov    %rax,%rdx
  800420e822:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e826:	48 29 c2             	sub    %rax,%rdx
  800420e829:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e82d:	48 83 c0 08          	add    $0x8,%rax
  800420e831:	48 8b 10             	mov    (%rax),%rdx
  800420e834:	48 b8 a0 b2 60 04 80 	movabs $0x800460b2a0,%rax
  800420e83b:	00 00 00 
  800420e83e:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420e841:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  800420e848:	00 00 00 
  800420e84b:	ff d0                	callq  *%rax
  800420e84d:	48 b9 20 f0 60 04 80 	movabs $0x800460f020,%rcx
  800420e854:	00 00 00 
  800420e857:	48 98                	cltq   
  800420e859:	48 c1 e0 03          	shl    $0x3,%rax
  800420e85d:	48 89 c2             	mov    %rax,%rdx
  800420e860:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e864:	48 29 c2             	sub    %rax,%rdx
  800420e867:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e86b:	48 83 c0 08          	add    $0x8,%rax
  800420e86f:	48 8b 00             	mov    (%rax),%rax
  800420e872:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e879:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420e87d:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e884:	00 00 00 
  800420e887:	48 8b 00             	mov    (%rax),%rax
  800420e88a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e88e:	48 89 d6             	mov    %rdx,%rsi
  800420e891:	48 89 c7             	mov    %rax,%rdi
  800420e894:	48 b8 95 08 21 04 80 	movabs $0x8004210895,%rax
  800420e89b:	00 00 00 
  800420e89e:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420e8a0:	48 bf b9 a1 21 04 80 	movabs $0x800421a1b9,%rdi
  800420e8a7:	00 00 00 
  800420e8aa:	48 b8 2c 51 21 04 80 	movabs $0x800421512c,%rax
  800420e8b1:	00 00 00 
  800420e8b4:	ff d0                	callq  *%rax
  800420e8b6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420e8ba:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e8c1:	00 00 00 
  800420e8c4:	48 8b 00             	mov    (%rax),%rax
  800420e8c7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e8cb:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420e8cf:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420e8d3:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e8da:	00 00 00 
  800420e8dd:	48 8b 00             	mov    (%rax),%rax
  800420e8e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e8e4:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420e8e8:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420e8ec:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e8f3:	00 00 00 
  800420e8f6:	48 8b 00             	mov    (%rax),%rax
  800420e8f9:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420e8fd:	48 85 c0             	test   %rax,%rax
  800420e900:	75 35                	jne    800420e937 <debuginfo_rip+0x27a>
  800420e902:	48 b9 c5 a1 21 04 80 	movabs $0x800421a1c5,%rcx
  800420e909:	00 00 00 
  800420e90c:	48 ba 8c a1 21 04 80 	movabs $0x800421a18c,%rdx
  800420e913:	00 00 00 
  800420e916:	be 37 01 00 00       	mov    $0x137,%esi
  800420e91b:	48 bf a1 a1 21 04 80 	movabs $0x800421a1a1,%rdi
  800420e922:	00 00 00 
  800420e925:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e92a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800420e931:	00 00 00 
  800420e934:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420e937:	e9 6f 01 00 00       	jmpq   800420eaab <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420e93c:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e943:	00 00 00 
  800420e946:	48 8b 00             	mov    (%rax),%rax
  800420e949:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e94d:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e954:	be 00 00 00 00       	mov    $0x0,%esi
  800420e959:	48 89 c7             	mov    %rax,%rdi
  800420e95c:	48 b8 1d 1a 21 04 80 	movabs $0x8004211a1d,%rax
  800420e963:	00 00 00 
  800420e966:	ff d0                	callq  *%rax
  800420e968:	83 f8 04             	cmp    $0x4,%eax
  800420e96b:	75 05                	jne    800420e972 <debuginfo_rip+0x2b5>
			continue;
  800420e96d:	e9 39 01 00 00       	jmpq   800420eaab <debuginfo_rip+0x3ee>

		cudie.cu_header = &cu;
  800420e972:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e976:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420e97d:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420e984:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420e988:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420e98f:	00 00 00 
  800420e992:	48 8b 00             	mov    (%rax),%rax
  800420e995:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e99c:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e9a3:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e9a7:	48 89 c7             	mov    %rax,%rdi
  800420e9aa:	48 b8 61 1c 21 04 80 	movabs $0x8004211c61,%rax
  800420e9b1:	00 00 00 
  800420e9b4:	ff d0                	callq  *%rax
  800420e9b6:	83 f8 04             	cmp    $0x4,%eax
  800420e9b9:	75 05                	jne    800420e9c0 <debuginfo_rip+0x303>
			continue;
  800420e9bb:	e9 eb 00 00 00       	jmpq   800420eaab <debuginfo_rip+0x3ee>

		die.cu_header = &cu;
  800420e9c0:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e9c4:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420e9cb:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e9d2:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420e9d9:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e9e0:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e9e7:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e9ee:	48 89 ce             	mov    %rcx,%rsi
  800420e9f1:	48 89 c7             	mov    %rax,%rdi
  800420e9f4:	48 b8 57 df 20 04 80 	movabs $0x800420df57,%rax
  800420e9fb:	00 00 00 
  800420e9fe:	ff d0                	callq  *%rax
  800420ea00:	85 c0                	test   %eax,%eax
  800420ea02:	74 30                	je     800420ea34 <debuginfo_rip+0x377>
				goto find_done;
  800420ea04:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420ea05:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420ea0c:	00 00 00 
  800420ea0f:	48 8b 00             	mov    (%rax),%rax
  800420ea12:	be 00 00 00 00       	mov    $0x0,%esi
  800420ea17:	48 89 c7             	mov    %rax,%rdi
  800420ea1a:	48 b8 39 43 21 04 80 	movabs $0x8004214339,%rax
  800420ea21:	00 00 00 
  800420ea24:	ff d0                	callq  *%rax
  800420ea26:	83 f8 01             	cmp    $0x1,%eax
  800420ea29:	0f 85 bb 00 00 00    	jne    800420eaea <debuginfo_rip+0x42d>
  800420ea2f:	e9 ac 00 00 00       	jmpq   800420eae0 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ea34:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420ea3b:	00 00 00 
  800420ea3e:	48 8b 00             	mov    (%rax),%rax
  800420ea41:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420ea45:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420ea4c:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420ea53:	48 89 c7             	mov    %rax,%rdi
  800420ea56:	48 b8 1d 1a 21 04 80 	movabs $0x8004211a1d,%rax
  800420ea5d:	00 00 00 
  800420ea60:	ff d0                	callq  *%rax
  800420ea62:	85 c0                	test   %eax,%eax
  800420ea64:	79 02                	jns    800420ea68 <debuginfo_rip+0x3ab>
				break; 
  800420ea66:	eb 43                	jmp    800420eaab <debuginfo_rip+0x3ee>
			die = die2;
  800420ea68:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420ea6f:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420ea76:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420ea7b:	48 89 ce             	mov    %rcx,%rsi
  800420ea7e:	48 89 c7             	mov    %rax,%rdi
  800420ea81:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  800420ea88:	00 00 00 
  800420ea8b:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420ea8d:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ea91:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420ea98:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ea9f:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420eaa6:	e9 2e ff ff ff       	jmpq   800420e9d9 <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420eaab:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420eab2:	00 00 00 
  800420eab5:	48 8b 00             	mov    (%rax),%rax
  800420eab8:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420eabc:	48 89 d6             	mov    %rdx,%rsi
  800420eabf:	48 89 c7             	mov    %rax,%rdi
  800420eac2:	48 b8 77 09 21 04 80 	movabs $0x8004210977,%rax
  800420eac9:	00 00 00 
  800420eacc:	ff d0                	callq  *%rax
  800420eace:	85 c0                	test   %eax,%eax
  800420ead0:	0f 84 66 fe ff ff    	je     800420e93c <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420ead6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420eadb:	e9 a0 00 00 00       	jmpq   800420eb80 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420eae0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420eae5:	e9 96 00 00 00       	jmpq   800420eb80 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420eaea:	48 b8 a0 e6 22 04 80 	movabs $0x800422e6a0,%rax
  800420eaf1:	00 00 00 
  800420eaf4:	48 8b 08             	mov    (%rax),%rcx
  800420eaf7:	48 b8 98 e6 22 04 80 	movabs $0x800422e698,%rax
  800420eafe:	00 00 00 
  800420eb01:	48 8b 10             	mov    (%rax),%rdx
  800420eb04:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420eb0b:	00 00 00 
  800420eb0e:	48 8b 00             	mov    (%rax),%rax
  800420eb11:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420eb18:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420eb1e:	48 89 c7             	mov    %rax,%rdi
  800420eb21:	48 b8 a2 1e 21 04 80 	movabs $0x8004211ea2,%rax
  800420eb28:	00 00 00 
  800420eb2b:	ff d0                	callq  *%rax
  800420eb2d:	85 c0                	test   %eax,%eax
  800420eb2f:	75 4a                	jne    800420eb7b <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420eb31:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420eb38:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420eb3f:	48 b8 98 e6 22 04 80 	movabs $0x800422e698,%rax
  800420eb46:	00 00 00 
  800420eb49:	48 8b 30             	mov    (%rax),%rsi
  800420eb4c:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800420eb53:	00 00 00 
  800420eb56:	48 8b 00             	mov    (%rax),%rax
  800420eb59:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420eb60:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420eb66:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420eb6c:	48 89 c7             	mov    %rax,%rdi
  800420eb6f:	48 b8 ae 31 21 04 80 	movabs $0x80042131ae,%rax
  800420eb76:	00 00 00 
  800420eb79:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420eb7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eb80:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420eb87:	5b                   	pop    %rbx
  800420eb88:	5d                   	pop    %rbp
  800420eb89:	c3                   	retq   

000000800420eb8a <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420eb8a:	55                   	push   %rbp
  800420eb8b:	48 89 e5             	mov    %rsp,%rbp
  800420eb8e:	53                   	push   %rbx
  800420eb8f:	48 83 ec 38          	sub    $0x38,%rsp
  800420eb93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb97:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eb9b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420eb9f:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420eba2:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420eba6:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420ebaa:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420ebad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ebb1:	77 3b                	ja     800420ebee <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420ebb3:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420ebb6:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420ebba:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420ebbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebc1:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ebc6:	48 f7 f3             	div    %rbx
  800420ebc9:	48 89 c2             	mov    %rax,%rdx
  800420ebcc:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ebcf:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ebd2:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ebd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebda:	41 89 f9             	mov    %edi,%r9d
  800420ebdd:	48 89 c7             	mov    %rax,%rdi
  800420ebe0:	48 b8 8a eb 20 04 80 	movabs $0x800420eb8a,%rax
  800420ebe7:	00 00 00 
  800420ebea:	ff d0                	callq  *%rax
  800420ebec:	eb 1e                	jmp    800420ec0c <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ebee:	eb 12                	jmp    800420ec02 <printnum+0x78>
			putch(padc, putdat);
  800420ebf0:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ebf4:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ebf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebfb:	48 89 ce             	mov    %rcx,%rsi
  800420ebfe:	89 d7                	mov    %edx,%edi
  800420ec00:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ec02:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420ec06:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ec0a:	7f e4                	jg     800420ebf0 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ec0c:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ec0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec13:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ec18:	48 f7 f1             	div    %rcx
  800420ec1b:	48 89 d0             	mov    %rdx,%rax
  800420ec1e:	48 ba d0 a3 21 04 80 	movabs $0x800421a3d0,%rdx
  800420ec25:	00 00 00 
  800420ec28:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420ec2c:	0f be d0             	movsbl %al,%edx
  800420ec2f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ec33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec37:	48 89 ce             	mov    %rcx,%rsi
  800420ec3a:	89 d7                	mov    %edx,%edi
  800420ec3c:	ff d0                	callq  *%rax
}
  800420ec3e:	48 83 c4 38          	add    $0x38,%rsp
  800420ec42:	5b                   	pop    %rbx
  800420ec43:	5d                   	pop    %rbp
  800420ec44:	c3                   	retq   

000000800420ec45 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420ec45:	55                   	push   %rbp
  800420ec46:	48 89 e5             	mov    %rsp,%rbp
  800420ec49:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ec4d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec51:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420ec54:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ec58:	7e 52                	jle    800420ecac <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420ec5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec5e:	8b 00                	mov    (%rax),%eax
  800420ec60:	83 f8 30             	cmp    $0x30,%eax
  800420ec63:	73 24                	jae    800420ec89 <getuint+0x44>
  800420ec65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec69:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ec6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec71:	8b 00                	mov    (%rax),%eax
  800420ec73:	89 c0                	mov    %eax,%eax
  800420ec75:	48 01 d0             	add    %rdx,%rax
  800420ec78:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec7c:	8b 12                	mov    (%rdx),%edx
  800420ec7e:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ec81:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec85:	89 0a                	mov    %ecx,(%rdx)
  800420ec87:	eb 17                	jmp    800420eca0 <getuint+0x5b>
  800420ec89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec8d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ec91:	48 89 d0             	mov    %rdx,%rax
  800420ec94:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ec98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec9c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eca0:	48 8b 00             	mov    (%rax),%rax
  800420eca3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420eca7:	e9 a3 00 00 00       	jmpq   800420ed4f <getuint+0x10a>
	else if (lflag)
  800420ecac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ecb0:	74 4f                	je     800420ed01 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420ecb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecb6:	8b 00                	mov    (%rax),%eax
  800420ecb8:	83 f8 30             	cmp    $0x30,%eax
  800420ecbb:	73 24                	jae    800420ece1 <getuint+0x9c>
  800420ecbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecc1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ecc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecc9:	8b 00                	mov    (%rax),%eax
  800420eccb:	89 c0                	mov    %eax,%eax
  800420eccd:	48 01 d0             	add    %rdx,%rax
  800420ecd0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecd4:	8b 12                	mov    (%rdx),%edx
  800420ecd6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ecd9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecdd:	89 0a                	mov    %ecx,(%rdx)
  800420ecdf:	eb 17                	jmp    800420ecf8 <getuint+0xb3>
  800420ece1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ece5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ece9:	48 89 d0             	mov    %rdx,%rax
  800420ecec:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ecf0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecf4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ecf8:	48 8b 00             	mov    (%rax),%rax
  800420ecfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ecff:	eb 4e                	jmp    800420ed4f <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420ed01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed05:	8b 00                	mov    (%rax),%eax
  800420ed07:	83 f8 30             	cmp    $0x30,%eax
  800420ed0a:	73 24                	jae    800420ed30 <getuint+0xeb>
  800420ed0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed10:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ed14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed18:	8b 00                	mov    (%rax),%eax
  800420ed1a:	89 c0                	mov    %eax,%eax
  800420ed1c:	48 01 d0             	add    %rdx,%rax
  800420ed1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed23:	8b 12                	mov    (%rdx),%edx
  800420ed25:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed2c:	89 0a                	mov    %ecx,(%rdx)
  800420ed2e:	eb 17                	jmp    800420ed47 <getuint+0x102>
  800420ed30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed34:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ed38:	48 89 d0             	mov    %rdx,%rax
  800420ed3b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ed3f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed43:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ed47:	8b 00                	mov    (%rax),%eax
  800420ed49:	89 c0                	mov    %eax,%eax
  800420ed4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ed4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ed53:	c9                   	leaveq 
  800420ed54:	c3                   	retq   

000000800420ed55 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420ed55:	55                   	push   %rbp
  800420ed56:	48 89 e5             	mov    %rsp,%rbp
  800420ed59:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ed5d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ed61:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ed64:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ed68:	7e 52                	jle    800420edbc <getint+0x67>
		x=va_arg(*ap, long long);
  800420ed6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed6e:	8b 00                	mov    (%rax),%eax
  800420ed70:	83 f8 30             	cmp    $0x30,%eax
  800420ed73:	73 24                	jae    800420ed99 <getint+0x44>
  800420ed75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed79:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ed7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed81:	8b 00                	mov    (%rax),%eax
  800420ed83:	89 c0                	mov    %eax,%eax
  800420ed85:	48 01 d0             	add    %rdx,%rax
  800420ed88:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed8c:	8b 12                	mov    (%rdx),%edx
  800420ed8e:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed95:	89 0a                	mov    %ecx,(%rdx)
  800420ed97:	eb 17                	jmp    800420edb0 <getint+0x5b>
  800420ed99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed9d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420eda1:	48 89 d0             	mov    %rdx,%rax
  800420eda4:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eda8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420edac:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420edb0:	48 8b 00             	mov    (%rax),%rax
  800420edb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420edb7:	e9 a3 00 00 00       	jmpq   800420ee5f <getint+0x10a>
	else if (lflag)
  800420edbc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420edc0:	74 4f                	je     800420ee11 <getint+0xbc>
		x=va_arg(*ap, long);
  800420edc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edc6:	8b 00                	mov    (%rax),%eax
  800420edc8:	83 f8 30             	cmp    $0x30,%eax
  800420edcb:	73 24                	jae    800420edf1 <getint+0x9c>
  800420edcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edd1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420edd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edd9:	8b 00                	mov    (%rax),%eax
  800420eddb:	89 c0                	mov    %eax,%eax
  800420eddd:	48 01 d0             	add    %rdx,%rax
  800420ede0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ede4:	8b 12                	mov    (%rdx),%edx
  800420ede6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ede9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eded:	89 0a                	mov    %ecx,(%rdx)
  800420edef:	eb 17                	jmp    800420ee08 <getint+0xb3>
  800420edf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edf5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420edf9:	48 89 d0             	mov    %rdx,%rax
  800420edfc:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ee00:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee04:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee08:	48 8b 00             	mov    (%rax),%rax
  800420ee0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ee0f:	eb 4e                	jmp    800420ee5f <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ee11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee15:	8b 00                	mov    (%rax),%eax
  800420ee17:	83 f8 30             	cmp    $0x30,%eax
  800420ee1a:	73 24                	jae    800420ee40 <getint+0xeb>
  800420ee1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee20:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ee24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee28:	8b 00                	mov    (%rax),%eax
  800420ee2a:	89 c0                	mov    %eax,%eax
  800420ee2c:	48 01 d0             	add    %rdx,%rax
  800420ee2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee33:	8b 12                	mov    (%rdx),%edx
  800420ee35:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ee38:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee3c:	89 0a                	mov    %ecx,(%rdx)
  800420ee3e:	eb 17                	jmp    800420ee57 <getint+0x102>
  800420ee40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee44:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ee48:	48 89 d0             	mov    %rdx,%rax
  800420ee4b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ee4f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee53:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee57:	8b 00                	mov    (%rax),%eax
  800420ee59:	48 98                	cltq   
  800420ee5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ee5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ee63:	c9                   	leaveq 
  800420ee64:	c3                   	retq   

000000800420ee65 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ee65:	55                   	push   %rbp
  800420ee66:	48 89 e5             	mov    %rsp,%rbp
  800420ee69:	41 54                	push   %r12
  800420ee6b:	53                   	push   %rbx
  800420ee6c:	48 83 ec 60          	sub    $0x60,%rsp
  800420ee70:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420ee74:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420ee78:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ee7c:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420ee80:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420ee84:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420ee88:	48 8b 0a             	mov    (%rdx),%rcx
  800420ee8b:	48 89 08             	mov    %rcx,(%rax)
  800420ee8e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ee92:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420ee96:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420ee9a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420ee9e:	eb 17                	jmp    800420eeb7 <vprintfmt+0x52>
			if (ch == '\0')
  800420eea0:	85 db                	test   %ebx,%ebx
  800420eea2:	0f 84 cc 04 00 00    	je     800420f374 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420eea8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420eeac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420eeb0:	48 89 d6             	mov    %rdx,%rsi
  800420eeb3:	89 df                	mov    %ebx,%edi
  800420eeb5:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420eeb7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eebb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420eebf:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420eec3:	0f b6 00             	movzbl (%rax),%eax
  800420eec6:	0f b6 d8             	movzbl %al,%ebx
  800420eec9:	83 fb 25             	cmp    $0x25,%ebx
  800420eecc:	75 d2                	jne    800420eea0 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420eece:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420eed2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420eed9:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420eee0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420eee7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420eeee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eef2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420eef6:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420eefa:	0f b6 00             	movzbl (%rax),%eax
  800420eefd:	0f b6 d8             	movzbl %al,%ebx
  800420ef00:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420ef03:	83 f8 55             	cmp    $0x55,%eax
  800420ef06:	0f 87 34 04 00 00    	ja     800420f340 <vprintfmt+0x4db>
  800420ef0c:	89 c0                	mov    %eax,%eax
  800420ef0e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ef15:	00 
  800420ef16:	48 b8 f8 a3 21 04 80 	movabs $0x800421a3f8,%rax
  800420ef1d:	00 00 00 
  800420ef20:	48 01 d0             	add    %rdx,%rax
  800420ef23:	48 8b 00             	mov    (%rax),%rax
  800420ef26:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420ef28:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420ef2c:	eb c0                	jmp    800420eeee <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420ef2e:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420ef32:	eb ba                	jmp    800420eeee <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ef34:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420ef3b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420ef3e:	89 d0                	mov    %edx,%eax
  800420ef40:	c1 e0 02             	shl    $0x2,%eax
  800420ef43:	01 d0                	add    %edx,%eax
  800420ef45:	01 c0                	add    %eax,%eax
  800420ef47:	01 d8                	add    %ebx,%eax
  800420ef49:	83 e8 30             	sub    $0x30,%eax
  800420ef4c:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420ef4f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef53:	0f b6 00             	movzbl (%rax),%eax
  800420ef56:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420ef59:	83 fb 2f             	cmp    $0x2f,%ebx
  800420ef5c:	7e 0c                	jle    800420ef6a <vprintfmt+0x105>
  800420ef5e:	83 fb 39             	cmp    $0x39,%ebx
  800420ef61:	7f 07                	jg     800420ef6a <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ef63:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420ef68:	eb d1                	jmp    800420ef3b <vprintfmt+0xd6>
			goto process_precision;
  800420ef6a:	eb 58                	jmp    800420efc4 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420ef6c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef6f:	83 f8 30             	cmp    $0x30,%eax
  800420ef72:	73 17                	jae    800420ef8b <vprintfmt+0x126>
  800420ef74:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ef78:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef7b:	89 c0                	mov    %eax,%eax
  800420ef7d:	48 01 d0             	add    %rdx,%rax
  800420ef80:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ef83:	83 c2 08             	add    $0x8,%edx
  800420ef86:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ef89:	eb 0f                	jmp    800420ef9a <vprintfmt+0x135>
  800420ef8b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ef8f:	48 89 d0             	mov    %rdx,%rax
  800420ef92:	48 83 c2 08          	add    $0x8,%rdx
  800420ef96:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ef9a:	8b 00                	mov    (%rax),%eax
  800420ef9c:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420ef9f:	eb 23                	jmp    800420efc4 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420efa1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420efa5:	79 0c                	jns    800420efb3 <vprintfmt+0x14e>
				width = 0;
  800420efa7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420efae:	e9 3b ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>
  800420efb3:	e9 36 ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420efb8:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420efbf:	e9 2a ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420efc4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420efc8:	79 12                	jns    800420efdc <vprintfmt+0x177>
				width = precision, precision = -1;
  800420efca:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420efcd:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420efd0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420efd7:	e9 12 ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>
  800420efdc:	e9 0d ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420efe1:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420efe5:	e9 04 ff ff ff       	jmpq   800420eeee <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420efea:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420efed:	83 f8 30             	cmp    $0x30,%eax
  800420eff0:	73 17                	jae    800420f009 <vprintfmt+0x1a4>
  800420eff2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420eff6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420eff9:	89 c0                	mov    %eax,%eax
  800420effb:	48 01 d0             	add    %rdx,%rax
  800420effe:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f001:	83 c2 08             	add    $0x8,%edx
  800420f004:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f007:	eb 0f                	jmp    800420f018 <vprintfmt+0x1b3>
  800420f009:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f00d:	48 89 d0             	mov    %rdx,%rax
  800420f010:	48 83 c2 08          	add    $0x8,%rdx
  800420f014:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f018:	8b 10                	mov    (%rax),%edx
  800420f01a:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f01e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f022:	48 89 ce             	mov    %rcx,%rsi
  800420f025:	89 d7                	mov    %edx,%edi
  800420f027:	ff d0                	callq  *%rax
			break;
  800420f029:	e9 40 03 00 00       	jmpq   800420f36e <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420f02e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f031:	83 f8 30             	cmp    $0x30,%eax
  800420f034:	73 17                	jae    800420f04d <vprintfmt+0x1e8>
  800420f036:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f03a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f03d:	89 c0                	mov    %eax,%eax
  800420f03f:	48 01 d0             	add    %rdx,%rax
  800420f042:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f045:	83 c2 08             	add    $0x8,%edx
  800420f048:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f04b:	eb 0f                	jmp    800420f05c <vprintfmt+0x1f7>
  800420f04d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f051:	48 89 d0             	mov    %rdx,%rax
  800420f054:	48 83 c2 08          	add    $0x8,%rdx
  800420f058:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f05c:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420f05e:	85 db                	test   %ebx,%ebx
  800420f060:	79 02                	jns    800420f064 <vprintfmt+0x1ff>
				err = -err;
  800420f062:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420f064:	83 fb 15             	cmp    $0x15,%ebx
  800420f067:	7f 16                	jg     800420f07f <vprintfmt+0x21a>
  800420f069:	48 b8 20 a3 21 04 80 	movabs $0x800421a320,%rax
  800420f070:	00 00 00 
  800420f073:	48 63 d3             	movslq %ebx,%rdx
  800420f076:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420f07a:	4d 85 e4             	test   %r12,%r12
  800420f07d:	75 2e                	jne    800420f0ad <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420f07f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f083:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f087:	89 d9                	mov    %ebx,%ecx
  800420f089:	48 ba e1 a3 21 04 80 	movabs $0x800421a3e1,%rdx
  800420f090:	00 00 00 
  800420f093:	48 89 c7             	mov    %rax,%rdi
  800420f096:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f09b:	49 b8 7d f3 20 04 80 	movabs $0x800420f37d,%r8
  800420f0a2:	00 00 00 
  800420f0a5:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420f0a8:	e9 c1 02 00 00       	jmpq   800420f36e <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420f0ad:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f0b1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0b5:	4c 89 e1             	mov    %r12,%rcx
  800420f0b8:	48 ba ea a3 21 04 80 	movabs $0x800421a3ea,%rdx
  800420f0bf:	00 00 00 
  800420f0c2:	48 89 c7             	mov    %rax,%rdi
  800420f0c5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f0ca:	49 b8 7d f3 20 04 80 	movabs $0x800420f37d,%r8
  800420f0d1:	00 00 00 
  800420f0d4:	41 ff d0             	callq  *%r8
			break;
  800420f0d7:	e9 92 02 00 00       	jmpq   800420f36e <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420f0dc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f0df:	83 f8 30             	cmp    $0x30,%eax
  800420f0e2:	73 17                	jae    800420f0fb <vprintfmt+0x296>
  800420f0e4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f0e8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f0eb:	89 c0                	mov    %eax,%eax
  800420f0ed:	48 01 d0             	add    %rdx,%rax
  800420f0f0:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f0f3:	83 c2 08             	add    $0x8,%edx
  800420f0f6:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f0f9:	eb 0f                	jmp    800420f10a <vprintfmt+0x2a5>
  800420f0fb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f0ff:	48 89 d0             	mov    %rdx,%rax
  800420f102:	48 83 c2 08          	add    $0x8,%rdx
  800420f106:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f10a:	4c 8b 20             	mov    (%rax),%r12
  800420f10d:	4d 85 e4             	test   %r12,%r12
  800420f110:	75 0a                	jne    800420f11c <vprintfmt+0x2b7>
				p = "(null)";
  800420f112:	49 bc ed a3 21 04 80 	movabs $0x800421a3ed,%r12
  800420f119:	00 00 00 
			if (width > 0 && padc != '-')
  800420f11c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f120:	7e 3f                	jle    800420f161 <vprintfmt+0x2fc>
  800420f122:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420f126:	74 39                	je     800420f161 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f128:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f12b:	48 98                	cltq   
  800420f12d:	48 89 c6             	mov    %rax,%rsi
  800420f130:	4c 89 e7             	mov    %r12,%rdi
  800420f133:	48 b8 7e f7 20 04 80 	movabs $0x800420f77e,%rax
  800420f13a:	00 00 00 
  800420f13d:	ff d0                	callq  *%rax
  800420f13f:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420f142:	eb 17                	jmp    800420f15b <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420f144:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420f148:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f14c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f150:	48 89 ce             	mov    %rcx,%rsi
  800420f153:	89 d7                	mov    %edx,%edi
  800420f155:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f157:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f15b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f15f:	7f e3                	jg     800420f144 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f161:	eb 37                	jmp    800420f19a <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420f163:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420f167:	74 1e                	je     800420f187 <vprintfmt+0x322>
  800420f169:	83 fb 1f             	cmp    $0x1f,%ebx
  800420f16c:	7e 05                	jle    800420f173 <vprintfmt+0x30e>
  800420f16e:	83 fb 7e             	cmp    $0x7e,%ebx
  800420f171:	7e 14                	jle    800420f187 <vprintfmt+0x322>
					putch('?', putdat);
  800420f173:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f177:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f17b:	48 89 d6             	mov    %rdx,%rsi
  800420f17e:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420f183:	ff d0                	callq  *%rax
  800420f185:	eb 0f                	jmp    800420f196 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420f187:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f18b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f18f:	48 89 d6             	mov    %rdx,%rsi
  800420f192:	89 df                	mov    %ebx,%edi
  800420f194:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f196:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f19a:	4c 89 e0             	mov    %r12,%rax
  800420f19d:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420f1a1:	0f b6 00             	movzbl (%rax),%eax
  800420f1a4:	0f be d8             	movsbl %al,%ebx
  800420f1a7:	85 db                	test   %ebx,%ebx
  800420f1a9:	74 10                	je     800420f1bb <vprintfmt+0x356>
  800420f1ab:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f1af:	78 b2                	js     800420f163 <vprintfmt+0x2fe>
  800420f1b1:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420f1b5:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f1b9:	79 a8                	jns    800420f163 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f1bb:	eb 16                	jmp    800420f1d3 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420f1bd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f1c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1c5:	48 89 d6             	mov    %rdx,%rsi
  800420f1c8:	bf 20 00 00 00       	mov    $0x20,%edi
  800420f1cd:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f1cf:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f1d3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f1d7:	7f e4                	jg     800420f1bd <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420f1d9:	e9 90 01 00 00       	jmpq   800420f36e <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420f1de:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f1e2:	be 03 00 00 00       	mov    $0x3,%esi
  800420f1e7:	48 89 c7             	mov    %rax,%rdi
  800420f1ea:	48 b8 55 ed 20 04 80 	movabs $0x800420ed55,%rax
  800420f1f1:	00 00 00 
  800420f1f4:	ff d0                	callq  *%rax
  800420f1f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420f1fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f1fe:	48 85 c0             	test   %rax,%rax
  800420f201:	79 1d                	jns    800420f220 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420f203:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f207:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f20b:	48 89 d6             	mov    %rdx,%rsi
  800420f20e:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420f213:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420f215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f219:	48 f7 d8             	neg    %rax
  800420f21c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420f220:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f227:	e9 d5 00 00 00       	jmpq   800420f301 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420f22c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f230:	be 03 00 00 00       	mov    $0x3,%esi
  800420f235:	48 89 c7             	mov    %rax,%rdi
  800420f238:	48 b8 45 ec 20 04 80 	movabs $0x800420ec45,%rax
  800420f23f:	00 00 00 
  800420f242:	ff d0                	callq  *%rax
  800420f244:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420f248:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f24f:	e9 ad 00 00 00       	jmpq   800420f301 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  800420f254:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420f257:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f25b:	89 d6                	mov    %edx,%esi
  800420f25d:	48 89 c7             	mov    %rax,%rdi
  800420f260:	48 b8 55 ed 20 04 80 	movabs $0x800420ed55,%rax
  800420f267:	00 00 00 
  800420f26a:	ff d0                	callq  *%rax
  800420f26c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420f270:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420f277:	e9 85 00 00 00       	jmpq   800420f301 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  800420f27c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f280:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f284:	48 89 d6             	mov    %rdx,%rsi
  800420f287:	bf 30 00 00 00       	mov    $0x30,%edi
  800420f28c:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420f28e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f292:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f296:	48 89 d6             	mov    %rdx,%rsi
  800420f299:	bf 78 00 00 00       	mov    $0x78,%edi
  800420f29e:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420f2a0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f2a3:	83 f8 30             	cmp    $0x30,%eax
  800420f2a6:	73 17                	jae    800420f2bf <vprintfmt+0x45a>
  800420f2a8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f2ac:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f2af:	89 c0                	mov    %eax,%eax
  800420f2b1:	48 01 d0             	add    %rdx,%rax
  800420f2b4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f2b7:	83 c2 08             	add    $0x8,%edx
  800420f2ba:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f2bd:	eb 0f                	jmp    800420f2ce <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420f2bf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f2c3:	48 89 d0             	mov    %rdx,%rax
  800420f2c6:	48 83 c2 08          	add    $0x8,%rdx
  800420f2ca:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f2ce:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f2d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420f2d5:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420f2dc:	eb 23                	jmp    800420f301 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420f2de:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f2e2:	be 03 00 00 00       	mov    $0x3,%esi
  800420f2e7:	48 89 c7             	mov    %rax,%rdi
  800420f2ea:	48 b8 45 ec 20 04 80 	movabs $0x800420ec45,%rax
  800420f2f1:	00 00 00 
  800420f2f4:	ff d0                	callq  *%rax
  800420f2f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420f2fa:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420f301:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420f306:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f309:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f30c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f310:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f314:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f318:	45 89 c1             	mov    %r8d,%r9d
  800420f31b:	41 89 f8             	mov    %edi,%r8d
  800420f31e:	48 89 c7             	mov    %rax,%rdi
  800420f321:	48 b8 8a eb 20 04 80 	movabs $0x800420eb8a,%rax
  800420f328:	00 00 00 
  800420f32b:	ff d0                	callq  *%rax
			break;
  800420f32d:	eb 3f                	jmp    800420f36e <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420f32f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f333:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f337:	48 89 d6             	mov    %rdx,%rsi
  800420f33a:	89 df                	mov    %ebx,%edi
  800420f33c:	ff d0                	callq  *%rax
			break;
  800420f33e:	eb 2e                	jmp    800420f36e <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420f340:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f344:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f348:	48 89 d6             	mov    %rdx,%rsi
  800420f34b:	bf 25 00 00 00       	mov    $0x25,%edi
  800420f350:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420f352:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f357:	eb 05                	jmp    800420f35e <vprintfmt+0x4f9>
  800420f359:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f35e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f362:	48 83 e8 01          	sub    $0x1,%rax
  800420f366:	0f b6 00             	movzbl (%rax),%eax
  800420f369:	3c 25                	cmp    $0x25,%al
  800420f36b:	75 ec                	jne    800420f359 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420f36d:	90                   	nop
		}
	}
  800420f36e:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f36f:	e9 43 fb ff ff       	jmpq   800420eeb7 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420f374:	48 83 c4 60          	add    $0x60,%rsp
  800420f378:	5b                   	pop    %rbx
  800420f379:	41 5c                	pop    %r12
  800420f37b:	5d                   	pop    %rbp
  800420f37c:	c3                   	retq   

000000800420f37d <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420f37d:	55                   	push   %rbp
  800420f37e:	48 89 e5             	mov    %rsp,%rbp
  800420f381:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420f388:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420f38f:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420f396:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f39d:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f3a4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f3ab:	84 c0                	test   %al,%al
  800420f3ad:	74 20                	je     800420f3cf <printfmt+0x52>
  800420f3af:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f3b3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f3b7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f3bb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f3bf:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f3c3:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f3c7:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f3cb:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f3cf:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420f3d6:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420f3dd:	00 00 00 
  800420f3e0:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420f3e7:	00 00 00 
  800420f3ea:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f3ee:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420f3f5:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f3fc:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420f403:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420f40a:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420f411:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420f418:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420f41f:	48 89 c7             	mov    %rax,%rdi
  800420f422:	48 b8 65 ee 20 04 80 	movabs $0x800420ee65,%rax
  800420f429:	00 00 00 
  800420f42c:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420f42e:	c9                   	leaveq 
  800420f42f:	c3                   	retq   

000000800420f430 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420f430:	55                   	push   %rbp
  800420f431:	48 89 e5             	mov    %rsp,%rbp
  800420f434:	48 83 ec 10          	sub    $0x10,%rsp
  800420f438:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420f43b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420f43f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f443:	8b 40 10             	mov    0x10(%rax),%eax
  800420f446:	8d 50 01             	lea    0x1(%rax),%edx
  800420f449:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f44d:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420f450:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f454:	48 8b 10             	mov    (%rax),%rdx
  800420f457:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f45b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f45f:	48 39 c2             	cmp    %rax,%rdx
  800420f462:	73 17                	jae    800420f47b <sprintputch+0x4b>
		*b->buf++ = ch;
  800420f464:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f468:	48 8b 00             	mov    (%rax),%rax
  800420f46b:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420f46f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f473:	48 89 0a             	mov    %rcx,(%rdx)
  800420f476:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f479:	88 10                	mov    %dl,(%rax)
}
  800420f47b:	c9                   	leaveq 
  800420f47c:	c3                   	retq   

000000800420f47d <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420f47d:	55                   	push   %rbp
  800420f47e:	48 89 e5             	mov    %rsp,%rbp
  800420f481:	48 83 ec 50          	sub    $0x50,%rsp
  800420f485:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f489:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420f48c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f490:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420f494:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420f498:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f49c:	48 8b 0a             	mov    (%rdx),%rcx
  800420f49f:	48 89 08             	mov    %rcx,(%rax)
  800420f4a2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f4a6:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f4aa:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f4ae:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420f4b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f4b6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420f4ba:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420f4bd:	48 98                	cltq   
  800420f4bf:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f4c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f4c7:	48 01 d0             	add    %rdx,%rax
  800420f4ca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420f4ce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420f4d5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f4da:	74 06                	je     800420f4e2 <vsnprintf+0x65>
  800420f4dc:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420f4e0:	7f 07                	jg     800420f4e9 <vsnprintf+0x6c>
		return -E_INVAL;
  800420f4e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f4e7:	eb 2f                	jmp    800420f518 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420f4e9:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f4ed:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f4f1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420f4f5:	48 89 c6             	mov    %rax,%rsi
  800420f4f8:	48 bf 30 f4 20 04 80 	movabs $0x800420f430,%rdi
  800420f4ff:	00 00 00 
  800420f502:	48 b8 65 ee 20 04 80 	movabs $0x800420ee65,%rax
  800420f509:	00 00 00 
  800420f50c:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420f50e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f512:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420f515:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420f518:	c9                   	leaveq 
  800420f519:	c3                   	retq   

000000800420f51a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420f51a:	55                   	push   %rbp
  800420f51b:	48 89 e5             	mov    %rsp,%rbp
  800420f51e:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420f525:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420f52c:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420f532:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f539:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f540:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f547:	84 c0                	test   %al,%al
  800420f549:	74 20                	je     800420f56b <snprintf+0x51>
  800420f54b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f54f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f553:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f557:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f55b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f55f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f563:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f567:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f56b:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420f572:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420f579:	00 00 00 
  800420f57c:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420f583:	00 00 00 
  800420f586:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f58a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420f591:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f598:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420f59f:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420f5a6:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420f5ad:	48 8b 0a             	mov    (%rdx),%rcx
  800420f5b0:	48 89 08             	mov    %rcx,(%rax)
  800420f5b3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f5b7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f5bb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f5bf:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420f5c3:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420f5ca:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420f5d1:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420f5d7:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420f5de:	48 89 c7             	mov    %rax,%rdi
  800420f5e1:	48 b8 7d f4 20 04 80 	movabs $0x800420f47d,%rax
  800420f5e8:	00 00 00 
  800420f5eb:	ff d0                	callq  *%rax
  800420f5ed:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420f5f3:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420f5f9:	c9                   	leaveq 
  800420f5fa:	c3                   	retq   

000000800420f5fb <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420f5fb:	55                   	push   %rbp
  800420f5fc:	48 89 e5             	mov    %rsp,%rbp
  800420f5ff:	48 83 ec 20          	sub    $0x20,%rsp
  800420f603:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420f607:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f60c:	74 22                	je     800420f630 <readline+0x35>
		cprintf("%s", prompt);
  800420f60e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f612:	48 89 c6             	mov    %rax,%rsi
  800420f615:	48 bf a8 a6 21 04 80 	movabs $0x800421a6a8,%rdi
  800420f61c:	00 00 00 
  800420f61f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f624:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420f62b:	00 00 00 
  800420f62e:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420f630:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420f637:	bf 00 00 00 00       	mov    $0x0,%edi
  800420f63c:	48 b8 a8 12 20 04 80 	movabs $0x80042012a8,%rax
  800420f643:	00 00 00 
  800420f646:	ff d0                	callq  *%rax
  800420f648:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420f64b:	48 b8 86 12 20 04 80 	movabs $0x8004201286,%rax
  800420f652:	00 00 00 
  800420f655:	ff d0                	callq  *%rax
  800420f657:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420f65a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420f65e:	79 30                	jns    800420f690 <readline+0x95>
			if (c != -E_EOF)
  800420f660:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420f664:	74 20                	je     800420f686 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420f666:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f669:	89 c6                	mov    %eax,%esi
  800420f66b:	48 bf ab a6 21 04 80 	movabs $0x800421a6ab,%rdi
  800420f672:	00 00 00 
  800420f675:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f67a:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800420f681:	00 00 00 
  800420f684:	ff d2                	callq  *%rdx
			return NULL;
  800420f686:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f68b:	e9 be 00 00 00       	jmpq   800420f74e <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420f690:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420f694:	74 06                	je     800420f69c <readline+0xa1>
  800420f696:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420f69a:	75 26                	jne    800420f6c2 <readline+0xc7>
  800420f69c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f6a0:	7e 20                	jle    800420f6c2 <readline+0xc7>
			if (echoing)
  800420f6a2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f6a6:	74 11                	je     800420f6b9 <readline+0xbe>
				cputchar('\b');
  800420f6a8:	bf 08 00 00 00       	mov    $0x8,%edi
  800420f6ad:	48 b8 68 12 20 04 80 	movabs $0x8004201268,%rax
  800420f6b4:	00 00 00 
  800420f6b7:	ff d0                	callq  *%rax
			i--;
  800420f6b9:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420f6bd:	e9 87 00 00 00       	jmpq   800420f749 <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420f6c2:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f6c6:	7e 3f                	jle    800420f707 <readline+0x10c>
  800420f6c8:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420f6cf:	7f 36                	jg     800420f707 <readline+0x10c>
			if (echoing)
  800420f6d1:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f6d5:	74 11                	je     800420f6e8 <readline+0xed>
				cputchar(c);
  800420f6d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f6da:	89 c7                	mov    %eax,%edi
  800420f6dc:	48 b8 68 12 20 04 80 	movabs $0x8004201268,%rax
  800420f6e3:	00 00 00 
  800420f6e6:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420f6e8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f6eb:	8d 50 01             	lea    0x1(%rax),%edx
  800420f6ee:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420f6f1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f6f4:	89 d1                	mov    %edx,%ecx
  800420f6f6:	48 ba c0 b2 60 04 80 	movabs $0x800460b2c0,%rdx
  800420f6fd:	00 00 00 
  800420f700:	48 98                	cltq   
  800420f702:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420f705:	eb 42                	jmp    800420f749 <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420f707:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420f70b:	74 06                	je     800420f713 <readline+0x118>
  800420f70d:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420f711:	75 36                	jne    800420f749 <readline+0x14e>
			if (echoing)
  800420f713:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f717:	74 11                	je     800420f72a <readline+0x12f>
				cputchar('\n');
  800420f719:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420f71e:	48 b8 68 12 20 04 80 	movabs $0x8004201268,%rax
  800420f725:	00 00 00 
  800420f728:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420f72a:	48 ba c0 b2 60 04 80 	movabs $0x800460b2c0,%rdx
  800420f731:	00 00 00 
  800420f734:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f737:	48 98                	cltq   
  800420f739:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420f73d:	48 b8 c0 b2 60 04 80 	movabs $0x800460b2c0,%rax
  800420f744:	00 00 00 
  800420f747:	eb 05                	jmp    800420f74e <readline+0x153>
		}
	}
  800420f749:	e9 fd fe ff ff       	jmpq   800420f64b <readline+0x50>
}
  800420f74e:	c9                   	leaveq 
  800420f74f:	c3                   	retq   

000000800420f750 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420f750:	55                   	push   %rbp
  800420f751:	48 89 e5             	mov    %rsp,%rbp
  800420f754:	48 83 ec 18          	sub    $0x18,%rsp
  800420f758:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f75c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f763:	eb 09                	jmp    800420f76e <strlen+0x1e>
		n++;
  800420f765:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f769:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f76e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f772:	0f b6 00             	movzbl (%rax),%eax
  800420f775:	84 c0                	test   %al,%al
  800420f777:	75 ec                	jne    800420f765 <strlen+0x15>
		n++;
	return n;
  800420f779:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f77c:	c9                   	leaveq 
  800420f77d:	c3                   	retq   

000000800420f77e <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420f77e:	55                   	push   %rbp
  800420f77f:	48 89 e5             	mov    %rsp,%rbp
  800420f782:	48 83 ec 20          	sub    $0x20,%rsp
  800420f786:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f78a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f78e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f795:	eb 0e                	jmp    800420f7a5 <strnlen+0x27>
		n++;
  800420f797:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f79b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f7a0:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420f7a5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420f7aa:	74 0b                	je     800420f7b7 <strnlen+0x39>
  800420f7ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7b0:	0f b6 00             	movzbl (%rax),%eax
  800420f7b3:	84 c0                	test   %al,%al
  800420f7b5:	75 e0                	jne    800420f797 <strnlen+0x19>
		n++;
	return n;
  800420f7b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f7ba:	c9                   	leaveq 
  800420f7bb:	c3                   	retq   

000000800420f7bc <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420f7bc:	55                   	push   %rbp
  800420f7bd:	48 89 e5             	mov    %rsp,%rbp
  800420f7c0:	48 83 ec 20          	sub    $0x20,%rsp
  800420f7c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f7c8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420f7cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420f7d4:	90                   	nop
  800420f7d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7d9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7dd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f7e1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f7e5:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f7e9:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f7ed:	0f b6 12             	movzbl (%rdx),%edx
  800420f7f0:	88 10                	mov    %dl,(%rax)
  800420f7f2:	0f b6 00             	movzbl (%rax),%eax
  800420f7f5:	84 c0                	test   %al,%al
  800420f7f7:	75 dc                	jne    800420f7d5 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420f7f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f7fd:	c9                   	leaveq 
  800420f7fe:	c3                   	retq   

000000800420f7ff <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420f7ff:	55                   	push   %rbp
  800420f800:	48 89 e5             	mov    %rsp,%rbp
  800420f803:	48 83 ec 20          	sub    $0x20,%rsp
  800420f807:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f80b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420f80f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f813:	48 89 c7             	mov    %rax,%rdi
  800420f816:	48 b8 50 f7 20 04 80 	movabs $0x800420f750,%rax
  800420f81d:	00 00 00 
  800420f820:	ff d0                	callq  *%rax
  800420f822:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420f825:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f828:	48 63 d0             	movslq %eax,%rdx
  800420f82b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f82f:	48 01 c2             	add    %rax,%rdx
  800420f832:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f836:	48 89 c6             	mov    %rax,%rsi
  800420f839:	48 89 d7             	mov    %rdx,%rdi
  800420f83c:	48 b8 bc f7 20 04 80 	movabs $0x800420f7bc,%rax
  800420f843:	00 00 00 
  800420f846:	ff d0                	callq  *%rax
	return dst;
  800420f848:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f84c:	c9                   	leaveq 
  800420f84d:	c3                   	retq   

000000800420f84e <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420f84e:	55                   	push   %rbp
  800420f84f:	48 89 e5             	mov    %rsp,%rbp
  800420f852:	48 83 ec 28          	sub    $0x28,%rsp
  800420f856:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f85a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f85e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420f862:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f866:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420f86a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f871:	00 
  800420f872:	eb 2a                	jmp    800420f89e <strncpy+0x50>
		*dst++ = *src;
  800420f874:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f878:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f87c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f880:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f884:	0f b6 12             	movzbl (%rdx),%edx
  800420f887:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420f889:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f88d:	0f b6 00             	movzbl (%rax),%eax
  800420f890:	84 c0                	test   %al,%al
  800420f892:	74 05                	je     800420f899 <strncpy+0x4b>
			src++;
  800420f894:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420f899:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f89e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8a2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420f8a6:	72 cc                	jb     800420f874 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420f8a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f8ac:	c9                   	leaveq 
  800420f8ad:	c3                   	retq   

000000800420f8ae <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420f8ae:	55                   	push   %rbp
  800420f8af:	48 89 e5             	mov    %rsp,%rbp
  800420f8b2:	48 83 ec 28          	sub    $0x28,%rsp
  800420f8b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f8ba:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f8be:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420f8c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420f8ca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f8cf:	74 3d                	je     800420f90e <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420f8d1:	eb 1d                	jmp    800420f8f0 <strlcpy+0x42>
			*dst++ = *src++;
  800420f8d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8d7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8db:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f8df:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f8e3:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f8e7:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f8eb:	0f b6 12             	movzbl (%rdx),%edx
  800420f8ee:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420f8f0:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420f8f5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f8fa:	74 0b                	je     800420f907 <strlcpy+0x59>
  800420f8fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f900:	0f b6 00             	movzbl (%rax),%eax
  800420f903:	84 c0                	test   %al,%al
  800420f905:	75 cc                	jne    800420f8d3 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420f907:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f90b:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420f90e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f912:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f916:	48 29 c2             	sub    %rax,%rdx
  800420f919:	48 89 d0             	mov    %rdx,%rax
}
  800420f91c:	c9                   	leaveq 
  800420f91d:	c3                   	retq   

000000800420f91e <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420f91e:	55                   	push   %rbp
  800420f91f:	48 89 e5             	mov    %rsp,%rbp
  800420f922:	48 83 ec 10          	sub    $0x10,%rsp
  800420f926:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f92a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420f92e:	eb 0a                	jmp    800420f93a <strcmp+0x1c>
		p++, q++;
  800420f930:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f935:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420f93a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f93e:	0f b6 00             	movzbl (%rax),%eax
  800420f941:	84 c0                	test   %al,%al
  800420f943:	74 12                	je     800420f957 <strcmp+0x39>
  800420f945:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f949:	0f b6 10             	movzbl (%rax),%edx
  800420f94c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f950:	0f b6 00             	movzbl (%rax),%eax
  800420f953:	38 c2                	cmp    %al,%dl
  800420f955:	74 d9                	je     800420f930 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f95b:	0f b6 00             	movzbl (%rax),%eax
  800420f95e:	0f b6 d0             	movzbl %al,%edx
  800420f961:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f965:	0f b6 00             	movzbl (%rax),%eax
  800420f968:	0f b6 c0             	movzbl %al,%eax
  800420f96b:	29 c2                	sub    %eax,%edx
  800420f96d:	89 d0                	mov    %edx,%eax
}
  800420f96f:	c9                   	leaveq 
  800420f970:	c3                   	retq   

000000800420f971 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420f971:	55                   	push   %rbp
  800420f972:	48 89 e5             	mov    %rsp,%rbp
  800420f975:	48 83 ec 18          	sub    $0x18,%rsp
  800420f979:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f97d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f981:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420f985:	eb 0f                	jmp    800420f996 <strncmp+0x25>
		n--, p++, q++;
  800420f987:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420f98c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f991:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420f996:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f99b:	74 1d                	je     800420f9ba <strncmp+0x49>
  800420f99d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9a1:	0f b6 00             	movzbl (%rax),%eax
  800420f9a4:	84 c0                	test   %al,%al
  800420f9a6:	74 12                	je     800420f9ba <strncmp+0x49>
  800420f9a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9ac:	0f b6 10             	movzbl (%rax),%edx
  800420f9af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9b3:	0f b6 00             	movzbl (%rax),%eax
  800420f9b6:	38 c2                	cmp    %al,%dl
  800420f9b8:	74 cd                	je     800420f987 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420f9ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9bf:	75 07                	jne    800420f9c8 <strncmp+0x57>
		return 0;
  800420f9c1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f9c6:	eb 18                	jmp    800420f9e0 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f9c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9cc:	0f b6 00             	movzbl (%rax),%eax
  800420f9cf:	0f b6 d0             	movzbl %al,%edx
  800420f9d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9d6:	0f b6 00             	movzbl (%rax),%eax
  800420f9d9:	0f b6 c0             	movzbl %al,%eax
  800420f9dc:	29 c2                	sub    %eax,%edx
  800420f9de:	89 d0                	mov    %edx,%eax
}
  800420f9e0:	c9                   	leaveq 
  800420f9e1:	c3                   	retq   

000000800420f9e2 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420f9e2:	55                   	push   %rbp
  800420f9e3:	48 89 e5             	mov    %rsp,%rbp
  800420f9e6:	48 83 ec 0c          	sub    $0xc,%rsp
  800420f9ea:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f9ee:	89 f0                	mov    %esi,%eax
  800420f9f0:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420f9f3:	eb 17                	jmp    800420fa0c <strchr+0x2a>
		if (*s == c)
  800420f9f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9f9:	0f b6 00             	movzbl (%rax),%eax
  800420f9fc:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420f9ff:	75 06                	jne    800420fa07 <strchr+0x25>
			return (char *) s;
  800420fa01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa05:	eb 15                	jmp    800420fa1c <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420fa07:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fa0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa10:	0f b6 00             	movzbl (%rax),%eax
  800420fa13:	84 c0                	test   %al,%al
  800420fa15:	75 de                	jne    800420f9f5 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420fa17:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fa1c:	c9                   	leaveq 
  800420fa1d:	c3                   	retq   

000000800420fa1e <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420fa1e:	55                   	push   %rbp
  800420fa1f:	48 89 e5             	mov    %rsp,%rbp
  800420fa22:	48 83 ec 0c          	sub    $0xc,%rsp
  800420fa26:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa2a:	89 f0                	mov    %esi,%eax
  800420fa2c:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420fa2f:	eb 13                	jmp    800420fa44 <strfind+0x26>
		if (*s == c)
  800420fa31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa35:	0f b6 00             	movzbl (%rax),%eax
  800420fa38:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420fa3b:	75 02                	jne    800420fa3f <strfind+0x21>
			break;
  800420fa3d:	eb 10                	jmp    800420fa4f <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420fa3f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fa44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa48:	0f b6 00             	movzbl (%rax),%eax
  800420fa4b:	84 c0                	test   %al,%al
  800420fa4d:	75 e2                	jne    800420fa31 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420fa4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fa53:	c9                   	leaveq 
  800420fa54:	c3                   	retq   

000000800420fa55 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420fa55:	55                   	push   %rbp
  800420fa56:	48 89 e5             	mov    %rsp,%rbp
  800420fa59:	48 83 ec 18          	sub    $0x18,%rsp
  800420fa5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa61:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420fa64:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420fa68:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fa6d:	75 06                	jne    800420fa75 <memset+0x20>
		return v;
  800420fa6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa73:	eb 69                	jmp    800420fade <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420fa75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa79:	83 e0 03             	and    $0x3,%eax
  800420fa7c:	48 85 c0             	test   %rax,%rax
  800420fa7f:	75 48                	jne    800420fac9 <memset+0x74>
  800420fa81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa85:	83 e0 03             	and    $0x3,%eax
  800420fa88:	48 85 c0             	test   %rax,%rax
  800420fa8b:	75 3c                	jne    800420fac9 <memset+0x74>
		c &= 0xFF;
  800420fa8d:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420fa94:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa97:	c1 e0 18             	shl    $0x18,%eax
  800420fa9a:	89 c2                	mov    %eax,%edx
  800420fa9c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa9f:	c1 e0 10             	shl    $0x10,%eax
  800420faa2:	09 c2                	or     %eax,%edx
  800420faa4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420faa7:	c1 e0 08             	shl    $0x8,%eax
  800420faaa:	09 d0                	or     %edx,%eax
  800420faac:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420faaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fab3:	48 c1 e8 02          	shr    $0x2,%rax
  800420fab7:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420faba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fabe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fac1:	48 89 d7             	mov    %rdx,%rdi
  800420fac4:	fc                   	cld    
  800420fac5:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420fac7:	eb 11                	jmp    800420fada <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420fac9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420facd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fad0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fad4:	48 89 d7             	mov    %rdx,%rdi
  800420fad7:	fc                   	cld    
  800420fad8:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420fada:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fade:	c9                   	leaveq 
  800420fadf:	c3                   	retq   

000000800420fae0 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420fae0:	55                   	push   %rbp
  800420fae1:	48 89 e5             	mov    %rsp,%rbp
  800420fae4:	48 83 ec 28          	sub    $0x28,%rsp
  800420fae8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420faec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420faf0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420faf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420faf8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420fafc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb00:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420fb04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb08:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fb0c:	0f 83 88 00 00 00    	jae    800420fb9a <memmove+0xba>
  800420fb12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb16:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb1a:	48 01 d0             	add    %rdx,%rax
  800420fb1d:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fb21:	76 77                	jbe    800420fb9a <memmove+0xba>
		s += n;
  800420fb23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb27:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420fb2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb2f:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fb33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb37:	83 e0 03             	and    $0x3,%eax
  800420fb3a:	48 85 c0             	test   %rax,%rax
  800420fb3d:	75 3b                	jne    800420fb7a <memmove+0x9a>
  800420fb3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb43:	83 e0 03             	and    $0x3,%eax
  800420fb46:	48 85 c0             	test   %rax,%rax
  800420fb49:	75 2f                	jne    800420fb7a <memmove+0x9a>
  800420fb4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb4f:	83 e0 03             	and    $0x3,%eax
  800420fb52:	48 85 c0             	test   %rax,%rax
  800420fb55:	75 23                	jne    800420fb7a <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420fb57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb5b:	48 83 e8 04          	sub    $0x4,%rax
  800420fb5f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb63:	48 83 ea 04          	sub    $0x4,%rdx
  800420fb67:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fb6b:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420fb6f:	48 89 c7             	mov    %rax,%rdi
  800420fb72:	48 89 d6             	mov    %rdx,%rsi
  800420fb75:	fd                   	std    
  800420fb76:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fb78:	eb 1d                	jmp    800420fb97 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420fb7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb7e:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fb82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb86:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420fb8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb8e:	48 89 d7             	mov    %rdx,%rdi
  800420fb91:	48 89 c1             	mov    %rax,%rcx
  800420fb94:	fd                   	std    
  800420fb95:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420fb97:	fc                   	cld    
  800420fb98:	eb 57                	jmp    800420fbf1 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fb9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb9e:	83 e0 03             	and    $0x3,%eax
  800420fba1:	48 85 c0             	test   %rax,%rax
  800420fba4:	75 36                	jne    800420fbdc <memmove+0xfc>
  800420fba6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fbaa:	83 e0 03             	and    $0x3,%eax
  800420fbad:	48 85 c0             	test   %rax,%rax
  800420fbb0:	75 2a                	jne    800420fbdc <memmove+0xfc>
  800420fbb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbb6:	83 e0 03             	and    $0x3,%eax
  800420fbb9:	48 85 c0             	test   %rax,%rax
  800420fbbc:	75 1e                	jne    800420fbdc <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420fbbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbc2:	48 c1 e8 02          	shr    $0x2,%rax
  800420fbc6:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420fbc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fbcd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fbd1:	48 89 c7             	mov    %rax,%rdi
  800420fbd4:	48 89 d6             	mov    %rdx,%rsi
  800420fbd7:	fc                   	cld    
  800420fbd8:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fbda:	eb 15                	jmp    800420fbf1 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420fbdc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fbe0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fbe4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fbe8:	48 89 c7             	mov    %rax,%rdi
  800420fbeb:	48 89 d6             	mov    %rdx,%rsi
  800420fbee:	fc                   	cld    
  800420fbef:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420fbf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fbf5:	c9                   	leaveq 
  800420fbf6:	c3                   	retq   

000000800420fbf7 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420fbf7:	55                   	push   %rbp
  800420fbf8:	48 89 e5             	mov    %rsp,%rbp
  800420fbfb:	48 83 ec 18          	sub    $0x18,%rsp
  800420fbff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fc03:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fc07:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420fc0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc0f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fc13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc17:	48 89 ce             	mov    %rcx,%rsi
  800420fc1a:	48 89 c7             	mov    %rax,%rdi
  800420fc1d:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  800420fc24:	00 00 00 
  800420fc27:	ff d0                	callq  *%rax
}
  800420fc29:	c9                   	leaveq 
  800420fc2a:	c3                   	retq   

000000800420fc2b <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420fc2b:	55                   	push   %rbp
  800420fc2c:	48 89 e5             	mov    %rsp,%rbp
  800420fc2f:	48 83 ec 28          	sub    $0x28,%rsp
  800420fc33:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fc37:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fc3b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420fc3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420fc47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc4b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420fc4f:	eb 36                	jmp    800420fc87 <memcmp+0x5c>
		if (*s1 != *s2)
  800420fc51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc55:	0f b6 10             	movzbl (%rax),%edx
  800420fc58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc5c:	0f b6 00             	movzbl (%rax),%eax
  800420fc5f:	38 c2                	cmp    %al,%dl
  800420fc61:	74 1a                	je     800420fc7d <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420fc63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc67:	0f b6 00             	movzbl (%rax),%eax
  800420fc6a:	0f b6 d0             	movzbl %al,%edx
  800420fc6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc71:	0f b6 00             	movzbl (%rax),%eax
  800420fc74:	0f b6 c0             	movzbl %al,%eax
  800420fc77:	29 c2                	sub    %eax,%edx
  800420fc79:	89 d0                	mov    %edx,%eax
  800420fc7b:	eb 20                	jmp    800420fc9d <memcmp+0x72>
		s1++, s2++;
  800420fc7d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fc82:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420fc87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc8b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fc8f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fc93:	48 85 c0             	test   %rax,%rax
  800420fc96:	75 b9                	jne    800420fc51 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420fc98:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fc9d:	c9                   	leaveq 
  800420fc9e:	c3                   	retq   

000000800420fc9f <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420fc9f:	55                   	push   %rbp
  800420fca0:	48 89 e5             	mov    %rsp,%rbp
  800420fca3:	48 83 ec 28          	sub    $0x28,%rsp
  800420fca7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fcab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420fcae:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420fcb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcb6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fcba:	48 01 d0             	add    %rdx,%rax
  800420fcbd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420fcc1:	eb 15                	jmp    800420fcd8 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420fcc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcc7:	0f b6 10             	movzbl (%rax),%edx
  800420fcca:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fccd:	38 c2                	cmp    %al,%dl
  800420fccf:	75 02                	jne    800420fcd3 <memfind+0x34>
			break;
  800420fcd1:	eb 0f                	jmp    800420fce2 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420fcd3:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420fcd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcdc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fce0:	72 e1                	jb     800420fcc3 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420fce2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fce6:	c9                   	leaveq 
  800420fce7:	c3                   	retq   

000000800420fce8 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420fce8:	55                   	push   %rbp
  800420fce9:	48 89 e5             	mov    %rsp,%rbp
  800420fcec:	48 83 ec 34          	sub    $0x34,%rsp
  800420fcf0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fcf4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fcf8:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420fcfb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420fd02:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fd09:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fd0a:	eb 05                	jmp    800420fd11 <strtol+0x29>
		s++;
  800420fd0c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fd11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd15:	0f b6 00             	movzbl (%rax),%eax
  800420fd18:	3c 20                	cmp    $0x20,%al
  800420fd1a:	74 f0                	je     800420fd0c <strtol+0x24>
  800420fd1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd20:	0f b6 00             	movzbl (%rax),%eax
  800420fd23:	3c 09                	cmp    $0x9,%al
  800420fd25:	74 e5                	je     800420fd0c <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420fd27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd2b:	0f b6 00             	movzbl (%rax),%eax
  800420fd2e:	3c 2b                	cmp    $0x2b,%al
  800420fd30:	75 07                	jne    800420fd39 <strtol+0x51>
		s++;
  800420fd32:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd37:	eb 17                	jmp    800420fd50 <strtol+0x68>
	else if (*s == '-')
  800420fd39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd3d:	0f b6 00             	movzbl (%rax),%eax
  800420fd40:	3c 2d                	cmp    $0x2d,%al
  800420fd42:	75 0c                	jne    800420fd50 <strtol+0x68>
		s++, neg = 1;
  800420fd44:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd49:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420fd50:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fd54:	74 06                	je     800420fd5c <strtol+0x74>
  800420fd56:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420fd5a:	75 28                	jne    800420fd84 <strtol+0x9c>
  800420fd5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd60:	0f b6 00             	movzbl (%rax),%eax
  800420fd63:	3c 30                	cmp    $0x30,%al
  800420fd65:	75 1d                	jne    800420fd84 <strtol+0x9c>
  800420fd67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd6b:	48 83 c0 01          	add    $0x1,%rax
  800420fd6f:	0f b6 00             	movzbl (%rax),%eax
  800420fd72:	3c 78                	cmp    $0x78,%al
  800420fd74:	75 0e                	jne    800420fd84 <strtol+0x9c>
		s += 2, base = 16;
  800420fd76:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420fd7b:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420fd82:	eb 2c                	jmp    800420fdb0 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420fd84:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fd88:	75 19                	jne    800420fda3 <strtol+0xbb>
  800420fd8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd8e:	0f b6 00             	movzbl (%rax),%eax
  800420fd91:	3c 30                	cmp    $0x30,%al
  800420fd93:	75 0e                	jne    800420fda3 <strtol+0xbb>
		s++, base = 8;
  800420fd95:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd9a:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420fda1:	eb 0d                	jmp    800420fdb0 <strtol+0xc8>
	else if (base == 0)
  800420fda3:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fda7:	75 07                	jne    800420fdb0 <strtol+0xc8>
		base = 10;
  800420fda9:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420fdb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdb4:	0f b6 00             	movzbl (%rax),%eax
  800420fdb7:	3c 2f                	cmp    $0x2f,%al
  800420fdb9:	7e 1d                	jle    800420fdd8 <strtol+0xf0>
  800420fdbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdbf:	0f b6 00             	movzbl (%rax),%eax
  800420fdc2:	3c 39                	cmp    $0x39,%al
  800420fdc4:	7f 12                	jg     800420fdd8 <strtol+0xf0>
			dig = *s - '0';
  800420fdc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdca:	0f b6 00             	movzbl (%rax),%eax
  800420fdcd:	0f be c0             	movsbl %al,%eax
  800420fdd0:	83 e8 30             	sub    $0x30,%eax
  800420fdd3:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fdd6:	eb 4e                	jmp    800420fe26 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420fdd8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fddc:	0f b6 00             	movzbl (%rax),%eax
  800420fddf:	3c 60                	cmp    $0x60,%al
  800420fde1:	7e 1d                	jle    800420fe00 <strtol+0x118>
  800420fde3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fde7:	0f b6 00             	movzbl (%rax),%eax
  800420fdea:	3c 7a                	cmp    $0x7a,%al
  800420fdec:	7f 12                	jg     800420fe00 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420fdee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdf2:	0f b6 00             	movzbl (%rax),%eax
  800420fdf5:	0f be c0             	movsbl %al,%eax
  800420fdf8:	83 e8 57             	sub    $0x57,%eax
  800420fdfb:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fdfe:	eb 26                	jmp    800420fe26 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420fe00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe04:	0f b6 00             	movzbl (%rax),%eax
  800420fe07:	3c 40                	cmp    $0x40,%al
  800420fe09:	7e 48                	jle    800420fe53 <strtol+0x16b>
  800420fe0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe0f:	0f b6 00             	movzbl (%rax),%eax
  800420fe12:	3c 5a                	cmp    $0x5a,%al
  800420fe14:	7f 3d                	jg     800420fe53 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420fe16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe1a:	0f b6 00             	movzbl (%rax),%eax
  800420fe1d:	0f be c0             	movsbl %al,%eax
  800420fe20:	83 e8 37             	sub    $0x37,%eax
  800420fe23:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420fe26:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fe29:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420fe2c:	7c 02                	jl     800420fe30 <strtol+0x148>
			break;
  800420fe2e:	eb 23                	jmp    800420fe53 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420fe30:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fe35:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420fe38:	48 98                	cltq   
  800420fe3a:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420fe3f:	48 89 c2             	mov    %rax,%rdx
  800420fe42:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fe45:	48 98                	cltq   
  800420fe47:	48 01 d0             	add    %rdx,%rax
  800420fe4a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420fe4e:	e9 5d ff ff ff       	jmpq   800420fdb0 <strtol+0xc8>

	if (endptr)
  800420fe53:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fe58:	74 0b                	je     800420fe65 <strtol+0x17d>
		*endptr = (char *) s;
  800420fe5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fe5e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420fe62:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420fe65:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420fe69:	74 09                	je     800420fe74 <strtol+0x18c>
  800420fe6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe6f:	48 f7 d8             	neg    %rax
  800420fe72:	eb 04                	jmp    800420fe78 <strtol+0x190>
  800420fe74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fe78:	c9                   	leaveq 
  800420fe79:	c3                   	retq   

000000800420fe7a <strstr>:

char * strstr(const char *in, const char *str)
{
  800420fe7a:	55                   	push   %rbp
  800420fe7b:	48 89 e5             	mov    %rsp,%rbp
  800420fe7e:	48 83 ec 30          	sub    $0x30,%rsp
  800420fe82:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fe86:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420fe8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fe8e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fe92:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420fe96:	0f b6 00             	movzbl (%rax),%eax
  800420fe99:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420fe9c:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420fea0:	75 06                	jne    800420fea8 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420fea2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fea6:	eb 6b                	jmp    800420ff13 <strstr+0x99>

	len = strlen(str);
  800420fea8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420feac:	48 89 c7             	mov    %rax,%rdi
  800420feaf:	48 b8 50 f7 20 04 80 	movabs $0x800420f750,%rax
  800420feb6:	00 00 00 
  800420feb9:	ff d0                	callq  *%rax
  800420febb:	48 98                	cltq   
  800420febd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420fec1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fec5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fec9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fecd:	0f b6 00             	movzbl (%rax),%eax
  800420fed0:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420fed3:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420fed7:	75 07                	jne    800420fee0 <strstr+0x66>
				return (char *) 0;
  800420fed9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fede:	eb 33                	jmp    800420ff13 <strstr+0x99>
		} while (sc != c);
  800420fee0:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420fee4:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420fee7:	75 d8                	jne    800420fec1 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420fee9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420feed:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420fef1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fef5:	48 89 ce             	mov    %rcx,%rsi
  800420fef8:	48 89 c7             	mov    %rax,%rdi
  800420fefb:	48 b8 71 f9 20 04 80 	movabs $0x800420f971,%rax
  800420ff02:	00 00 00 
  800420ff05:	ff d0                	callq  *%rax
  800420ff07:	85 c0                	test   %eax,%eax
  800420ff09:	75 b6                	jne    800420fec1 <strstr+0x47>

	return (char *) (in - 1);
  800420ff0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff0f:	48 83 e8 01          	sub    $0x1,%rax
}
  800420ff13:	c9                   	leaveq 
  800420ff14:	c3                   	retq   

000000800420ff15 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420ff15:	55                   	push   %rbp
  800420ff16:	48 89 e5             	mov    %rsp,%rbp
  800420ff19:	48 83 ec 24          	sub    $0x24,%rsp
  800420ff1d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ff21:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ff25:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420ff28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff2c:	48 8b 10             	mov    (%rax),%rdx
  800420ff2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff33:	48 01 d0             	add    %rdx,%rax
  800420ff36:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420ff3a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ff41:	00 
	switch (bytes_to_read) {
  800420ff42:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ff45:	83 f8 02             	cmp    $0x2,%eax
  800420ff48:	0f 84 ab 00 00 00    	je     800420fff9 <_dwarf_read_lsb+0xe4>
  800420ff4e:	83 f8 02             	cmp    $0x2,%eax
  800420ff51:	7f 0e                	jg     800420ff61 <_dwarf_read_lsb+0x4c>
  800420ff53:	83 f8 01             	cmp    $0x1,%eax
  800420ff56:	0f 84 b3 00 00 00    	je     800421000f <_dwarf_read_lsb+0xfa>
  800420ff5c:	e9 d9 00 00 00       	jmpq   800421003a <_dwarf_read_lsb+0x125>
  800420ff61:	83 f8 04             	cmp    $0x4,%eax
  800420ff64:	74 65                	je     800420ffcb <_dwarf_read_lsb+0xb6>
  800420ff66:	83 f8 08             	cmp    $0x8,%eax
  800420ff69:	0f 85 cb 00 00 00    	jne    800421003a <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ff6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff73:	48 83 c0 04          	add    $0x4,%rax
  800420ff77:	0f b6 00             	movzbl (%rax),%eax
  800420ff7a:	0f b6 c0             	movzbl %al,%eax
  800420ff7d:	48 c1 e0 20          	shl    $0x20,%rax
  800420ff81:	48 89 c2             	mov    %rax,%rdx
  800420ff84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff88:	48 83 c0 05          	add    $0x5,%rax
  800420ff8c:	0f b6 00             	movzbl (%rax),%eax
  800420ff8f:	0f b6 c0             	movzbl %al,%eax
  800420ff92:	48 c1 e0 28          	shl    $0x28,%rax
  800420ff96:	48 09 d0             	or     %rdx,%rax
  800420ff99:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ff9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffa1:	48 83 c0 06          	add    $0x6,%rax
  800420ffa5:	0f b6 00             	movzbl (%rax),%eax
  800420ffa8:	0f b6 c0             	movzbl %al,%eax
  800420ffab:	48 c1 e0 30          	shl    $0x30,%rax
  800420ffaf:	48 89 c2             	mov    %rax,%rdx
  800420ffb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffb6:	48 83 c0 07          	add    $0x7,%rax
  800420ffba:	0f b6 00             	movzbl (%rax),%eax
  800420ffbd:	0f b6 c0             	movzbl %al,%eax
  800420ffc0:	48 c1 e0 38          	shl    $0x38,%rax
  800420ffc4:	48 09 d0             	or     %rdx,%rax
  800420ffc7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ffcb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffcf:	48 83 c0 02          	add    $0x2,%rax
  800420ffd3:	0f b6 00             	movzbl (%rax),%eax
  800420ffd6:	0f b6 c0             	movzbl %al,%eax
  800420ffd9:	48 c1 e0 10          	shl    $0x10,%rax
  800420ffdd:	48 89 c2             	mov    %rax,%rdx
  800420ffe0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffe4:	48 83 c0 03          	add    $0x3,%rax
  800420ffe8:	0f b6 00             	movzbl (%rax),%eax
  800420ffeb:	0f b6 c0             	movzbl %al,%eax
  800420ffee:	48 c1 e0 18          	shl    $0x18,%rax
  800420fff2:	48 09 d0             	or     %rdx,%rax
  800420fff5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420fff9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fffd:	48 83 c0 01          	add    $0x1,%rax
  8004210001:	0f b6 00             	movzbl (%rax),%eax
  8004210004:	0f b6 c0             	movzbl %al,%eax
  8004210007:	48 c1 e0 08          	shl    $0x8,%rax
  800421000b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421000f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210013:	0f b6 00             	movzbl (%rax),%eax
  8004210016:	0f b6 c0             	movzbl %al,%eax
  8004210019:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421001d:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800421001e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210022:	48 8b 10             	mov    (%rax),%rdx
  8004210025:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210028:	48 98                	cltq   
  800421002a:	48 01 c2             	add    %rax,%rdx
  800421002d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210031:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210034:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210038:	eb 05                	jmp    800421003f <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800421003a:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800421003f:	c9                   	leaveq 
  8004210040:	c3                   	retq   

0000008004210041 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  8004210041:	55                   	push   %rbp
  8004210042:	48 89 e5             	mov    %rsp,%rbp
  8004210045:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210049:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421004d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210050:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210054:	48 8b 00             	mov    (%rax),%rax
  8004210057:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800421005b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210062:	00 
	switch (bytes_to_read) {
  8004210063:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210066:	83 f8 02             	cmp    $0x2,%eax
  8004210069:	0f 84 ab 00 00 00    	je     800421011a <_dwarf_decode_lsb+0xd9>
  800421006f:	83 f8 02             	cmp    $0x2,%eax
  8004210072:	7f 0e                	jg     8004210082 <_dwarf_decode_lsb+0x41>
  8004210074:	83 f8 01             	cmp    $0x1,%eax
  8004210077:	0f 84 b3 00 00 00    	je     8004210130 <_dwarf_decode_lsb+0xef>
  800421007d:	e9 d9 00 00 00       	jmpq   800421015b <_dwarf_decode_lsb+0x11a>
  8004210082:	83 f8 04             	cmp    $0x4,%eax
  8004210085:	74 65                	je     80042100ec <_dwarf_decode_lsb+0xab>
  8004210087:	83 f8 08             	cmp    $0x8,%eax
  800421008a:	0f 85 cb 00 00 00    	jne    800421015b <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  8004210090:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210094:	48 83 c0 04          	add    $0x4,%rax
  8004210098:	0f b6 00             	movzbl (%rax),%eax
  800421009b:	0f b6 c0             	movzbl %al,%eax
  800421009e:	48 c1 e0 20          	shl    $0x20,%rax
  80042100a2:	48 89 c2             	mov    %rax,%rdx
  80042100a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100a9:	48 83 c0 05          	add    $0x5,%rax
  80042100ad:	0f b6 00             	movzbl (%rax),%eax
  80042100b0:	0f b6 c0             	movzbl %al,%eax
  80042100b3:	48 c1 e0 28          	shl    $0x28,%rax
  80042100b7:	48 09 d0             	or     %rdx,%rax
  80042100ba:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042100be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100c2:	48 83 c0 06          	add    $0x6,%rax
  80042100c6:	0f b6 00             	movzbl (%rax),%eax
  80042100c9:	0f b6 c0             	movzbl %al,%eax
  80042100cc:	48 c1 e0 30          	shl    $0x30,%rax
  80042100d0:	48 89 c2             	mov    %rax,%rdx
  80042100d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100d7:	48 83 c0 07          	add    $0x7,%rax
  80042100db:	0f b6 00             	movzbl (%rax),%eax
  80042100de:	0f b6 c0             	movzbl %al,%eax
  80042100e1:	48 c1 e0 38          	shl    $0x38,%rax
  80042100e5:	48 09 d0             	or     %rdx,%rax
  80042100e8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  80042100ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100f0:	48 83 c0 02          	add    $0x2,%rax
  80042100f4:	0f b6 00             	movzbl (%rax),%eax
  80042100f7:	0f b6 c0             	movzbl %al,%eax
  80042100fa:	48 c1 e0 10          	shl    $0x10,%rax
  80042100fe:	48 89 c2             	mov    %rax,%rdx
  8004210101:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210105:	48 83 c0 03          	add    $0x3,%rax
  8004210109:	0f b6 00             	movzbl (%rax),%eax
  800421010c:	0f b6 c0             	movzbl %al,%eax
  800421010f:	48 c1 e0 18          	shl    $0x18,%rax
  8004210113:	48 09 d0             	or     %rdx,%rax
  8004210116:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800421011a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421011e:	48 83 c0 01          	add    $0x1,%rax
  8004210122:	0f b6 00             	movzbl (%rax),%eax
  8004210125:	0f b6 c0             	movzbl %al,%eax
  8004210128:	48 c1 e0 08          	shl    $0x8,%rax
  800421012c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210130:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210134:	0f b6 00             	movzbl (%rax),%eax
  8004210137:	0f b6 c0             	movzbl %al,%eax
  800421013a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421013e:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800421013f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210143:	48 8b 10             	mov    (%rax),%rdx
  8004210146:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210149:	48 98                	cltq   
  800421014b:	48 01 c2             	add    %rax,%rdx
  800421014e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210152:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210155:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210159:	eb 05                	jmp    8004210160 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800421015b:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004210160:	c9                   	leaveq 
  8004210161:	c3                   	retq   

0000008004210162 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210162:	55                   	push   %rbp
  8004210163:	48 89 e5             	mov    %rsp,%rbp
  8004210166:	48 83 ec 24          	sub    $0x24,%rsp
  800421016a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421016e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210172:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004210175:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210179:	48 8b 10             	mov    (%rax),%rdx
  800421017c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210180:	48 01 d0             	add    %rdx,%rax
  8004210183:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  8004210187:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421018a:	83 f8 02             	cmp    $0x2,%eax
  800421018d:	74 35                	je     80042101c4 <_dwarf_read_msb+0x62>
  800421018f:	83 f8 02             	cmp    $0x2,%eax
  8004210192:	7f 0a                	jg     800421019e <_dwarf_read_msb+0x3c>
  8004210194:	83 f8 01             	cmp    $0x1,%eax
  8004210197:	74 18                	je     80042101b1 <_dwarf_read_msb+0x4f>
  8004210199:	e9 53 01 00 00       	jmpq   80042102f1 <_dwarf_read_msb+0x18f>
  800421019e:	83 f8 04             	cmp    $0x4,%eax
  80042101a1:	74 49                	je     80042101ec <_dwarf_read_msb+0x8a>
  80042101a3:	83 f8 08             	cmp    $0x8,%eax
  80042101a6:	0f 84 96 00 00 00    	je     8004210242 <_dwarf_read_msb+0xe0>
  80042101ac:	e9 40 01 00 00       	jmpq   80042102f1 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  80042101b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101b5:	0f b6 00             	movzbl (%rax),%eax
  80042101b8:	0f b6 c0             	movzbl %al,%eax
  80042101bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042101bf:	e9 34 01 00 00       	jmpq   80042102f8 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042101c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101c8:	48 83 c0 01          	add    $0x1,%rax
  80042101cc:	0f b6 00             	movzbl (%rax),%eax
  80042101cf:	0f b6 d0             	movzbl %al,%edx
  80042101d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101d6:	0f b6 00             	movzbl (%rax),%eax
  80042101d9:	0f b6 c0             	movzbl %al,%eax
  80042101dc:	48 c1 e0 08          	shl    $0x8,%rax
  80042101e0:	48 09 d0             	or     %rdx,%rax
  80042101e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042101e7:	e9 0c 01 00 00       	jmpq   80042102f8 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042101ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101f0:	48 83 c0 03          	add    $0x3,%rax
  80042101f4:	0f b6 00             	movzbl (%rax),%eax
  80042101f7:	0f b6 c0             	movzbl %al,%eax
  80042101fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042101fe:	48 83 c2 02          	add    $0x2,%rdx
  8004210202:	0f b6 12             	movzbl (%rdx),%edx
  8004210205:	0f b6 d2             	movzbl %dl,%edx
  8004210208:	48 c1 e2 08          	shl    $0x8,%rdx
  800421020c:	48 09 d0             	or     %rdx,%rax
  800421020f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210213:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210217:	48 83 c0 01          	add    $0x1,%rax
  800421021b:	0f b6 00             	movzbl (%rax),%eax
  800421021e:	0f b6 c0             	movzbl %al,%eax
  8004210221:	48 c1 e0 10          	shl    $0x10,%rax
  8004210225:	48 89 c2             	mov    %rax,%rdx
  8004210228:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421022c:	0f b6 00             	movzbl (%rax),%eax
  800421022f:	0f b6 c0             	movzbl %al,%eax
  8004210232:	48 c1 e0 18          	shl    $0x18,%rax
  8004210236:	48 09 d0             	or     %rdx,%rax
  8004210239:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421023d:	e9 b6 00 00 00       	jmpq   80042102f8 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210242:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210246:	48 83 c0 07          	add    $0x7,%rax
  800421024a:	0f b6 00             	movzbl (%rax),%eax
  800421024d:	0f b6 c0             	movzbl %al,%eax
  8004210250:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210254:	48 83 c2 06          	add    $0x6,%rdx
  8004210258:	0f b6 12             	movzbl (%rdx),%edx
  800421025b:	0f b6 d2             	movzbl %dl,%edx
  800421025e:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210262:	48 09 d0             	or     %rdx,%rax
  8004210265:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210269:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421026d:	48 83 c0 05          	add    $0x5,%rax
  8004210271:	0f b6 00             	movzbl (%rax),%eax
  8004210274:	0f b6 c0             	movzbl %al,%eax
  8004210277:	48 c1 e0 10          	shl    $0x10,%rax
  800421027b:	48 89 c2             	mov    %rax,%rdx
  800421027e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210282:	48 83 c0 04          	add    $0x4,%rax
  8004210286:	0f b6 00             	movzbl (%rax),%eax
  8004210289:	0f b6 c0             	movzbl %al,%eax
  800421028c:	48 c1 e0 18          	shl    $0x18,%rax
  8004210290:	48 09 d0             	or     %rdx,%rax
  8004210293:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210297:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421029b:	48 83 c0 03          	add    $0x3,%rax
  800421029f:	0f b6 00             	movzbl (%rax),%eax
  80042102a2:	0f b6 c0             	movzbl %al,%eax
  80042102a5:	48 c1 e0 20          	shl    $0x20,%rax
  80042102a9:	48 89 c2             	mov    %rax,%rdx
  80042102ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102b0:	48 83 c0 02          	add    $0x2,%rax
  80042102b4:	0f b6 00             	movzbl (%rax),%eax
  80042102b7:	0f b6 c0             	movzbl %al,%eax
  80042102ba:	48 c1 e0 28          	shl    $0x28,%rax
  80042102be:	48 09 d0             	or     %rdx,%rax
  80042102c1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042102c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102c9:	48 83 c0 01          	add    $0x1,%rax
  80042102cd:	0f b6 00             	movzbl (%rax),%eax
  80042102d0:	0f b6 c0             	movzbl %al,%eax
  80042102d3:	48 c1 e0 30          	shl    $0x30,%rax
  80042102d7:	48 89 c2             	mov    %rax,%rdx
  80042102da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102de:	0f b6 00             	movzbl (%rax),%eax
  80042102e1:	0f b6 c0             	movzbl %al,%eax
  80042102e4:	48 c1 e0 38          	shl    $0x38,%rax
  80042102e8:	48 09 d0             	or     %rdx,%rax
  80042102eb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042102ef:	eb 07                	jmp    80042102f8 <_dwarf_read_msb+0x196>
	default:
		return (0);
  80042102f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042102f6:	eb 1a                	jmp    8004210312 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  80042102f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042102fc:	48 8b 10             	mov    (%rax),%rdx
  80042102ff:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210302:	48 98                	cltq   
  8004210304:	48 01 c2             	add    %rax,%rdx
  8004210307:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421030b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421030e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210312:	c9                   	leaveq 
  8004210313:	c3                   	retq   

0000008004210314 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210314:	55                   	push   %rbp
  8004210315:	48 89 e5             	mov    %rsp,%rbp
  8004210318:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421031c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210320:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210327:	48 8b 00             	mov    (%rax),%rax
  800421032a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800421032e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210335:	00 
	switch (bytes_to_read) {
  8004210336:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210339:	83 f8 02             	cmp    $0x2,%eax
  800421033c:	74 35                	je     8004210373 <_dwarf_decode_msb+0x5f>
  800421033e:	83 f8 02             	cmp    $0x2,%eax
  8004210341:	7f 0a                	jg     800421034d <_dwarf_decode_msb+0x39>
  8004210343:	83 f8 01             	cmp    $0x1,%eax
  8004210346:	74 18                	je     8004210360 <_dwarf_decode_msb+0x4c>
  8004210348:	e9 53 01 00 00       	jmpq   80042104a0 <_dwarf_decode_msb+0x18c>
  800421034d:	83 f8 04             	cmp    $0x4,%eax
  8004210350:	74 49                	je     800421039b <_dwarf_decode_msb+0x87>
  8004210352:	83 f8 08             	cmp    $0x8,%eax
  8004210355:	0f 84 96 00 00 00    	je     80042103f1 <_dwarf_decode_msb+0xdd>
  800421035b:	e9 40 01 00 00       	jmpq   80042104a0 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004210360:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210364:	0f b6 00             	movzbl (%rax),%eax
  8004210367:	0f b6 c0             	movzbl %al,%eax
  800421036a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800421036e:	e9 34 01 00 00       	jmpq   80042104a7 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210373:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210377:	48 83 c0 01          	add    $0x1,%rax
  800421037b:	0f b6 00             	movzbl (%rax),%eax
  800421037e:	0f b6 d0             	movzbl %al,%edx
  8004210381:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210385:	0f b6 00             	movzbl (%rax),%eax
  8004210388:	0f b6 c0             	movzbl %al,%eax
  800421038b:	48 c1 e0 08          	shl    $0x8,%rax
  800421038f:	48 09 d0             	or     %rdx,%rax
  8004210392:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210396:	e9 0c 01 00 00       	jmpq   80042104a7 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800421039b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421039f:	48 83 c0 03          	add    $0x3,%rax
  80042103a3:	0f b6 00             	movzbl (%rax),%eax
  80042103a6:	0f b6 c0             	movzbl %al,%eax
  80042103a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042103ad:	48 83 c2 02          	add    $0x2,%rdx
  80042103b1:	0f b6 12             	movzbl (%rdx),%edx
  80042103b4:	0f b6 d2             	movzbl %dl,%edx
  80042103b7:	48 c1 e2 08          	shl    $0x8,%rdx
  80042103bb:	48 09 d0             	or     %rdx,%rax
  80042103be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  80042103c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103c6:	48 83 c0 01          	add    $0x1,%rax
  80042103ca:	0f b6 00             	movzbl (%rax),%eax
  80042103cd:	0f b6 c0             	movzbl %al,%eax
  80042103d0:	48 c1 e0 10          	shl    $0x10,%rax
  80042103d4:	48 89 c2             	mov    %rax,%rdx
  80042103d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103db:	0f b6 00             	movzbl (%rax),%eax
  80042103de:	0f b6 c0             	movzbl %al,%eax
  80042103e1:	48 c1 e0 18          	shl    $0x18,%rax
  80042103e5:	48 09 d0             	or     %rdx,%rax
  80042103e8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042103ec:	e9 b6 00 00 00       	jmpq   80042104a7 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  80042103f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103f5:	48 83 c0 07          	add    $0x7,%rax
  80042103f9:	0f b6 00             	movzbl (%rax),%eax
  80042103fc:	0f b6 c0             	movzbl %al,%eax
  80042103ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210403:	48 83 c2 06          	add    $0x6,%rdx
  8004210407:	0f b6 12             	movzbl (%rdx),%edx
  800421040a:	0f b6 d2             	movzbl %dl,%edx
  800421040d:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210411:	48 09 d0             	or     %rdx,%rax
  8004210414:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421041c:	48 83 c0 05          	add    $0x5,%rax
  8004210420:	0f b6 00             	movzbl (%rax),%eax
  8004210423:	0f b6 c0             	movzbl %al,%eax
  8004210426:	48 c1 e0 10          	shl    $0x10,%rax
  800421042a:	48 89 c2             	mov    %rax,%rdx
  800421042d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210431:	48 83 c0 04          	add    $0x4,%rax
  8004210435:	0f b6 00             	movzbl (%rax),%eax
  8004210438:	0f b6 c0             	movzbl %al,%eax
  800421043b:	48 c1 e0 18          	shl    $0x18,%rax
  800421043f:	48 09 d0             	or     %rdx,%rax
  8004210442:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210446:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421044a:	48 83 c0 03          	add    $0x3,%rax
  800421044e:	0f b6 00             	movzbl (%rax),%eax
  8004210451:	0f b6 c0             	movzbl %al,%eax
  8004210454:	48 c1 e0 20          	shl    $0x20,%rax
  8004210458:	48 89 c2             	mov    %rax,%rdx
  800421045b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421045f:	48 83 c0 02          	add    $0x2,%rax
  8004210463:	0f b6 00             	movzbl (%rax),%eax
  8004210466:	0f b6 c0             	movzbl %al,%eax
  8004210469:	48 c1 e0 28          	shl    $0x28,%rax
  800421046d:	48 09 d0             	or     %rdx,%rax
  8004210470:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210474:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210478:	48 83 c0 01          	add    $0x1,%rax
  800421047c:	0f b6 00             	movzbl (%rax),%eax
  800421047f:	0f b6 c0             	movzbl %al,%eax
  8004210482:	48 c1 e0 30          	shl    $0x30,%rax
  8004210486:	48 89 c2             	mov    %rax,%rdx
  8004210489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421048d:	0f b6 00             	movzbl (%rax),%eax
  8004210490:	0f b6 c0             	movzbl %al,%eax
  8004210493:	48 c1 e0 38          	shl    $0x38,%rax
  8004210497:	48 09 d0             	or     %rdx,%rax
  800421049a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421049e:	eb 07                	jmp    80042104a7 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042104a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042104a5:	eb 1a                	jmp    80042104c1 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042104a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ab:	48 8b 10             	mov    (%rax),%rdx
  80042104ae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042104b1:	48 98                	cltq   
  80042104b3:	48 01 c2             	add    %rax,%rdx
  80042104b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ba:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042104bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042104c1:	c9                   	leaveq 
  80042104c2:	c3                   	retq   

00000080042104c3 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  80042104c3:	55                   	push   %rbp
  80042104c4:	48 89 e5             	mov    %rsp,%rbp
  80042104c7:	48 83 ec 30          	sub    $0x30,%rsp
  80042104cb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042104cf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  80042104d3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042104da:	00 
	uint8_t b;
	int shift = 0;
  80042104db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042104e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042104e6:	48 8b 10             	mov    (%rax),%rdx
  80042104e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104ed:	48 01 d0             	add    %rdx,%rax
  80042104f0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042104f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104f8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042104fc:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210500:	0f b6 00             	movzbl (%rax),%eax
  8004210503:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210506:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421050a:	83 e0 7f             	and    $0x7f,%eax
  800421050d:	89 c2                	mov    %eax,%edx
  800421050f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210512:	89 c1                	mov    %eax,%ecx
  8004210514:	d3 e2                	shl    %cl,%edx
  8004210516:	89 d0                	mov    %edx,%eax
  8004210518:	48 98                	cltq   
  800421051a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800421051e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210522:	48 8b 00             	mov    (%rax),%rax
  8004210525:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210529:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421052d:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210530:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210534:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210538:	84 c0                	test   %al,%al
  800421053a:	78 b8                	js     80042104f4 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800421053c:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210540:	7f 1f                	jg     8004210561 <_dwarf_read_sleb128+0x9e>
  8004210542:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210546:	83 e0 40             	and    $0x40,%eax
  8004210549:	85 c0                	test   %eax,%eax
  800421054b:	74 14                	je     8004210561 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800421054d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210550:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210555:	89 c1                	mov    %eax,%ecx
  8004210557:	d3 e2                	shl    %cl,%edx
  8004210559:	89 d0                	mov    %edx,%eax
  800421055b:	48 98                	cltq   
  800421055d:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004210561:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210565:	c9                   	leaveq 
  8004210566:	c3                   	retq   

0000008004210567 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210567:	55                   	push   %rbp
  8004210568:	48 89 e5             	mov    %rsp,%rbp
  800421056b:	48 83 ec 30          	sub    $0x30,%rsp
  800421056f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210573:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  8004210577:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421057e:	00 
	uint8_t b;
	int shift = 0;
  800421057f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210586:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421058a:	48 8b 10             	mov    (%rax),%rdx
  800421058d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210591:	48 01 d0             	add    %rdx,%rax
  8004210594:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210598:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421059c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105a0:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042105a4:	0f b6 00             	movzbl (%rax),%eax
  80042105a7:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042105aa:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042105ae:	83 e0 7f             	and    $0x7f,%eax
  80042105b1:	89 c2                	mov    %eax,%edx
  80042105b3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042105b6:	89 c1                	mov    %eax,%ecx
  80042105b8:	d3 e2                	shl    %cl,%edx
  80042105ba:	89 d0                	mov    %edx,%eax
  80042105bc:	48 98                	cltq   
  80042105be:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  80042105c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042105c6:	48 8b 00             	mov    (%rax),%rax
  80042105c9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042105d1:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  80042105d4:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  80042105d8:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042105dc:	84 c0                	test   %al,%al
  80042105de:	78 b8                	js     8004210598 <_dwarf_read_uleb128+0x31>

	return (ret);
  80042105e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042105e4:	c9                   	leaveq 
  80042105e5:	c3                   	retq   

00000080042105e6 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  80042105e6:	55                   	push   %rbp
  80042105e7:	48 89 e5             	mov    %rsp,%rbp
  80042105ea:	48 83 ec 28          	sub    $0x28,%rsp
  80042105ee:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  80042105f2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042105f9:	00 
	uint8_t b;
	int shift = 0;
  80042105fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210601:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210605:	48 8b 00             	mov    (%rax),%rax
  8004210608:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421060c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210610:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210614:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210618:	0f b6 00             	movzbl (%rax),%eax
  800421061b:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421061e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210622:	83 e0 7f             	and    $0x7f,%eax
  8004210625:	89 c2                	mov    %eax,%edx
  8004210627:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421062a:	89 c1                	mov    %eax,%ecx
  800421062c:	d3 e2                	shl    %cl,%edx
  800421062e:	89 d0                	mov    %edx,%eax
  8004210630:	48 98                	cltq   
  8004210632:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210636:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421063a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421063e:	84 c0                	test   %al,%al
  8004210640:	78 ca                	js     800421060c <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004210642:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210646:	7f 1f                	jg     8004210667 <_dwarf_decode_sleb128+0x81>
  8004210648:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421064c:	83 e0 40             	and    $0x40,%eax
  800421064f:	85 c0                	test   %eax,%eax
  8004210651:	74 14                	je     8004210667 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  8004210653:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210656:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421065b:	89 c1                	mov    %eax,%ecx
  800421065d:	d3 e2                	shl    %cl,%edx
  800421065f:	89 d0                	mov    %edx,%eax
  8004210661:	48 98                	cltq   
  8004210663:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  8004210667:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421066b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421066f:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210672:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210676:	c9                   	leaveq 
  8004210677:	c3                   	retq   

0000008004210678 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  8004210678:	55                   	push   %rbp
  8004210679:	48 89 e5             	mov    %rsp,%rbp
  800421067c:	48 83 ec 28          	sub    $0x28,%rsp
  8004210680:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  8004210684:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421068b:	00 
	uint8_t b;
	int shift = 0;
  800421068c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210693:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210697:	48 8b 00             	mov    (%rax),%rax
  800421069a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421069e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106a2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042106a6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042106aa:	0f b6 00             	movzbl (%rax),%eax
  80042106ad:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042106b0:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042106b4:	83 e0 7f             	and    $0x7f,%eax
  80042106b7:	89 c2                	mov    %eax,%edx
  80042106b9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042106bc:	89 c1                	mov    %eax,%ecx
  80042106be:	d3 e2                	shl    %cl,%edx
  80042106c0:	89 d0                	mov    %edx,%eax
  80042106c2:	48 98                	cltq   
  80042106c4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  80042106c8:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  80042106cc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042106d0:	84 c0                	test   %al,%al
  80042106d2:	78 ca                	js     800421069e <_dwarf_decode_uleb128+0x26>

	*dp = src;
  80042106d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106d8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042106dc:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042106df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042106e3:	c9                   	leaveq 
  80042106e4:	c3                   	retq   

00000080042106e5 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  80042106e5:	55                   	push   %rbp
  80042106e6:	48 89 e5             	mov    %rsp,%rbp
  80042106e9:	48 83 ec 28          	sub    $0x28,%rsp
  80042106ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042106f1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042106f5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  80042106f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106fd:	48 8b 10             	mov    (%rax),%rdx
  8004210700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210704:	48 01 d0             	add    %rdx,%rax
  8004210707:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421070b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421070f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004210713:	eb 17                	jmp    800421072c <_dwarf_read_string+0x47>
		src++;
  8004210715:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800421071a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421071e:	48 8b 00             	mov    (%rax),%rax
  8004210721:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210725:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210729:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800421072c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210730:	0f b6 00             	movzbl (%rax),%eax
  8004210733:	84 c0                	test   %al,%al
  8004210735:	74 0d                	je     8004210744 <_dwarf_read_string+0x5f>
  8004210737:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421073b:	48 8b 00             	mov    (%rax),%rax
  800421073e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210742:	72 d1                	jb     8004210715 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  8004210744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210748:	0f b6 00             	movzbl (%rax),%eax
  800421074b:	84 c0                	test   %al,%al
  800421074d:	75 1f                	jne    800421076e <_dwarf_read_string+0x89>
  800421074f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210753:	48 8b 00             	mov    (%rax),%rax
  8004210756:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421075a:	73 12                	jae    800421076e <_dwarf_read_string+0x89>
		(*offsetp)++;
  800421075c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210760:	48 8b 00             	mov    (%rax),%rax
  8004210763:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210767:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421076b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421076e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210772:	c9                   	leaveq 
  8004210773:	c3                   	retq   

0000008004210774 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  8004210774:	55                   	push   %rbp
  8004210775:	48 89 e5             	mov    %rsp,%rbp
  8004210778:	48 83 ec 28          	sub    $0x28,%rsp
  800421077c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210780:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210784:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  8004210788:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421078c:	48 8b 10             	mov    (%rax),%rdx
  800421078f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210793:	48 01 d0             	add    %rdx,%rax
  8004210796:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421079a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421079e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  80042107a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042107a6:	48 8b 10             	mov    (%rax),%rdx
  80042107a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107ad:	48 01 c2             	add    %rax,%rdx
  80042107b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042107b4:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042107b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042107bb:	c9                   	leaveq 
  80042107bc:	c3                   	retq   

00000080042107bd <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  80042107bd:	55                   	push   %rbp
  80042107be:	48 89 e5             	mov    %rsp,%rbp
  80042107c1:	48 83 ec 20          	sub    $0x20,%rsp
  80042107c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  80042107c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  80042107d1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042107d6:	75 35                	jne    800421080d <_dwarf_elf_get_byte_order+0x50>
  80042107d8:	48 b9 c0 a6 21 04 80 	movabs $0x800421a6c0,%rcx
  80042107df:	00 00 00 
  80042107e2:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  80042107e9:	00 00 00 
  80042107ec:	be 29 01 00 00       	mov    $0x129,%esi
  80042107f1:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  80042107f8:	00 00 00 
  80042107fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210800:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004210807:	00 00 00 
  800421080a:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800421080d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210811:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004210815:	0f b6 c0             	movzbl %al,%eax
  8004210818:	83 f8 02             	cmp    $0x2,%eax
  800421081b:	75 07                	jne    8004210824 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800421081d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210822:	eb 05                	jmp    8004210829 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  8004210824:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  8004210829:	c9                   	leaveq 
  800421082a:	c3                   	retq   

000000800421082b <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800421082b:	55                   	push   %rbp
  800421082c:	48 89 e5             	mov    %rsp,%rbp
  800421082f:	48 83 ec 20          	sub    $0x20,%rsp
  8004210833:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  8004210837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421083b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800421083f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210844:	75 35                	jne    800421087b <_dwarf_elf_get_pointer_size+0x50>
  8004210846:	48 b9 c0 a6 21 04 80 	movabs $0x800421a6c0,%rcx
  800421084d:	00 00 00 
  8004210850:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004210857:	00 00 00 
  800421085a:	be 3f 01 00 00       	mov    $0x13f,%esi
  800421085f:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004210866:	00 00 00 
  8004210869:	b8 00 00 00 00       	mov    $0x0,%eax
  800421086e:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004210875:	00 00 00 
  8004210878:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800421087b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421087f:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  8004210883:	3c 01                	cmp    $0x1,%al
  8004210885:	75 07                	jne    800421088e <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  8004210887:	b8 04 00 00 00       	mov    $0x4,%eax
  800421088c:	eb 05                	jmp    8004210893 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800421088e:	b8 08 00 00 00       	mov    $0x8,%eax
}
  8004210893:	c9                   	leaveq 
  8004210894:	c3                   	retq   

0000008004210895 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  8004210895:	55                   	push   %rbp
  8004210896:	48 89 e5             	mov    %rsp,%rbp
  8004210899:	53                   	push   %rbx
  800421089a:	48 83 ec 18          	sub    $0x18,%rsp
  800421089e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  80042108a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108aa:	ba 60 00 00 00       	mov    $0x60,%edx
  80042108af:	be 00 00 00 00       	mov    $0x0,%esi
  80042108b4:	48 89 c7             	mov    %rax,%rdi
  80042108b7:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  80042108be:	00 00 00 
  80042108c1:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  80042108c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108c7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  80042108ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108d2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042108d9:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  80042108da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108de:	48 89 c7             	mov    %rax,%rdi
  80042108e1:	48 b8 2b 08 21 04 80 	movabs $0x800421082b,%rax
  80042108e8:	00 00 00 
  80042108eb:	ff d0                	callq  *%rax
  80042108ed:	0f b6 d0             	movzbl %al,%edx
  80042108f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108f4:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  80042108f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108fb:	48 89 c7             	mov    %rax,%rdi
  80042108fe:	48 b8 bd 07 21 04 80 	movabs $0x80042107bd,%rax
  8004210905:	00 00 00 
  8004210908:	ff d0                	callq  *%rax
  800421090a:	85 c0                	test   %eax,%eax
  800421090c:	75 26                	jne    8004210934 <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800421090e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210912:	48 b9 62 01 21 04 80 	movabs $0x8004210162,%rcx
  8004210919:	00 00 00 
  800421091c:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004210920:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210924:	48 bb 14 03 21 04 80 	movabs $0x8004210314,%rbx
  800421092b:	00 00 00 
  800421092e:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8004210932:	eb 24                	jmp    8004210958 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  8004210934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210938:	48 b9 15 ff 20 04 80 	movabs $0x800420ff15,%rcx
  800421093f:	00 00 00 
  8004210942:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  8004210946:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421094a:	48 be 41 00 21 04 80 	movabs $0x8004210041,%rsi
  8004210951:	00 00 00 
  8004210954:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  8004210958:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421095c:	48 89 c7             	mov    %rax,%rdi
  800421095f:	48 b8 62 1e 21 04 80 	movabs $0x8004211e62,%rax
  8004210966:	00 00 00 
  8004210969:	ff d0                	callq  *%rax
	return 0;
  800421096b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210970:	48 83 c4 18          	add    $0x18,%rsp
  8004210974:	5b                   	pop    %rbx
  8004210975:	5d                   	pop    %rbp
  8004210976:	c3                   	retq   

0000008004210977 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  8004210977:	55                   	push   %rbp
  8004210978:	48 89 e5             	mov    %rsp,%rbp
  800421097b:	48 83 ec 20          	sub    $0x20,%rsp
  800421097f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210983:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004210987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421098b:	48 8b 10             	mov    (%rax),%rdx
  800421098e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210992:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004210996:	48 39 c2             	cmp    %rax,%rdx
  8004210999:	76 0a                	jbe    80042109a5 <_get_next_cu+0x2e>
		return -1;
  800421099b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042109a0:	e9 6b 01 00 00       	jmpq   8004210b10 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  80042109a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109a9:	48 8b 00             	mov    (%rax),%rax
  80042109ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  80042109b0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042109b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109b8:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  80042109bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109c0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042109c4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042109c8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042109cc:	48 89 d1             	mov    %rdx,%rcx
  80042109cf:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109d3:	ba 04 00 00 00       	mov    $0x4,%edx
  80042109d8:	48 89 cf             	mov    %rcx,%rdi
  80042109db:	ff d0                	callq  *%rax
  80042109dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  80042109e0:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042109e4:	75 2a                	jne    8004210a10 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  80042109e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109ea:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042109ee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042109f2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042109f6:	48 89 d1             	mov    %rdx,%rcx
  80042109f9:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109fd:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210a02:	48 89 cf             	mov    %rcx,%rdi
  8004210a05:	ff d0                	callq  *%rax
  8004210a07:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  8004210a0a:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004210a0e:	eb 04                	jmp    8004210a14 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004210a10:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004210a14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a18:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210a1c:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004210a1f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210a22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a26:	48 01 c2             	add    %rax,%rdx
  8004210a29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a2d:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004210a30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a34:	48 8b 10             	mov    (%rax),%rdx
  8004210a37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a3b:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004210a3f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210a42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a46:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  8004210a49:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004210a4d:	75 07                	jne    8004210a56 <_get_next_cu+0xdf>
  8004210a4f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210a54:	eb 05                	jmp    8004210a5b <_get_next_cu+0xe4>
  8004210a56:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004210a5b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210a5f:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004210a62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a66:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a6a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210a6e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210a72:	48 89 d1             	mov    %rdx,%rcx
  8004210a75:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210a79:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210a7e:	48 89 cf             	mov    %rcx,%rdi
  8004210a81:	ff d0                	callq  *%rax
  8004210a83:	89 c2                	mov    %eax,%edx
  8004210a85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a89:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  8004210a8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a91:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a95:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210a99:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210a9d:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004210aa1:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210aa5:	48 89 cf             	mov    %rcx,%rdi
  8004210aa8:	ff d0                	callq  *%rax
  8004210aaa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210aae:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004210ab2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ab6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210aba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210abe:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210ac2:	48 89 d1             	mov    %rdx,%rcx
  8004210ac5:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210ac9:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210ace:	48 89 cf             	mov    %rcx,%rdi
  8004210ad1:	ff d0                	callq  *%rax
  8004210ad3:	89 c2                	mov    %eax,%edx
  8004210ad5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ad9:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004210adc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ae0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210ae4:	66 83 f8 01          	cmp    $0x1,%ax
  8004210ae8:	76 0e                	jbe    8004210af8 <_get_next_cu+0x181>
  8004210aea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210aee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210af2:	66 83 f8 04          	cmp    $0x4,%ax
  8004210af6:	76 07                	jbe    8004210aff <_get_next_cu+0x188>
		return -1;
  8004210af8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210afd:	eb 11                	jmp    8004210b10 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004210aff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b07:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004210b0b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210b10:	c9                   	leaveq 
  8004210b11:	c3                   	retq   

0000008004210b12 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004210b12:	55                   	push   %rbp
  8004210b13:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004210b16:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004210b1a:	0f b6 c8             	movzbl %al,%ecx
  8004210b1d:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004210b21:	0f b7 d0             	movzwl %ax,%edx
  8004210b24:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004210b28:	48 89 c6             	mov    %rax,%rsi
  8004210b2b:	48 bf f2 a6 21 04 80 	movabs $0x800421a6f2,%rdi
  8004210b32:	00 00 00 
  8004210b35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b3a:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  8004210b41:	00 00 00 
  8004210b44:	41 ff d0             	callq  *%r8
}
  8004210b47:	5d                   	pop    %rbp
  8004210b48:	c3                   	retq   

0000008004210b49 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004210b49:	55                   	push   %rbp
  8004210b4a:	48 89 e5             	mov    %rsp,%rbp
  8004210b4d:	48 83 ec 60          	sub    $0x60,%rsp
  8004210b51:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004210b55:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004210b59:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004210b5d:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  8004210b61:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004210b66:	75 35                	jne    8004210b9d <_dwarf_abbrev_parse+0x54>
  8004210b68:	48 b9 01 a7 21 04 80 	movabs $0x800421a701,%rcx
  8004210b6f:	00 00 00 
  8004210b72:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004210b79:	00 00 00 
  8004210b7c:	be a4 01 00 00       	mov    $0x1a4,%esi
  8004210b81:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004210b88:	00 00 00 
  8004210b8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b90:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004210b97:	00 00 00 
  8004210b9a:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004210b9d:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004210ba2:	75 35                	jne    8004210bd9 <_dwarf_abbrev_parse+0x90>
  8004210ba4:	48 b9 0d a7 21 04 80 	movabs $0x800421a70d,%rcx
  8004210bab:	00 00 00 
  8004210bae:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004210bb5:	00 00 00 
  8004210bb8:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004210bbd:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004210bc4:	00 00 00 
  8004210bc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bcc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004210bd3:	00 00 00 
  8004210bd6:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004210bd9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210bdd:	48 8b 10             	mov    (%rax),%rdx
  8004210be0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210be4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210be8:	48 39 c2             	cmp    %rax,%rdx
  8004210beb:	72 0a                	jb     8004210bf7 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004210bed:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210bf2:	e9 d3 01 00 00       	jmpq   8004210dca <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004210bf7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210bfb:	48 8b 00             	mov    (%rax),%rax
  8004210bfe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004210c02:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210c06:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210c0a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c12:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c16:	48 89 d6             	mov    %rdx,%rsi
  8004210c19:	48 89 c7             	mov    %rax,%rdi
  8004210c1c:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004210c23:	00 00 00 
  8004210c26:	ff d0                	callq  *%rax
  8004210c28:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004210c2c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210c31:	75 15                	jne    8004210c48 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  8004210c33:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c37:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004210c3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c43:	e9 82 01 00 00       	jmpq   8004210dca <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c4c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c50:	48 89 d6             	mov    %rdx,%rsi
  8004210c53:	48 89 c7             	mov    %rax,%rdi
  8004210c56:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004210c5d:	00 00 00 
  8004210c60:	ff d0                	callq  *%rax
  8004210c62:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210c66:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210c6a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210c6e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210c72:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210c76:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210c7b:	48 89 cf             	mov    %rcx,%rdi
  8004210c7e:	ff d0                	callq  *%rax
  8004210c80:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  8004210c83:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210c8b:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004210c8e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c92:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210c96:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004210c9a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c9e:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004210ca2:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004210ca5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ca9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210cad:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004210cb1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cb5:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210cbc:	00 
	abp->ab_atnum    = 0;
  8004210cbd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cc1:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210cc8:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004210cc9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210ccd:	48 8b 00             	mov    (%rax),%rax
  8004210cd0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210cd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cd8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210cdc:	48 89 d6             	mov    %rdx,%rsi
  8004210cdf:	48 89 c7             	mov    %rax,%rdi
  8004210ce2:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004210ce9:	00 00 00 
  8004210cec:	ff d0                	callq  *%rax
  8004210cee:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210cf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cf6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210cfa:	48 89 d6             	mov    %rdx,%rsi
  8004210cfd:	48 89 c7             	mov    %rax,%rdi
  8004210d00:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004210d07:	00 00 00 
  8004210d0a:	ff d0                	callq  *%rax
  8004210d0c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  8004210d10:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210d15:	0f 84 89 00 00 00    	je     8004210da4 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210d1b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d1f:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d23:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d27:	48 89 d0             	mov    %rdx,%rax
  8004210d2a:	48 01 c0             	add    %rax,%rax
  8004210d2d:	48 01 d0             	add    %rdx,%rax
  8004210d30:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d34:	48 01 c8             	add    %rcx,%rax
  8004210d37:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210d3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210d3f:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004210d42:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d46:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d4a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d4e:	48 89 d0             	mov    %rdx,%rax
  8004210d51:	48 01 c0             	add    %rax,%rax
  8004210d54:	48 01 d0             	add    %rdx,%rax
  8004210d57:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d5b:	48 01 c8             	add    %rcx,%rax
  8004210d5e:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004210d62:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d66:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210d69:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d6d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d71:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d75:	48 89 d0             	mov    %rdx,%rax
  8004210d78:	48 01 c0             	add    %rax,%rax
  8004210d7b:	48 01 d0             	add    %rdx,%rax
  8004210d7e:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d82:	48 01 c8             	add    %rcx,%rax
  8004210d85:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210d89:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d8d:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  8004210d90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d94:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210d98:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210d9c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210da0:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  8004210da4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210da9:	0f 85 1a ff ff ff    	jne    8004210cc9 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  8004210daf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210db3:	48 8b 00             	mov    (%rax),%rax
  8004210db6:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210dba:	48 89 c2             	mov    %rax,%rdx
  8004210dbd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210dc1:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004210dc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210dca:	c9                   	leaveq 
  8004210dcb:	c3                   	retq   

0000008004210dcc <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210dcc:	55                   	push   %rbp
  8004210dcd:	48 89 e5             	mov    %rsp,%rbp
  8004210dd0:	48 83 ec 70          	sub    $0x70,%rsp
  8004210dd4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210dd8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210ddc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004210de0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210de5:	75 0a                	jne    8004210df1 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004210de7:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210dec:	e9 0a 01 00 00       	jmpq   8004210efb <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004210df1:	48 bf 18 a7 21 04 80 	movabs $0x800421a718,%rdi
  8004210df8:	00 00 00 
  8004210dfb:	48 b8 2c 51 21 04 80 	movabs $0x800421512c,%rax
  8004210e02:	00 00 00 
  8004210e05:	ff d0                	callq  *%rax
  8004210e07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210e0b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210e10:	75 35                	jne    8004210e47 <_dwarf_abbrev_find+0x7b>
  8004210e12:	48 b9 0d a7 21 04 80 	movabs $0x800421a70d,%rcx
  8004210e19:	00 00 00 
  8004210e1c:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004210e23:	00 00 00 
  8004210e26:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210e2b:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004210e32:	00 00 00 
  8004210e35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e3a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004210e41:	00 00 00 
  8004210e44:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210e47:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210e4b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004210e4f:	e9 8d 00 00 00       	jmpq   8004210ee1 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004210e54:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210e58:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210e5c:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210e60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e64:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210e68:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210e6c:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210e70:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210e75:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210e79:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210e7e:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210e82:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210e87:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210e8b:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210e90:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004210e94:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210e99:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210e9d:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004210ea2:	48 89 c7             	mov    %rax,%rdi
  8004210ea5:	48 b8 49 0b 21 04 80 	movabs $0x8004210b49,%rax
  8004210eac:	00 00 00 
  8004210eaf:	ff d0                	callq  *%rax
  8004210eb1:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  8004210eb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210eb8:	74 05                	je     8004210ebf <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004210eba:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210ebd:	eb 3c                	jmp    8004210efb <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  8004210ebf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210ec3:	48 8b 00             	mov    (%rax),%rax
  8004210ec6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210eca:	75 07                	jne    8004210ed3 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004210ecc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ed1:	eb 28                	jmp    8004210efb <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  8004210ed3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210ed7:	48 8b 00             	mov    (%rax),%rax
  8004210eda:	48 85 c0             	test   %rax,%rax
  8004210edd:	75 02                	jne    8004210ee1 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004210edf:	eb 15                	jmp    8004210ef6 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004210ee1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ee5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210ee9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210eed:	48 39 c2             	cmp    %rax,%rdx
  8004210ef0:	0f 87 5e ff ff ff    	ja     8004210e54 <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  8004210ef6:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210efb:	c9                   	leaveq 
  8004210efc:	c3                   	retq   

0000008004210efd <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004210efd:	55                   	push   %rbp
  8004210efe:	48 89 e5             	mov    %rsp,%rbp
  8004210f01:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210f08:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210f0f:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210f16:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210f1d:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004210f24:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210f2b:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210f32:	48 bf 26 a7 21 04 80 	movabs $0x800421a726,%rdi
  8004210f39:	00 00 00 
  8004210f3c:	48 b8 2c 51 21 04 80 	movabs $0x800421512c,%rax
  8004210f43:	00 00 00 
  8004210f46:	ff d0                	callq  *%rax
  8004210f48:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210f4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210f50:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f54:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  8004210f58:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210f5f:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210f63:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004210f66:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004210f6d:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004210f74:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210f79:	be 00 00 00 00       	mov    $0x0,%esi
  8004210f7e:	48 89 c7             	mov    %rax,%rdi
  8004210f81:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004210f88:	00 00 00 
  8004210f8b:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210f8d:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210f94:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210f9b:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210fa2:	48 8b 00             	mov    (%rax),%rax
  8004210fa5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  8004210fa9:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210fb0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210fb4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  8004210fb8:	8b 45 10             	mov    0x10(%rbp),%eax
  8004210fbb:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  8004210fbe:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004210fc5:	00 

	switch (form) {
  8004210fc6:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004210fcd:	20 
  8004210fce:	0f 87 82 04 00 00    	ja     8004211456 <_dwarf_attr_init+0x559>
  8004210fd4:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004210fdb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210fe2:	00 
  8004210fe3:	48 b8 50 a7 21 04 80 	movabs $0x800421a750,%rax
  8004210fea:	00 00 00 
  8004210fed:	48 01 d0             	add    %rdx,%rax
  8004210ff0:	48 8b 00             	mov    (%rax),%rax
  8004210ff3:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210ff5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210ffc:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211000:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211007:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421100b:	0f b6 d2             	movzbl %dl,%edx
  800421100e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211015:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211019:	48 89 cf             	mov    %rcx,%rdi
  800421101c:	ff d0                	callq  *%rax
  800421101e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211022:	e9 37 04 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211027:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421102e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211032:	48 89 d6             	mov    %rdx,%rsi
  8004211035:	48 89 c7             	mov    %rax,%rdi
  8004211038:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  800421103f:	00 00 00 
  8004211042:	ff d0                	callq  *%rax
  8004211044:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211048:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421104c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211057:	48 89 ce             	mov    %rcx,%rsi
  800421105a:	48 89 c7             	mov    %rax,%rdi
  800421105d:	48 b8 74 07 21 04 80 	movabs $0x8004210774,%rax
  8004211064:	00 00 00 
  8004211067:	ff d0                	callq  *%rax
  8004211069:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421106d:	e9 ec 03 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004211072:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211079:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421107d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211084:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211088:	ba 01 00 00 00       	mov    $0x1,%edx
  800421108d:	48 89 cf             	mov    %rcx,%rdi
  8004211090:	ff d0                	callq  *%rax
  8004211092:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211096:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421109a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042110a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110a5:	48 89 ce             	mov    %rcx,%rsi
  80042110a8:	48 89 c7             	mov    %rax,%rdi
  80042110ab:	48 b8 74 07 21 04 80 	movabs $0x8004210774,%rax
  80042110b2:	00 00 00 
  80042110b5:	ff d0                	callq  *%rax
  80042110b7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042110bb:	e9 9e 03 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042110c0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110c7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110cb:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110d2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110d6:	ba 02 00 00 00       	mov    $0x2,%edx
  80042110db:	48 89 cf             	mov    %rcx,%rdi
  80042110de:	ff d0                	callq  *%rax
  80042110e0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042110e4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042110e8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042110ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110f3:	48 89 ce             	mov    %rcx,%rsi
  80042110f6:	48 89 c7             	mov    %rax,%rdi
  80042110f9:	48 b8 74 07 21 04 80 	movabs $0x8004210774,%rax
  8004211100:	00 00 00 
  8004211103:	ff d0                	callq  *%rax
  8004211105:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211109:	e9 50 03 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800421110e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211115:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211119:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211120:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211124:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211129:	48 89 cf             	mov    %rcx,%rdi
  800421112c:	ff d0                	callq  *%rax
  800421112e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211132:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211136:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421113d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211141:	48 89 ce             	mov    %rcx,%rsi
  8004211144:	48 89 c7             	mov    %rax,%rdi
  8004211147:	48 b8 74 07 21 04 80 	movabs $0x8004210774,%rax
  800421114e:	00 00 00 
  8004211151:	ff d0                	callq  *%rax
  8004211153:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211157:	e9 02 03 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800421115c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211163:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211167:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421116e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211172:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211177:	48 89 cf             	mov    %rcx,%rdi
  800421117a:	ff d0                	callq  *%rax
  800421117c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211180:	e9 d9 02 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004211185:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421118c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211190:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211197:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421119b:	ba 02 00 00 00       	mov    $0x2,%edx
  80042111a0:	48 89 cf             	mov    %rcx,%rdi
  80042111a3:	ff d0                	callq  *%rax
  80042111a5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111a9:	e9 b0 02 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042111ae:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111b5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111b9:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111c0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111c4:	ba 04 00 00 00       	mov    $0x4,%edx
  80042111c9:	48 89 cf             	mov    %rcx,%rdi
  80042111cc:	ff d0                	callq  *%rax
  80042111ce:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111d2:	e9 87 02 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042111d7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111de:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111e2:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111e9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111ed:	ba 08 00 00 00       	mov    $0x8,%edx
  80042111f2:	48 89 cf             	mov    %rcx,%rdi
  80042111f5:	ff d0                	callq  *%rax
  80042111f7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111fb:	e9 5e 02 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211200:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211207:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421120b:	48 89 d6             	mov    %rdx,%rsi
  800421120e:	48 89 c7             	mov    %rax,%rdi
  8004211211:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004211218:	00 00 00 
  800421121b:	ff d0                	callq  *%rax
  800421121d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211224:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800421122b:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211232:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211239:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211240:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211247:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421124e:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  8004211255:	4d 89 c1             	mov    %r8,%r9
  8004211258:	49 89 f8             	mov    %rdi,%r8
  800421125b:	48 89 c7             	mov    %rax,%rdi
  800421125e:	48 b8 fd 0e 21 04 80 	movabs $0x8004210efd,%rax
  8004211265:	00 00 00 
  8004211268:	ff d0                	callq  *%rax
  800421126a:	e9 1d 03 00 00       	jmpq   800421158c <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  800421126f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211276:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421127a:	66 83 f8 02          	cmp    $0x2,%ax
  800421127e:	75 2f                	jne    80042112af <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004211280:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211287:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421128b:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211292:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004211296:	0f b6 d2             	movzbl %dl,%edx
  8004211299:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112a0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112a4:	48 89 cf             	mov    %rcx,%rdi
  80042112a7:	ff d0                	callq  *%rax
  80042112a9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042112ad:	eb 39                	jmp    80042112e8 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042112af:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042112b6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042112ba:	66 83 f8 03          	cmp    $0x3,%ax
  80042112be:	75 28                	jne    80042112e8 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042112c0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112c7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112cb:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042112cf:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112d6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112da:	48 89 cf             	mov    %rcx,%rdi
  80042112dd:	ff d0                	callq  *%rax
  80042112df:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042112e3:	e9 76 01 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
  80042112e8:	e9 71 01 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042112ed:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042112f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112f8:	48 89 d6             	mov    %rdx,%rsi
  80042112fb:	48 89 c7             	mov    %rax,%rdi
  80042112fe:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004211305:	00 00 00 
  8004211308:	ff d0                	callq  *%rax
  800421130a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421130e:	e9 4b 01 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211313:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421131a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421131e:	48 89 d6             	mov    %rdx,%rsi
  8004211321:	48 89 c7             	mov    %rax,%rdi
  8004211324:	48 b8 c3 04 21 04 80 	movabs $0x80042104c3,%rax
  800421132b:	00 00 00 
  800421132e:	ff d0                	callq  *%rax
  8004211330:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211334:	e9 25 01 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211339:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211340:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211344:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211348:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421134f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211353:	48 89 cf             	mov    %rcx,%rdi
  8004211356:	ff d0                	callq  *%rax
  8004211358:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421135c:	e9 fd 00 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004211361:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211365:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211369:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211370:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211374:	48 89 ce             	mov    %rcx,%rsi
  8004211377:	48 89 c7             	mov    %rax,%rdi
  800421137a:	48 b8 e5 06 21 04 80 	movabs $0x80042106e5,%rax
  8004211381:	00 00 00 
  8004211384:	ff d0                	callq  *%rax
  8004211386:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421138a:	e9 cf 00 00 00       	jmpq   800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421138f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211396:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421139a:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421139e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042113a5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042113a9:	48 89 cf             	mov    %rcx,%rdi
  80042113ac:	ff d0                	callq  *%rax
  80042113ae:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042113b2:	48 bf 32 a7 21 04 80 	movabs $0x800421a732,%rdi
  80042113b9:	00 00 00 
  80042113bc:	48 b8 2c 51 21 04 80 	movabs $0x800421512c,%rax
  80042113c3:	00 00 00 
  80042113c6:	ff d0                	callq  *%rax
  80042113c8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042113cc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042113d1:	75 35                	jne    8004211408 <_dwarf_attr_init+0x50b>
  80042113d3:	48 b9 3d a7 21 04 80 	movabs $0x800421a73d,%rcx
  80042113da:	00 00 00 
  80042113dd:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  80042113e4:	00 00 00 
  80042113e7:	be 51 02 00 00       	mov    $0x251,%esi
  80042113ec:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  80042113f3:	00 00 00 
  80042113f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042113fb:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211402:	00 00 00 
  8004211405:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211408:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421140c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211410:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211414:	48 01 d0             	add    %rdx,%rax
  8004211417:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421141b:	eb 41                	jmp    800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  800421141d:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211424:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211425:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211429:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211430:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211434:	48 89 ce             	mov    %rcx,%rsi
  8004211437:	48 89 c7             	mov    %rax,%rdi
  800421143a:	48 b8 74 07 21 04 80 	movabs $0x8004210774,%rax
  8004211441:	00 00 00 
  8004211444:	ff d0                	callq  *%rax
  8004211446:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421144a:	eb 12                	jmp    800421145e <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  800421144c:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004211453:	00 
		break;
  8004211454:	eb 08                	jmp    800421145e <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004211456:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  800421145d:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  800421145e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211462:	0f 85 21 01 00 00    	jne    8004211589 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004211468:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800421146f:	09 
  8004211470:	74 1e                	je     8004211490 <_dwarf_attr_init+0x593>
  8004211472:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004211479:	0a 
  800421147a:	74 14                	je     8004211490 <_dwarf_attr_init+0x593>
  800421147c:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004211483:	03 
  8004211484:	74 0a                	je     8004211490 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  8004211486:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  800421148d:	04 
  800421148e:	75 10                	jne    80042114a0 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  8004211490:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211494:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004211498:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421149c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042114a0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042114a4:	48 83 f8 03          	cmp    $0x3,%rax
  80042114a8:	75 39                	jne    80042114e3 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042114aa:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042114ae:	48 83 f8 08          	cmp    $0x8,%rax
  80042114b2:	74 1c                	je     80042114d0 <_dwarf_attr_init+0x5d3>
  80042114b4:	48 83 f8 0e          	cmp    $0xe,%rax
  80042114b8:	74 02                	je     80042114bc <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042114ba:	eb 27                	jmp    80042114e3 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042114bc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042114c0:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042114c7:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042114ce:	eb 13                	jmp    80042114e3 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042114d0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042114d4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042114db:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042114e2:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  80042114e3:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042114ea:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  80042114f1:	8d 48 01             	lea    0x1(%rax),%ecx
  80042114f4:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  80042114fb:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004211501:	0f b6 c0             	movzbl %al,%eax
  8004211504:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421150b:	48 63 d0             	movslq %eax,%rdx
  800421150e:	48 89 d0             	mov    %rdx,%rax
  8004211511:	48 01 c0             	add    %rax,%rax
  8004211514:	48 01 d0             	add    %rdx,%rax
  8004211517:	48 c1 e0 05          	shl    $0x5,%rax
  800421151b:	48 01 c8             	add    %rcx,%rax
  800421151e:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211524:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421152b:	48 89 10             	mov    %rdx,(%rax)
  800421152e:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004211535:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004211539:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421153d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211541:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004211545:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004211549:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421154d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211551:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211555:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004211559:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421155d:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004211561:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211565:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004211569:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421156d:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004211571:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211575:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004211579:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421157d:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004211581:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211585:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004211589:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800421158c:	c9                   	leaveq 
  800421158d:	c3                   	retq   

000000800421158e <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  800421158e:	55                   	push   %rbp
  800421158f:	48 89 e5             	mov    %rsp,%rbp
  8004211592:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  8004211599:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042115a0:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042115a7:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042115ae:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042115b4:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042115bb:	00 
  80042115bc:	75 35                	jne    80042115f3 <dwarf_search_die_within_cu+0x65>
  80042115be:	48 b9 58 a8 21 04 80 	movabs $0x800421a858,%rcx
  80042115c5:	00 00 00 
  80042115c8:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  80042115cf:	00 00 00 
  80042115d2:	be 86 02 00 00       	mov    $0x286,%esi
  80042115d7:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  80042115de:	00 00 00 
  80042115e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042115e6:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042115ed:	00 00 00 
  80042115f0:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  80042115f3:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  80042115fa:	00 
  80042115fb:	75 35                	jne    8004211632 <dwarf_search_die_within_cu+0xa4>
  80042115fd:	48 b9 5c a8 21 04 80 	movabs $0x800421a85c,%rcx
  8004211604:	00 00 00 
  8004211607:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  800421160e:	00 00 00 
  8004211611:	be 88 02 00 00       	mov    $0x288,%esi
  8004211616:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  800421161d:	00 00 00 
  8004211620:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211625:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421162c:	00 00 00 
  800421162f:	41 ff d0             	callq  *%r8

	level = 1;
  8004211632:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211639:	e9 17 02 00 00       	jmpq   8004211855 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  800421163e:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211645:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004211649:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211650:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211654:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  800421165b:	48 89 d6             	mov    %rdx,%rsi
  800421165e:	48 89 c7             	mov    %rax,%rdi
  8004211661:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004211668:	00 00 00 
  800421166b:	ff d0                	callq  *%rax
  800421166d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004211671:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211676:	75 22                	jne    800421169a <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  8004211678:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421167c:	74 09                	je     8004211687 <dwarf_search_die_within_cu+0xf9>
  800421167e:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211685:	75 0a                	jne    8004211691 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004211687:	b8 04 00 00 00       	mov    $0x4,%eax
  800421168c:	e9 f4 01 00 00       	jmpq   8004211885 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004211691:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004211695:	e9 bb 01 00 00       	jmpq   8004211855 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  800421169a:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042116a1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042116a5:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042116ac:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042116b0:	48 89 34 24          	mov    %rsi,(%rsp)
  80042116b4:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042116b8:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042116bd:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042116c1:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  80042116c6:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  80042116ca:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  80042116cf:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  80042116d3:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  80042116d8:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  80042116dc:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  80042116e1:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  80042116e5:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  80042116ea:	48 89 ce             	mov    %rcx,%rsi
  80042116ed:	48 89 c7             	mov    %rax,%rdi
  80042116f0:	48 b8 cc 0d 21 04 80 	movabs $0x8004210dcc,%rax
  80042116f7:	00 00 00 
  80042116fa:	ff d0                	callq  *%rax
  80042116fc:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042116ff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211703:	74 08                	je     800421170d <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004211705:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211708:	e9 78 01 00 00       	jmpq   8004211885 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  800421170d:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211714:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211718:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800421171b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211722:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211726:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800421172a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211731:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004211735:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800421173c:	b8 66 00 00 00       	mov    $0x66,%eax
  8004211741:	48 89 d6             	mov    %rdx,%rsi
  8004211744:	48 89 c1             	mov    %rax,%rcx
  8004211747:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800421174a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211751:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004211758:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800421175f:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211766:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800421176a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004211771:	e9 8e 00 00 00       	jmpq   8004211804 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004211776:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004211779:	48 63 d0             	movslq %eax,%rdx
  800421177c:	48 89 d0             	mov    %rdx,%rax
  800421177f:	48 01 c0             	add    %rax,%rax
  8004211782:	48 01 d0             	add    %rdx,%rax
  8004211785:	48 c1 e0 03          	shl    $0x3,%rax
  8004211789:	48 01 e8             	add    %rbp,%rax
  800421178c:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004211792:	48 8b 08             	mov    (%rax),%rcx
  8004211795:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  800421179c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421179f:	48 63 d0             	movslq %eax,%rdx
  80042117a2:	48 89 d0             	mov    %rdx,%rax
  80042117a5:	48 01 c0             	add    %rax,%rax
  80042117a8:	48 01 d0             	add    %rdx,%rax
  80042117ab:	48 c1 e0 03          	shl    $0x3,%rax
  80042117af:	48 83 c0 30          	add    $0x30,%rax
  80042117b3:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042117b7:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042117be:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042117c5:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042117cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  80042117d3:	49 89 c9             	mov    %rcx,%r9
  80042117d6:	49 89 f8             	mov    %rdi,%r8
  80042117d9:	48 89 d1             	mov    %rdx,%rcx
  80042117dc:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  80042117e0:	48 89 c7             	mov    %rax,%rdi
  80042117e3:	48 b8 fd 0e 21 04 80 	movabs $0x8004210efd,%rax
  80042117ea:	00 00 00 
  80042117ed:	ff d0                	callq  *%rax
  80042117ef:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042117f2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042117f6:	74 08                	je     8004211800 <dwarf_search_die_within_cu+0x272>
				return (ret);
  80042117f8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042117fb:	e9 85 00 00 00       	jmpq   8004211885 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004211800:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004211804:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004211807:	48 63 d0             	movslq %eax,%rdx
  800421180a:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004211811:	48 39 c2             	cmp    %rax,%rdx
  8004211814:	0f 82 5c ff ff ff    	jb     8004211776 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  800421181a:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004211821:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211828:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800421182c:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211833:	74 19                	je     800421184e <dwarf_search_die_within_cu+0x2c0>
  8004211835:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211839:	7e 13                	jle    800421184e <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421183b:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004211842:	3c 01                	cmp    $0x1,%al
  8004211844:	75 06                	jne    800421184c <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  8004211846:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421184a:	eb 09                	jmp    8004211855 <dwarf_search_die_within_cu+0x2c7>
  800421184c:	eb 07                	jmp    8004211855 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  800421184e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211853:	eb 30                	jmp    8004211885 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211855:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004211859:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211860:	48 39 c2             	cmp    %rax,%rdx
  8004211863:	76 1b                	jbe    8004211880 <dwarf_search_die_within_cu+0x2f2>
  8004211865:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421186c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211870:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211877:	48 39 c2             	cmp    %rax,%rdx
  800421187a:	0f 87 be fd ff ff    	ja     800421163e <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004211880:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004211885:	c9                   	leaveq 
  8004211886:	c3                   	retq   

0000008004211887 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004211887:	55                   	push   %rbp
  8004211888:	48 89 e5             	mov    %rsp,%rbp
  800421188b:	48 83 ec 60          	sub    $0x60,%rsp
  800421188f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211893:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211897:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  800421189b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042118a0:	75 35                	jne    80042118d7 <dwarf_offdie+0x50>
  80042118a2:	48 b9 58 a8 21 04 80 	movabs $0x800421a858,%rcx
  80042118a9:	00 00 00 
  80042118ac:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  80042118b3:	00 00 00 
  80042118b6:	be c4 02 00 00       	mov    $0x2c4,%esi
  80042118bb:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  80042118c2:	00 00 00 
  80042118c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042118ca:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042118d1:	00 00 00 
  80042118d4:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042118d7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042118dc:	75 35                	jne    8004211913 <dwarf_offdie+0x8c>
  80042118de:	48 b9 5c a8 21 04 80 	movabs $0x800421a85c,%rcx
  80042118e5:	00 00 00 
  80042118e8:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  80042118ef:	00 00 00 
  80042118f2:	be c5 02 00 00       	mov    $0x2c5,%esi
  80042118f7:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  80042118fe:	00 00 00 
  8004211901:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211906:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421190d:	00 00 00 
  8004211910:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004211913:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004211917:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421191b:	76 66                	jbe    8004211983 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800421191d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211921:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004211925:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211929:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  800421192d:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211931:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004211935:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421193a:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  800421193e:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211943:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211947:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800421194c:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004211950:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211955:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004211959:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800421195e:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004211962:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004211967:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421196c:	48 89 c7             	mov    %rax,%rdi
  800421196f:	48 b8 8e 15 21 04 80 	movabs $0x800421158e,%rax
  8004211976:	00 00 00 
  8004211979:	ff d0                	callq  *%rax
  800421197b:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  800421197e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211981:	eb 05                	jmp    8004211988 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004211983:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211988:	c9                   	leaveq 
  8004211989:	c3                   	retq   

000000800421198a <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  800421198a:	55                   	push   %rbp
  800421198b:	48 89 e5             	mov    %rsp,%rbp
  800421198e:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004211992:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211996:	89 f0                	mov    %esi,%eax
  8004211998:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  800421199c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042119a3:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  80042119a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042119ab:	eb 57                	jmp    8004211a04 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  80042119ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042119b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042119b4:	48 63 d0             	movslq %eax,%rdx
  80042119b7:	48 89 d0             	mov    %rdx,%rax
  80042119ba:	48 01 c0             	add    %rax,%rax
  80042119bd:	48 01 d0             	add    %rdx,%rax
  80042119c0:	48 c1 e0 05          	shl    $0x5,%rax
  80042119c4:	48 01 c8             	add    %rcx,%rax
  80042119c7:	48 05 80 03 00 00    	add    $0x380,%rax
  80042119cd:	48 8b 10             	mov    (%rax),%rdx
  80042119d0:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80042119d4:	48 39 c2             	cmp    %rax,%rdx
  80042119d7:	75 27                	jne    8004211a00 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  80042119d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042119dc:	48 63 d0             	movslq %eax,%rdx
  80042119df:	48 89 d0             	mov    %rdx,%rax
  80042119e2:	48 01 c0             	add    %rax,%rax
  80042119e5:	48 01 d0             	add    %rdx,%rax
  80042119e8:	48 c1 e0 05          	shl    $0x5,%rax
  80042119ec:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  80042119f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119f7:	48 01 d0             	add    %rdx,%rax
  80042119fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042119fe:	eb 17                	jmp    8004211a17 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004211a00:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211a04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a08:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211a0f:	0f b6 c0             	movzbl %al,%eax
  8004211a12:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004211a15:	7f 96                	jg     80042119ad <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004211a17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211a1b:	c9                   	leaveq 
  8004211a1c:	c3                   	retq   

0000008004211a1d <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004211a1d:	55                   	push   %rbp
  8004211a1e:	48 89 e5             	mov    %rsp,%rbp
  8004211a21:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211a25:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211a29:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211a2d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211a31:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004211a35:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211a3a:	75 35                	jne    8004211a71 <dwarf_siblingof+0x54>
  8004211a3c:	48 b9 58 a8 21 04 80 	movabs $0x800421a858,%rcx
  8004211a43:	00 00 00 
  8004211a46:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211a4d:	00 00 00 
  8004211a50:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004211a55:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211a5c:	00 00 00 
  8004211a5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a64:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211a6b:	00 00 00 
  8004211a6e:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004211a71:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211a76:	75 35                	jne    8004211aad <dwarf_siblingof+0x90>
  8004211a78:	48 b9 5c a8 21 04 80 	movabs $0x800421a85c,%rcx
  8004211a7f:	00 00 00 
  8004211a82:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211a89:	00 00 00 
  8004211a8c:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004211a91:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211a98:	00 00 00 
  8004211a9b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211aa0:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211aa7:	00 00 00 
  8004211aaa:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211aad:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004211ab2:	75 35                	jne    8004211ae9 <dwarf_siblingof+0xcc>
  8004211ab4:	48 b9 64 a8 21 04 80 	movabs $0x800421a864,%rcx
  8004211abb:	00 00 00 
  8004211abe:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211ac5:	00 00 00 
  8004211ac8:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004211acd:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211ad4:	00 00 00 
  8004211ad7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211adc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211ae3:	00 00 00 
  8004211ae6:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004211ae9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211aee:	75 65                	jne    8004211b55 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004211af0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211af4:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211af8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211afc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211b00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211b04:	48 8b 38             	mov    (%rax),%rdi
  8004211b07:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211b0b:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004211b0f:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211b14:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004211b18:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211b1d:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004211b21:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211b26:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004211b2a:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211b2f:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004211b33:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211b38:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211b3c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211b41:	48 89 cf             	mov    %rcx,%rdi
  8004211b44:	48 b8 87 18 21 04 80 	movabs $0x8004211887,%rax
  8004211b4b:	00 00 00 
  8004211b4e:	ff d0                	callq  *%rax
  8004211b50:	e9 0a 01 00 00       	jmpq   8004211c5f <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004211b55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211b5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b60:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211b64:	84 c0                	test   %al,%al
  8004211b66:	75 0e                	jne    8004211b76 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004211b68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b6c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211b70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211b74:	eb 6b                	jmp    8004211be1 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004211b76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b7a:	be 01 00 00 00       	mov    $0x1,%esi
  8004211b7f:	48 89 c7             	mov    %rax,%rdi
  8004211b82:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  8004211b89:	00 00 00 
  8004211b8c:	ff d0                	callq  *%rax
  8004211b8e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004211b92:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211b97:	74 35                	je     8004211bce <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004211b99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b9d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211ba1:	48 83 f8 10          	cmp    $0x10,%rax
  8004211ba5:	74 19                	je     8004211bc0 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004211ba7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bab:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211baf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211bb3:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211bb7:	48 01 d0             	add    %rdx,%rax
  8004211bba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211bbe:	eb 21                	jmp    8004211be1 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004211bc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bc4:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211bc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211bcc:	eb 13                	jmp    8004211be1 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004211bce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211bd2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211bd6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004211bda:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004211be1:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004211be4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211be8:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004211bec:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004211bf0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211bf4:	4c 8b 00             	mov    (%rax),%r8
  8004211bf7:	4c 89 04 24          	mov    %r8,(%rsp)
  8004211bfb:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004211bff:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211c04:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211c08:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211c0d:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211c11:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211c16:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211c1a:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004211c1f:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004211c23:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211c28:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211c2c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211c31:	48 b8 8e 15 21 04 80 	movabs $0x800421158e,%rax
  8004211c38:	00 00 00 
  8004211c3b:	ff d0                	callq  *%rax
  8004211c3d:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004211c40:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004211c44:	75 07                	jne    8004211c4d <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004211c46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211c4b:	eb 12                	jmp    8004211c5f <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004211c4d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211c51:	74 07                	je     8004211c5a <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004211c53:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211c58:	eb 05                	jmp    8004211c5f <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004211c5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211c5f:	c9                   	leaveq 
  8004211c60:	c3                   	retq   

0000008004211c61 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004211c61:	55                   	push   %rbp
  8004211c62:	48 89 e5             	mov    %rsp,%rbp
  8004211c65:	48 83 ec 70          	sub    $0x70,%rsp
  8004211c69:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211c6d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211c71:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211c75:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004211c79:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211c7e:	75 35                	jne    8004211cb5 <dwarf_child+0x54>
  8004211c80:	48 b9 67 a8 21 04 80 	movabs $0x800421a867,%rcx
  8004211c87:	00 00 00 
  8004211c8a:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211c91:	00 00 00 
  8004211c94:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211c99:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211ca0:	00 00 00 
  8004211ca3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ca8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211caf:	00 00 00 
  8004211cb2:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004211cb5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211cba:	75 35                	jne    8004211cf1 <dwarf_child+0x90>
  8004211cbc:	48 b9 5c a8 21 04 80 	movabs $0x800421a85c,%rcx
  8004211cc3:	00 00 00 
  8004211cc6:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211ccd:	00 00 00 
  8004211cd0:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004211cd5:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211cdc:	00 00 00 
  8004211cdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ce4:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211ceb:	00 00 00 
  8004211cee:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004211cf1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211cf6:	75 35                	jne    8004211d2d <dwarf_child+0xcc>
  8004211cf8:	48 b9 58 a8 21 04 80 	movabs $0x800421a858,%rcx
  8004211cff:	00 00 00 
  8004211d02:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211d09:	00 00 00 
  8004211d0c:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211d11:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211d18:	00 00 00 
  8004211d1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d20:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211d27:	00 00 00 
  8004211d2a:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211d2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004211d32:	75 35                	jne    8004211d69 <dwarf_child+0x108>
  8004211d34:	48 b9 64 a8 21 04 80 	movabs $0x800421a864,%rcx
  8004211d3b:	00 00 00 
  8004211d3e:	48 ba ca a6 21 04 80 	movabs $0x800421a6ca,%rdx
  8004211d45:	00 00 00 
  8004211d48:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211d4d:	48 bf df a6 21 04 80 	movabs $0x800421a6df,%rdi
  8004211d54:	00 00 00 
  8004211d57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d5c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211d63:	00 00 00 
  8004211d66:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211d69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d6d:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211d71:	84 c0                	test   %al,%al
  8004211d73:	75 0a                	jne    8004211d7f <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004211d75:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211d7a:	e9 84 00 00 00       	jmpq   8004211e03 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211d7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d83:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211d87:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d8b:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211d8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211d93:	48 8b 08             	mov    (%rax),%rcx
  8004211d96:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211d9a:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211d9e:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211da3:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004211da7:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211dac:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211db0:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211db5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211db9:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211dbe:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004211dc2:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211dc7:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211dcb:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211dd0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211dd5:	48 b8 8e 15 21 04 80 	movabs $0x800421158e,%rax
  8004211ddc:	00 00 00 
  8004211ddf:	ff d0                	callq  *%rax
  8004211de1:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004211de4:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211de8:	75 07                	jne    8004211df1 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004211dea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211def:	eb 12                	jmp    8004211e03 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004211df1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211df5:	74 07                	je     8004211dfe <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004211df7:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211dfc:	eb 05                	jmp    8004211e03 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004211dfe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211e03:	c9                   	leaveq 
  8004211e04:	c3                   	retq   

0000008004211e05 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211e05:	55                   	push   %rbp
  8004211e06:	48 89 e5             	mov    %rsp,%rbp
  8004211e09:	48 83 ec 20          	sub    $0x20,%rsp
  8004211e0d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211e11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e15:	48 8b 00             	mov    (%rax),%rax
  8004211e18:	48 89 c7             	mov    %rax,%rdi
  8004211e1b:	48 b8 2c 51 21 04 80 	movabs $0x800421512c,%rax
  8004211e22:	00 00 00 
  8004211e25:	ff d0                	callq  *%rax
  8004211e27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211e2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e2f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211e33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e37:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004211e3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e3f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211e43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e47:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004211e4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e4f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211e53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e57:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004211e5b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211e60:	c9                   	leaveq 
  8004211e61:	c3                   	retq   

0000008004211e62 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211e62:	55                   	push   %rbp
  8004211e63:	48 89 e5             	mov    %rsp,%rbp
  8004211e66:	48 83 ec 08          	sub    $0x8,%rsp
  8004211e6a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211e6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e72:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211e78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e7c:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211e82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e86:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211e8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e90:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211e96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e9a:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211ea0:	c9                   	leaveq 
  8004211ea1:	c3                   	retq   

0000008004211ea2 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  8004211ea2:	55                   	push   %rbp
  8004211ea3:	48 89 e5             	mov    %rsp,%rbp
  8004211ea6:	48 83 ec 40          	sub    $0x40,%rsp
  8004211eaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211eae:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211eb2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211eb6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211eba:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004211ebe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ec2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004211ec6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211eca:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211ecf:	be 00 00 00 00       	mov    $0x0,%esi
  8004211ed4:	48 89 c7             	mov    %rax,%rdi
  8004211ed7:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004211ede:	00 00 00 
  8004211ee1:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004211ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ee7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211eeb:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004211eef:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211ef4:	75 07                	jne    8004211efd <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  8004211ef6:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211efb:	eb 75                	jmp    8004211f72 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211efd:	eb 59                	jmp    8004211f58 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211eff:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211f03:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211f07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f0b:	be 01 00 00 00       	mov    $0x1,%esi
  8004211f10:	48 89 c7             	mov    %rax,%rdi
  8004211f13:	48 b8 b7 40 21 04 80 	movabs $0x80042140b7,%rax
  8004211f1a:	00 00 00 
  8004211f1d:	ff d0                	callq  *%rax
  8004211f1f:	85 c0                	test   %eax,%eax
  8004211f21:	79 07                	jns    8004211f2a <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  8004211f23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211f28:	eb 48                	jmp    8004211f72 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211f2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f2e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211f32:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211f36:	77 20                	ja     8004211f58 <dwarf_get_fde_at_pc+0xb6>
  8004211f38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f3c:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  8004211f40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f44:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211f48:	48 01 d0             	add    %rdx,%rax
  8004211f4b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211f4f:	76 07                	jbe    8004211f58 <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  8004211f51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f56:	eb 1a                	jmp    8004211f72 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211f58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f5c:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004211f60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f64:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004211f68:	48 39 c2             	cmp    %rax,%rdx
  8004211f6b:	72 92                	jb     8004211eff <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  8004211f6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211f72:	c9                   	leaveq 
  8004211f73:	c3                   	retq   

0000008004211f74 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004211f74:	55                   	push   %rbp
  8004211f75:	48 89 e5             	mov    %rsp,%rbp
  8004211f78:	53                   	push   %rbx
  8004211f79:	48 83 ec 38          	sub    $0x38,%rsp
  8004211f7d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211f81:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211f85:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211f89:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  8004211f8d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211f92:	75 35                	jne    8004211fc9 <_dwarf_frame_regtable_copy+0x55>
  8004211f94:	48 b9 7a a8 21 04 80 	movabs $0x800421a87a,%rcx
  8004211f9b:	00 00 00 
  8004211f9e:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  8004211fa5:	00 00 00 
  8004211fa8:	be 57 00 00 00       	mov    $0x57,%esi
  8004211fad:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  8004211fb4:	00 00 00 
  8004211fb7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211fbc:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211fc3:	00 00 00 
  8004211fc6:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  8004211fc9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211fce:	75 35                	jne    8004212005 <_dwarf_frame_regtable_copy+0x91>
  8004211fd0:	48 b9 b2 a8 21 04 80 	movabs $0x800421a8b2,%rcx
  8004211fd7:	00 00 00 
  8004211fda:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  8004211fe1:	00 00 00 
  8004211fe4:	be 58 00 00 00       	mov    $0x58,%esi
  8004211fe9:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  8004211ff0:	00 00 00 
  8004211ff3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ff8:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004211fff:	00 00 00 
  8004212002:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  8004212005:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212009:	48 8b 00             	mov    (%rax),%rax
  800421200c:	48 85 c0             	test   %rax,%rax
  800421200f:	75 39                	jne    800421204a <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004212011:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212015:	48 bb 00 b7 60 04 80 	movabs $0x800460b700,%rbx
  800421201c:	00 00 00 
  800421201f:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004212022:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212026:	48 8b 00             	mov    (%rax),%rax
  8004212029:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421202d:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004212031:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004212035:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212039:	48 8b 00             	mov    (%rax),%rax
  800421203c:	48 bb 60 d6 60 04 80 	movabs $0x800460d660,%rbx
  8004212043:	00 00 00 
  8004212046:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  800421204a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421204e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212052:	48 8b 00             	mov    (%rax),%rax
  8004212055:	ba 18 00 00 00       	mov    $0x18,%edx
  800421205a:	48 89 ce             	mov    %rcx,%rsi
  800421205d:	48 89 c7             	mov    %rax,%rdi
  8004212060:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  8004212067:	00 00 00 
  800421206a:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421206c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004212073:	eb 5a                	jmp    80042120cf <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004212075:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212079:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421207d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004212080:	48 63 d0             	movslq %eax,%rdx
  8004212083:	48 89 d0             	mov    %rdx,%rax
  8004212086:	48 01 c0             	add    %rax,%rax
  8004212089:	48 01 d0             	add    %rdx,%rax
  800421208c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212090:	48 01 c1             	add    %rax,%rcx
  8004212093:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212097:	48 8b 00             	mov    (%rax),%rax
  800421209a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421209e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042120a1:	48 63 d0             	movslq %eax,%rdx
  80042120a4:	48 89 d0             	mov    %rdx,%rax
  80042120a7:	48 01 c0             	add    %rax,%rax
  80042120aa:	48 01 d0             	add    %rdx,%rax
  80042120ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042120b1:	48 01 f0             	add    %rsi,%rax
  80042120b4:	ba 18 00 00 00       	mov    $0x18,%edx
  80042120b9:	48 89 ce             	mov    %rcx,%rsi
  80042120bc:	48 89 c7             	mov    %rax,%rdi
  80042120bf:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  80042120c6:	00 00 00 
  80042120c9:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  80042120cb:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042120cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120d3:	48 8b 00             	mov    (%rax),%rax
  80042120d6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042120da:	0f b7 c0             	movzwl %ax,%eax
  80042120dd:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042120e0:	7e 10                	jle    80042120f2 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  80042120e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042120e6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042120ea:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042120ed:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042120f0:	7f 83                	jg     8004212075 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  80042120f2:	eb 32                	jmp    8004212126 <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  80042120f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120f8:	48 8b 00             	mov    (%rax),%rax
  80042120fb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004212102:	48 63 d0             	movslq %eax,%rdx
  8004212105:	48 89 d0             	mov    %rdx,%rax
  8004212108:	48 01 c0             	add    %rax,%rax
  800421210b:	48 01 d0             	add    %rdx,%rax
  800421210e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212112:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004212116:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421211a:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  800421211e:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212122:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004212126:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421212a:	48 8b 00             	mov    (%rax),%rax
  800421212d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212131:	0f b7 c0             	movzwl %ax,%eax
  8004212134:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212137:	7f bb                	jg     80042120f4 <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  8004212139:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421213e:	48 83 c4 38          	add    $0x38,%rsp
  8004212142:	5b                   	pop    %rbx
  8004212143:	5d                   	pop    %rbp
  8004212144:	c3                   	retq   

0000008004212145 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212145:	55                   	push   %rbp
  8004212146:	48 89 e5             	mov    %rsp,%rbp
  8004212149:	53                   	push   %rbx
  800421214a:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004212151:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212155:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004212159:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  800421215d:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004212161:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004212168:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  800421216f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  8004212176:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800421217d:	00 
  800421217e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212182:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  8004212186:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421218a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421218e:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004212191:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212195:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212199:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  800421219d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042121a1:	48 89 c7             	mov    %rax,%rdi
  80042121a4:	48 b8 74 1f 21 04 80 	movabs $0x8004211f74,%rax
  80042121ab:	00 00 00 
  80042121ae:	ff d0                	callq  *%rax
	p = insts;
  80042121b0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042121b4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  80042121b8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042121bc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042121c0:	48 01 d0             	add    %rdx,%rax
  80042121c3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  80042121c7:	e9 3a 0d 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  80042121cc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042121d0:	0f b6 00             	movzbl (%rax),%eax
  80042121d3:	84 c0                	test   %al,%al
  80042121d5:	75 11                	jne    80042121e8 <_dwarf_frame_run_inst+0xa3>
			p++;
  80042121d7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042121db:	48 83 c0 01          	add    $0x1,%rax
  80042121df:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  80042121e3:	e9 1e 0d 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  80042121e8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042121ec:	0f b6 00             	movzbl (%rax),%eax
  80042121ef:	83 e0 c0             	and    $0xffffffc0,%eax
  80042121f2:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  80042121f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042121f9:	0f b6 00             	movzbl (%rax),%eax
  80042121fc:	83 e0 3f             	and    $0x3f,%eax
  80042121ff:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  8004212202:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212206:	48 83 c0 01          	add    $0x1,%rax
  800421220a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  800421220e:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004212212:	0f 84 a1 01 00 00    	je     80042123b9 <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  8004212218:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800421221c:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004212221:	74 38                	je     800421225b <_dwarf_frame_run_inst+0x116>
  8004212223:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004212228:	0f 84 01 01 00 00    	je     800421232f <_dwarf_frame_run_inst+0x1ea>
  800421222e:	83 f8 40             	cmp    $0x40,%eax
  8004212231:	0f 85 71 01 00 00    	jne    80042123a8 <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  8004212237:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421223b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212242:	ff 
  8004212243:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  8004212247:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421224b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421224f:	73 05                	jae    8004212256 <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  8004212251:	e9 be 0c 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			        break;
  8004212256:	e9 59 01 00 00       	jmpq   80042123b4 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  800421225b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421225f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212263:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004212266:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421226a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421226e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212272:	66 39 c2             	cmp    %ax,%dx
  8004212275:	72 0c                	jb     8004212283 <_dwarf_frame_run_inst+0x13e>
  8004212277:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421227e:	e9 91 0c 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  8004212283:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212287:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421228b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421228f:	48 89 d0             	mov    %rdx,%rax
  8004212292:	48 01 c0             	add    %rax,%rax
  8004212295:	48 01 d0             	add    %rdx,%rax
  8004212298:	48 c1 e0 03          	shl    $0x3,%rax
  800421229c:	48 01 c8             	add    %rcx,%rax
  800421229f:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042122a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122a6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122aa:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122ae:	48 89 d0             	mov    %rdx,%rax
  80042122b1:	48 01 c0             	add    %rax,%rax
  80042122b4:	48 01 d0             	add    %rdx,%rax
  80042122b7:	48 c1 e0 03          	shl    $0x3,%rax
  80042122bb:	48 01 c8             	add    %rcx,%rax
  80042122be:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  80042122c2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122c6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122ca:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122ce:	48 89 d0             	mov    %rdx,%rax
  80042122d1:	48 01 c0             	add    %rax,%rax
  80042122d4:	48 01 d0             	add    %rdx,%rax
  80042122d7:	48 c1 e0 03          	shl    $0x3,%rax
  80042122db:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042122df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042122e3:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042122e7:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  80042122eb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122ef:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122f3:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122f7:	48 89 d0             	mov    %rdx,%rax
  80042122fa:	48 01 c0             	add    %rax,%rax
  80042122fd:	48 01 d0             	add    %rdx,%rax
  8004212300:	48 c1 e0 03          	shl    $0x3,%rax
  8004212304:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004212308:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421230c:	48 89 c7             	mov    %rax,%rdi
  800421230f:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212316:	00 00 00 
  8004212319:	ff d0                	callq  *%rax
  800421231b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212322:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  8004212326:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  800421232a:	e9 85 00 00 00       	jmpq   80042123b4 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  800421232f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212333:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212337:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800421233a:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421233e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212342:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212346:	66 39 c2             	cmp    %ax,%dx
  8004212349:	72 0c                	jb     8004212357 <_dwarf_frame_run_inst+0x212>
  800421234b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212352:	e9 bd 0b 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  8004212357:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421235b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421235f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212363:	48 89 d0             	mov    %rdx,%rax
  8004212366:	48 01 c0             	add    %rax,%rax
  8004212369:	48 01 d0             	add    %rdx,%rax
  800421236c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212370:	48 01 c1             	add    %rax,%rcx
  8004212373:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212377:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421237b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421237f:	48 89 d0             	mov    %rdx,%rax
  8004212382:	48 01 c0             	add    %rax,%rax
  8004212385:	48 01 d0             	add    %rdx,%rax
  8004212388:	48 c1 e0 03          	shl    $0x3,%rax
  800421238c:	48 01 f0             	add    %rsi,%rax
  800421238f:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212394:	48 89 ce             	mov    %rcx,%rsi
  8004212397:	48 89 c7             	mov    %rax,%rdi
  800421239a:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  80042123a1:	00 00 00 
  80042123a4:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  80042123a6:	eb 0c                	jmp    80042123b4 <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042123a8:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  80042123af:	e9 60 0b 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  80042123b4:	e9 4d 0b 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  80042123b9:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042123bd:	83 f8 16             	cmp    $0x16,%eax
  80042123c0:	0f 87 37 0b 00 00    	ja     8004212efd <_dwarf_frame_run_inst+0xdb8>
  80042123c6:	89 c0                	mov    %eax,%eax
  80042123c8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042123cf:	00 
  80042123d0:	48 b8 c0 a8 21 04 80 	movabs $0x800421a8c0,%rax
  80042123d7:	00 00 00 
  80042123da:	48 01 d0             	add    %rdx,%rax
  80042123dd:	48 8b 00             	mov    (%rax),%rax
  80042123e0:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  80042123e2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042123e6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042123ea:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042123ee:	8b 4a 28             	mov    0x28(%rdx),%ecx
  80042123f1:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042123f5:	89 ce                	mov    %ecx,%esi
  80042123f7:	48 89 d7             	mov    %rdx,%rdi
  80042123fa:	ff d0                	callq  *%rax
  80042123fc:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212400:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212404:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212408:	73 05                	jae    800421240f <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  800421240a:	e9 05 0b 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			break;
  800421240f:	e9 f2 0a 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  8004212414:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212418:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421241c:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212420:	be 01 00 00 00       	mov    $0x1,%esi
  8004212425:	48 89 d7             	mov    %rdx,%rdi
  8004212428:	ff d0                	callq  *%rax
  800421242a:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212431:	ff 
  8004212432:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212436:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421243a:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421243e:	73 05                	jae    8004212445 <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  8004212440:	e9 cf 0a 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212445:	e9 bc 0a 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  800421244a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421244e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212452:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212456:	be 02 00 00 00       	mov    $0x2,%esi
  800421245b:	48 89 d7             	mov    %rdx,%rdi
  800421245e:	ff d0                	callq  *%rax
  8004212460:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212467:	ff 
  8004212468:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800421246c:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212470:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212474:	73 05                	jae    800421247b <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  8004212476:	e9 99 0a 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			break;
  800421247b:	e9 86 0a 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004212480:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212484:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212488:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421248c:	be 04 00 00 00       	mov    $0x4,%esi
  8004212491:	48 89 d7             	mov    %rdx,%rdi
  8004212494:	ff d0                	callq  *%rax
  8004212496:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421249d:	ff 
  800421249e:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042124a2:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042124a6:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042124aa:	73 05                	jae    80042124b1 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  80042124ac:	e9 63 0a 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			break;
  80042124b1:	e9 50 0a 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  80042124b6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042124ba:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042124be:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042124c1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042124c5:	48 89 c7             	mov    %rax,%rdi
  80042124c8:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042124cf:	00 00 00 
  80042124d2:	ff d0                	callq  *%rax
  80042124d4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042124d8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042124dc:	48 89 c7             	mov    %rax,%rdi
  80042124df:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042124e6:	00 00 00 
  80042124e9:	ff d0                	callq  *%rax
  80042124eb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042124ef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124f3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042124f7:	0f b7 c0             	movzwl %ax,%eax
  80042124fa:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042124fe:	77 0c                	ja     800421250c <_dwarf_frame_run_inst+0x3c7>
  8004212500:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212507:	e9 08 0a 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800421250c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212510:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212514:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212518:	48 89 d0             	mov    %rdx,%rax
  800421251b:	48 01 c0             	add    %rax,%rax
  800421251e:	48 01 d0             	add    %rdx,%rax
  8004212521:	48 c1 e0 03          	shl    $0x3,%rax
  8004212525:	48 01 c8             	add    %rcx,%rax
  8004212528:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421252b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421252f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212533:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212537:	48 89 d0             	mov    %rdx,%rax
  800421253a:	48 01 c0             	add    %rax,%rax
  800421253d:	48 01 d0             	add    %rdx,%rax
  8004212540:	48 c1 e0 03          	shl    $0x3,%rax
  8004212544:	48 01 c8             	add    %rcx,%rax
  8004212547:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421254b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421254f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212553:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212557:	48 89 d0             	mov    %rdx,%rax
  800421255a:	48 01 c0             	add    %rax,%rax
  800421255d:	48 01 d0             	add    %rdx,%rax
  8004212560:	48 c1 e0 03          	shl    $0x3,%rax
  8004212564:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212568:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421256c:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212570:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212574:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212578:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421257c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212580:	48 89 d0             	mov    %rdx,%rax
  8004212583:	48 01 c0             	add    %rax,%rax
  8004212586:	48 01 d0             	add    %rdx,%rax
  8004212589:	48 c1 e0 03          	shl    $0x3,%rax
  800421258d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212591:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212598:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800421259d:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  80042125a1:	e9 60 09 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  80042125a6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042125aa:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042125ae:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042125b1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042125b5:	48 89 c7             	mov    %rax,%rdi
  80042125b8:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042125bf:	00 00 00 
  80042125c2:	ff d0                	callq  *%rax
  80042125c4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042125c8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125cc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042125d0:	0f b7 c0             	movzwl %ax,%eax
  80042125d3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042125d7:	77 0c                	ja     80042125e5 <_dwarf_frame_run_inst+0x4a0>
  80042125d9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042125e0:	e9 2f 09 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  80042125e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042125e9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125ed:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042125f1:	48 89 d0             	mov    %rdx,%rax
  80042125f4:	48 01 c0             	add    %rax,%rax
  80042125f7:	48 01 d0             	add    %rdx,%rax
  80042125fa:	48 c1 e0 03          	shl    $0x3,%rax
  80042125fe:	48 01 c1             	add    %rax,%rcx
  8004212601:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212605:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212609:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421260d:	48 89 d0             	mov    %rdx,%rax
  8004212610:	48 01 c0             	add    %rax,%rax
  8004212613:	48 01 d0             	add    %rdx,%rax
  8004212616:	48 c1 e0 03          	shl    $0x3,%rax
  800421261a:	48 01 f0             	add    %rsi,%rax
  800421261d:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212622:	48 89 ce             	mov    %rcx,%rsi
  8004212625:	48 89 c7             	mov    %rax,%rdi
  8004212628:	48 b8 f7 fb 20 04 80 	movabs $0x800420fbf7,%rax
  800421262f:	00 00 00 
  8004212632:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004212634:	e9 cd 08 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  8004212639:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421263d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212641:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212644:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212648:	48 89 c7             	mov    %rax,%rdi
  800421264b:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212652:	00 00 00 
  8004212655:	ff d0                	callq  *%rax
  8004212657:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421265b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421265f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212663:	0f b7 c0             	movzwl %ax,%eax
  8004212666:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421266a:	77 0c                	ja     8004212678 <_dwarf_frame_run_inst+0x533>
  800421266c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212673:	e9 9c 08 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004212678:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421267c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212680:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212684:	48 89 d0             	mov    %rdx,%rax
  8004212687:	48 01 c0             	add    %rax,%rax
  800421268a:	48 01 d0             	add    %rdx,%rax
  800421268d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212691:	48 01 c8             	add    %rcx,%rax
  8004212694:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004212697:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421269b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421269f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126a3:	48 89 d0             	mov    %rdx,%rax
  80042126a6:	48 01 c0             	add    %rax,%rax
  80042126a9:	48 01 d0             	add    %rdx,%rax
  80042126ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042126b0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042126b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042126b8:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80042126bc:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042126c0:	e9 41 08 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  80042126c5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042126c9:	48 89 c7             	mov    %rax,%rdi
  80042126cc:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042126d3:	00 00 00 
  80042126d6:	ff d0                	callq  *%rax
  80042126d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042126dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126e0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042126e4:	0f b7 c0             	movzwl %ax,%eax
  80042126e7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042126eb:	77 0c                	ja     80042126f9 <_dwarf_frame_run_inst+0x5b4>
  80042126ed:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042126f4:	e9 1b 08 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042126f9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126fd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212701:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212705:	48 89 d0             	mov    %rdx,%rax
  8004212708:	48 01 c0             	add    %rax,%rax
  800421270b:	48 01 d0             	add    %rdx,%rax
  800421270e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212712:	48 01 c8             	add    %rcx,%rax
  8004212715:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004212718:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421271c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212720:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212724:	48 89 d0             	mov    %rdx,%rax
  8004212727:	48 01 c0             	add    %rax,%rax
  800421272a:	48 01 d0             	add    %rdx,%rax
  800421272d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212731:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212735:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212739:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800421273d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004212741:	e9 c0 07 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  8004212746:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421274a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421274e:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212751:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212755:	48 89 c7             	mov    %rax,%rdi
  8004212758:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  800421275f:	00 00 00 
  8004212762:	ff d0                	callq  *%rax
  8004212764:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  8004212768:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421276c:	48 89 c7             	mov    %rax,%rdi
  800421276f:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212776:	00 00 00 
  8004212779:	ff d0                	callq  *%rax
  800421277b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421277f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212783:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212787:	0f b7 c0             	movzwl %ax,%eax
  800421278a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421278e:	77 0c                	ja     800421279c <_dwarf_frame_run_inst+0x657>
  8004212790:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212797:	e9 78 07 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421279c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127a0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127a4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127a8:	48 89 d0             	mov    %rdx,%rax
  80042127ab:	48 01 c0             	add    %rax,%rax
  80042127ae:	48 01 d0             	add    %rdx,%rax
  80042127b1:	48 c1 e0 03          	shl    $0x3,%rax
  80042127b5:	48 01 c8             	add    %rcx,%rax
  80042127b8:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  80042127bb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127bf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127c3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127c7:	48 89 d0             	mov    %rdx,%rax
  80042127ca:	48 01 c0             	add    %rax,%rax
  80042127cd:	48 01 d0             	add    %rdx,%rax
  80042127d0:	48 c1 e0 03          	shl    $0x3,%rax
  80042127d4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042127d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042127dc:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042127e0:	e9 21 07 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  80042127e5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042127e9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042127ed:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80042127f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042127f5:	48 89 c7             	mov    %rax,%rdi
  80042127f8:	48 b8 74 1f 21 04 80 	movabs $0x8004211f74,%rax
  80042127ff:	00 00 00 
  8004212802:	ff d0                	callq  *%rax
			break;
  8004212804:	e9 fd 06 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004212809:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421280d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212811:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004212814:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212818:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421281c:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004212820:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212824:	48 89 c7             	mov    %rax,%rdi
  8004212827:	48 b8 74 1f 21 04 80 	movabs $0x8004211f74,%rax
  800421282e:	00 00 00 
  8004212831:	ff d0                	callq  *%rax
			break;
  8004212833:	e9 ce 06 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004212838:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421283c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212840:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212843:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212847:	48 89 c7             	mov    %rax,%rdi
  800421284a:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212851:	00 00 00 
  8004212854:	ff d0                	callq  *%rax
  8004212856:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800421285a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421285e:	48 89 c7             	mov    %rax,%rdi
  8004212861:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212868:	00 00 00 
  800421286b:	ff d0                	callq  *%rax
  800421286d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212871:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212875:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212878:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421287c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004212880:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212884:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212888:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800421288c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212890:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212894:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212898:	e9 69 06 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  800421289d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042128a1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042128a5:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042128a8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128ac:	48 89 c7             	mov    %rax,%rdi
  80042128af:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042128b6:	00 00 00 
  80042128b9:	ff d0                	callq  *%rax
  80042128bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  80042128bf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128c3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128c7:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  80042128cb:	e9 36 06 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  80042128d0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042128d4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042128d8:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  80042128db:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128df:	48 89 c7             	mov    %rax,%rdi
  80042128e2:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042128e9:	00 00 00 
  80042128ec:	ff d0                	callq  *%rax
  80042128ee:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  80042128f2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128f6:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  80042128f9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128fd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004212901:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212905:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212909:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800421290d:	e9 f4 05 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004212912:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212916:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421291a:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  800421291d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212921:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004212924:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212928:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  800421292c:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004212930:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212934:	48 89 c7             	mov    %rax,%rdi
  8004212937:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  800421293e:	00 00 00 
  8004212941:	ff d0                	callq  *%rax
  8004212943:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004212947:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421294b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421294f:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004212953:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212957:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421295b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421295f:	48 01 d0             	add    %rdx,%rax
  8004212962:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212966:	e9 9b 05 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  800421296b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421296f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212973:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212976:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421297a:	48 89 c7             	mov    %rax,%rdi
  800421297d:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212984:	00 00 00 
  8004212987:	ff d0                	callq  *%rax
  8004212989:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421298d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212991:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212995:	0f b7 c0             	movzwl %ax,%eax
  8004212998:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421299c:	77 0c                	ja     80042129aa <_dwarf_frame_run_inst+0x865>
  800421299e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042129a5:	e9 6a 05 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042129aa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ae:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129b2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129b6:	48 89 d0             	mov    %rdx,%rax
  80042129b9:	48 01 c0             	add    %rax,%rax
  80042129bc:	48 01 d0             	add    %rdx,%rax
  80042129bf:	48 c1 e0 03          	shl    $0x3,%rax
  80042129c3:	48 01 c8             	add    %rcx,%rax
  80042129c6:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  80042129c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129cd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129d1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129d5:	48 89 d0             	mov    %rdx,%rax
  80042129d8:	48 01 c0             	add    %rax,%rax
  80042129db:	48 01 d0             	add    %rdx,%rax
  80042129de:	48 c1 e0 03          	shl    $0x3,%rax
  80042129e2:	48 01 c8             	add    %rcx,%rax
  80042129e5:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  80042129e9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ed:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129f1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129f5:	48 89 d0             	mov    %rdx,%rax
  80042129f8:	48 01 c0             	add    %rax,%rax
  80042129fb:	48 01 d0             	add    %rdx,%rax
  80042129fe:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a02:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212a06:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a0a:	48 89 c7             	mov    %rax,%rdi
  8004212a0d:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212a14:	00 00 00 
  8004212a17:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004212a19:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004212a1d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a21:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a25:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a29:	48 89 d0             	mov    %rdx,%rax
  8004212a2c:	48 01 c0             	add    %rax,%rax
  8004212a2f:	48 01 d0             	add    %rdx,%rax
  8004212a32:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a36:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212a3a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212a3e:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004212a42:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212a46:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a4a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212a4e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a52:	48 89 d0             	mov    %rdx,%rax
  8004212a55:	48 01 c0             	add    %rax,%rax
  8004212a58:	48 01 d0             	add    %rdx,%rax
  8004212a5b:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a5f:	48 01 f0             	add    %rsi,%rax
  8004212a62:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212a66:	48 01 c8             	add    %rcx,%rax
  8004212a69:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212a6d:	e9 94 04 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004212a72:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a76:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a7a:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212a7d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a81:	48 89 c7             	mov    %rax,%rdi
  8004212a84:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212a8b:	00 00 00 
  8004212a8e:	ff d0                	callq  *%rax
  8004212a90:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004212a94:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a98:	48 89 c7             	mov    %rax,%rdi
  8004212a9b:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  8004212aa2:	00 00 00 
  8004212aa5:	ff d0                	callq  *%rax
  8004212aa7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212aab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212aaf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212ab3:	0f b7 c0             	movzwl %ax,%eax
  8004212ab6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212aba:	77 0c                	ja     8004212ac8 <_dwarf_frame_run_inst+0x983>
  8004212abc:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212ac3:	e9 4c 04 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212ac8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212acc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ad0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ad4:	48 89 d0             	mov    %rdx,%rax
  8004212ad7:	48 01 c0             	add    %rax,%rax
  8004212ada:	48 01 d0             	add    %rdx,%rax
  8004212add:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ae1:	48 01 c8             	add    %rcx,%rax
  8004212ae4:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212ae7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212aeb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212aef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212af3:	48 89 d0             	mov    %rdx,%rax
  8004212af6:	48 01 c0             	add    %rax,%rax
  8004212af9:	48 01 d0             	add    %rdx,%rax
  8004212afc:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b00:	48 01 c8             	add    %rcx,%rax
  8004212b03:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212b07:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b0b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b0f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b13:	48 89 d0             	mov    %rdx,%rax
  8004212b16:	48 01 c0             	add    %rax,%rax
  8004212b19:	48 01 d0             	add    %rdx,%rax
  8004212b1c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b20:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b28:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212b2c:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004212b30:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b34:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b38:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b3c:	48 89 d0             	mov    %rdx,%rax
  8004212b3f:	48 01 c0             	add    %rax,%rax
  8004212b42:	48 01 d0             	add    %rdx,%rax
  8004212b45:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b49:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b4d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212b54:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212b59:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212b5d:	e9 a4 03 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004212b62:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b66:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b6a:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212b6d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b71:	48 89 c7             	mov    %rax,%rdi
  8004212b74:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212b7b:	00 00 00 
  8004212b7e:	ff d0                	callq  *%rax
  8004212b80:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004212b84:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b88:	48 89 c7             	mov    %rax,%rdi
  8004212b8b:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  8004212b92:	00 00 00 
  8004212b95:	ff d0                	callq  *%rax
  8004212b97:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212b9b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b9f:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212ba2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ba6:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004212baa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bb2:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004212bb6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bba:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212bc1:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212bc6:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212bca:	e9 37 03 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004212bcf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212bd3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212bd7:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004212bda:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212bde:	48 89 c7             	mov    %rax,%rdi
  8004212be1:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  8004212be8:	00 00 00 
  8004212beb:	ff d0                	callq  *%rax
  8004212bed:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212bf1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bf5:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212bf8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bfc:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004212c00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c04:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212c0b:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212c10:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212c14:	e9 ed 02 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004212c19:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c1d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c21:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212c24:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c28:	48 89 c7             	mov    %rax,%rdi
  8004212c2b:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212c32:	00 00 00 
  8004212c35:	ff d0                	callq  *%rax
  8004212c37:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004212c3b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c3f:	48 89 c7             	mov    %rax,%rdi
  8004212c42:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212c49:	00 00 00 
  8004212c4c:	ff d0                	callq  *%rax
  8004212c4e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212c52:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c56:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212c5a:	0f b7 c0             	movzwl %ax,%eax
  8004212c5d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212c61:	77 0c                	ja     8004212c6f <_dwarf_frame_run_inst+0xb2a>
  8004212c63:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212c6a:	e9 a5 02 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212c6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c73:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c77:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c7b:	48 89 d0             	mov    %rdx,%rax
  8004212c7e:	48 01 c0             	add    %rax,%rax
  8004212c81:	48 01 d0             	add    %rdx,%rax
  8004212c84:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c88:	48 01 c8             	add    %rcx,%rax
  8004212c8b:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212c8e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c92:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c96:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c9a:	48 89 d0             	mov    %rdx,%rax
  8004212c9d:	48 01 c0             	add    %rax,%rax
  8004212ca0:	48 01 d0             	add    %rdx,%rax
  8004212ca3:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ca7:	48 01 c8             	add    %rcx,%rax
  8004212caa:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212cae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cb2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cb6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cba:	48 89 d0             	mov    %rdx,%rax
  8004212cbd:	48 01 c0             	add    %rax,%rax
  8004212cc0:	48 01 d0             	add    %rdx,%rax
  8004212cc3:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cc7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212ccb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212ccf:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212cd3:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212cd7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cdb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cdf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ce3:	48 89 d0             	mov    %rdx,%rax
  8004212ce6:	48 01 c0             	add    %rax,%rax
  8004212ce9:	48 01 d0             	add    %rdx,%rax
  8004212cec:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cf0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212cf4:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212cfb:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212d00:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212d04:	e9 fd 01 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004212d09:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212d0d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212d11:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212d14:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d18:	48 89 c7             	mov    %rax,%rdi
  8004212d1b:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212d22:	00 00 00 
  8004212d25:	ff d0                	callq  *%rax
  8004212d27:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004212d2b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d2f:	48 89 c7             	mov    %rax,%rdi
  8004212d32:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  8004212d39:	00 00 00 
  8004212d3c:	ff d0                	callq  *%rax
  8004212d3e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212d42:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d46:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212d4a:	0f b7 c0             	movzwl %ax,%eax
  8004212d4d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212d51:	77 0c                	ja     8004212d5f <_dwarf_frame_run_inst+0xc1a>
  8004212d53:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212d5a:	e9 b5 01 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212d5f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d63:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d67:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d6b:	48 89 d0             	mov    %rdx,%rax
  8004212d6e:	48 01 c0             	add    %rax,%rax
  8004212d71:	48 01 d0             	add    %rdx,%rax
  8004212d74:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d78:	48 01 c8             	add    %rcx,%rax
  8004212d7b:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212d7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d82:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d86:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d8a:	48 89 d0             	mov    %rdx,%rax
  8004212d8d:	48 01 c0             	add    %rax,%rax
  8004212d90:	48 01 d0             	add    %rdx,%rax
  8004212d93:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d97:	48 01 c8             	add    %rcx,%rax
  8004212d9a:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212d9e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212da2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212da6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212daa:	48 89 d0             	mov    %rdx,%rax
  8004212dad:	48 01 c0             	add    %rax,%rax
  8004212db0:	48 01 d0             	add    %rdx,%rax
  8004212db3:	48 c1 e0 03          	shl    $0x3,%rax
  8004212db7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212dbb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212dbf:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212dc3:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004212dc7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212dcb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212dcf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212dd3:	48 89 d0             	mov    %rdx,%rax
  8004212dd6:	48 01 c0             	add    %rax,%rax
  8004212dd9:	48 01 d0             	add    %rdx,%rax
  8004212ddc:	48 c1 e0 03          	shl    $0x3,%rax
  8004212de0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212de4:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212deb:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212df0:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212df4:	e9 0d 01 00 00       	jmpq   8004212f06 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004212df9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212dfd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212e01:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212e04:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e08:	48 89 c7             	mov    %rax,%rdi
  8004212e0b:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212e12:	00 00 00 
  8004212e15:	ff d0                	callq  *%rax
  8004212e17:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212e1b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e1f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212e23:	0f b7 c0             	movzwl %ax,%eax
  8004212e26:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212e2a:	77 0c                	ja     8004212e38 <_dwarf_frame_run_inst+0xcf3>
  8004212e2c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212e33:	e9 dc 00 00 00       	jmpq   8004212f14 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004212e38:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e3c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e40:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e44:	48 89 d0             	mov    %rdx,%rax
  8004212e47:	48 01 c0             	add    %rax,%rax
  8004212e4a:	48 01 d0             	add    %rdx,%rax
  8004212e4d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e51:	48 01 c8             	add    %rcx,%rax
  8004212e54:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004212e57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e5b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e5f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e63:	48 89 d0             	mov    %rdx,%rax
  8004212e66:	48 01 c0             	add    %rax,%rax
  8004212e69:	48 01 d0             	add    %rdx,%rax
  8004212e6c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e70:	48 01 c8             	add    %rcx,%rax
  8004212e73:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004212e77:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e7b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e7f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e83:	48 89 d0             	mov    %rdx,%rax
  8004212e86:	48 01 c0             	add    %rax,%rax
  8004212e89:	48 01 d0             	add    %rdx,%rax
  8004212e8c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e90:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212e94:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e98:	48 89 c7             	mov    %rax,%rdi
  8004212e9b:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004212ea2:	00 00 00 
  8004212ea5:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004212ea7:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004212eab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212eaf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212eb3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212eb7:	48 89 d0             	mov    %rdx,%rax
  8004212eba:	48 01 c0             	add    %rax,%rax
  8004212ebd:	48 01 d0             	add    %rdx,%rax
  8004212ec0:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ec4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212ec8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212ecc:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004212ed0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212ed4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ed8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212edc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ee0:	48 89 d0             	mov    %rdx,%rax
  8004212ee3:	48 01 c0             	add    %rax,%rax
  8004212ee6:	48 01 d0             	add    %rdx,%rax
  8004212ee9:	48 c1 e0 03          	shl    $0x3,%rax
  8004212eed:	48 01 f0             	add    %rsi,%rax
  8004212ef0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212ef4:	48 01 c8             	add    %rcx,%rax
  8004212ef7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212efb:	eb 09                	jmp    8004212f06 <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212efd:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004212f04:	eb 0e                	jmp    8004212f14 <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004212f06:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212f0a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212f0e:	0f 82 b8 f2 ff ff    	jb     80042121cc <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  8004212f14:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212f17:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212f1e:	5b                   	pop    %rbx
  8004212f1f:	5d                   	pop    %rbp
  8004212f20:	c3                   	retq   

0000008004212f21 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004212f21:	55                   	push   %rbp
  8004212f22:	48 89 e5             	mov    %rsp,%rbp
  8004212f25:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212f29:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212f2d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212f31:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212f35:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212f39:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212f3d:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  8004212f41:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212f46:	75 35                	jne    8004212f7d <_dwarf_frame_get_internal_table+0x5c>
  8004212f48:	48 b9 78 a9 21 04 80 	movabs $0x800421a978,%rcx
  8004212f4f:	00 00 00 
  8004212f52:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  8004212f59:	00 00 00 
  8004212f5c:	be 83 01 00 00       	mov    $0x183,%esi
  8004212f61:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  8004212f68:	00 00 00 
  8004212f6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f70:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004212f77:	00 00 00 
  8004212f7a:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  8004212f7d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212f82:	75 35                	jne    8004212fb9 <_dwarf_frame_get_internal_table+0x98>
  8004212f84:	48 b9 87 a9 21 04 80 	movabs $0x800421a987,%rcx
  8004212f8b:	00 00 00 
  8004212f8e:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  8004212f95:	00 00 00 
  8004212f98:	be 86 01 00 00       	mov    $0x186,%esi
  8004212f9d:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  8004212fa4:	00 00 00 
  8004212fa7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fac:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004212fb3:	00 00 00 
  8004212fb6:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004212fb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fbd:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212fc1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004212fc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212fc9:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212fce:	be 00 00 00 00       	mov    $0x0,%esi
  8004212fd3:	48 89 c7             	mov    %rax,%rdi
  8004212fd6:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004212fdd:	00 00 00 
  8004212fe0:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004212fe2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212fe6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212fea:	0f b7 d0             	movzwl %ax,%edx
  8004212fed:	48 89 d0             	mov    %rdx,%rax
  8004212ff0:	48 01 c0             	add    %rax,%rax
  8004212ff3:	48 01 d0             	add    %rdx,%rax
  8004212ff6:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ffa:	48 89 c2             	mov    %rax,%rdx
  8004212ffd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213001:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213005:	be 00 00 00 00       	mov    $0x0,%esi
  800421300a:	48 89 c7             	mov    %rax,%rdi
  800421300d:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004213014:	00 00 00 
  8004213017:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213019:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213020:	eb 2f                	jmp    8004213051 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004213022:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213026:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421302a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421302d:	48 63 d0             	movslq %eax,%rdx
  8004213030:	48 89 d0             	mov    %rdx,%rax
  8004213033:	48 01 c0             	add    %rax,%rax
  8004213036:	48 01 d0             	add    %rdx,%rax
  8004213039:	48 c1 e0 03          	shl    $0x3,%rax
  800421303d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213041:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213045:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004213049:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800421304d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004213051:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213055:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213059:	0f b7 c0             	movzwl %ax,%eax
  800421305c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421305f:	7f c1                	jg     8004213022 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  8004213061:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213065:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213069:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  800421306d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213072:	75 35                	jne    80042130a9 <_dwarf_frame_get_internal_table+0x188>
  8004213074:	48 b9 93 a9 21 04 80 	movabs $0x800421a993,%rcx
  800421307b:	00 00 00 
  800421307e:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  8004213085:	00 00 00 
  8004213088:	be 95 01 00 00       	mov    $0x195,%esi
  800421308d:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  8004213094:	00 00 00 
  8004213097:	b8 00 00 00 00       	mov    $0x0,%eax
  800421309c:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042130a3:	00 00 00 
  80042130a6:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  80042130a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130ad:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042130b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130b5:	4c 8b 40 38          	mov    0x38(%rax),%r8
  80042130b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130bd:	48 8b 48 70          	mov    0x70(%rax),%rcx
  80042130c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130c5:	48 8b 50 68          	mov    0x68(%rax),%rdx
  80042130c9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042130cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130d1:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  80042130d5:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  80042130da:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  80042130de:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042130e3:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  80042130ea:	ff ff 
  80042130ec:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80042130f3:	00 
  80042130f4:	48 89 c7             	mov    %rax,%rdi
  80042130f7:	48 b8 45 21 21 04 80 	movabs $0x8004212145,%rax
  80042130fe:	00 00 00 
  8004213101:	ff d0                	callq  *%rax
  8004213103:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  8004213106:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421310a:	74 08                	je     8004213114 <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  800421310c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421310f:	e9 98 00 00 00       	jmpq   80042131ac <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  8004213114:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213118:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421311c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004213120:	77 6f                	ja     8004213191 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213122:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213126:	48 8b 78 30          	mov    0x30(%rax),%rdi
  800421312a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421312e:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004213132:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213136:	4c 8b 50 38          	mov    0x38(%rax),%r10
  800421313a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421313e:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004213142:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213146:	48 8b 50 50          	mov    0x50(%rax),%rdx
  800421314a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421314e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213152:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004213156:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800421315b:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  800421315f:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004213164:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004213168:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800421316d:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213171:	4d 89 d0             	mov    %r10,%r8
  8004213174:	48 89 c7             	mov    %rax,%rdi
  8004213177:	48 b8 45 21 21 04 80 	movabs $0x8004212145,%rax
  800421317e:	00 00 00 
  8004213181:	ff d0                	callq  *%rax
  8004213183:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  8004213186:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421318a:	74 05                	je     8004213191 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  800421318c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421318f:	eb 1b                	jmp    80042131ac <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  8004213191:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213195:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213199:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  800421319c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042131a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042131a4:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042131a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042131ac:	c9                   	leaveq 
  80042131ad:	c3                   	retq   

00000080042131ae <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042131ae:	55                   	push   %rbp
  80042131af:	48 89 e5             	mov    %rsp,%rbp
  80042131b2:	48 83 ec 50          	sub    $0x50,%rsp
  80042131b6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042131ba:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042131be:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042131c2:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042131c6:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  80042131ca:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  80042131ce:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042131d3:	74 07                	je     80042131dc <dwarf_get_fde_info_for_all_regs+0x2e>
  80042131d5:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042131da:	75 0a                	jne    80042131e6 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  80042131dc:	b8 01 00 00 00       	mov    $0x1,%eax
  80042131e1:	e9 eb 02 00 00       	jmpq   80042134d1 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  80042131e6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042131eb:	75 35                	jne    8004213222 <dwarf_get_fde_info_for_all_regs+0x74>
  80042131ed:	48 b9 87 a9 21 04 80 	movabs $0x800421a987,%rcx
  80042131f4:	00 00 00 
  80042131f7:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  80042131fe:	00 00 00 
  8004213201:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004213206:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  800421320d:	00 00 00 
  8004213210:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213215:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421321c:	00 00 00 
  800421321f:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  8004213222:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213226:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421322a:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421322e:	77 19                	ja     8004213249 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004213230:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213234:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213238:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421323c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213240:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  8004213243:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213247:	77 0a                	ja     8004213253 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  8004213249:	b8 01 00 00 00       	mov    $0x1,%eax
  800421324e:	e9 7e 02 00 00       	jmpq   80042134d1 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004213253:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  8004213257:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800421325b:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800421325f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213263:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213267:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421326b:	4d 89 c1             	mov    %r8,%r9
  800421326e:	49 89 f8             	mov    %rdi,%r8
  8004213271:	48 89 c7             	mov    %rax,%rdi
  8004213274:	48 b8 21 2f 21 04 80 	movabs $0x8004212f21,%rax
  800421327b:	00 00 00 
  800421327e:	ff d0                	callq  *%rax
  8004213280:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  8004213283:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004213287:	74 0a                	je     8004213293 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  8004213289:	b8 01 00 00 00       	mov    $0x1,%eax
  800421328e:	e9 3e 02 00 00       	jmpq   80042134d1 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  8004213293:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213297:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421329b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  800421329f:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042132a4:	0f 87 b1 00 00 00    	ja     800421335b <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  80042132aa:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042132ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132b2:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  80042132b5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042132b9:	48 63 c9             	movslq %ecx,%rcx
  80042132bc:	48 83 c1 01          	add    $0x1,%rcx
  80042132c0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042132c4:	48 01 ca             	add    %rcx,%rdx
  80042132c7:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  80042132c9:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042132cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132d1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042132d5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042132d9:	48 63 c9             	movslq %ecx,%rcx
  80042132dc:	48 83 c1 01          	add    $0x1,%rcx
  80042132e0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042132e4:	48 01 ca             	add    %rcx,%rdx
  80042132e7:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  80042132ea:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042132ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132f2:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042132f6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042132fa:	48 63 c9             	movslq %ecx,%rcx
  80042132fd:	48 83 c1 01          	add    $0x1,%rcx
  8004213301:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213305:	48 01 ca             	add    %rcx,%rdx
  8004213308:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421330c:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213310:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213314:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213318:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421331c:	48 63 c9             	movslq %ecx,%rcx
  800421331f:	48 83 c1 01          	add    $0x1,%rcx
  8004213323:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213327:	48 01 ca             	add    %rcx,%rdx
  800421332a:	48 83 c2 08          	add    $0x8,%rdx
  800421332e:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004213331:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004213335:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213339:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421333d:	48 63 d2             	movslq %edx,%rdx
  8004213340:	48 83 c2 01          	add    $0x1,%rdx
  8004213344:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213348:	48 01 d0             	add    %rdx,%rax
  800421334b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421334f:	48 8b 00             	mov    (%rax),%rax
  8004213352:	48 89 01             	mov    %rax,(%rcx)
  8004213355:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  8004213359:	eb 3c                	jmp    8004213397 <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  800421335b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421335f:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  8004213362:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213366:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  8004213368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421336c:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004213370:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213374:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  8004213377:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421337b:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  800421337f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213383:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  8004213387:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421338b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421338f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213393:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213397:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421339e:	e9 fd 00 00 00       	jmpq   80042134a0 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  80042133a3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042133a7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042133aa:	75 05                	jne    80042133b1 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  80042133ac:	e9 eb 00 00 00       	jmpq   800421349c <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042133b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133b5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042133bc:	48 63 d0             	movslq %eax,%rdx
  80042133bf:	48 89 d0             	mov    %rdx,%rax
  80042133c2:	48 01 c0             	add    %rax,%rax
  80042133c5:	48 01 d0             	add    %rdx,%rax
  80042133c8:	48 c1 e0 03          	shl    $0x3,%rax
  80042133cc:	48 01 c8             	add    %rcx,%rax
  80042133cf:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  80042133d2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042133d6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042133d9:	48 63 c9             	movslq %ecx,%rcx
  80042133dc:	48 83 c1 01          	add    $0x1,%rcx
  80042133e0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042133e4:	48 01 ca             	add    %rcx,%rdx
  80042133e7:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  80042133e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133ed:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133f1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042133f4:	48 63 d0             	movslq %eax,%rdx
  80042133f7:	48 89 d0             	mov    %rdx,%rax
  80042133fa:	48 01 c0             	add    %rax,%rax
  80042133fd:	48 01 d0             	add    %rdx,%rax
  8004213400:	48 c1 e0 03          	shl    $0x3,%rax
  8004213404:	48 01 c8             	add    %rcx,%rax
  8004213407:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  800421340b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421340f:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213412:	48 63 c9             	movslq %ecx,%rcx
  8004213415:	48 83 c1 01          	add    $0x1,%rcx
  8004213419:	48 c1 e1 04          	shl    $0x4,%rcx
  800421341d:	48 01 ca             	add    %rcx,%rdx
  8004213420:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213423:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213427:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421342b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421342e:	48 63 d0             	movslq %eax,%rdx
  8004213431:	48 89 d0             	mov    %rdx,%rax
  8004213434:	48 01 c0             	add    %rax,%rax
  8004213437:	48 01 d0             	add    %rdx,%rax
  800421343a:	48 c1 e0 03          	shl    $0x3,%rax
  800421343e:	48 01 c8             	add    %rcx,%rax
  8004213441:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213445:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213449:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421344c:	48 63 c9             	movslq %ecx,%rcx
  800421344f:	48 83 c1 01          	add    $0x1,%rcx
  8004213453:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213457:	48 01 ca             	add    %rcx,%rdx
  800421345a:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  800421345e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213462:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213466:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213469:	48 63 d0             	movslq %eax,%rdx
  800421346c:	48 89 d0             	mov    %rdx,%rax
  800421346f:	48 01 c0             	add    %rax,%rax
  8004213472:	48 01 d0             	add    %rdx,%rax
  8004213475:	48 c1 e0 03          	shl    $0x3,%rax
  8004213479:	48 01 c8             	add    %rcx,%rax
  800421347c:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004213480:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213484:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213487:	48 63 c9             	movslq %ecx,%rcx
  800421348a:	48 83 c1 01          	add    $0x1,%rcx
  800421348e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213492:	48 01 ca             	add    %rcx,%rdx
  8004213495:	48 83 c2 08          	add    $0x8,%rdx
  8004213499:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  800421349c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042134a0:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042134a4:	7f 14                	jg     80042134ba <dwarf_get_fde_info_for_all_regs+0x30c>
  80042134a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042134aa:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042134ae:	0f b7 c0             	movzwl %ax,%eax
  80042134b1:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042134b4:	0f 8f e9 fe ff ff    	jg     80042133a3 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  80042134ba:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042134bf:	74 0b                	je     80042134cc <dwarf_get_fde_info_for_all_regs+0x31e>
  80042134c1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134c5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042134c9:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  80042134cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042134d1:	c9                   	leaveq 
  80042134d2:	c3                   	retq   

00000080042134d3 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042134d3:	55                   	push   %rbp
  80042134d4:	48 89 e5             	mov    %rsp,%rbp
  80042134d7:	48 83 ec 40          	sub    $0x40,%rsp
  80042134db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042134df:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042134e3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042134e7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042134eb:	44 89 c0             	mov    %r8d,%eax
  80042134ee:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  80042134f2:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  80042134f5:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  80042134f9:	75 0a                	jne    8004213505 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  80042134fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213500:	e9 e6 01 00 00       	jmpq   80042136eb <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213505:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213509:	83 e0 f0             	and    $0xfffffff0,%eax
  800421350c:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421350f:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213513:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213517:	83 f8 0c             	cmp    $0xc,%eax
  800421351a:	0f 87 72 01 00 00    	ja     8004213692 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004213520:	89 c0                	mov    %eax,%eax
  8004213522:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213529:	00 
  800421352a:	48 b8 a0 a9 21 04 80 	movabs $0x800421a9a0,%rax
  8004213531:	00 00 00 
  8004213534:	48 01 d0             	add    %rdx,%rax
  8004213537:	48 8b 00             	mov    (%rax),%rax
  800421353a:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800421353c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213540:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213544:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213548:	8b 52 28             	mov    0x28(%rdx),%edx
  800421354b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421354f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213553:	48 89 cf             	mov    %rcx,%rdi
  8004213556:	ff d0                	callq  *%rax
  8004213558:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421355c:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421355f:	e9 35 01 00 00       	jmpq   8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004213564:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213568:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421356c:	48 89 d6             	mov    %rdx,%rsi
  800421356f:	48 89 c7             	mov    %rax,%rdi
  8004213572:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004213579:	00 00 00 
  800421357c:	ff d0                	callq  *%rax
  800421357e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213582:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213585:	e9 0f 01 00 00       	jmpq   8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  800421358a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421358e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213592:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213596:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421359a:	ba 02 00 00 00       	mov    $0x2,%edx
  800421359f:	48 89 cf             	mov    %rcx,%rdi
  80042135a2:	ff d0                	callq  *%rax
  80042135a4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135a8:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135ab:	e9 e9 00 00 00       	jmpq   8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042135b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135b4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135b8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042135bc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042135c0:	ba 04 00 00 00       	mov    $0x4,%edx
  80042135c5:	48 89 cf             	mov    %rcx,%rdi
  80042135c8:	ff d0                	callq  *%rax
  80042135ca:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135ce:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135d1:	e9 c3 00 00 00       	jmpq   8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  80042135d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135da:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135de:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042135e2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042135e6:	ba 08 00 00 00       	mov    $0x8,%edx
  80042135eb:	48 89 cf             	mov    %rcx,%rdi
  80042135ee:	ff d0                	callq  *%rax
  80042135f0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135f4:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135f7:	e9 9d 00 00 00       	jmpq   8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  80042135fc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213600:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213604:	48 89 d6             	mov    %rdx,%rsi
  8004213607:	48 89 c7             	mov    %rax,%rdi
  800421360a:	48 b8 c3 04 21 04 80 	movabs $0x80042104c3,%rax
  8004213611:	00 00 00 
  8004213614:	ff d0                	callq  *%rax
  8004213616:	48 89 c2             	mov    %rax,%rdx
  8004213619:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421361d:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213620:	eb 77                	jmp    8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004213622:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213626:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421362a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421362e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213632:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213637:	48 89 cf             	mov    %rcx,%rdi
  800421363a:	ff d0                	callq  *%rax
  800421363c:	48 0f bf d0          	movswq %ax,%rdx
  8004213640:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213644:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213647:	eb 50                	jmp    8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004213649:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421364d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213651:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213655:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213659:	ba 04 00 00 00       	mov    $0x4,%edx
  800421365e:	48 89 cf             	mov    %rcx,%rdi
  8004213661:	ff d0                	callq  *%rax
  8004213663:	48 63 d0             	movslq %eax,%rdx
  8004213666:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421366a:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421366d:	eb 2a                	jmp    8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  800421366f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213673:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213677:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421367b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421367f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213684:	48 89 cf             	mov    %rcx,%rdi
  8004213687:	ff d0                	callq  *%rax
  8004213689:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421368d:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213690:	eb 07                	jmp    8004213699 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004213692:	b8 14 00 00 00       	mov    $0x14,%eax
  8004213697:	eb 52                	jmp    80042136eb <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  8004213699:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  800421369d:	75 47                	jne    80042136e6 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  800421369f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042136a3:	83 f8 01             	cmp    $0x1,%eax
  80042136a6:	7c 3d                	jl     80042136e5 <_dwarf_frame_read_lsb_encoded+0x212>
  80042136a8:	83 f8 04             	cmp    $0x4,%eax
  80042136ab:	7e 0a                	jle    80042136b7 <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042136ad:	83 e8 09             	sub    $0x9,%eax
  80042136b0:	83 f8 03             	cmp    $0x3,%eax
  80042136b3:	77 30                	ja     80042136e5 <_dwarf_frame_read_lsb_encoded+0x212>
  80042136b5:	eb 17                	jmp    80042136ce <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  80042136b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136bb:	48 8b 10             	mov    (%rax),%rdx
  80042136be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042136c2:	48 01 c2             	add    %rax,%rdx
  80042136c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136c9:	48 89 10             	mov    %rdx,(%rax)
			break;
  80042136cc:	eb 18                	jmp    80042136e6 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  80042136ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136d2:	48 8b 10             	mov    (%rax),%rdx
  80042136d5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042136d9:	48 01 c2             	add    %rax,%rdx
  80042136dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136e0:	48 89 10             	mov    %rdx,(%rax)
			break;
  80042136e3:	eb 01                	jmp    80042136e6 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  80042136e5:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  80042136e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042136eb:	c9                   	leaveq 
  80042136ec:	c3                   	retq   

00000080042136ed <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  80042136ed:	55                   	push   %rbp
  80042136ee:	48 89 e5             	mov    %rsp,%rbp
  80042136f1:	48 83 ec 50          	sub    $0x50,%rsp
  80042136f5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042136f9:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042136fd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004213701:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213705:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213709:	48 85 c0             	test   %rax,%rax
  800421370c:	74 0f                	je     800421371d <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421370e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213712:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213716:	0f b6 00             	movzbl (%rax),%eax
  8004213719:	3c 7a                	cmp    $0x7a,%al
  800421371b:	74 35                	je     8004213752 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800421371d:	48 b9 08 aa 21 04 80 	movabs $0x800421aa08,%rcx
  8004213724:	00 00 00 
  8004213727:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  800421372e:	00 00 00 
  8004213731:	be 4a 02 00 00       	mov    $0x24a,%esi
  8004213736:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  800421373d:	00 00 00 
  8004213740:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213745:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421374c:	00 00 00 
  800421374f:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004213752:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213756:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421375a:	48 83 c0 01          	add    $0x1,%rax
  800421375e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004213762:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213766:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421376a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  800421376e:	e9 af 00 00 00       	jmpq   8004213822 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  8004213773:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213777:	0f b6 00             	movzbl (%rax),%eax
  800421377a:	0f b6 c0             	movzbl %al,%eax
  800421377d:	83 f8 50             	cmp    $0x50,%eax
  8004213780:	74 18                	je     800421379a <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004213782:	83 f8 52             	cmp    $0x52,%eax
  8004213785:	74 77                	je     80042137fe <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004213787:	83 f8 4c             	cmp    $0x4c,%eax
  800421378a:	0f 85 86 00 00 00    	jne    8004213816 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004213790:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004213795:	e9 83 00 00 00       	jmpq   800421381d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  800421379a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421379e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042137a2:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042137a6:	0f b6 00             	movzbl (%rax),%eax
  80042137a9:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042137ac:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042137b3:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042137b4:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  80042137b9:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042137bd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042137c1:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80042137c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042137c9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042137cd:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042137d1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042137d7:	48 89 c7             	mov    %rax,%rdi
  80042137da:	48 b8 d3 34 21 04 80 	movabs $0x80042134d3,%rax
  80042137e1:	00 00 00 
  80042137e4:	ff d0                	callq  *%rax
  80042137e6:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  80042137e9:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042137ed:	74 05                	je     80042137f4 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  80042137ef:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042137f2:	eb 42                	jmp    8004213836 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  80042137f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042137f8:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  80042137fc:	eb 1f                	jmp    800421381d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  80042137fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213802:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213806:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421380a:	0f b6 10             	movzbl (%rax),%edx
  800421380d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213811:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004213814:	eb 07                	jmp    800421381d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004213816:	b8 14 00 00 00       	mov    $0x14,%eax
  800421381b:	eb 19                	jmp    8004213836 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  800421381d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004213822:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213826:	0f b6 00             	movzbl (%rax),%eax
  8004213829:	84 c0                	test   %al,%al
  800421382b:	0f 85 42 ff ff ff    	jne    8004213773 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004213831:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213836:	c9                   	leaveq 
  8004213837:	c3                   	retq   

0000008004213838 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004213838:	55                   	push   %rbp
  8004213839:	48 89 e5             	mov    %rsp,%rbp
  800421383c:	48 83 ec 60          	sub    $0x60,%rsp
  8004213840:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213844:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213848:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421384c:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213850:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004213854:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004213859:	75 35                	jne    8004213890 <_dwarf_frame_set_cie+0x58>
  800421385b:	48 b9 3d aa 21 04 80 	movabs $0x800421aa3d,%rcx
  8004213862:	00 00 00 
  8004213865:	48 ba 87 a8 21 04 80 	movabs $0x800421a887,%rdx
  800421386c:	00 00 00 
  800421386f:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004213874:	48 bf 9c a8 21 04 80 	movabs $0x800421a89c,%rdi
  800421387b:	00 00 00 
  800421387e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213883:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421388a:	00 00 00 
  800421388d:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004213890:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213894:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004213898:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421389c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138a0:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  80042138a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138a7:	48 8b 10             	mov    (%rax),%rdx
  80042138aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138ae:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042138b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042138b6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042138ba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138be:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042138c2:	48 89 d1             	mov    %rdx,%rcx
  80042138c5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042138c9:	ba 04 00 00 00       	mov    $0x4,%edx
  80042138ce:	48 89 cf             	mov    %rcx,%rdi
  80042138d1:	ff d0                	callq  *%rax
  80042138d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042138d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042138dc:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042138e0:	75 2e                	jne    8004213910 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  80042138e2:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  80042138e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042138ed:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042138f1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138f5:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042138f9:	48 89 d1             	mov    %rdx,%rcx
  80042138fc:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213900:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213905:	48 89 cf             	mov    %rcx,%rdi
  8004213908:	ff d0                	callq  *%rax
  800421390a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421390e:	eb 07                	jmp    8004213917 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004213910:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213917:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421391b:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421391f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213923:	48 8b 00             	mov    (%rax),%rax
  8004213926:	48 29 c2             	sub    %rax,%rdx
  8004213929:	48 89 d0             	mov    %rdx,%rax
  800421392c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213930:	73 0a                	jae    800421393c <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213932:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213937:	e9 5d 03 00 00       	jmpq   8004213c99 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  800421393c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213940:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213944:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213948:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421394c:	48 89 d1             	mov    %rdx,%rcx
  800421394f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213952:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213956:	48 89 cf             	mov    %rcx,%rdi
  8004213959:	ff d0                	callq  *%rax
	cie->cie_length = length;
  800421395b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421395f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213963:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004213967:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421396b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421396f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213973:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213977:	48 89 d1             	mov    %rdx,%rcx
  800421397a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421397e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213983:	48 89 cf             	mov    %rcx,%rdi
  8004213986:	ff d0                	callq  *%rax
  8004213988:	89 c2                	mov    %eax,%edx
  800421398a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421398e:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004213992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213996:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421399a:	66 83 f8 01          	cmp    $0x1,%ax
  800421399e:	74 26                	je     80042139c6 <_dwarf_frame_set_cie+0x18e>
  80042139a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139a4:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042139a8:	66 83 f8 03          	cmp    $0x3,%ax
  80042139ac:	74 18                	je     80042139c6 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  80042139ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139b2:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042139b6:	66 83 f8 04          	cmp    $0x4,%ax
  80042139ba:	74 0a                	je     80042139c6 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  80042139bc:	b8 16 00 00 00       	mov    $0x16,%eax
  80042139c1:	e9 d3 02 00 00       	jmpq   8004213c99 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042139c6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042139ca:	48 8b 10             	mov    (%rax),%rdx
  80042139cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139d1:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042139d5:	48 01 d0             	add    %rdx,%rax
  80042139d8:	48 89 c2             	mov    %rax,%rdx
  80042139db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139df:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  80042139e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139e7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042139eb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  80042139ef:	90                   	nop
  80042139f0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042139f4:	48 8b 00             	mov    (%rax),%rax
  80042139f7:	48 8d 48 01          	lea    0x1(%rax),%rcx
  80042139fb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042139ff:	48 89 0a             	mov    %rcx,(%rdx)
  8004213a02:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213a06:	48 01 d0             	add    %rdx,%rax
  8004213a09:	0f b6 00             	movzbl (%rax),%eax
  8004213a0c:	84 c0                	test   %al,%al
  8004213a0e:	75 e0                	jne    80042139f0 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004213a10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a14:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a18:	0f b6 00             	movzbl (%rax),%eax
  8004213a1b:	84 c0                	test   %al,%al
  8004213a1d:	74 48                	je     8004213a67 <_dwarf_frame_set_cie+0x22f>
  8004213a1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a23:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a27:	0f b6 00             	movzbl (%rax),%eax
  8004213a2a:	3c 7a                	cmp    $0x7a,%al
  8004213a2c:	74 39                	je     8004213a67 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213a2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a32:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213a36:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213a3a:	75 07                	jne    8004213a43 <_dwarf_frame_set_cie+0x20b>
  8004213a3c:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213a41:	eb 05                	jmp    8004213a48 <_dwarf_frame_set_cie+0x210>
  8004213a43:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004213a48:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004213a4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a4f:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213a53:	48 01 c2             	add    %rax,%rdx
  8004213a56:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a5a:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004213a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a62:	e9 32 02 00 00       	jmpq   8004213c99 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004213a67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a6b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a6f:	48 be 45 aa 21 04 80 	movabs $0x800421aa45,%rsi
  8004213a76:	00 00 00 
  8004213a79:	48 89 c7             	mov    %rax,%rdi
  8004213a7c:	48 b8 7a fe 20 04 80 	movabs $0x800420fe7a,%rax
  8004213a83:	00 00 00 
  8004213a86:	ff d0                	callq  *%rax
  8004213a88:	48 85 c0             	test   %rax,%rax
  8004213a8b:	74 28                	je     8004213ab5 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213a8d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a91:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a95:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213a99:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213a9c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213aa0:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213aa4:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213aa8:	48 89 cf             	mov    %rcx,%rdi
  8004213aab:	ff d0                	callq  *%rax
  8004213aad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ab1:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213ab5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ab9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213abd:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213ac1:	48 89 d6             	mov    %rdx,%rsi
  8004213ac4:	48 89 c7             	mov    %rax,%rdi
  8004213ac7:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004213ace:	00 00 00 
  8004213ad1:	ff d0                	callq  *%rax
  8004213ad3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ad7:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213adb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213adf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213ae3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213ae7:	48 89 d6             	mov    %rdx,%rsi
  8004213aea:	48 89 c7             	mov    %rax,%rdi
  8004213aed:	48 b8 c3 04 21 04 80 	movabs $0x80042104c3,%rax
  8004213af4:	00 00 00 
  8004213af7:	ff d0                	callq  *%rax
  8004213af9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213afd:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004213b01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b05:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213b09:	66 83 f8 01          	cmp    $0x1,%ax
  8004213b0d:	75 2b                	jne    8004213b3a <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004213b0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b13:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b17:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213b1b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213b1f:	48 89 d1             	mov    %rdx,%rcx
  8004213b22:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213b26:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b2b:	48 89 cf             	mov    %rcx,%rdi
  8004213b2e:	ff d0                	callq  *%rax
  8004213b30:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b34:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004213b38:	eb 26                	jmp    8004213b60 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213b3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b3e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b42:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213b46:	48 89 d6             	mov    %rdx,%rsi
  8004213b49:	48 89 c7             	mov    %rax,%rdi
  8004213b4c:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004213b53:	00 00 00 
  8004213b56:	ff d0                	callq  *%rax
  8004213b58:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b5c:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004213b60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b64:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213b68:	0f b6 00             	movzbl (%rax),%eax
  8004213b6b:	3c 7a                	cmp    $0x7a,%al
  8004213b6d:	0f 85 93 00 00 00    	jne    8004213c06 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213b73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b77:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b7b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213b7f:	48 89 d6             	mov    %rdx,%rsi
  8004213b82:	48 89 c7             	mov    %rax,%rdi
  8004213b85:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004213b8c:	00 00 00 
  8004213b8f:	ff d0                	callq  *%rax
  8004213b91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b95:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213b99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b9d:	48 8b 10             	mov    (%rax),%rdx
  8004213ba0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ba4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213ba8:	48 01 d0             	add    %rdx,%rax
  8004213bab:	48 89 c2             	mov    %rax,%rdx
  8004213bae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bb2:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004213bb6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bba:	48 8b 10             	mov    (%rax),%rdx
  8004213bbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bc1:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213bc5:	48 01 c2             	add    %rax,%rdx
  8004213bc8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bcc:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004213bcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bd3:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004213bd7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213bdb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004213bdf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213be3:	48 89 ce             	mov    %rcx,%rsi
  8004213be6:	48 89 c7             	mov    %rax,%rdi
  8004213be9:	48 b8 ed 36 21 04 80 	movabs $0x80042136ed,%rax
  8004213bf0:	00 00 00 
  8004213bf3:	ff d0                	callq  *%rax
  8004213bf5:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213bf8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213bfc:	74 08                	je     8004213c06 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004213bfe:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213c01:	e9 93 00 00 00       	jmpq   8004213c99 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213c06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c0a:	48 8b 10             	mov    (%rax),%rdx
  8004213c0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c11:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213c15:	48 01 d0             	add    %rdx,%rax
  8004213c18:	48 89 c2             	mov    %rax,%rdx
  8004213c1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c1f:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213c23:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213c27:	75 2a                	jne    8004213c53 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213c29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c2d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213c35:	48 01 c2             	add    %rax,%rdx
  8004213c38:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c3c:	48 8b 00             	mov    (%rax),%rax
  8004213c3f:	48 29 c2             	sub    %rax,%rdx
  8004213c42:	48 89 d0             	mov    %rdx,%rax
  8004213c45:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213c49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c4d:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213c51:	eb 28                	jmp    8004213c7b <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213c53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c57:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213c5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213c5f:	48 01 c2             	add    %rax,%rdx
  8004213c62:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c66:	48 8b 00             	mov    (%rax),%rax
  8004213c69:	48 29 c2             	sub    %rax,%rdx
  8004213c6c:	48 89 d0             	mov    %rdx,%rax
  8004213c6f:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213c73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c77:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213c7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c7f:	48 8b 10             	mov    (%rax),%rdx
  8004213c82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c86:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213c8a:	48 01 c2             	add    %rax,%rdx
  8004213c8d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c91:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213c94:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213c99:	c9                   	leaveq 
  8004213c9a:	c3                   	retq   

0000008004213c9b <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213c9b:	55                   	push   %rbp
  8004213c9c:	48 89 e5             	mov    %rsp,%rbp
  8004213c9f:	48 83 ec 70          	sub    $0x70,%rsp
  8004213ca3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213ca7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213cab:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213caf:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213cb3:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004213cb7:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004213cbb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cbf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004213cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cc7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213ccb:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213cce:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213cd2:	48 8b 10             	mov    (%rax),%rdx
  8004213cd5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213cd9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213cdd:	48 01 d0             	add    %rdx,%rax
  8004213ce0:	48 89 c2             	mov    %rax,%rdx
  8004213ce3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ce7:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213ceb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213cef:	48 8b 10             	mov    (%rax),%rdx
  8004213cf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cf6:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213cfa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213cfe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d02:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d06:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213d0a:	48 89 d1             	mov    %rdx,%rcx
  8004213d0d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213d11:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213d16:	48 89 cf             	mov    %rcx,%rdi
  8004213d19:	ff d0                	callq  *%rax
  8004213d1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213d1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213d24:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213d28:	75 2e                	jne    8004213d58 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004213d2a:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213d31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d39:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d3d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213d41:	48 89 d1             	mov    %rdx,%rcx
  8004213d44:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213d48:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213d4d:	48 89 cf             	mov    %rcx,%rdi
  8004213d50:	ff d0                	callq  *%rax
  8004213d52:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213d56:	eb 07                	jmp    8004213d5f <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004213d58:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213d5f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d63:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213d67:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213d6b:	48 8b 00             	mov    (%rax),%rax
  8004213d6e:	48 29 c2             	sub    %rax,%rdx
  8004213d71:	48 89 d0             	mov    %rdx,%rax
  8004213d74:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213d78:	73 0a                	jae    8004213d84 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213d7a:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213d7f:	e9 ca 02 00 00       	jmpq   800421404e <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  8004213d84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213d8c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213d90:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213d94:	74 5e                	je     8004213df4 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213d96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d9a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d9e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213da2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213da6:	48 89 d1             	mov    %rdx,%rcx
  8004213da9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213dad:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213db2:	48 89 cf             	mov    %rcx,%rdi
  8004213db5:	ff d0                	callq  *%rax
  8004213db7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213dbb:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213dbf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213dc3:	48 8b 10             	mov    (%rax),%rdx
  8004213dc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dca:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213dce:	48 29 c2             	sub    %rax,%rdx
  8004213dd1:	48 89 d0             	mov    %rdx,%rax
  8004213dd4:	48 83 e8 04          	sub    $0x4,%rax
  8004213dd8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213ddc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213de0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213de4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213de8:	75 3d                	jne    8004213e27 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213dea:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213def:	e9 5a 02 00 00       	jmpq   800421404e <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004213df4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213df8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213dfc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213e00:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213e04:	48 89 d1             	mov    %rdx,%rcx
  8004213e07:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213e0a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213e0e:	48 89 cf             	mov    %rcx,%rdi
  8004213e11:	ff d0                	callq  *%rax
  8004213e13:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213e17:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213e1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e1f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213e23:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213e27:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213e2b:	0f 84 c9 00 00 00    	je     8004213efa <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213e31:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e35:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213e39:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213e3d:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213e40:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213e44:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e48:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213e4c:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004213e50:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e54:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213e58:	48 89 c2             	mov    %rax,%rdx
  8004213e5b:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213e5f:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213e63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e67:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213e6b:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213e6f:	48 89 c7             	mov    %rax,%rdi
  8004213e72:	48 b8 d3 34 21 04 80 	movabs $0x80042134d3,%rax
  8004213e79:	00 00 00 
  8004213e7c:	ff d0                	callq  *%rax
  8004213e7e:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213e81:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213e85:	74 08                	je     8004213e8f <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  8004213e87:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213e8a:	e9 bf 01 00 00       	jmpq   800421404e <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  8004213e8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e97:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004213e9b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e9f:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213ea3:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004213ea7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213eab:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213eaf:	48 89 c2             	mov    %rax,%rdx
  8004213eb2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213eb6:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213eba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ebe:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213ec2:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213ec6:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213ecc:	48 89 c7             	mov    %rax,%rdi
  8004213ecf:	48 b8 d3 34 21 04 80 	movabs $0x80042134d3,%rax
  8004213ed6:	00 00 00 
  8004213ed9:	ff d0                	callq  *%rax
  8004213edb:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004213ede:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213ee2:	74 08                	je     8004213eec <_dwarf_frame_set_fde+0x251>
			return (ret);
  8004213ee4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213ee7:	e9 62 01 00 00       	jmpq   800421404e <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  8004213eec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ef0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef4:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213ef8:	eb 50                	jmp    8004213f4a <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213efa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213efe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f02:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f06:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213f09:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213f0d:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213f11:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f15:	48 89 cf             	mov    %rcx,%rdi
  8004213f18:	ff d0                	callq  *%rax
  8004213f1a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f1e:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213f22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f26:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f2a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f2e:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213f31:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213f35:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213f39:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f3d:	48 89 cf             	mov    %rcx,%rdi
  8004213f40:	ff d0                	callq  *%rax
  8004213f42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f46:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213f4a:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213f4e:	74 6b                	je     8004213fbb <_dwarf_frame_set_fde+0x320>
  8004213f50:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213f54:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213f58:	0f b6 00             	movzbl (%rax),%eax
  8004213f5b:	3c 7a                	cmp    $0x7a,%al
  8004213f5d:	75 5c                	jne    8004213fbb <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213f5f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f63:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213f67:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213f6b:	48 89 d6             	mov    %rdx,%rsi
  8004213f6e:	48 89 c7             	mov    %rax,%rdi
  8004213f71:	48 b8 67 05 21 04 80 	movabs $0x8004210567,%rax
  8004213f78:	00 00 00 
  8004213f7b:	ff d0                	callq  *%rax
  8004213f7d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f81:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213f85:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f89:	48 8b 10             	mov    (%rax),%rdx
  8004213f8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f90:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213f94:	48 01 d0             	add    %rdx,%rax
  8004213f97:	48 89 c2             	mov    %rax,%rdx
  8004213f9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f9e:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213fa2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fa6:	48 8b 10             	mov    (%rax),%rdx
  8004213fa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fad:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213fb1:	48 01 c2             	add    %rax,%rdx
  8004213fb4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fb8:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213fbb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fbf:	48 8b 10             	mov    (%rax),%rdx
  8004213fc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213fc6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213fca:	48 01 d0             	add    %rdx,%rax
  8004213fcd:	48 89 c2             	mov    %rax,%rdx
  8004213fd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fd4:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004213fd8:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213fdc:	75 2a                	jne    8004214008 <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004213fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fe2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213fe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213fea:	48 01 c2             	add    %rax,%rdx
  8004213fed:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ff1:	48 8b 00             	mov    (%rax),%rax
  8004213ff4:	48 29 c2             	sub    %rax,%rdx
  8004213ff7:	48 89 d0             	mov    %rdx,%rax
  8004213ffa:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213ffe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214002:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214006:	eb 28                	jmp    8004214030 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004214008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421400c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214010:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214014:	48 01 c2             	add    %rax,%rdx
  8004214017:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421401b:	48 8b 00             	mov    (%rax),%rax
  800421401e:	48 29 c2             	sub    %rax,%rdx
  8004214021:	48 89 d0             	mov    %rdx,%rax
  8004214024:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004214028:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421402c:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004214030:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214034:	48 8b 10             	mov    (%rax),%rdx
  8004214037:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421403b:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421403f:	48 01 c2             	add    %rax,%rdx
  8004214042:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214046:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004214049:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421404e:	c9                   	leaveq 
  800421404f:	c3                   	retq   

0000008004214050 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214050:	55                   	push   %rbp
  8004214051:	48 89 e5             	mov    %rsp,%rbp
  8004214054:	48 83 ec 20          	sub    $0x20,%rsp
  8004214058:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421405c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004214060:	48 b8 c0 b6 60 04 80 	movabs $0x800460b6c0,%rax
  8004214067:	00 00 00 
  800421406a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  800421406e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214072:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214076:	48 85 c0             	test   %rax,%rax
  8004214079:	74 07                	je     8004214082 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  800421407b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214080:	eb 33                	jmp    80042140b5 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004214082:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214086:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  800421408a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421408e:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004214092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214096:	48 b9 a0 dc 60 04 80 	movabs $0x800460dca0,%rcx
  800421409d:	00 00 00 
  80042140a0:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  80042140a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042140a8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140ac:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  80042140b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042140b5:	c9                   	leaveq 
  80042140b6:	c3                   	retq   

00000080042140b7 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042140b7:	55                   	push   %rbp
  80042140b8:	48 89 e5             	mov    %rsp,%rbp
  80042140bb:	48 83 ec 60          	sub    $0x60,%rsp
  80042140bf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042140c3:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042140c6:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042140ca:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  80042140ce:	48 b8 c0 e6 22 04 80 	movabs $0x800422e6c0,%rax
  80042140d5:	00 00 00 
  80042140d8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  80042140dc:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042140e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140e7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042140eb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042140ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140f3:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042140f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042140fb:	48 39 c2             	cmp    %rax,%rdx
  80042140fe:	0f 86 fe 01 00 00    	jbe    8004214302 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  8004214104:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214108:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  800421410c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214110:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214114:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214118:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421411c:	48 89 d1             	mov    %rdx,%rcx
  800421411f:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214123:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214128:	48 89 cf             	mov    %rcx,%rdi
  800421412b:	ff d0                	callq  *%rax
  800421412d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214131:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214136:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421413a:	75 2e                	jne    800421416a <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  800421413c:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004214143:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214147:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421414b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421414f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214153:	48 89 d1             	mov    %rdx,%rcx
  8004214156:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421415a:	ba 08 00 00 00       	mov    $0x8,%edx
  800421415f:	48 89 cf             	mov    %rcx,%rdi
  8004214162:	ff d0                	callq  *%rax
  8004214164:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214168:	eb 07                	jmp    8004214171 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421416a:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004214171:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214175:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214179:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421417d:	48 29 c2             	sub    %rax,%rdx
  8004214180:	48 89 d0             	mov    %rdx,%rax
  8004214183:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214187:	72 0d                	jb     8004214196 <_dwarf_get_next_fde+0xdf>
  8004214189:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421418e:	75 10                	jne    80042141a0 <_dwarf_get_next_fde+0xe9>
  8004214190:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214194:	75 0a                	jne    80042141a0 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214196:	b8 12 00 00 00       	mov    $0x12,%eax
  800421419b:	e9 67 01 00 00       	jmpq   8004214307 <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042141a0:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042141a4:	74 11                	je     80042141b7 <_dwarf_get_next_fde+0x100>
  80042141a6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042141ab:	75 0a                	jne    80042141b7 <_dwarf_get_next_fde+0x100>
			return(-1);
  80042141ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042141b2:	e9 50 01 00 00       	jmpq   8004214307 <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042141b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141bb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042141bf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042141c3:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042141c7:	48 89 d1             	mov    %rdx,%rcx
  80042141ca:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042141cd:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042141d1:	48 89 cf             	mov    %rcx,%rdi
  80042141d4:	ff d0                	callq  *%rax
  80042141d6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  80042141da:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042141de:	74 79                	je     8004214259 <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042141e0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042141e5:	75 32                	jne    8004214219 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042141e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042141eb:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042141ef:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042141f3:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042141f7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042141fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141ff:	49 89 f8             	mov    %rdi,%r8
  8004214202:	48 89 c7             	mov    %rax,%rdi
  8004214205:	48 b8 38 38 21 04 80 	movabs $0x8004213838,%rax
  800421420c:	00 00 00 
  800421420f:	ff d0                	callq  *%rax
  8004214211:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214214:	e9 c8 00 00 00       	jmpq   80042142e1 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214219:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421421d:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214221:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214225:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214229:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421422d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214231:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214235:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214239:	4d 89 c1             	mov    %r8,%r9
  800421423c:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214242:	48 89 c7             	mov    %rax,%rdi
  8004214245:	48 b8 9b 3c 21 04 80 	movabs $0x8004213c9b,%rax
  800421424c:	00 00 00 
  800421424f:	ff d0                	callq  *%rax
  8004214251:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214254:	e9 88 00 00 00       	jmpq   80042142e1 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004214259:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421425d:	75 0b                	jne    800421426a <_dwarf_get_next_fde+0x1b3>
  800421425f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214264:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004214268:	74 0d                	je     8004214277 <_dwarf_get_next_fde+0x1c0>
  800421426a:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800421426e:	75 36                	jne    80042142a6 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004214270:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004214275:	75 2f                	jne    80042142a6 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214277:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421427b:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421427f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214283:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004214287:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421428b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421428f:	49 89 f8             	mov    %rdi,%r8
  8004214292:	48 89 c7             	mov    %rax,%rdi
  8004214295:	48 b8 38 38 21 04 80 	movabs $0x8004213838,%rax
  800421429c:	00 00 00 
  800421429f:	ff d0                	callq  *%rax
  80042142a1:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042142a4:	eb 3b                	jmp    80042142e1 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042142a6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042142aa:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042142ae:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042142b2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042142b6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042142ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142be:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042142c2:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042142c6:	4d 89 c1             	mov    %r8,%r9
  80042142c9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042142cf:	48 89 c7             	mov    %rax,%rdi
  80042142d2:	48 b8 9b 3c 21 04 80 	movabs $0x8004213c9b,%rax
  80042142d9:	00 00 00 
  80042142dc:	ff d0                	callq  *%rax
  80042142de:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042142e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042142e5:	74 07                	je     80042142ee <_dwarf_get_next_fde+0x237>
			return(-1);
  80042142e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042142ec:	eb 19                	jmp    8004214307 <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  80042142ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042142f2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  80042142f6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042142fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142fe:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214302:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214307:	c9                   	leaveq 
  8004214308:	c3                   	retq   

0000008004214309 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004214309:	55                   	push   %rbp
  800421430a:	48 89 e5             	mov    %rsp,%rbp
  800421430d:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214311:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214315:	89 f0                	mov    %esi,%eax
  8004214317:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  800421431b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421431f:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214323:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004214327:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421432b:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  800421432f:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004214333:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004214337:	c9                   	leaveq 
  8004214338:	c3                   	retq   

0000008004214339 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214339:	55                   	push   %rbp
  800421433a:	48 89 e5             	mov    %rsp,%rbp
  800421433d:	48 83 ec 10          	sub    $0x10,%rsp
  8004214341:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214345:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004214349:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421434e:	75 0a                	jne    800421435a <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214350:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214355:	e9 85 00 00 00       	jmpq   80042143df <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  800421435a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421435e:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214362:	48 85 c0             	test   %rax,%rax
  8004214365:	75 25                	jne    800421438c <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004214367:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421436b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421436f:	48 89 d6             	mov    %rdx,%rsi
  8004214372:	48 89 c7             	mov    %rax,%rdi
  8004214375:	48 b8 50 40 21 04 80 	movabs $0x8004214050,%rax
  800421437c:	00 00 00 
  800421437f:	ff d0                	callq  *%rax
  8004214381:	85 c0                	test   %eax,%eax
  8004214383:	74 07                	je     800421438c <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004214385:	b8 01 00 00 00       	mov    $0x1,%eax
  800421438a:	eb 53                	jmp    80042143df <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  800421438c:	48 bf c0 e6 22 04 80 	movabs $0x800422e6c0,%rdi
  8004214393:	00 00 00 
  8004214396:	48 b8 05 1e 21 04 80 	movabs $0x8004211e05,%rax
  800421439d:	00 00 00 
  80042143a0:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042143a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143a6:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042143ad:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042143ae:	48 b8 c0 e6 22 04 80 	movabs $0x800422e6c0,%rax
  80042143b5:	00 00 00 
  80042143b8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042143bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143c0:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042143c4:	48 b8 c0 e6 22 04 80 	movabs $0x800422e6c0,%rax
  80042143cb:	00 00 00 
  80042143ce:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042143d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143d6:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042143da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042143df:	c9                   	leaveq 
  80042143e0:	c3                   	retq   

00000080042143e1 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042143e1:	55                   	push   %rbp
  80042143e2:	48 89 e5             	mov    %rsp,%rbp
  80042143e5:	53                   	push   %rbx
  80042143e6:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80042143ed:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  80042143f1:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  80042143f5:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  80042143fc:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004214403:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  800421440a:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004214411:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214415:	48 83 c0 48          	add    $0x48,%rax
  8004214419:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  800421441d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214424:	00 
  8004214425:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421442c:	00 
  800421442d:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214434:	00 
  8004214435:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421443c:	00 
  800421443d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214441:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214445:	0f b6 c0             	movzbl %al,%eax
  8004214448:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421444b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214452:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214459:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214460:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004214467:	e9 0a 05 00 00       	jmpq   8004214976 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  800421446c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214473:	0f b6 00             	movzbl (%rax),%eax
  8004214476:	84 c0                	test   %al,%al
  8004214478:	0f 85 78 01 00 00    	jne    80042145f6 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  800421447e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214485:	48 83 c0 01          	add    $0x1,%rax
  8004214489:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004214490:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214497:	48 89 c7             	mov    %rax,%rdi
  800421449a:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042144a1:	00 00 00 
  80042144a4:	ff d0                	callq  *%rax
  80042144a6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042144aa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144b1:	0f b6 00             	movzbl (%rax),%eax
  80042144b4:	0f b6 c0             	movzbl %al,%eax
  80042144b7:	83 f8 02             	cmp    $0x2,%eax
  80042144ba:	74 7a                	je     8004214536 <_dwarf_lineno_run_program+0x155>
  80042144bc:	83 f8 03             	cmp    $0x3,%eax
  80042144bf:	0f 84 b3 00 00 00    	je     8004214578 <_dwarf_lineno_run_program+0x197>
  80042144c5:	83 f8 01             	cmp    $0x1,%eax
  80042144c8:	0f 85 09 01 00 00    	jne    80042145d7 <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  80042144ce:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144d5:	48 83 c0 01          	add    $0x1,%rax
  80042144d9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  80042144e0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  80042144e7:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042144ee:	00 
  80042144ef:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  80042144f6:	00 
  80042144f7:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  80042144fe:	00 
  80042144ff:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214506:	00 
  8004214507:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421450b:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421450f:	0f b6 c0             	movzbl %al,%eax
  8004214512:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214515:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  800421451c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214523:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  800421452a:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214531:	e9 bb 00 00 00       	jmpq   80042145f1 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  8004214536:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421453d:	48 83 c0 01          	add    $0x1,%rax
  8004214541:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004214548:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  800421454f:	00 00 00 
  8004214552:	48 8b 00             	mov    (%rax),%rax
  8004214555:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214559:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421455d:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004214561:	0f b6 ca             	movzbl %dl,%ecx
  8004214564:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  800421456b:	89 ce                	mov    %ecx,%esi
  800421456d:	48 89 d7             	mov    %rdx,%rdi
  8004214570:	ff d0                	callq  *%rax
  8004214572:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  8004214576:	eb 79                	jmp    80042145f1 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  8004214578:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421457f:	48 83 c0 01          	add    $0x1,%rax
  8004214583:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  800421458a:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214591:	00 00 00 
  8004214594:	48 8b 08             	mov    (%rax),%rcx
  8004214597:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421459e:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042145a5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145a9:	49 89 c8             	mov    %rcx,%r8
  80042145ac:	48 89 d1             	mov    %rdx,%rcx
  80042145af:	ba 00 00 00 00       	mov    $0x0,%edx
  80042145b4:	48 89 c7             	mov    %rax,%rdi
  80042145b7:	48 b8 99 49 21 04 80 	movabs $0x8004214999,%rax
  80042145be:	00 00 00 
  80042145c1:	ff d0                	callq  *%rax
  80042145c3:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  80042145c6:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  80042145ca:	74 09                	je     80042145d5 <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  80042145cc:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  80042145cd:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042145d0:	e9 ba 03 00 00       	jmpq   800421498f <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  80042145d5:	eb 1a                	jmp    80042145f1 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  80042145d7:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042145de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042145e2:	48 01 d0             	add    %rdx,%rax
  80042145e5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042145ec:	e9 85 03 00 00       	jmpq   8004214976 <_dwarf_lineno_run_program+0x595>
  80042145f1:	e9 80 03 00 00       	jmpq   8004214976 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  80042145f6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042145fd:	0f b6 00             	movzbl (%rax),%eax
  8004214600:	84 c0                	test   %al,%al
  8004214602:	0f 84 3c 02 00 00    	je     8004214844 <_dwarf_lineno_run_program+0x463>
  8004214608:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421460f:	0f b6 10             	movzbl (%rax),%edx
  8004214612:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214616:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421461a:	38 c2                	cmp    %al,%dl
  800421461c:	0f 83 22 02 00 00    	jae    8004214844 <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004214622:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214629:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421462d:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214634:	0f b6 00             	movzbl (%rax),%eax
  8004214637:	0f b6 c0             	movzbl %al,%eax
  800421463a:	83 f8 0c             	cmp    $0xc,%eax
  800421463d:	0f 87 fb 01 00 00    	ja     800421483e <_dwarf_lineno_run_program+0x45d>
  8004214643:	89 c0                	mov    %eax,%eax
  8004214645:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421464c:	00 
  800421464d:	48 b8 48 aa 21 04 80 	movabs $0x800421aa48,%rax
  8004214654:	00 00 00 
  8004214657:	48 01 d0             	add    %rdx,%rax
  800421465a:	48 8b 00             	mov    (%rax),%rax
  800421465d:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  800421465f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214666:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421466a:	73 0a                	jae    8004214676 <_dwarf_lineno_run_program+0x295>
  800421466c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214671:	e9 19 03 00 00       	jmpq   800421498f <_dwarf_lineno_run_program+0x5ae>
  8004214676:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421467a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421467e:	48 89 10             	mov    %rdx,(%rax)
  8004214681:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214685:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800421468c:	00 
  800421468d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214691:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214695:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214699:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421469d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042146a1:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042146a5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042146a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146ad:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042146b1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146b5:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042146b8:	89 50 28             	mov    %edx,0x28(%rax)
  80042146bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146bf:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042146c2:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042146c5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146c9:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042146cc:	89 50 30             	mov    %edx,0x30(%rax)
  80042146cf:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146d3:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042146da:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042146de:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146e2:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  80042146e9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  80042146f0:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  80042146f7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  80042146fe:	e9 3c 01 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004214703:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421470a:	48 89 c7             	mov    %rax,%rdi
  800421470d:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214714:	00 00 00 
  8004214717:	ff d0                	callq  *%rax
					li->li_minlen;
  8004214719:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421471d:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004214721:	0f b6 d2             	movzbl %dl,%edx
  8004214724:	48 0f af c2          	imul   %rdx,%rax
  8004214728:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  800421472c:	e9 0e 01 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004214731:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214738:	48 89 c7             	mov    %rax,%rdi
  800421473b:	48 b8 e6 05 21 04 80 	movabs $0x80042105e6,%rax
  8004214742:	00 00 00 
  8004214745:	ff d0                	callq  *%rax
  8004214747:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  800421474b:	e9 ef 00 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004214750:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214757:	48 89 c7             	mov    %rax,%rdi
  800421475a:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214761:	00 00 00 
  8004214764:	ff d0                	callq  *%rax
  8004214766:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  800421476a:	e9 d0 00 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  800421476f:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214776:	48 89 c7             	mov    %rax,%rdi
  8004214779:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214780:	00 00 00 
  8004214783:	ff d0                	callq  *%rax
  8004214785:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  8004214789:	e9 b1 00 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  800421478e:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004214792:	0f 94 c0             	sete   %al
  8004214795:	0f b6 c0             	movzbl %al,%eax
  8004214798:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  800421479b:	e9 9f 00 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  80042147a0:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  80042147a7:	e9 93 00 00 00       	jmpq   800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042147ac:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147b0:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042147b4:	0f b6 c0             	movzbl %al,%eax
  80042147b7:	ba ff 00 00 00       	mov    $0xff,%edx
  80042147bc:	89 d1                	mov    %edx,%ecx
  80042147be:	29 c1                	sub    %eax,%ecx
  80042147c0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147c4:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042147c8:	0f b6 d8             	movzbl %al,%ebx
  80042147cb:	89 c8                	mov    %ecx,%eax
  80042147cd:	99                   	cltd   
  80042147ce:	f7 fb                	idiv   %ebx
  80042147d0:	89 c2                	mov    %eax,%edx
  80042147d2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147d6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042147da:	0f b6 c0             	movzbl %al,%eax
  80042147dd:	0f af c2             	imul   %edx,%eax
  80042147e0:	48 98                	cltq   
  80042147e2:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  80042147e6:	eb 57                	jmp    800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  80042147e8:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  80042147ef:	00 00 00 
  80042147f2:	48 8b 00             	mov    (%rax),%rax
  80042147f5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042147f9:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214800:	be 02 00 00 00       	mov    $0x2,%esi
  8004214805:	48 89 d7             	mov    %rdx,%rdi
  8004214808:	ff d0                	callq  *%rax
  800421480a:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  800421480e:	eb 2f                	jmp    800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004214810:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004214817:	eb 26                	jmp    800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004214819:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004214820:	eb 1d                	jmp    800421483f <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004214822:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214829:	48 89 c7             	mov    %rax,%rdi
  800421482c:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214833:	00 00 00 
  8004214836:	ff d0                	callq  *%rax
  8004214838:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  800421483c:	eb 01                	jmp    800421483f <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  800421483e:	90                   	nop
			}

		} else {
  800421483f:	e9 32 01 00 00       	jmpq   8004214976 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004214844:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214848:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  800421484c:	0f be c8             	movsbl %al,%ecx
  800421484f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214856:	0f b6 00             	movzbl (%rax),%eax
  8004214859:	0f b6 d0             	movzbl %al,%edx
  800421485c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214860:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214864:	0f b6 c0             	movzbl %al,%eax
  8004214867:	29 c2                	sub    %eax,%edx
  8004214869:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421486d:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004214871:	0f b6 f0             	movzbl %al,%esi
  8004214874:	89 d0                	mov    %edx,%eax
  8004214876:	99                   	cltd   
  8004214877:	f7 fe                	idiv   %esi
  8004214879:	89 d0                	mov    %edx,%eax
  800421487b:	01 c8                	add    %ecx,%eax
  800421487d:	48 98                	cltq   
  800421487f:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004214883:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421488a:	0f b6 00             	movzbl (%rax),%eax
  800421488d:	0f b6 d0             	movzbl %al,%edx
  8004214890:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214894:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214898:	0f b6 c0             	movzbl %al,%eax
  800421489b:	89 d1                	mov    %edx,%ecx
  800421489d:	29 c1                	sub    %eax,%ecx
  800421489f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148a3:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042148a7:	0f b6 d8             	movzbl %al,%ebx
  80042148aa:	89 c8                	mov    %ecx,%eax
  80042148ac:	99                   	cltd   
  80042148ad:	f7 fb                	idiv   %ebx
  80042148af:	89 c2                	mov    %eax,%edx
  80042148b1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148b5:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042148b9:	0f b6 c0             	movzbl %al,%eax
  80042148bc:	0f af c2             	imul   %edx,%eax
  80042148bf:	48 98                	cltq   
  80042148c1:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  80042148c5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042148cc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042148d0:	73 0a                	jae    80042148dc <_dwarf_lineno_run_program+0x4fb>
  80042148d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042148d7:	e9 b3 00 00 00       	jmpq   800421498f <_dwarf_lineno_run_program+0x5ae>
  80042148dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042148e0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042148e4:	48 89 10             	mov    %rdx,(%rax)
  80042148e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042148eb:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042148f2:	00 
  80042148f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042148f7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042148fb:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042148ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214903:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214907:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421490b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421490f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214913:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214917:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421491b:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421491e:	89 50 28             	mov    %edx,0x28(%rax)
  8004214921:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214925:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214928:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421492b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421492f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214932:	89 50 30             	mov    %edx,0x30(%rax)
  8004214935:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214939:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214940:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214944:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214948:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  800421494f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004214956:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  800421495d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004214964:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421496b:	48 83 c0 01          	add    $0x1,%rax
  800421496f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004214976:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421497d:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004214984:	0f 82 e2 fa ff ff    	jb     800421446c <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  800421498a:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421498f:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004214996:	5b                   	pop    %rbx
  8004214997:	5d                   	pop    %rbp
  8004214998:	c3                   	retq   

0000008004214999 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004214999:	55                   	push   %rbp
  800421499a:	48 89 e5             	mov    %rsp,%rbp
  800421499d:	53                   	push   %rbx
  800421499e:	48 83 ec 48          	sub    $0x48,%rsp
  80042149a2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042149a6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042149aa:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042149ae:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042149b2:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  80042149b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042149ba:	48 8b 00             	mov    (%rax),%rax
  80042149bd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  80042149c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042149c5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  80042149c9:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  80042149cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149d1:	48 89 c7             	mov    %rax,%rdi
  80042149d4:	48 b8 50 f7 20 04 80 	movabs $0x800420f750,%rax
  80042149db:	00 00 00 
  80042149de:	ff d0                	callq  *%rax
  80042149e0:	48 98                	cltq   
  80042149e2:	48 83 c0 01          	add    $0x1,%rax
  80042149e6:	48 01 d8             	add    %rbx,%rax
  80042149e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  80042149ed:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042149f1:	48 89 c7             	mov    %rax,%rdi
  80042149f4:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  80042149fb:	00 00 00 
  80042149fe:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004214a00:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214a04:	48 89 c7             	mov    %rax,%rdi
  8004214a07:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214a0e:	00 00 00 
  8004214a11:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004214a13:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214a17:	48 89 c7             	mov    %rax,%rdi
  8004214a1a:	48 b8 78 06 21 04 80 	movabs $0x8004210678,%rax
  8004214a21:	00 00 00 
  8004214a24:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004214a26:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214a2a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214a2e:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004214a31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214a36:	48 83 c4 48          	add    $0x48,%rsp
  8004214a3a:	5b                   	pop    %rbx
  8004214a3b:	5d                   	pop    %rbp
  8004214a3c:	c3                   	retq   

0000008004214a3d <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004214a3d:	55                   	push   %rbp
  8004214a3e:	48 89 e5             	mov    %rsp,%rbp
  8004214a41:	53                   	push   %rbx
  8004214a42:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004214a49:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004214a50:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004214a57:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004214a5e:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004214a65:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004214a6c:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004214a73:	00 
  8004214a74:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004214a7b:	00 
  8004214a7c:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004214a83:	00 
  8004214a84:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004214a8b:	00 
  8004214a8c:	48 b8 b0 aa 21 04 80 	movabs $0x800421aab0,%rax
  8004214a93:	00 00 00 
  8004214a96:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004214a9a:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004214a9e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004214aa2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004214aa9:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004214ab0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004214ab4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004214ab9:	75 35                	jne    8004214af0 <_dwarf_lineno_init+0xb3>
  8004214abb:	48 b9 bc aa 21 04 80 	movabs $0x800421aabc,%rcx
  8004214ac2:	00 00 00 
  8004214ac5:	48 ba c7 aa 21 04 80 	movabs $0x800421aac7,%rdx
  8004214acc:	00 00 00 
  8004214acf:	be 13 01 00 00       	mov    $0x113,%esi
  8004214ad4:	48 bf dc aa 21 04 80 	movabs $0x800421aadc,%rdi
  8004214adb:	00 00 00 
  8004214ade:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ae3:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004214aea:	00 00 00 
  8004214aed:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004214af0:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214af7:	00 00 00 
  8004214afa:	48 8b 00             	mov    (%rax),%rax
  8004214afd:	48 85 c0             	test   %rax,%rax
  8004214b00:	75 35                	jne    8004214b37 <_dwarf_lineno_init+0xfa>
  8004214b02:	48 b9 f3 aa 21 04 80 	movabs $0x800421aaf3,%rcx
  8004214b09:	00 00 00 
  8004214b0c:	48 ba c7 aa 21 04 80 	movabs $0x800421aac7,%rdx
  8004214b13:	00 00 00 
  8004214b16:	be 14 01 00 00       	mov    $0x114,%esi
  8004214b1b:	48 bf dc aa 21 04 80 	movabs $0x800421aadc,%rdi
  8004214b22:	00 00 00 
  8004214b25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b2a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004214b31:	00 00 00 
  8004214b34:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004214b37:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b3b:	48 89 c7             	mov    %rax,%rdi
  8004214b3e:	48 b8 05 1e 21 04 80 	movabs $0x8004211e05,%rax
  8004214b45:	00 00 00 
  8004214b48:	ff d0                	callq  *%rax
  8004214b4a:	85 c0                	test   %eax,%eax
  8004214b4c:	74 0a                	je     8004214b58 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004214b4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b53:	e9 4f 04 00 00       	jmpq   8004214fa7 <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004214b58:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004214b5f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004214b63:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214b6a:	00 00 00 
  8004214b6d:	48 8b 00             	mov    (%rax),%rax
  8004214b70:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b74:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b78:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b7c:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214b83:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214b88:	48 89 cf             	mov    %rcx,%rdi
  8004214b8b:	ff d0                	callq  *%rax
  8004214b8d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004214b91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214b96:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004214b9a:	75 37                	jne    8004214bd3 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004214b9c:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004214ba3:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214baa:	00 00 00 
  8004214bad:	48 8b 00             	mov    (%rax),%rax
  8004214bb0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214bb4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214bb8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214bbc:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214bc3:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214bc8:	48 89 cf             	mov    %rcx,%rdi
  8004214bcb:	ff d0                	callq  *%rax
  8004214bcd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004214bd1:	eb 07                	jmp    8004214bda <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004214bd3:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004214bda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214bde:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214be2:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214be9:	48 29 c2             	sub    %rax,%rdx
  8004214bec:	48 89 d0             	mov    %rdx,%rax
  8004214bef:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214bf3:	73 0a                	jae    8004214bff <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004214bf5:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214bfa:	e9 a8 03 00 00       	jmpq   8004214fa7 <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004214bff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c07:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004214c0a:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004214c11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c15:	48 01 d0             	add    %rdx,%rax
  8004214c18:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214c1c:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214c23:	00 00 00 
  8004214c26:	48 8b 00             	mov    (%rax),%rax
  8004214c29:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c2d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c31:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c35:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c3c:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214c41:	48 89 cf             	mov    %rcx,%rdi
  8004214c44:	ff d0                	callq  *%rax
  8004214c46:	89 c2                	mov    %eax,%edx
  8004214c48:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c4c:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214c50:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214c57:	00 00 00 
  8004214c5a:	48 8b 00             	mov    (%rax),%rax
  8004214c5d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c61:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c65:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c69:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214c6c:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c73:	48 89 cf             	mov    %rcx,%rdi
  8004214c76:	ff d0                	callq  *%rax
  8004214c78:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214c7c:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004214c80:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214c87:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214c8b:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214c92:	00 00 00 
  8004214c95:	48 8b 00             	mov    (%rax),%rax
  8004214c98:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c9c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214ca0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ca4:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214cab:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214cb0:	48 89 cf             	mov    %rcx,%rdi
  8004214cb3:	ff d0                	callq  *%rax
  8004214cb5:	89 c2                	mov    %eax,%edx
  8004214cb7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cbb:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214cbe:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214cc5:	00 00 00 
  8004214cc8:	48 8b 00             	mov    (%rax),%rax
  8004214ccb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214ccf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214cd3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214cd7:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214cde:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214ce3:	48 89 cf             	mov    %rcx,%rdi
  8004214ce6:	ff d0                	callq  *%rax
  8004214ce8:	89 c2                	mov    %eax,%edx
  8004214cea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cee:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214cf1:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214cf8:	00 00 00 
  8004214cfb:	48 8b 00             	mov    (%rax),%rax
  8004214cfe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d06:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d0a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d11:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d16:	48 89 cf             	mov    %rcx,%rdi
  8004214d19:	ff d0                	callq  *%rax
  8004214d1b:	89 c2                	mov    %eax,%edx
  8004214d1d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d21:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004214d24:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214d2b:	00 00 00 
  8004214d2e:	48 8b 00             	mov    (%rax),%rax
  8004214d31:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d35:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d39:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d3d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d44:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d49:	48 89 cf             	mov    %rcx,%rdi
  8004214d4c:	ff d0                	callq  *%rax
  8004214d4e:	89 c2                	mov    %eax,%edx
  8004214d50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d54:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214d57:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214d5e:	00 00 00 
  8004214d61:	48 8b 00             	mov    (%rax),%rax
  8004214d64:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d68:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d6c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d70:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d77:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d7c:	48 89 cf             	mov    %rcx,%rdi
  8004214d7f:	ff d0                	callq  *%rax
  8004214d81:	89 c2                	mov    %eax,%edx
  8004214d83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d87:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214d8a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d8e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214d92:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004214d95:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d99:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214d9d:	0f b6 c0             	movzbl %al,%eax
  8004214da0:	83 e8 01             	sub    $0x1,%eax
  8004214da3:	39 c2                	cmp    %eax,%edx
  8004214da5:	7d 0c                	jge    8004214db3 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214da7:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214dae:	e9 f1 01 00 00       	jmpq   8004214fa4 <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004214db3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214db7:	48 bb e0 e2 60 04 80 	movabs $0x800460e2e0,%rbx
  8004214dbe:	00 00 00 
  8004214dc1:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214dc5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214dcc:	eb 41                	jmp    8004214e0f <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214dce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dd2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214dd6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214dd9:	48 98                	cltq   
  8004214ddb:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214ddf:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214de6:	00 00 00 
  8004214de9:	48 8b 00             	mov    (%rax),%rax
  8004214dec:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214df0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214df4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214df8:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214dff:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e04:	48 89 cf             	mov    %rcx,%rdi
  8004214e07:	ff d0                	callq  *%rax
  8004214e09:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214e0b:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214e0f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e13:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214e17:	0f b6 c0             	movzbl %al,%eax
  8004214e1a:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214e1d:	7f af                	jg     8004214dce <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004214e1f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214e26:	00 
	p = ds->ds_data + offset;
  8004214e27:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e2b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214e2f:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214e36:	48 01 d0             	add    %rdx,%rax
  8004214e39:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004214e40:	eb 1f                	jmp    8004214e61 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004214e42:	90                   	nop
  8004214e43:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e4a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214e4e:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004214e55:	0f b6 00             	movzbl (%rax),%eax
  8004214e58:	84 c0                	test   %al,%al
  8004214e5a:	75 e7                	jne    8004214e43 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004214e5c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004214e61:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e68:	0f b6 00             	movzbl (%rax),%eax
  8004214e6b:	84 c0                	test   %al,%al
  8004214e6d:	75 d3                	jne    8004214e42 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004214e6f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214e77:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214e7b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e82:	48 89 c2             	mov    %rax,%rdx
  8004214e85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e89:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214e8d:	48 29 c2             	sub    %rax,%rdx
  8004214e90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e98:	48 98                	cltq   
  8004214e9a:	48 39 c2             	cmp    %rax,%rdx
  8004214e9d:	7e 0c                	jle    8004214eab <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214e9f:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214ea6:	e9 f9 00 00 00       	jmpq   8004214fa4 <_dwarf_lineno_init+0x567>
	}
	p++;
  8004214eab:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214eb2:	48 83 c0 01          	add    $0x1,%rax
  8004214eb6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214ebd:	eb 3c                	jmp    8004214efb <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004214ebf:	48 b8 a8 e6 22 04 80 	movabs $0x800422e6a8,%rax
  8004214ec6:	00 00 00 
  8004214ec9:	48 8b 08             	mov    (%rax),%rcx
  8004214ecc:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004214ed3:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214eda:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ede:	49 89 c8             	mov    %rcx,%r8
  8004214ee1:	48 89 d1             	mov    %rdx,%rcx
  8004214ee4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214ee9:	48 89 c7             	mov    %rax,%rdi
  8004214eec:	48 b8 99 49 21 04 80 	movabs $0x8004214999,%rax
  8004214ef3:	00 00 00 
  8004214ef6:	ff d0                	callq  *%rax
  8004214ef8:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214efb:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f02:	0f b6 00             	movzbl (%rax),%eax
  8004214f05:	84 c0                	test   %al,%al
  8004214f07:	75 b6                	jne    8004214ebf <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214f09:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f10:	48 83 c0 01          	add    $0x1,%rax
  8004214f14:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214f1b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f22:	48 89 c2             	mov    %rax,%rdx
  8004214f25:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214f29:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214f2d:	48 29 c2             	sub    %rax,%rdx
  8004214f30:	48 89 d0             	mov    %rdx,%rax
  8004214f33:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214f37:	48 89 c2             	mov    %rax,%rdx
  8004214f3a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f3e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214f42:	48 39 c2             	cmp    %rax,%rdx
  8004214f45:	74 09                	je     8004214f50 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214f47:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214f4e:	eb 54                	jmp    8004214fa4 <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004214f50:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214f54:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214f58:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f5c:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004214f60:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004214f67:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214f6e:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004214f75:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214f79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f7d:	4d 89 c1             	mov    %r8,%r9
  8004214f80:	49 89 f8             	mov    %rdi,%r8
  8004214f83:	48 89 c7             	mov    %rax,%rdi
  8004214f86:	48 b8 e1 43 21 04 80 	movabs $0x80042143e1,%rax
  8004214f8d:	00 00 00 
  8004214f90:	ff d0                	callq  *%rax
  8004214f92:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004214f95:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214f99:	74 02                	je     8004214f9d <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004214f9b:	eb 07                	jmp    8004214fa4 <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004214f9d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fa2:	eb 03                	jmp    8004214fa7 <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004214fa4:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004214fa7:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004214fae:	5b                   	pop    %rbx
  8004214faf:	5d                   	pop    %rbp
  8004214fb0:	c3                   	retq   

0000008004214fb1 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214fb1:	55                   	push   %rbp
  8004214fb2:	48 89 e5             	mov    %rsp,%rbp
  8004214fb5:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214fbc:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004214fc3:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004214fca:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004214fd1:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004214fd8:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004214fdf:	00 
  8004214fe0:	75 35                	jne    8004215017 <dwarf_srclines+0x66>
  8004214fe2:	48 b9 ff aa 21 04 80 	movabs $0x800421aaff,%rcx
  8004214fe9:	00 00 00 
  8004214fec:	48 ba c7 aa 21 04 80 	movabs $0x800421aac7,%rdx
  8004214ff3:	00 00 00 
  8004214ff6:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004214ffb:	48 bf dc aa 21 04 80 	movabs $0x800421aadc,%rdi
  8004215002:	00 00 00 
  8004215005:	b8 00 00 00 00       	mov    $0x0,%eax
  800421500a:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004215011:	00 00 00 
  8004215014:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004215017:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800421501e:	00 
  800421501f:	75 35                	jne    8004215056 <dwarf_srclines+0xa5>
  8004215021:	48 b9 03 ab 21 04 80 	movabs $0x800421ab03,%rcx
  8004215028:	00 00 00 
  800421502b:	48 ba c7 aa 21 04 80 	movabs $0x800421aac7,%rdx
  8004215032:	00 00 00 
  8004215035:	be 9b 01 00 00       	mov    $0x19b,%esi
  800421503a:	48 bf dc aa 21 04 80 	movabs $0x800421aadc,%rdi
  8004215041:	00 00 00 
  8004215044:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215049:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004215050:	00 00 00 
  8004215053:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004215056:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800421505d:	ba 88 00 00 00       	mov    $0x88,%edx
  8004215062:	be 00 00 00 00       	mov    $0x0,%esi
  8004215067:	48 89 c7             	mov    %rax,%rdi
  800421506a:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004215071:	00 00 00 
  8004215074:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004215076:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421507d:	be 10 00 00 00       	mov    $0x10,%esi
  8004215082:	48 89 c7             	mov    %rax,%rdi
  8004215085:	48 b8 8a 19 21 04 80 	movabs $0x800421198a,%rax
  800421508c:	00 00 00 
  800421508f:	ff d0                	callq  *%rax
  8004215091:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215095:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421509a:	75 0a                	jne    80042150a6 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800421509c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042150a1:	e9 84 00 00 00       	jmpq   800421512a <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  80042150a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042150aa:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042150ae:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042150b5:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  80042150bc:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  80042150c3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042150ca:	49 89 f8             	mov    %rdi,%r8
  80042150cd:	48 89 c7             	mov    %rax,%rdi
  80042150d0:	48 b8 3d 4a 21 04 80 	movabs $0x8004214a3d,%rax
  80042150d7:	00 00 00 
  80042150da:	ff d0                	callq  *%rax
  80042150dc:	85 c0                	test   %eax,%eax
  80042150de:	74 07                	je     80042150e7 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  80042150e0:	b8 01 00 00 00       	mov    $0x1,%eax
  80042150e5:	eb 43                	jmp    800421512a <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  80042150e7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042150ee:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042150f2:	48 89 10             	mov    %rdx,(%rax)
  80042150f5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042150f9:	48 89 50 08          	mov    %rdx,0x8(%rax)
  80042150fd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215101:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215105:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215109:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421510d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215111:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215115:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215119:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800421511d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215121:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004215125:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421512a:	c9                   	leaveq 
  800421512b:	c3                   	retq   

000000800421512c <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  800421512c:	55                   	push   %rbp
  800421512d:	48 89 e5             	mov    %rsp,%rbp
  8004215130:	48 83 ec 20          	sub    $0x20,%rsp
  8004215134:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004215138:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421513f:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215140:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215147:	eb 57                	jmp    80042151a0 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004215149:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215150:	00 00 00 
  8004215153:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215156:	48 63 d2             	movslq %edx,%rdx
  8004215159:	48 c1 e2 05          	shl    $0x5,%rdx
  800421515d:	48 01 d0             	add    %rdx,%rax
  8004215160:	48 8b 00             	mov    (%rax),%rax
  8004215163:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215167:	48 89 d6             	mov    %rdx,%rsi
  800421516a:	48 89 c7             	mov    %rax,%rdi
  800421516d:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215174:	00 00 00 
  8004215177:	ff d0                	callq  *%rax
  8004215179:	85 c0                	test   %eax,%eax
  800421517b:	75 1f                	jne    800421519c <_dwarf_find_section+0x70>
			ret = (section_info + i);
  800421517d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215180:	48 98                	cltq   
  8004215182:	48 c1 e0 05          	shl    $0x5,%rax
  8004215186:	48 89 c2             	mov    %rax,%rdx
  8004215189:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215190:	00 00 00 
  8004215193:	48 01 d0             	add    %rdx,%rax
  8004215196:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421519a:	eb 0a                	jmp    80042151a6 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421519c:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042151a0:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042151a4:	7e a3                	jle    8004215149 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042151a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042151aa:	c9                   	leaveq 
  80042151ab:	c3                   	retq   

00000080042151ac <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042151ac:	55                   	push   %rbp
  80042151ad:	48 89 e5             	mov    %rsp,%rbp
  80042151b0:	48 83 ec 40          	sub    $0x40,%rsp
  80042151b4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042151b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  80042151c0:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  80042151c7:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  80042151c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151cc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042151d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151d4:	48 01 d0             	add    %rdx,%rax
  80042151d7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  80042151db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151df:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042151e3:	0f b7 c0             	movzwl %ax,%eax
  80042151e6:	48 c1 e0 06          	shl    $0x6,%rax
  80042151ea:	48 89 c2             	mov    %rax,%rdx
  80042151ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151f1:	48 01 d0             	add    %rdx,%rax
  80042151f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  80042151f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151fc:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215200:	0f b7 c0             	movzwl %ax,%eax
  8004215203:	48 c1 e0 06          	shl    $0x6,%rax
  8004215207:	48 89 c2             	mov    %rax,%rdx
  800421520a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421520e:	48 01 d0             	add    %rdx,%rax
  8004215211:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004215215:	e9 4b 02 00 00       	jmpq   8004215465 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421521a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421521e:	8b 00                	mov    (%rax),%eax
  8004215220:	89 c2                	mov    %eax,%edx
  8004215222:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215226:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421522a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421522e:	48 01 c8             	add    %rcx,%rax
  8004215231:	48 01 d0             	add    %rdx,%rax
  8004215234:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004215238:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421523c:	48 be 0b ab 21 04 80 	movabs $0x800421ab0b,%rsi
  8004215243:	00 00 00 
  8004215246:	48 89 c7             	mov    %rax,%rdi
  8004215249:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215250:	00 00 00 
  8004215253:	ff d0                	callq  *%rax
  8004215255:	85 c0                	test   %eax,%eax
  8004215257:	75 4b                	jne    80042152a4 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004215259:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421525d:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215264:	00 00 00 
  8004215267:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  800421526b:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215272:	00 00 00 
  8004215275:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215279:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  800421527d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215281:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215285:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421528c:	00 00 00 
  800421528f:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004215293:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215297:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421529b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421529f:	e9 bc 01 00 00       	jmpq   8004215460 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042152a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042152a8:	48 be 17 ab 21 04 80 	movabs $0x800421ab17,%rsi
  80042152af:	00 00 00 
  80042152b2:	48 89 c7             	mov    %rax,%rdi
  80042152b5:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  80042152bc:	00 00 00 
  80042152bf:	ff d0                	callq  *%rax
  80042152c1:	85 c0                	test   %eax,%eax
  80042152c3:	75 4b                	jne    8004215310 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042152c5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042152c9:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042152d0:	00 00 00 
  80042152d3:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  80042152d7:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042152de:	00 00 00 
  80042152e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042152e5:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  80042152e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152ed:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042152f1:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042152f8:	00 00 00 
  80042152fb:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  80042152ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215303:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215307:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421530b:	e9 50 01 00 00       	jmpq   8004215460 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004215310:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215314:	48 be 2f ab 21 04 80 	movabs $0x800421ab2f,%rsi
  800421531b:	00 00 00 
  800421531e:	48 89 c7             	mov    %rax,%rdi
  8004215321:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215328:	00 00 00 
  800421532b:	ff d0                	callq  *%rax
  800421532d:	85 c0                	test   %eax,%eax
  800421532f:	75 4b                	jne    800421537c <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215331:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215335:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421533c:	00 00 00 
  800421533f:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004215343:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421534a:	00 00 00 
  800421534d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215351:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004215355:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215359:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421535d:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215364:	00 00 00 
  8004215367:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  800421536b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421536f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215373:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215377:	e9 e4 00 00 00       	jmpq   8004215460 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  800421537c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215380:	48 be 25 ab 21 04 80 	movabs $0x800421ab25,%rsi
  8004215387:	00 00 00 
  800421538a:	48 89 c7             	mov    %rax,%rdi
  800421538d:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215394:	00 00 00 
  8004215397:	ff d0                	callq  *%rax
  8004215399:	85 c0                	test   %eax,%eax
  800421539b:	75 53                	jne    80042153f0 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  800421539d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153a1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042153a5:	48 89 c2             	mov    %rax,%rdx
  80042153a8:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042153af:	00 00 00 
  80042153b2:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042153b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153ba:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042153be:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042153c5:	00 00 00 
  80042153c8:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  80042153cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153d0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042153d4:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042153db:	00 00 00 
  80042153de:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  80042153e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153e6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042153ea:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042153ee:	eb 70                	jmp    8004215460 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  80042153f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153f4:	48 be 3b ab 21 04 80 	movabs $0x800421ab3b,%rsi
  80042153fb:	00 00 00 
  80042153fe:	48 89 c7             	mov    %rax,%rdi
  8004215401:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215408:	00 00 00 
  800421540b:	ff d0                	callq  *%rax
  800421540d:	85 c0                	test   %eax,%eax
  800421540f:	75 4f                	jne    8004215460 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215411:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215415:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421541c:	00 00 00 
  800421541f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004215426:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421542d:	00 00 00 
  8004215430:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215434:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  800421543b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421543f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215443:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  800421544a:	00 00 00 
  800421544d:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004215454:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215458:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421545c:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004215460:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004215465:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215469:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800421546d:	0f 82 a7 fd ff ff    	jb     800421521a <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004215473:	c9                   	leaveq 
  8004215474:	c3                   	retq   

0000008004215475 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004215475:	55                   	push   %rbp
  8004215476:	48 89 e5             	mov    %rsp,%rbp
  8004215479:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004215480:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004215487:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  800421548e:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004215495:	b8 00 00 00 00       	mov    $0x0,%eax
  800421549a:	ba 14 00 00 00       	mov    $0x14,%edx
  800421549f:	48 89 f7             	mov    %rsi,%rdi
  80042154a2:	48 89 d1             	mov    %rdx,%rcx
  80042154a5:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042154a8:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042154af:	00 
  80042154b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154b4:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042154bb:	48 01 d0             	add    %rdx,%rax
  80042154be:	48 83 e8 01          	sub    $0x1,%rax
  80042154c2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042154c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154ca:	ba 00 00 00 00       	mov    $0x0,%edx
  80042154cf:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042154d3:	48 89 d0             	mov    %rdx,%rax
  80042154d6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042154da:	48 29 c2             	sub    %rax,%rdx
  80042154dd:	48 89 d0             	mov    %rdx,%rax
  80042154e0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  80042154e4:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  80042154eb:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  80042154ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042154f3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  80042154f7:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80042154fe:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  80042154ff:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004215506:	00 00 00 
  8004215509:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215510:	75 11                	jne    8004215523 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004215512:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215519:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421551d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215521:	eb 26                	jmp    8004215549 <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004215523:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421552a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421552e:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215535:	48 01 c2             	add    %rax,%rdx
  8004215538:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421553f:	ff ff ff 
  8004215542:	48 01 d0             	add    %rdx,%rax
  8004215545:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004215549:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215550:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215554:	0f b7 c0             	movzwl %ax,%eax
  8004215557:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  800421555a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215561:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004215565:	0f b7 c0             	movzwl %ax,%eax
  8004215568:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  800421556b:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215572:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004215576:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215579:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  800421557d:	48 63 f0             	movslq %eax,%rsi
  8004215580:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215584:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421558b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421558f:	48 89 c7             	mov    %rax,%rdi
  8004215592:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215599:	00 00 00 
  800421559c:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  800421559e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155a2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042155a6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042155aa:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042155b0:	48 89 c2             	mov    %rax,%rdx
  80042155b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155b7:	48 29 d0             	sub    %rdx,%rax
  80042155ba:	48 89 c2             	mov    %rax,%rdx
  80042155bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042155c1:	48 01 d0             	add    %rdx,%rax
  80042155c4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042155c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042155cf:	eb 24                	jmp    80042155f5 <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  80042155d1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155d4:	48 98                	cltq   
  80042155d6:	48 c1 e0 06          	shl    $0x6,%rax
  80042155da:	48 89 c2             	mov    %rax,%rdx
  80042155dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155e1:	48 01 c2             	add    %rax,%rdx
  80042155e4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155e7:	48 98                	cltq   
  80042155e9:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  80042155f0:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  80042155f1:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042155f5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155f8:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  80042155fb:	7c d4                	jl     80042155d1 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  80042155fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215601:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215605:	0f b7 c0             	movzwl %ax,%eax
  8004215608:	48 98                	cltq   
  800421560a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215611:	ff 
  8004215612:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004215616:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421561d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215621:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215625:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215629:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421562d:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215631:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215638:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421563c:	48 01 c8             	add    %rcx,%rax
  800421563f:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215646:	48 89 c7             	mov    %rax,%rdi
  8004215649:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215650:	00 00 00 
  8004215653:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004215655:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215659:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421565d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215661:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215665:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004215669:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421566d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215673:	48 29 c2             	sub    %rax,%rdx
  8004215676:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421567a:	48 01 c2             	add    %rax,%rdx
  800421567d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215681:	48 01 d0             	add    %rdx,%rax
  8004215684:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004215688:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421568f:	e9 04 05 00 00       	jmpq   8004215b98 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004215694:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215697:	48 98                	cltq   
  8004215699:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042156a0:	ff 
  80042156a1:	8b 00                	mov    (%rax),%eax
  80042156a3:	89 c2                	mov    %eax,%edx
  80042156a5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042156a9:	48 01 d0             	add    %rdx,%rax
  80042156ac:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042156b0:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042156b7:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042156bc:	48 85 c0             	test   %rax,%rax
  80042156bf:	74 35                	je     80042156f6 <read_section_headers+0x281>
  80042156c1:	48 b9 46 ab 21 04 80 	movabs $0x800421ab46,%rcx
  80042156c8:	00 00 00 
  80042156cb:	48 ba 5f ab 21 04 80 	movabs $0x800421ab5f,%rdx
  80042156d2:	00 00 00 
  80042156d5:	be 86 00 00 00       	mov    $0x86,%esi
  80042156da:	48 bf 74 ab 21 04 80 	movabs $0x800421ab74,%rdi
  80042156e1:	00 00 00 
  80042156e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156e9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042156f0:	00 00 00 
  80042156f3:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  80042156f6:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042156fd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004215701:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215705:	48 be 0b ab 21 04 80 	movabs $0x800421ab0b,%rsi
  800421570c:	00 00 00 
  800421570f:	48 89 c7             	mov    %rax,%rdi
  8004215712:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215719:	00 00 00 
  800421571c:	ff d0                	callq  *%rax
  800421571e:	85 c0                	test   %eax,%eax
  8004215720:	0f 85 d8 00 00 00    	jne    80042157fe <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215726:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215729:	48 98                	cltq   
  800421572b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215732:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215733:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215737:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421573a:	48 98                	cltq   
  800421573c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215743:	ff 
  8004215744:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215748:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421574f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215753:	48 01 c8             	add    %rcx,%rax
  8004215756:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421575d:	48 89 c7             	mov    %rax,%rdi
  8004215760:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215767:	00 00 00 
  800421576a:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421576c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421576f:	48 98                	cltq   
  8004215771:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215778:	ff 
  8004215779:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421577d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215780:	48 98                	cltq   
  8004215782:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215789:	ff 
  800421578a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421578e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004215792:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215796:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421579c:	48 29 c2             	sub    %rax,%rdx
  800421579f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042157a3:	48 01 c2             	add    %rax,%rdx
  80042157a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157aa:	48 01 c2             	add    %rax,%rdx
  80042157ad:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042157b4:	00 00 00 
  80042157b7:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042157bb:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042157c2:	00 00 00 
  80042157c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042157c9:	48 89 c2             	mov    %rax,%rdx
  80042157cc:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042157d3:	00 00 00 
  80042157d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  80042157da:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042157dd:	48 98                	cltq   
  80042157df:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157e6:	ff 
  80042157e7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042157eb:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042157f2:	00 00 00 
  80042157f5:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042157f9:	e9 96 03 00 00       	jmpq   8004215b94 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  80042157fe:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215802:	48 be 17 ab 21 04 80 	movabs $0x800421ab17,%rsi
  8004215809:	00 00 00 
  800421580c:	48 89 c7             	mov    %rax,%rdi
  800421580f:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215816:	00 00 00 
  8004215819:	ff d0                	callq  *%rax
  800421581b:	85 c0                	test   %eax,%eax
  800421581d:	0f 85 de 00 00 00    	jne    8004215901 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215823:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215826:	48 98                	cltq   
  8004215828:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421582f:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215830:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215834:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215837:	48 98                	cltq   
  8004215839:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215840:	ff 
  8004215841:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215845:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421584c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215850:	48 01 c8             	add    %rcx,%rax
  8004215853:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421585a:	48 89 c7             	mov    %rax,%rdi
  800421585d:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215864:	00 00 00 
  8004215867:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215869:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421586c:	48 98                	cltq   
  800421586e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215875:	ff 
  8004215876:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421587a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421587d:	48 98                	cltq   
  800421587f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215886:	ff 
  8004215887:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421588b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004215892:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215899:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421589f:	48 29 c2             	sub    %rax,%rdx
  80042158a2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042158a6:	48 01 c2             	add    %rax,%rdx
  80042158a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042158ad:	48 01 c2             	add    %rax,%rdx
  80042158b0:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042158b7:	00 00 00 
  80042158ba:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  80042158be:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042158c5:	00 00 00 
  80042158c8:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042158cc:	48 89 c2             	mov    %rax,%rdx
  80042158cf:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042158d6:	00 00 00 
  80042158d9:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  80042158dd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158e0:	48 98                	cltq   
  80042158e2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158e9:	ff 
  80042158ea:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042158ee:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042158f5:	00 00 00 
  80042158f8:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042158fc:	e9 93 02 00 00       	jmpq   8004215b94 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004215901:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215905:	48 be 2f ab 21 04 80 	movabs $0x800421ab2f,%rsi
  800421590c:	00 00 00 
  800421590f:	48 89 c7             	mov    %rax,%rdi
  8004215912:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215919:	00 00 00 
  800421591c:	ff d0                	callq  *%rax
  800421591e:	85 c0                	test   %eax,%eax
  8004215920:	0f 85 de 00 00 00    	jne    8004215a04 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215926:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215929:	48 98                	cltq   
  800421592b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215932:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215933:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215937:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421593a:	48 98                	cltq   
  800421593c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215943:	ff 
  8004215944:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215948:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421594f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215953:	48 01 c8             	add    %rcx,%rax
  8004215956:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421595d:	48 89 c7             	mov    %rax,%rdi
  8004215960:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215967:	00 00 00 
  800421596a:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421596c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421596f:	48 98                	cltq   
  8004215971:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215978:	ff 
  8004215979:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421597d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215980:	48 98                	cltq   
  8004215982:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215989:	ff 
  800421598a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421598e:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004215995:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421599c:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042159a2:	48 29 c2             	sub    %rax,%rdx
  80042159a5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042159a9:	48 01 c2             	add    %rax,%rdx
  80042159ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042159b0:	48 01 c2             	add    %rax,%rdx
  80042159b3:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042159ba:	00 00 00 
  80042159bd:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  80042159c1:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042159c8:	00 00 00 
  80042159cb:	48 8b 40 68          	mov    0x68(%rax),%rax
  80042159cf:	48 89 c2             	mov    %rax,%rdx
  80042159d2:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042159d9:	00 00 00 
  80042159dc:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  80042159e0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159e3:	48 98                	cltq   
  80042159e5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159ec:	ff 
  80042159ed:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042159f1:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  80042159f8:	00 00 00 
  80042159fb:	48 89 50 78          	mov    %rdx,0x78(%rax)
  80042159ff:	e9 90 01 00 00       	jmpq   8004215b94 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004215a04:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a08:	48 be 25 ab 21 04 80 	movabs $0x800421ab25,%rsi
  8004215a0f:	00 00 00 
  8004215a12:	48 89 c7             	mov    %rax,%rdi
  8004215a15:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215a1c:	00 00 00 
  8004215a1f:	ff d0                	callq  *%rax
  8004215a21:	85 c0                	test   %eax,%eax
  8004215a23:	75 65                	jne    8004215a8a <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004215a25:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a28:	48 98                	cltq   
  8004215a2a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a31:	ff 
  8004215a32:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215a36:	48 89 c2             	mov    %rax,%rdx
  8004215a39:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215a40:	00 00 00 
  8004215a43:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004215a47:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215a4e:	00 00 00 
  8004215a51:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004215a55:	48 89 c2             	mov    %rax,%rdx
  8004215a58:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215a5f:	00 00 00 
  8004215a62:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004215a66:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a69:	48 98                	cltq   
  8004215a6b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a72:	ff 
  8004215a73:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215a77:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215a7e:	00 00 00 
  8004215a81:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004215a85:	e9 0a 01 00 00       	jmpq   8004215b94 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004215a8a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a8e:	48 be 3b ab 21 04 80 	movabs $0x800421ab3b,%rsi
  8004215a95:	00 00 00 
  8004215a98:	48 89 c7             	mov    %rax,%rdi
  8004215a9b:	48 b8 1e f9 20 04 80 	movabs $0x800420f91e,%rax
  8004215aa2:	00 00 00 
  8004215aa5:	ff d0                	callq  *%rax
  8004215aa7:	85 c0                	test   %eax,%eax
  8004215aa9:	0f 85 e5 00 00 00    	jne    8004215b94 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215aaf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215ab2:	48 98                	cltq   
  8004215ab4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215abb:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215abc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215ac0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215ac3:	48 98                	cltq   
  8004215ac5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215acc:	ff 
  8004215acd:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215ad1:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215ad8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215adc:	48 01 c8             	add    %rcx,%rax
  8004215adf:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215ae6:	48 89 c7             	mov    %rax,%rdi
  8004215ae9:	48 b8 b4 5b 21 04 80 	movabs $0x8004215bb4,%rax
  8004215af0:	00 00 00 
  8004215af3:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215af5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215af8:	48 98                	cltq   
  8004215afa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b01:	ff 
  8004215b02:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215b06:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b09:	48 98                	cltq   
  8004215b0b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b12:	ff 
  8004215b13:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215b17:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004215b1e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215b25:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215b2b:	48 29 c2             	sub    %rax,%rdx
  8004215b2e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215b32:	48 01 c2             	add    %rax,%rdx
  8004215b35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b39:	48 01 c2             	add    %rax,%rdx
  8004215b3c:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215b43:	00 00 00 
  8004215b46:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004215b4d:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215b54:	00 00 00 
  8004215b57:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004215b5e:	48 89 c2             	mov    %rax,%rdx
  8004215b61:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215b68:	00 00 00 
  8004215b6b:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004215b72:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b75:	48 98                	cltq   
  8004215b77:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b7e:	ff 
  8004215b7f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215b83:	48 b8 e0 e6 22 04 80 	movabs $0x800422e6e0,%rax
  8004215b8a:	00 00 00 
  8004215b8d:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004215b94:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215b98:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b9b:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215b9e:	0f 8c f0 fa ff ff    	jl     8004215694 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004215ba4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215ba8:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215baf:	48 01 d0             	add    %rdx,%rax
}
  8004215bb2:	c9                   	leaveq 
  8004215bb3:	c3                   	retq   

0000008004215bb4 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004215bb4:	55                   	push   %rbp
  8004215bb5:	48 89 e5             	mov    %rsp,%rbp
  8004215bb8:	48 83 ec 30          	sub    $0x30,%rsp
  8004215bbc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215bc0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004215bc4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004215bc8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004215bcc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215bd0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004215bd4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215bd8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215bdc:	48 01 d0             	add    %rdx,%rax
  8004215bdf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004215be3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215be7:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215bec:	48 85 c0             	test   %rax,%rax
  8004215bef:	74 35                	je     8004215c26 <readseg+0x72>
  8004215bf1:	48 b9 82 ab 21 04 80 	movabs $0x800421ab82,%rcx
  8004215bf8:	00 00 00 
  8004215bfb:	48 ba 5f ab 21 04 80 	movabs $0x800421ab5f,%rdx
  8004215c02:	00 00 00 
  8004215c05:	be c0 00 00 00       	mov    $0xc0,%esi
  8004215c0a:	48 bf 74 ab 21 04 80 	movabs $0x800421ab74,%rdi
  8004215c11:	00 00 00 
  8004215c14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c19:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004215c20:	00 00 00 
  8004215c23:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215c26:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215c2d:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215c2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215c32:	48 c1 e8 09          	shr    $0x9,%rax
  8004215c36:	48 83 c0 01          	add    $0x1,%rax
  8004215c3a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215c3e:	eb 3c                	jmp    8004215c7c <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004215c40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215c44:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215c48:	48 89 d6             	mov    %rdx,%rsi
  8004215c4b:	48 89 c7             	mov    %rax,%rdi
  8004215c4e:	48 b8 44 5d 21 04 80 	movabs $0x8004215d44,%rax
  8004215c55:	00 00 00 
  8004215c58:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215c5a:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004215c61:	00 
		*kvoffset += SECTSIZE;
  8004215c62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c66:	48 8b 00             	mov    (%rax),%rax
  8004215c69:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215c70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c74:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215c77:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215c7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215c80:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004215c84:	72 ba                	jb     8004215c40 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215c86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215c8a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215c8f:	48 89 c2             	mov    %rax,%rdx
  8004215c92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215c96:	48 01 d0             	add    %rdx,%rax
  8004215c99:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215c9f:	76 2f                	jbe    8004215cd0 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215ca1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215ca5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215ca9:	48 89 d6             	mov    %rdx,%rsi
  8004215cac:	48 89 c7             	mov    %rax,%rdi
  8004215caf:	48 b8 44 5d 21 04 80 	movabs $0x8004215d44,%rax
  8004215cb6:	00 00 00 
  8004215cb9:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215cbb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215cbf:	48 8b 00             	mov    (%rax),%rax
  8004215cc2:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215cc9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215ccd:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215cd0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215cd4:	48 8b 00             	mov    (%rax),%rax
  8004215cd7:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215cdc:	48 85 c0             	test   %rax,%rax
  8004215cdf:	74 35                	je     8004215d16 <readseg+0x162>
  8004215ce1:	48 b9 95 ab 21 04 80 	movabs $0x800421ab95,%rcx
  8004215ce8:	00 00 00 
  8004215ceb:	48 ba 5f ab 21 04 80 	movabs $0x800421ab5f,%rdx
  8004215cf2:	00 00 00 
  8004215cf5:	be d6 00 00 00       	mov    $0xd6,%esi
  8004215cfa:	48 bf 74 ab 21 04 80 	movabs $0x800421ab74,%rdi
  8004215d01:	00 00 00 
  8004215d04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d09:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004215d10:	00 00 00 
  8004215d13:	41 ff d0             	callq  *%r8
}
  8004215d16:	c9                   	leaveq 
  8004215d17:	c3                   	retq   

0000008004215d18 <waitdisk>:

void
waitdisk(void)
{
  8004215d18:	55                   	push   %rbp
  8004215d19:	48 89 e5             	mov    %rsp,%rbp
  8004215d1c:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004215d20:	90                   	nop
  8004215d21:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215d28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215d2b:	89 c2                	mov    %eax,%edx
  8004215d2d:	ec                   	in     (%dx),%al
  8004215d2e:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004215d31:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215d35:	0f b6 c0             	movzbl %al,%eax
  8004215d38:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215d3d:	83 f8 40             	cmp    $0x40,%eax
  8004215d40:	75 df                	jne    8004215d21 <waitdisk+0x9>
		/* do nothing */;
}
  8004215d42:	c9                   	leaveq 
  8004215d43:	c3                   	retq   

0000008004215d44 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004215d44:	55                   	push   %rbp
  8004215d45:	48 89 e5             	mov    %rsp,%rbp
  8004215d48:	48 83 ec 60          	sub    $0x60,%rsp
  8004215d4c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004215d50:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004215d54:	48 b8 18 5d 21 04 80 	movabs $0x8004215d18,%rax
  8004215d5b:	00 00 00 
  8004215d5e:	ff d0                	callq  *%rax
  8004215d60:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215d67:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215d6b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215d6f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d72:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004215d73:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215d77:	0f b6 c0             	movzbl %al,%eax
  8004215d7a:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215d81:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004215d84:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215d88:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215d8b:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215d8c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215d90:	48 c1 e8 08          	shr    $0x8,%rax
  8004215d94:	0f b6 c0             	movzbl %al,%eax
  8004215d97:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215d9e:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215da1:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004215da5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215da8:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215da9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215dad:	48 c1 e8 10          	shr    $0x10,%rax
  8004215db1:	0f b6 c0             	movzbl %al,%eax
  8004215db4:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215dbb:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215dbe:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004215dc2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215dc5:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004215dc6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215dca:	48 c1 e8 18          	shr    $0x18,%rax
  8004215dce:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215dd1:	0f b6 c0             	movzbl %al,%eax
  8004215dd4:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215ddb:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215dde:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215de2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215de5:	ee                   	out    %al,(%dx)
  8004215de6:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215ded:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215df1:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215df5:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215df8:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215df9:	48 b8 18 5d 21 04 80 	movabs $0x8004215d18,%rax
  8004215e00:	00 00 00 
  8004215e03:	ff d0                	callq  *%rax
  8004215e05:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215e0c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215e10:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004215e14:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215e1b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215e1e:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215e22:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004215e25:	48 89 ce             	mov    %rcx,%rsi
  8004215e28:	48 89 f7             	mov    %rsi,%rdi
  8004215e2b:	89 c1                	mov    %eax,%ecx
  8004215e2d:	fc                   	cld    
  8004215e2e:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215e30:	89 c8                	mov    %ecx,%eax
  8004215e32:	48 89 fe             	mov    %rdi,%rsi
  8004215e35:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215e39:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215e3c:	c9                   	leaveq 
  8004215e3d:	c3                   	retq   
  8004215e3e:	66 90                	xchg   %ax,%ax

0000008004215e40 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215e40:	fa                   	cli    
	xorw    %ax, %ax
  8004215e41:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004215e43:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215e45:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215e47:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215e49:	0f 01 16             	lgdt   (%rsi)
  8004215e4c:	e0 70                	loopne 8004215ebe <start64+0x10>
	movl    %cr0, %eax
  8004215e4e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215e51:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004215e55:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215e58:	ea                   	(bad)  
  8004215e59:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215e5d <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215e5d:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215e61:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215e63:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215e65:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215e67:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215e6b:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215e6d:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004215e6f:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  8004215e74:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004215e77:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421cf3e <error_string+0x2c1e>
	movl    %cr0, %eax
  8004215e7e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215e81:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004215e84:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004215e87:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215e8c:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215e8f:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004215e94:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004215e96:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215e9a:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215e9c:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215e9f:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004215ea4:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004215ea7:	ea                   	(bad)  
  8004215ea8:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215ea9:	70 00                	jo     8004215eab <start32+0x4e>
  8004215eab:	00 08                	add    %cl,(%rax)
	...

0000008004215eae <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215eae:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215eb2:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215eb4:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215eb6:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215eb8:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215ebc:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215ebe:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215ec0:	48 a1 48 d4 60 04 80 	movabs 0x800460d448,%rax
  8004215ec7:	00 00 00 
	movq    %rax,%rsp
  8004215eca:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215ecd:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004215ed4:	48 b8 78 04 20 04 80 	movabs $0x8004200478,%rax
  8004215edb:	00 00 00 
	call    *%rax
  8004215ede:	ff d0                	callq  *%rax

0000008004215ee0 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215ee0:	eb fe                	jmp    8004215ee0 <spin>
  8004215ee2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215ee8 <gdt>:
	...
  8004215ef0:	ff                   	(bad)  
  8004215ef1:	ff 00                	incl   (%rax)
  8004215ef3:	00 00                	add    %al,(%rax)
  8004215ef5:	9a                   	(bad)  
  8004215ef6:	af                   	scas   %es:(%rdi),%eax
  8004215ef7:	00 ff                	add    %bh,%bh
  8004215ef9:	ff 00                	incl   (%rax)
  8004215efb:	00 00                	add    %al,(%rax)
  8004215efd:	92                   	xchg   %eax,%edx
  8004215efe:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215f00 <gdtdesc>:
  8004215f00:	17                   	(bad)  
  8004215f01:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004215f07:	90                   	nop

0000008004215f08 <gdt32>:
	...
  8004215f10:	ff                   	(bad)  
  8004215f11:	ff 00                	incl   (%rax)
  8004215f13:	00 00                	add    %al,(%rax)
  8004215f15:	9a                   	(bad)  
  8004215f16:	cf                   	iret   
  8004215f17:	00 ff                	add    %bh,%bh
  8004215f19:	ff 00                	incl   (%rax)
  8004215f1b:	00 00                	add    %al,(%rax)
  8004215f1d:	92                   	xchg   %eax,%edx
  8004215f1e:	cf                   	iret   
	...

0000008004215f20 <gdt32desc>:
  8004215f20:	17                   	(bad)  
  8004215f21:	00 c8                	add    %cl,%al
  8004215f23:	70 00                	jo     8004215f25 <gdt32desc+0x5>
	...

0000008004215f26 <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004215f26:	90                   	nop

0000008004215f27 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004215f27:	55                   	push   %rbp
  8004215f28:	48 89 e5             	mov    %rsp,%rbp
  8004215f2b:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215f2f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215f33:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004215f36:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215f3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215f44:	eb 1a                	jmp    8004215f60 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004215f46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f49:	48 63 d0             	movslq %eax,%rdx
  8004215f4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f50:	48 01 d0             	add    %rdx,%rax
  8004215f53:	0f b6 00             	movzbl (%rax),%eax
  8004215f56:	0f b6 c0             	movzbl %al,%eax
  8004215f59:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215f5c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215f60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f63:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215f66:	7c de                	jl     8004215f46 <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215f68:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215f6b:	c9                   	leaveq 
  8004215f6c:	c3                   	retq   

0000008004215f6d <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215f6d:	55                   	push   %rbp
  8004215f6e:	48 89 e5             	mov    %rsp,%rbp
  8004215f71:	48 83 ec 40          	sub    $0x40,%rsp
  8004215f75:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215f79:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215f7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215f80:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215f84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f88:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215f8c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215f8f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215f92:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004215f99:	00 00 00 
  8004215f9c:	48 8b 00             	mov    (%rax),%rax
  8004215f9f:	48 39 c2             	cmp    %rax,%rdx
  8004215fa2:	72 32                	jb     8004215fd6 <mpsearch1+0x69>
  8004215fa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215fa8:	48 89 c1             	mov    %rax,%rcx
  8004215fab:	48 ba b0 ab 21 04 80 	movabs $0x800421abb0,%rdx
  8004215fb2:	00 00 00 
  8004215fb5:	be 58 00 00 00       	mov    $0x58,%esi
  8004215fba:	48 bf d3 ab 21 04 80 	movabs $0x800421abd3,%rdi
  8004215fc1:	00 00 00 
  8004215fc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215fc9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004215fd0:	00 00 00 
  8004215fd3:	41 ff d0             	callq  *%r8
  8004215fd6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215fdd:	00 00 00 
  8004215fe0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215fe4:	48 01 d0             	add    %rdx,%rax
  8004215fe7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215feb:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215fee:	48 63 d0             	movslq %eax,%rdx
  8004215ff1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215ff5:	48 01 d0             	add    %rdx,%rax
  8004215ff8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215ffc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216000:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216004:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004216007:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421600a:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004216011:	00 00 00 
  8004216014:	48 8b 00             	mov    (%rax),%rax
  8004216017:	48 39 c2             	cmp    %rax,%rdx
  800421601a:	72 32                	jb     800421604e <mpsearch1+0xe1>
  800421601c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216020:	48 89 c1             	mov    %rax,%rcx
  8004216023:	48 ba b0 ab 21 04 80 	movabs $0x800421abb0,%rdx
  800421602a:	00 00 00 
  800421602d:	be 58 00 00 00       	mov    $0x58,%esi
  8004216032:	48 bf d3 ab 21 04 80 	movabs $0x800421abd3,%rdi
  8004216039:	00 00 00 
  800421603c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216041:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004216048:	00 00 00 
  800421604b:	41 ff d0             	callq  *%r8
  800421604e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216055:	00 00 00 
  8004216058:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421605c:	48 01 d0             	add    %rdx,%rax
  800421605f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004216063:	eb 4d                	jmp    80042160b2 <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004216065:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216069:	ba 04 00 00 00       	mov    $0x4,%edx
  800421606e:	48 be e3 ab 21 04 80 	movabs $0x800421abe3,%rsi
  8004216075:	00 00 00 
  8004216078:	48 89 c7             	mov    %rax,%rdi
  800421607b:	48 b8 2b fc 20 04 80 	movabs $0x800420fc2b,%rax
  8004216082:	00 00 00 
  8004216085:	ff d0                	callq  *%rax
  8004216087:	85 c0                	test   %eax,%eax
  8004216089:	75 22                	jne    80042160ad <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  800421608b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421608f:	be 10 00 00 00       	mov    $0x10,%esi
  8004216094:	48 89 c7             	mov    %rax,%rdi
  8004216097:	48 b8 27 5f 21 04 80 	movabs $0x8004215f27,%rax
  800421609e:	00 00 00 
  80042160a1:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042160a3:	84 c0                	test   %al,%al
  80042160a5:	75 06                	jne    80042160ad <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  80042160a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160ab:	eb 14                	jmp    80042160c1 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  80042160ad:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  80042160b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160b6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042160ba:	72 a9                	jb     8004216065 <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  80042160bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042160c1:	c9                   	leaveq 
  80042160c2:	c3                   	retq   

00000080042160c3 <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  80042160c3:	55                   	push   %rbp
  80042160c4:	48 89 e5             	mov    %rsp,%rbp
  80042160c7:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  80042160cb:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042160d2:	00 
  80042160d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160d7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042160db:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042160de:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042160e1:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  80042160e8:	00 00 00 
  80042160eb:	48 8b 00             	mov    (%rax),%rax
  80042160ee:	48 39 c2             	cmp    %rax,%rdx
  80042160f1:	72 32                	jb     8004216125 <mpsearch+0x62>
  80042160f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160f7:	48 89 c1             	mov    %rax,%rcx
  80042160fa:	48 ba b0 ab 21 04 80 	movabs $0x800421abb0,%rdx
  8004216101:	00 00 00 
  8004216104:	be 70 00 00 00       	mov    $0x70,%esi
  8004216109:	48 bf d3 ab 21 04 80 	movabs $0x800421abd3,%rdi
  8004216110:	00 00 00 
  8004216113:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216118:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421611f:	00 00 00 
  8004216122:	41 ff d0             	callq  *%r8
  8004216125:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421612c:	00 00 00 
  800421612f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216133:	48 01 d0             	add    %rdx,%rax
  8004216136:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  800421613a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421613e:	48 83 c0 0e          	add    $0xe,%rax
  8004216142:	0f b7 00             	movzwl (%rax),%eax
  8004216145:	0f b7 c0             	movzwl %ax,%eax
  8004216148:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421614b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421614f:	74 2c                	je     800421617d <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004216151:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004216155:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216158:	be 00 04 00 00       	mov    $0x400,%esi
  800421615d:	48 89 c7             	mov    %rax,%rdi
  8004216160:	48 b8 6d 5f 21 04 80 	movabs $0x8004215f6d,%rax
  8004216167:	00 00 00 
  800421616a:	ff d0                	callq  *%rax
  800421616c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216170:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216175:	74 49                	je     80042161c0 <mpsearch+0xfd>
			return mp;
  8004216177:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421617b:	eb 59                	jmp    80042161d6 <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  800421617d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216181:	48 83 c0 13          	add    $0x13,%rax
  8004216185:	0f b7 00             	movzwl (%rax),%eax
  8004216188:	0f b7 c0             	movzwl %ax,%eax
  800421618b:	c1 e0 0a             	shl    $0xa,%eax
  800421618e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004216191:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216194:	2d 00 04 00 00       	sub    $0x400,%eax
  8004216199:	89 c0                	mov    %eax,%eax
  800421619b:	be 00 04 00 00       	mov    $0x400,%esi
  80042161a0:	48 89 c7             	mov    %rax,%rdi
  80042161a3:	48 b8 6d 5f 21 04 80 	movabs $0x8004215f6d,%rax
  80042161aa:	00 00 00 
  80042161ad:	ff d0                	callq  *%rax
  80042161af:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042161b3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042161b8:	74 06                	je     80042161c0 <mpsearch+0xfd>
			return mp;
  80042161ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042161be:	eb 16                	jmp    80042161d6 <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  80042161c0:	be 00 00 01 00       	mov    $0x10000,%esi
  80042161c5:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  80042161ca:	48 b8 6d 5f 21 04 80 	movabs $0x8004215f6d,%rax
  80042161d1:	00 00 00 
  80042161d4:	ff d0                	callq  *%rax
}
  80042161d6:	c9                   	leaveq 
  80042161d7:	c3                   	retq   

00000080042161d8 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  80042161d8:	55                   	push   %rbp
  80042161d9:	48 89 e5             	mov    %rsp,%rbp
  80042161dc:	48 83 ec 30          	sub    $0x30,%rsp
  80042161e0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  80042161e4:	48 b8 c3 60 21 04 80 	movabs $0x80042160c3,%rax
  80042161eb:	00 00 00 
  80042161ee:	ff d0                	callq  *%rax
  80042161f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042161f4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042161f9:	75 0a                	jne    8004216205 <mpconfig+0x2d>
		return NULL;
  80042161fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216200:	e9 f6 01 00 00       	jmpq   80042163fb <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004216205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216209:	8b 40 04             	mov    0x4(%rax),%eax
  800421620c:	85 c0                	test   %eax,%eax
  800421620e:	74 0c                	je     800421621c <mpconfig+0x44>
  8004216210:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216214:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216218:	84 c0                	test   %al,%al
  800421621a:	74 25                	je     8004216241 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  800421621c:	48 bf e8 ab 21 04 80 	movabs $0x800421abe8,%rdi
  8004216223:	00 00 00 
  8004216226:	b8 00 00 00 00       	mov    $0x0,%eax
  800421622b:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004216232:	00 00 00 
  8004216235:	ff d2                	callq  *%rdx
		return NULL;
  8004216237:	b8 00 00 00 00       	mov    $0x0,%eax
  800421623c:	e9 ba 01 00 00       	jmpq   80042163fb <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216241:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216245:	8b 40 04             	mov    0x4(%rax),%eax
  8004216248:	89 c0                	mov    %eax,%eax
  800421624a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421624e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216252:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216256:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216259:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421625c:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004216263:	00 00 00 
  8004216266:	48 8b 00             	mov    (%rax),%rax
  8004216269:	48 39 c2             	cmp    %rax,%rdx
  800421626c:	72 32                	jb     80042162a0 <mpconfig+0xc8>
  800421626e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216272:	48 89 c1             	mov    %rax,%rcx
  8004216275:	48 ba b0 ab 21 04 80 	movabs $0x800421abb0,%rdx
  800421627c:	00 00 00 
  800421627f:	be 91 00 00 00       	mov    $0x91,%esi
  8004216284:	48 bf d3 ab 21 04 80 	movabs $0x800421abd3,%rdi
  800421628b:	00 00 00 
  800421628e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216293:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421629a:	00 00 00 
  800421629d:	41 ff d0             	callq  *%r8
  80042162a0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042162a7:	00 00 00 
  80042162aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042162ae:	48 01 d0             	add    %rdx,%rax
  80042162b1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042162b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042162b9:	ba 04 00 00 00       	mov    $0x4,%edx
  80042162be:	48 be 15 ac 21 04 80 	movabs $0x800421ac15,%rsi
  80042162c5:	00 00 00 
  80042162c8:	48 89 c7             	mov    %rax,%rdi
  80042162cb:	48 b8 2b fc 20 04 80 	movabs $0x800420fc2b,%rax
  80042162d2:	00 00 00 
  80042162d5:	ff d0                	callq  *%rax
  80042162d7:	85 c0                	test   %eax,%eax
  80042162d9:	74 25                	je     8004216300 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  80042162db:	48 bf 20 ac 21 04 80 	movabs $0x800421ac20,%rdi
  80042162e2:	00 00 00 
  80042162e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162ea:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042162f1:	00 00 00 
  80042162f4:	ff d2                	callq  *%rdx
		return NULL;
  80042162f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162fb:	e9 fb 00 00 00       	jmpq   80042163fb <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216300:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216304:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216308:	0f b7 d0             	movzwl %ax,%edx
  800421630b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421630f:	89 d6                	mov    %edx,%esi
  8004216311:	48 89 c7             	mov    %rax,%rdi
  8004216314:	48 b8 27 5f 21 04 80 	movabs $0x8004215f27,%rax
  800421631b:	00 00 00 
  800421631e:	ff d0                	callq  *%rax
  8004216320:	84 c0                	test   %al,%al
  8004216322:	74 25                	je     8004216349 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004216324:	48 bf 58 ac 21 04 80 	movabs $0x800421ac58,%rdi
  800421632b:	00 00 00 
  800421632e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216333:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421633a:	00 00 00 
  800421633d:	ff d2                	callq  *%rdx
		return NULL;
  800421633f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216344:	e9 b2 00 00 00       	jmpq   80042163fb <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216349:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421634d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216351:	3c 01                	cmp    $0x1,%al
  8004216353:	74 3b                	je     8004216390 <mpconfig+0x1b8>
  8004216355:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216359:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  800421635d:	3c 04                	cmp    $0x4,%al
  800421635f:	74 2f                	je     8004216390 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216361:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216365:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216369:	0f b6 c0             	movzbl %al,%eax
  800421636c:	89 c6                	mov    %eax,%esi
  800421636e:	48 bf 80 ac 21 04 80 	movabs $0x800421ac80,%rdi
  8004216375:	00 00 00 
  8004216378:	b8 00 00 00 00       	mov    $0x0,%eax
  800421637d:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004216384:	00 00 00 
  8004216387:	ff d2                	callq  *%rdx
		return NULL;
  8004216389:	b8 00 00 00 00       	mov    $0x0,%eax
  800421638e:	eb 6b                	jmp    80042163fb <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004216390:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216394:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004216398:	0f b7 c0             	movzwl %ax,%eax
  800421639b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421639f:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042163a3:	0f b7 ca             	movzwl %dx,%ecx
  80042163a6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042163aa:	48 01 ca             	add    %rcx,%rdx
  80042163ad:	89 c6                	mov    %eax,%esi
  80042163af:	48 89 d7             	mov    %rdx,%rdi
  80042163b2:	48 b8 27 5f 21 04 80 	movabs $0x8004215f27,%rax
  80042163b9:	00 00 00 
  80042163bc:	ff d0                	callq  *%rax
  80042163be:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042163c2:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042163c6:	38 d0                	cmp    %dl,%al
  80042163c8:	74 22                	je     80042163ec <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  80042163ca:	48 bf a0 ac 21 04 80 	movabs $0x800421aca0,%rdi
  80042163d1:	00 00 00 
  80042163d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163d9:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042163e0:	00 00 00 
  80042163e3:	ff d2                	callq  *%rdx
		return NULL;
  80042163e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163ea:	eb 0f                	jmp    80042163fb <mpconfig+0x223>
	}
	*pmp = mp;
  80042163ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042163f0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042163f4:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  80042163f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  80042163fb:	c9                   	leaveq 
  80042163fc:	c3                   	retq   

00000080042163fd <mp_init>:

void
mp_init(void)
{
  80042163fd:	55                   	push   %rbp
  80042163fe:	48 89 e5             	mov    %rsp,%rbp
  8004216401:	53                   	push   %rbx
  8004216402:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004216406:	48 b8 e0 f3 60 04 80 	movabs $0x800460f3e0,%rax
  800421640d:	00 00 00 
  8004216410:	48 bb 20 f0 60 04 80 	movabs $0x800460f020,%rbx
  8004216417:	00 00 00 
  800421641a:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  800421641d:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216421:	48 89 c7             	mov    %rax,%rdi
  8004216424:	48 b8 d8 61 21 04 80 	movabs $0x80042161d8,%rax
  800421642b:	00 00 00 
  800421642e:	ff d0                	callq  *%rax
  8004216430:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216434:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216439:	75 05                	jne    8004216440 <mp_init+0x43>
		return;
  800421643b:	e9 71 03 00 00       	jmpq   80042167b1 <mp_init+0x3b4>
	ismp = 1;
  8004216440:	48 b8 00 f0 60 04 80 	movabs $0x800460f000,%rax
  8004216447:	00 00 00 
  800421644a:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216450:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216454:	8b 40 24             	mov    0x24(%rax),%eax
  8004216457:	89 c2                	mov    %eax,%edx
  8004216459:	48 b8 00 00 69 04 80 	movabs $0x8004690000,%rax
  8004216460:	00 00 00 
  8004216463:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216466:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421646a:	48 83 c0 2c          	add    $0x2c,%rax
  800421646e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004216472:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216479:	e9 18 02 00 00       	jmpq   8004216696 <mp_init+0x299>
		switch (*p) {
  800421647e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216482:	0f b6 00             	movzbl (%rax),%eax
  8004216485:	0f b6 c0             	movzbl %al,%eax
  8004216488:	85 c0                	test   %eax,%eax
  800421648a:	74 16                	je     80042164a2 <mp_init+0xa5>
  800421648c:	85 c0                	test   %eax,%eax
  800421648e:	0f 88 b9 01 00 00    	js     800421664d <mp_init+0x250>
  8004216494:	83 f8 04             	cmp    $0x4,%eax
  8004216497:	0f 8f b0 01 00 00    	jg     800421664d <mp_init+0x250>
  800421649d:	e9 a4 01 00 00       	jmpq   8004216646 <mp_init+0x249>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042164a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042164a6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042164aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042164ae:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042164b2:	0f b6 c0             	movzbl %al,%eax
  80042164b5:	83 e0 02             	and    $0x2,%eax
  80042164b8:	85 c0                	test   %eax,%eax
  80042164ba:	74 51                	je     800421650d <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  80042164bc:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042164c3:	00 00 00 
  80042164c6:	8b 00                	mov    (%rax),%eax
  80042164c8:	48 98                	cltq   
  80042164ca:	48 c1 e0 03          	shl    $0x3,%rax
  80042164ce:	48 89 c2             	mov    %rax,%rdx
  80042164d1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042164d5:	48 29 c2             	sub    %rax,%rdx
  80042164d8:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  80042164df:	00 00 00 
  80042164e2:	48 01 c2             	add    %rax,%rdx
  80042164e5:	48 b8 e0 f3 60 04 80 	movabs $0x800460f3e0,%rax
  80042164ec:	00 00 00 
  80042164ef:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  80042164f2:	48 bf cd ac 21 04 80 	movabs $0x800421accd,%rdi
  80042164f9:	00 00 00 
  80042164fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216501:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004216508:	00 00 00 
  800421650b:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  800421650d:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  8004216514:	00 00 00 
  8004216517:	8b 00                	mov    (%rax),%eax
  8004216519:	83 f8 07             	cmp    $0x7,%eax
  800421651c:	0f 8f f5 00 00 00    	jg     8004216617 <mp_init+0x21a>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  8004216522:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216526:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  800421652a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421652e:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216532:	0f b6 f0             	movzbl %al,%esi
  8004216535:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216539:	8b 78 08             	mov    0x8(%rax),%edi
  800421653c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216540:	4c 8d 50 04          	lea    0x4(%rax),%r10
  8004216544:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216548:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  800421654c:	0f b6 c8             	movzbl %al,%ecx
  800421654f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216553:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004216557:	0f b6 d0             	movzbl %al,%edx
  800421655a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421655e:	0f b6 00             	movzbl (%rax),%eax
  8004216561:	0f b6 c0             	movzbl %al,%eax
  8004216564:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004216569:	89 34 24             	mov    %esi,(%rsp)
  800421656c:	41 89 f9             	mov    %edi,%r9d
  800421656f:	4d 89 d0             	mov    %r10,%r8
  8004216572:	89 c6                	mov    %eax,%esi
  8004216574:	48 bf e0 ac 21 04 80 	movabs $0x800421ace0,%rdi
  800421657b:	00 00 00 
  800421657e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216583:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  800421658a:	00 00 00 
  800421658d:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004216590:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216594:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216598:	0f b6 c0             	movzbl %al,%eax
  800421659b:	83 e0 01             	and    $0x1,%eax
  800421659e:	85 c0                	test   %eax,%eax
  80042165a0:	74 58                	je     80042165fa <mp_init+0x1fd>
					cpus[ncpu].cpu_id = ncpu;
  80042165a2:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042165a9:	00 00 00 
  80042165ac:	8b 10                	mov    (%rax),%edx
  80042165ae:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042165b5:	00 00 00 
  80042165b8:	8b 00                	mov    (%rax),%eax
  80042165ba:	89 c1                	mov    %eax,%ecx
  80042165bc:	48 be 20 f0 60 04 80 	movabs $0x800460f020,%rsi
  80042165c3:	00 00 00 
  80042165c6:	48 63 c2             	movslq %edx,%rax
  80042165c9:	48 c1 e0 03          	shl    $0x3,%rax
  80042165cd:	48 89 c2             	mov    %rax,%rdx
  80042165d0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042165d4:	48 29 c2             	sub    %rax,%rdx
  80042165d7:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  80042165db:	88 08                	mov    %cl,(%rax)
					ncpu++;
  80042165dd:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042165e4:	00 00 00 
  80042165e7:	8b 00                	mov    (%rax),%eax
  80042165e9:	8d 50 01             	lea    0x1(%rax),%edx
  80042165ec:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042165f3:	00 00 00 
  80042165f6:	89 10                	mov    %edx,(%rax)
  80042165f8:	eb 45                	jmp    800421663f <mp_init+0x242>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  80042165fa:	48 bf 30 ad 21 04 80 	movabs $0x800421ad30,%rdi
  8004216601:	00 00 00 
  8004216604:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216609:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004216610:	00 00 00 
  8004216613:	ff d2                	callq  *%rdx
  8004216615:	eb 28                	jmp    800421663f <mp_init+0x242>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004216617:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421661b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  800421661f:	0f b6 c0             	movzbl %al,%eax
  8004216622:	89 c6                	mov    %eax,%esi
  8004216624:	48 bf 60 ad 21 04 80 	movabs $0x800421ad60,%rdi
  800421662b:	00 00 00 
  800421662e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216633:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421663a:	00 00 00 
  800421663d:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  800421663f:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004216644:	eb 4c                	jmp    8004216692 <mp_init+0x295>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  8004216646:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  800421664b:	eb 45                	jmp    8004216692 <mp_init+0x295>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  800421664d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216651:	0f b6 00             	movzbl (%rax),%eax
  8004216654:	0f b6 c0             	movzbl %al,%eax
  8004216657:	89 c6                	mov    %eax,%esi
  8004216659:	48 bf 88 ad 21 04 80 	movabs $0x800421ad88,%rdi
  8004216660:	00 00 00 
  8004216663:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216668:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421666f:	00 00 00 
  8004216672:	ff d2                	callq  *%rdx
			ismp = 0;
  8004216674:	48 b8 00 f0 60 04 80 	movabs $0x800460f000,%rax
  800421667b:	00 00 00 
  800421667e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004216684:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216688:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421668c:	0f b7 c0             	movzwl %ax,%eax
  800421668f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216692:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004216696:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421669a:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421669e:	0f b7 c0             	movzwl %ax,%eax
  80042166a1:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042166a4:	0f 87 d4 fd ff ff    	ja     800421647e <mp_init+0x81>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  80042166aa:	48 b8 e0 f3 60 04 80 	movabs $0x800460f3e0,%rax
  80042166b1:	00 00 00 
  80042166b4:	48 8b 00             	mov    (%rax),%rax
  80042166b7:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  80042166be:	48 b8 00 f0 60 04 80 	movabs $0x800460f000,%rax
  80042166c5:	00 00 00 
  80042166c8:	8b 00                	mov    (%rax),%eax
  80042166ca:	85 c0                	test   %eax,%eax
  80042166cc:	75 41                	jne    800421670f <mp_init+0x312>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  80042166ce:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  80042166d5:	00 00 00 
  80042166d8:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042166de:	48 b8 00 00 69 04 80 	movabs $0x8004690000,%rax
  80042166e5:	00 00 00 
  80042166e8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042166ef:	48 bf a8 ad 21 04 80 	movabs $0x800421ada8,%rdi
  80042166f6:	00 00 00 
  80042166f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042166fe:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004216705:	00 00 00 
  8004216708:	ff d2                	callq  *%rdx
		return;
  800421670a:	e9 a2 00 00 00       	jmpq   80042167b1 <mp_init+0x3b4>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  800421670f:	48 b8 e8 f3 60 04 80 	movabs $0x800460f3e8,%rax
  8004216716:	00 00 00 
  8004216719:	8b 10                	mov    (%rax),%edx
  800421671b:	48 b8 e0 f3 60 04 80 	movabs $0x800460f3e0,%rax
  8004216722:	00 00 00 
  8004216725:	48 8b 00             	mov    (%rax),%rax
  8004216728:	0f b6 00             	movzbl (%rax),%eax
  800421672b:	0f b6 c0             	movzbl %al,%eax
  800421672e:	89 c6                	mov    %eax,%esi
  8004216730:	48 bf d4 ad 21 04 80 	movabs $0x800421add4,%rdi
  8004216737:	00 00 00 
  800421673a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421673f:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004216746:	00 00 00 
  8004216749:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  800421674b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421674f:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004216753:	84 c0                	test   %al,%al
  8004216755:	74 5a                	je     80042167b1 <mp_init+0x3b4>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004216757:	48 bf f8 ad 21 04 80 	movabs $0x800421adf8,%rdi
  800421675e:	00 00 00 
  8004216761:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216766:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421676d:	00 00 00 
  8004216770:	ff d2                	callq  *%rdx
  8004216772:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004216779:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421677d:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004216781:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004216784:	ee                   	out    %al,(%dx)
  8004216785:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800421678c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421678f:	89 c2                	mov    %eax,%edx
  8004216791:	ec                   	in     (%dx),%al
  8004216792:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004216795:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004216799:	83 c8 01             	or     $0x1,%eax
  800421679c:	0f b6 c0             	movzbl %al,%eax
  800421679f:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  80042167a6:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042167a9:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042167ad:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042167b0:	ee                   	out    %al,(%dx)
	}
}
  80042167b1:	48 83 c4 58          	add    $0x58,%rsp
  80042167b5:	5b                   	pop    %rbx
  80042167b6:	5d                   	pop    %rbp
  80042167b7:	c3                   	retq   

00000080042167b8 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  80042167b8:	55                   	push   %rbp
  80042167b9:	48 89 e5             	mov    %rsp,%rbp
  80042167bc:	48 83 ec 08          	sub    $0x8,%rsp
  80042167c0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042167c3:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042167c6:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  80042167cd:	00 00 00 
  80042167d0:	48 8b 00             	mov    (%rax),%rax
  80042167d3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042167d6:	48 63 d2             	movslq %edx,%rdx
  80042167d9:	48 c1 e2 02          	shl    $0x2,%rdx
  80042167dd:	48 01 c2             	add    %rax,%rdx
  80042167e0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042167e3:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042167e5:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  80042167ec:	00 00 00 
  80042167ef:	48 8b 00             	mov    (%rax),%rax
  80042167f2:	48 83 c0 20          	add    $0x20,%rax
  80042167f6:	8b 00                	mov    (%rax),%eax
}
  80042167f8:	c9                   	leaveq 
  80042167f9:	c3                   	retq   

00000080042167fa <lapic_init>:

void
lapic_init(void)
{
  80042167fa:	55                   	push   %rbp
  80042167fb:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042167fe:	48 b8 00 00 69 04 80 	movabs $0x8004690000,%rax
  8004216805:	00 00 00 
  8004216808:	48 8b 00             	mov    (%rax),%rax
  800421680b:	48 85 c0             	test   %rax,%rax
  800421680e:	75 05                	jne    8004216815 <lapic_init+0x1b>
		return;
  8004216810:	e9 da 01 00 00       	jmpq   80042169ef <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004216815:	48 b8 00 00 69 04 80 	movabs $0x8004690000,%rax
  800421681c:	00 00 00 
  800421681f:	48 8b 00             	mov    (%rax),%rax
  8004216822:	be 00 10 00 00       	mov    $0x1000,%esi
  8004216827:	48 89 c7             	mov    %rax,%rdi
  800421682a:	48 b8 30 3b 20 04 80 	movabs $0x8004203b30,%rax
  8004216831:	00 00 00 
  8004216834:	ff d0                	callq  *%rax
  8004216836:	48 ba 08 00 69 04 80 	movabs $0x8004690008,%rdx
  800421683d:	00 00 00 
  8004216840:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004216843:	be 27 01 00 00       	mov    $0x127,%esi
  8004216848:	bf 3c 00 00 00       	mov    $0x3c,%edi
  800421684d:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216854:	00 00 00 
  8004216857:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004216859:	be 0b 00 00 00       	mov    $0xb,%esi
  800421685e:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004216863:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  800421686a:	00 00 00 
  800421686d:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  800421686f:	be 20 00 02 00       	mov    $0x20020,%esi
  8004216874:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216879:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216880:	00 00 00 
  8004216883:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004216885:	be 80 96 98 00       	mov    $0x989680,%esi
  800421688a:	bf e0 00 00 00       	mov    $0xe0,%edi
  800421688f:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216896:	00 00 00 
  8004216899:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  800421689b:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  80042168a2:	00 00 00 
  80042168a5:	ff d0                	callq  *%rax
  80042168a7:	48 98                	cltq   
  80042168a9:	48 c1 e0 03          	shl    $0x3,%rax
  80042168ad:	48 89 c2             	mov    %rax,%rdx
  80042168b0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042168b4:	48 29 c2             	sub    %rax,%rdx
  80042168b7:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  80042168be:	00 00 00 
  80042168c1:	48 01 c2             	add    %rax,%rdx
  80042168c4:	48 b8 e0 f3 60 04 80 	movabs $0x800460f3e0,%rax
  80042168cb:	00 00 00 
  80042168ce:	48 8b 00             	mov    (%rax),%rax
  80042168d1:	48 39 c2             	cmp    %rax,%rdx
  80042168d4:	74 16                	je     80042168ec <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  80042168d6:	be 00 00 01 00       	mov    $0x10000,%esi
  80042168db:	bf d4 00 00 00       	mov    $0xd4,%edi
  80042168e0:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042168e7:	00 00 00 
  80042168ea:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  80042168ec:	be 00 00 01 00       	mov    $0x10000,%esi
  80042168f1:	bf d8 00 00 00       	mov    $0xd8,%edi
  80042168f6:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042168fd:	00 00 00 
  8004216900:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004216902:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  8004216909:	00 00 00 
  800421690c:	48 8b 00             	mov    (%rax),%rax
  800421690f:	48 83 c0 30          	add    $0x30,%rax
  8004216913:	8b 00                	mov    (%rax),%eax
  8004216915:	c1 e8 10             	shr    $0x10,%eax
  8004216918:	0f b6 c0             	movzbl %al,%eax
  800421691b:	83 f8 03             	cmp    $0x3,%eax
  800421691e:	76 16                	jbe    8004216936 <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004216920:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216925:	bf d0 00 00 00       	mov    $0xd0,%edi
  800421692a:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216931:	00 00 00 
  8004216934:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004216936:	be 33 00 00 00       	mov    $0x33,%esi
  800421693b:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004216940:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216947:	00 00 00 
  800421694a:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  800421694c:	be 00 00 00 00       	mov    $0x0,%esi
  8004216951:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004216956:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  800421695d:	00 00 00 
  8004216960:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004216962:	be 00 00 00 00       	mov    $0x0,%esi
  8004216967:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421696c:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216973:	00 00 00 
  8004216976:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004216978:	be 00 00 00 00       	mov    $0x0,%esi
  800421697d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216982:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216989:	00 00 00 
  800421698c:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  800421698e:	be 00 00 00 00       	mov    $0x0,%esi
  8004216993:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216998:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  800421699f:	00 00 00 
  80042169a2:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  80042169a4:	be 00 85 08 00       	mov    $0x88500,%esi
  80042169a9:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042169ae:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042169b5:	00 00 00 
  80042169b8:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  80042169ba:	90                   	nop
  80042169bb:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  80042169c2:	00 00 00 
  80042169c5:	48 8b 00             	mov    (%rax),%rax
  80042169c8:	48 05 00 03 00 00    	add    $0x300,%rax
  80042169ce:	8b 00                	mov    (%rax),%eax
  80042169d0:	25 00 10 00 00       	and    $0x1000,%eax
  80042169d5:	85 c0                	test   %eax,%eax
  80042169d7:	75 e2                	jne    80042169bb <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  80042169d9:	be 00 00 00 00       	mov    $0x0,%esi
  80042169de:	bf 20 00 00 00       	mov    $0x20,%edi
  80042169e3:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042169ea:	00 00 00 
  80042169ed:	ff d0                	callq  *%rax
}
  80042169ef:	5d                   	pop    %rbp
  80042169f0:	c3                   	retq   

00000080042169f1 <cpunum>:

int
cpunum(void)
{
  80042169f1:	55                   	push   %rbp
  80042169f2:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  80042169f5:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  80042169fc:	00 00 00 
  80042169ff:	48 8b 00             	mov    (%rax),%rax
  8004216a02:	48 85 c0             	test   %rax,%rax
  8004216a05:	74 18                	je     8004216a1f <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004216a07:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  8004216a0e:	00 00 00 
  8004216a11:	48 8b 00             	mov    (%rax),%rax
  8004216a14:	48 83 c0 20          	add    $0x20,%rax
  8004216a18:	8b 00                	mov    (%rax),%eax
  8004216a1a:	c1 e8 18             	shr    $0x18,%eax
  8004216a1d:	eb 05                	jmp    8004216a24 <cpunum+0x33>
	return 0;
  8004216a1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216a24:	5d                   	pop    %rbp
  8004216a25:	c3                   	retq   

0000008004216a26 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004216a26:	55                   	push   %rbp
  8004216a27:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216a2a:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  8004216a31:	00 00 00 
  8004216a34:	48 8b 00             	mov    (%rax),%rax
  8004216a37:	48 85 c0             	test   %rax,%rax
  8004216a3a:	74 16                	je     8004216a52 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004216a3c:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a41:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216a46:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216a4d:	00 00 00 
  8004216a50:	ff d0                	callq  *%rax
}
  8004216a52:	5d                   	pop    %rbp
  8004216a53:	c3                   	retq   

0000008004216a54 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004216a54:	55                   	push   %rbp
  8004216a55:	48 89 e5             	mov    %rsp,%rbp
  8004216a58:	48 83 ec 04          	sub    $0x4,%rsp
  8004216a5c:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004216a5f:	c9                   	leaveq 
  8004216a60:	c3                   	retq   

0000008004216a61 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004216a61:	55                   	push   %rbp
  8004216a62:	48 89 e5             	mov    %rsp,%rbp
  8004216a65:	48 83 ec 40          	sub    $0x40,%rsp
  8004216a69:	89 f8                	mov    %edi,%eax
  8004216a6b:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004216a6e:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004216a71:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004216a78:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004216a7c:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216a80:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216a83:	ee                   	out    %al,(%dx)
  8004216a84:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004216a8b:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004216a8f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216a93:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216a96:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004216a97:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004216a9e:	00 
  8004216a9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216aa3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216aa7:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216aaa:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216aad:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004216ab4:	00 00 00 
  8004216ab7:	48 8b 00             	mov    (%rax),%rax
  8004216aba:	48 39 c2             	cmp    %rax,%rdx
  8004216abd:	72 32                	jb     8004216af1 <lapic_startap+0x90>
  8004216abf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216ac3:	48 89 c1             	mov    %rax,%rcx
  8004216ac6:	48 ba 40 ae 21 04 80 	movabs $0x800421ae40,%rdx
  8004216acd:	00 00 00 
  8004216ad0:	be 98 00 00 00       	mov    $0x98,%esi
  8004216ad5:	48 bf 63 ae 21 04 80 	movabs $0x800421ae63,%rdi
  8004216adc:	00 00 00 
  8004216adf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216ae4:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004216aeb:	00 00 00 
  8004216aee:	41 ff d0             	callq  *%r8
  8004216af1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216af8:	00 00 00 
  8004216afb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216aff:	48 01 d0             	add    %rdx,%rax
  8004216b02:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004216b06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216b0a:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004216b0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216b13:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004216b17:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216b1a:	c1 e8 04             	shr    $0x4,%eax
  8004216b1d:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004216b20:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216b24:	c1 e0 18             	shl    $0x18,%eax
  8004216b27:	89 c6                	mov    %eax,%esi
  8004216b29:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216b2e:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216b35:	00 00 00 
  8004216b38:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004216b3a:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004216b3f:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216b44:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216b4b:	00 00 00 
  8004216b4e:	ff d0                	callq  *%rax
	microdelay(200);
  8004216b50:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216b55:	48 b8 54 6a 21 04 80 	movabs $0x8004216a54,%rax
  8004216b5c:	00 00 00 
  8004216b5f:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004216b61:	be 00 85 00 00       	mov    $0x8500,%esi
  8004216b66:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216b6b:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216b72:	00 00 00 
  8004216b75:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004216b77:	bf 64 00 00 00       	mov    $0x64,%edi
  8004216b7c:	48 b8 54 6a 21 04 80 	movabs $0x8004216a54,%rax
  8004216b83:	00 00 00 
  8004216b86:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216b88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216b8f:	eb 4b                	jmp    8004216bdc <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004216b91:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216b95:	c1 e0 18             	shl    $0x18,%eax
  8004216b98:	89 c6                	mov    %eax,%esi
  8004216b9a:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216b9f:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216ba6:	00 00 00 
  8004216ba9:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004216bab:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216bae:	c1 e8 0c             	shr    $0xc,%eax
  8004216bb1:	80 cc 06             	or     $0x6,%ah
  8004216bb4:	89 c6                	mov    %eax,%esi
  8004216bb6:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216bbb:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216bc2:	00 00 00 
  8004216bc5:	ff d0                	callq  *%rax
		microdelay(200);
  8004216bc7:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216bcc:	48 b8 54 6a 21 04 80 	movabs $0x8004216a54,%rax
  8004216bd3:	00 00 00 
  8004216bd6:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216bd8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216bdc:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216be0:	7e af                	jle    8004216b91 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004216be2:	c9                   	leaveq 
  8004216be3:	c3                   	retq   

0000008004216be4 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004216be4:	55                   	push   %rbp
  8004216be5:	48 89 e5             	mov    %rsp,%rbp
  8004216be8:	48 83 ec 08          	sub    $0x8,%rsp
  8004216bec:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216bef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216bf2:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004216bf7:	89 c6                	mov    %eax,%esi
  8004216bf9:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216bfe:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216c05:	00 00 00 
  8004216c08:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004216c0a:	90                   	nop
  8004216c0b:	48 b8 08 00 69 04 80 	movabs $0x8004690008,%rax
  8004216c12:	00 00 00 
  8004216c15:	48 8b 00             	mov    (%rax),%rax
  8004216c18:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216c1e:	8b 00                	mov    (%rax),%eax
  8004216c20:	25 00 10 00 00       	and    $0x1000,%eax
  8004216c25:	85 c0                	test   %eax,%eax
  8004216c27:	75 e2                	jne    8004216c0b <lapic_ipi+0x27>
		;
}
  8004216c29:	c9                   	leaveq 
  8004216c2a:	c3                   	retq   

0000008004216c2b <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004216c2b:	55                   	push   %rbp
  8004216c2c:	48 89 e5             	mov    %rsp,%rbp
  8004216c2f:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004216c33:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216c37:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004216c3a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216c3e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216c41:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004216c45:	f0 87 02             	lock xchg %eax,(%rdx)
  8004216c48:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004216c4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216c4e:	c9                   	leaveq 
  8004216c4f:	c3                   	retq   

0000008004216c50 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004216c50:	55                   	push   %rbp
  8004216c51:	48 89 e5             	mov    %rsp,%rbp
  8004216c54:	48 83 ec 28          	sub    $0x28,%rsp
  8004216c58:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004216c5c:	48 89 e8             	mov    %rbp,%rax
  8004216c5f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004216c63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004216c67:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004216c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216c72:	eb 45                	jmp    8004216cb9 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004216c74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216c79:	74 44                	je     8004216cbf <get_caller_pcs+0x6f>
  8004216c7b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004216c82:	00 00 00 
  8004216c85:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004216c89:	76 34                	jbe    8004216cbf <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004216c8b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c8e:	48 98                	cltq   
  8004216c90:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216c97:	00 
  8004216c98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c9c:	48 01 c2             	add    %rax,%rdx
  8004216c9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216ca3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216ca7:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216caa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216cae:	48 8b 00             	mov    (%rax),%rax
  8004216cb1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004216cb5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216cb9:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216cbd:	7e b5                	jle    8004216c74 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216cbf:	eb 1f                	jmp    8004216ce0 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216cc1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216cc4:	48 98                	cltq   
  8004216cc6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216ccd:	00 
  8004216cce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cd2:	48 01 d0             	add    %rdx,%rax
  8004216cd5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216cdc:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216ce0:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216ce4:	7e db                	jle    8004216cc1 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004216ce6:	c9                   	leaveq 
  8004216ce7:	c3                   	retq   

0000008004216ce8 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216ce8:	55                   	push   %rbp
  8004216ce9:	48 89 e5             	mov    %rsp,%rbp
  8004216cec:	53                   	push   %rbx
  8004216ced:	48 83 ec 18          	sub    $0x18,%rsp
  8004216cf1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004216cf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216cf9:	8b 00                	mov    (%rax),%eax
  8004216cfb:	85 c0                	test   %eax,%eax
  8004216cfd:	74 3d                	je     8004216d3c <holding+0x54>
  8004216cff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d03:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216d07:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004216d0e:	00 00 00 
  8004216d11:	ff d0                	callq  *%rax
  8004216d13:	48 98                	cltq   
  8004216d15:	48 c1 e0 03          	shl    $0x3,%rax
  8004216d19:	48 89 c2             	mov    %rax,%rdx
  8004216d1c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216d20:	48 29 c2             	sub    %rax,%rdx
  8004216d23:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  8004216d2a:	00 00 00 
  8004216d2d:	48 01 d0             	add    %rdx,%rax
  8004216d30:	48 39 c3             	cmp    %rax,%rbx
  8004216d33:	75 07                	jne    8004216d3c <holding+0x54>
  8004216d35:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216d3a:	eb 05                	jmp    8004216d41 <holding+0x59>
  8004216d3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216d41:	48 83 c4 18          	add    $0x18,%rsp
  8004216d45:	5b                   	pop    %rbx
  8004216d46:	5d                   	pop    %rbp
  8004216d47:	c3                   	retq   

0000008004216d48 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004216d48:	55                   	push   %rbp
  8004216d49:	48 89 e5             	mov    %rsp,%rbp
  8004216d4c:	48 83 ec 10          	sub    $0x10,%rsp
  8004216d50:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004216d54:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004216d58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d5c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004216d62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d66:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216d6a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004216d6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d72:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216d79:	00 
#endif
}
  8004216d7a:	c9                   	leaveq 
  8004216d7b:	c3                   	retq   

0000008004216d7c <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216d7c:	55                   	push   %rbp
  8004216d7d:	48 89 e5             	mov    %rsp,%rbp
  8004216d80:	53                   	push   %rbx
  8004216d81:	48 83 ec 18          	sub    $0x18,%rsp
  8004216d85:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216d89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d8d:	48 89 c7             	mov    %rax,%rdi
  8004216d90:	48 b8 e8 6c 21 04 80 	movabs $0x8004216ce8,%rax
  8004216d97:	00 00 00 
  8004216d9a:	ff d0                	callq  *%rax
  8004216d9c:	85 c0                	test   %eax,%eax
  8004216d9e:	74 44                	je     8004216de4 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216da0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216da4:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216da8:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004216daf:	00 00 00 
  8004216db2:	ff d0                	callq  *%rax
  8004216db4:	49 89 d8             	mov    %rbx,%r8
  8004216db7:	89 c1                	mov    %eax,%ecx
  8004216db9:	48 ba 80 ae 21 04 80 	movabs $0x800421ae80,%rdx
  8004216dc0:	00 00 00 
  8004216dc3:	be 41 00 00 00       	mov    $0x41,%esi
  8004216dc8:	48 bf aa ae 21 04 80 	movabs $0x800421aeaa,%rdi
  8004216dcf:	00 00 00 
  8004216dd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216dd7:	49 b9 3e 05 20 04 80 	movabs $0x800420053e,%r9
  8004216dde:	00 00 00 
  8004216de1:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216de4:	eb 02                	jmp    8004216de8 <spin_lock+0x6c>
		asm volatile ("pause");
  8004216de6:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216de8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216dec:	be 01 00 00 00       	mov    $0x1,%esi
  8004216df1:	48 89 c7             	mov    %rax,%rdi
  8004216df4:	48 b8 2b 6c 21 04 80 	movabs $0x8004216c2b,%rax
  8004216dfb:	00 00 00 
  8004216dfe:	ff d0                	callq  *%rax
  8004216e00:	85 c0                	test   %eax,%eax
  8004216e02:	75 e2                	jne    8004216de6 <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004216e04:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004216e0b:	00 00 00 
  8004216e0e:	ff d0                	callq  *%rax
  8004216e10:	48 98                	cltq   
  8004216e12:	48 c1 e0 03          	shl    $0x3,%rax
  8004216e16:	48 89 c2             	mov    %rax,%rdx
  8004216e19:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216e1d:	48 29 c2             	sub    %rax,%rdx
  8004216e20:	48 b8 20 f0 60 04 80 	movabs $0x800460f020,%rax
  8004216e27:	00 00 00 
  8004216e2a:	48 01 c2             	add    %rax,%rdx
  8004216e2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e31:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004216e35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e39:	48 83 c0 18          	add    $0x18,%rax
  8004216e3d:	48 89 c7             	mov    %rax,%rdi
  8004216e40:	48 b8 50 6c 21 04 80 	movabs $0x8004216c50,%rax
  8004216e47:	00 00 00 
  8004216e4a:	ff d0                	callq  *%rax
#endif
}
  8004216e4c:	48 83 c4 18          	add    $0x18,%rsp
  8004216e50:	5b                   	pop    %rbx
  8004216e51:	5d                   	pop    %rbp
  8004216e52:	c3                   	retq   

0000008004216e53 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004216e53:	55                   	push   %rbp
  8004216e54:	48 89 e5             	mov    %rsp,%rbp
  8004216e57:	41 54                	push   %r12
  8004216e59:	53                   	push   %rbx
  8004216e5a:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004216e61:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216e68:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216e6f:	48 89 c7             	mov    %rax,%rdi
  8004216e72:	48 b8 e8 6c 21 04 80 	movabs $0x8004216ce8,%rax
  8004216e79:	00 00 00 
  8004216e7c:	ff d0                	callq  *%rax
  8004216e7e:	85 c0                	test   %eax,%eax
  8004216e80:	0f 85 d2 01 00 00    	jne    8004217058 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216e86:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216e8d:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216e91:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216e98:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216e9d:	48 89 ce             	mov    %rcx,%rsi
  8004216ea0:	48 89 c7             	mov    %rax,%rdi
  8004216ea3:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  8004216eaa:	00 00 00 
  8004216ead:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216eaf:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216eb6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216eba:	48 85 c0             	test   %rax,%rax
  8004216ebd:	75 39                	jne    8004216ef8 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216ebf:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216ec6:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216eca:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004216ed1:	00 00 00 
  8004216ed4:	ff d0                	callq  *%rax
  8004216ed6:	48 89 da             	mov    %rbx,%rdx
  8004216ed9:	89 c6                	mov    %eax,%esi
  8004216edb:	48 bf c0 ae 21 04 80 	movabs $0x800421aec0,%rdi
  8004216ee2:	00 00 00 
  8004216ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216eea:	48 b9 de 8d 20 04 80 	movabs $0x8004208dde,%rcx
  8004216ef1:	00 00 00 
  8004216ef4:	ff d1                	callq  *%rcx
  8004216ef6:	eb 4d                	jmp    8004216f45 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216ef8:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216eff:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216f03:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004216f06:	44 0f b6 e0          	movzbl %al,%r12d
  8004216f0a:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f11:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216f15:	48 b8 f1 69 21 04 80 	movabs $0x80042169f1,%rax
  8004216f1c:	00 00 00 
  8004216f1f:	ff d0                	callq  *%rax
  8004216f21:	44 89 e1             	mov    %r12d,%ecx
  8004216f24:	48 89 da             	mov    %rbx,%rdx
  8004216f27:	89 c6                	mov    %eax,%esi
  8004216f29:	48 bf 00 af 21 04 80 	movabs $0x800421af00,%rdi
  8004216f30:	00 00 00 
  8004216f33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f38:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  8004216f3f:	00 00 00 
  8004216f42:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216f45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004216f4c:	e9 c3 00 00 00       	jmpq   8004217014 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004216f51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216f54:	48 98                	cltq   
  8004216f56:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216f5d:	89 c0                	mov    %eax,%eax
  8004216f5f:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004216f66:	48 89 d6             	mov    %rdx,%rsi
  8004216f69:	48 89 c7             	mov    %rax,%rdi
  8004216f6c:	48 b8 bd e6 20 04 80 	movabs $0x800420e6bd,%rax
  8004216f73:	00 00 00 
  8004216f76:	ff d0                	callq  *%rax
  8004216f78:	85 c0                	test   %eax,%eax
  8004216f7a:	78 6b                	js     8004216fe7 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216f7c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216f7f:	48 98                	cltq   
  8004216f81:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216f88:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216f8a:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216f91:	48 29 c2             	sub    %rax,%rdx
  8004216f94:	49 89 d0             	mov    %rdx,%r8
  8004216f97:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216f9e:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004216fa4:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216faa:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004216fb1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216fb4:	48 98                	cltq   
  8004216fb6:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216fbd:	4c 89 04 24          	mov    %r8,(%rsp)
  8004216fc1:	49 89 f9             	mov    %rdi,%r9
  8004216fc4:	41 89 f0             	mov    %esi,%r8d
  8004216fc7:	89 c6                	mov    %eax,%esi
  8004216fc9:	48 bf 36 af 21 04 80 	movabs $0x800421af36,%rdi
  8004216fd0:	00 00 00 
  8004216fd3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fd8:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  8004216fdf:	00 00 00 
  8004216fe2:	41 ff d2             	callq  *%r10
  8004216fe5:	eb 29                	jmp    8004217010 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004216fe7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216fea:	48 98                	cltq   
  8004216fec:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216ff3:	89 c6                	mov    %eax,%esi
  8004216ff5:	48 bf 4d af 21 04 80 	movabs $0x800421af4d,%rdi
  8004216ffc:	00 00 00 
  8004216fff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217004:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421700b:	00 00 00 
  800421700e:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004217010:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004217014:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004217018:	7f 14                	jg     800421702e <spin_unlock+0x1db>
  800421701a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421701d:	48 98                	cltq   
  800421701f:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004217026:	85 c0                	test   %eax,%eax
  8004217028:	0f 85 23 ff ff ff    	jne    8004216f51 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  800421702e:	48 ba 55 af 21 04 80 	movabs $0x800421af55,%rdx
  8004217035:	00 00 00 
  8004217038:	be 6b 00 00 00       	mov    $0x6b,%esi
  800421703d:	48 bf aa ae 21 04 80 	movabs $0x800421aeaa,%rdi
  8004217044:	00 00 00 
  8004217047:	b8 00 00 00 00       	mov    $0x0,%eax
  800421704c:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004217053:	00 00 00 
  8004217056:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004217058:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421705f:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004217066:	00 
	lk->cpu = 0;
  8004217067:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421706e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004217075:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004217076:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421707d:	be 00 00 00 00       	mov    $0x0,%esi
  8004217082:	48 89 c7             	mov    %rax,%rdi
  8004217085:	48 b8 2b 6c 21 04 80 	movabs $0x8004216c2b,%rax
  800421708c:	00 00 00 
  800421708f:	ff d0                	callq  *%rax
}
  8004217091:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004217098:	5b                   	pop    %rbx
  8004217099:	41 5c                	pop    %r12
  800421709b:	5d                   	pop    %rbp
  800421709c:	c3                   	retq   

000000800421709d <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421709d:	55                   	push   %rbp
  800421709e:	48 89 e5             	mov    %rsp,%rbp
  80042170a1:	48 83 ec 08          	sub    $0x8,%rsp
  80042170a5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042170a9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042170ad:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  80042170b4:	00 00 00 
  80042170b7:	48 8b 00             	mov    (%rax),%rax
  80042170ba:	48 29 c2             	sub    %rax,%rdx
  80042170bd:	48 89 d0             	mov    %rdx,%rax
  80042170c0:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042170c4:	c9                   	leaveq 
  80042170c5:	c3                   	retq   

00000080042170c6 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042170c6:	55                   	push   %rbp
  80042170c7:	48 89 e5             	mov    %rsp,%rbp
  80042170ca:	48 83 ec 08          	sub    $0x8,%rsp
  80042170ce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042170d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042170d6:	48 89 c7             	mov    %rax,%rdi
  80042170d9:	48 b8 9d 70 21 04 80 	movabs $0x800421709d,%rax
  80042170e0:	00 00 00 
  80042170e3:	ff d0                	callq  *%rax
  80042170e5:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042170e9:	c9                   	leaveq 
  80042170ea:	c3                   	retq   

00000080042170eb <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042170eb:	55                   	push   %rbp
  80042170ec:	48 89 e5             	mov    %rsp,%rbp
  80042170ef:	48 83 ec 10          	sub    $0x10,%rsp
  80042170f3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042170f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042170fb:	48 c1 e8 0c          	shr    $0xc,%rax
  80042170ff:	48 89 c2             	mov    %rax,%rdx
  8004217102:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004217109:	00 00 00 
  800421710c:	48 8b 00             	mov    (%rax),%rax
  800421710f:	48 39 c2             	cmp    %rax,%rdx
  8004217112:	72 2a                	jb     800421713e <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004217114:	48 ba 68 af 21 04 80 	movabs $0x800421af68,%rdx
  800421711b:	00 00 00 
  800421711e:	be 54 00 00 00       	mov    $0x54,%esi
  8004217123:	48 bf 87 af 21 04 80 	movabs $0x800421af87,%rdi
  800421712a:	00 00 00 
  800421712d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217132:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  8004217139:	00 00 00 
  800421713c:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800421713e:	48 b8 68 d4 60 04 80 	movabs $0x800460d468,%rax
  8004217145:	00 00 00 
  8004217148:	48 8b 00             	mov    (%rax),%rax
  800421714b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421714f:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004217153:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217157:	48 01 d0             	add    %rdx,%rax
}
  800421715a:	c9                   	leaveq 
  800421715b:	c3                   	retq   

000000800421715c <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800421715c:	55                   	push   %rbp
  800421715d:	48 89 e5             	mov    %rsp,%rbp
  8004217160:	48 83 ec 20          	sub    $0x20,%rsp
  8004217164:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004217168:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421716c:	48 89 c7             	mov    %rax,%rdi
  800421716f:	48 b8 c6 70 21 04 80 	movabs $0x80042170c6,%rax
  8004217176:	00 00 00 
  8004217179:	ff d0                	callq  *%rax
  800421717b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421717f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217183:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217187:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421718a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421718d:	48 b8 60 d4 60 04 80 	movabs $0x800460d460,%rax
  8004217194:	00 00 00 
  8004217197:	48 8b 00             	mov    (%rax),%rax
  800421719a:	48 39 c2             	cmp    %rax,%rdx
  800421719d:	72 32                	jb     80042171d1 <page2kva+0x75>
  800421719f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171a3:	48 89 c1             	mov    %rax,%rcx
  80042171a6:	48 ba 98 af 21 04 80 	movabs $0x800421af98,%rdx
  80042171ad:	00 00 00 
  80042171b0:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042171b5:	48 bf 87 af 21 04 80 	movabs $0x800421af87,%rdi
  80042171bc:	00 00 00 
  80042171bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042171c4:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042171cb:	00 00 00 
  80042171ce:	41 ff d0             	callq  *%r8
  80042171d1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042171d8:	00 00 00 
  80042171db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171df:	48 01 d0             	add    %rdx,%rax
}
  80042171e2:	c9                   	leaveq 
  80042171e3:	c3                   	retq   

00000080042171e4 <initializeTxDescriptors>:
	uint8_t css;
	uint16_t special;
};
#endif

void initializeTxDescriptors(){
  80042171e4:	55                   	push   %rbp
  80042171e5:	48 89 e5             	mov    %rsp,%rbp
  80042171e8:	48 83 ec 10          	sub    $0x10,%rsp
    int i;
    struct PageInfo* page;
    for (i = 0; i < NUM_TX_DESC; i++){
  80042171ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042171f3:	e9 99 00 00 00       	jmpq   8004217291 <initializeTxDescriptors+0xad>
        page = page_alloc(1);
  80042171f8:	bf 01 00 00 00       	mov    $0x1,%edi
  80042171fd:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  8004217204:	00 00 00 
  8004217207:	ff d0                	callq  *%rax
  8004217209:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        txDescArr[i].addr = page2pa(page);
  800421720d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217211:	48 89 c7             	mov    %rax,%rdi
  8004217214:	48 b8 c6 70 21 04 80 	movabs $0x80042170c6,%rax
  800421721b:	00 00 00 
  800421721e:	ff d0                	callq  *%rax
  8004217220:	48 ba 00 c0 60 04 80 	movabs $0x800460c000,%rdx
  8004217227:	00 00 00 
  800421722a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421722d:	48 63 c9             	movslq %ecx,%rcx
  8004217230:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217234:	48 01 ca             	add    %rcx,%rdx
  8004217237:	48 89 02             	mov    %rax,(%rdx)
        txDescArr[i].cmd = 0x09;
  800421723a:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  8004217241:	00 00 00 
  8004217244:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217247:	48 63 d2             	movslq %edx,%rdx
  800421724a:	48 c1 e2 04          	shl    $0x4,%rdx
  800421724e:	48 01 d0             	add    %rdx,%rax
  8004217251:	c6 40 0b 09          	movb   $0x9,0xb(%rax)
        txDescArr[i].length = E1000_TXD_BUFFER_LENGTH;
  8004217255:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  800421725c:	00 00 00 
  800421725f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217262:	48 63 d2             	movslq %edx,%rdx
  8004217265:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217269:	48 01 d0             	add    %rdx,%rax
  800421726c:	66 c7 40 08 ee 05    	movw   $0x5ee,0x8(%rax)
        txDescArr[i].status = 0x1;
  8004217272:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  8004217279:	00 00 00 
  800421727c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421727f:	48 63 d2             	movslq %edx,%rdx
  8004217282:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217286:	48 01 d0             	add    %rdx,%rax
  8004217289:	c6 40 0c 01          	movb   $0x1,0xc(%rax)
#endif

void initializeTxDescriptors(){
    int i;
    struct PageInfo* page;
    for (i = 0; i < NUM_TX_DESC; i++){
  800421728d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217291:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  8004217295:	0f 8e 5d ff ff ff    	jle    80042171f8 <initializeTxDescriptors+0x14>
        txDescArr[i].addr = page2pa(page);
        txDescArr[i].cmd = 0x09;
        txDescArr[i].length = E1000_TXD_BUFFER_LENGTH;
        txDescArr[i].status = 0x1;
    }
}
  800421729b:	c9                   	leaveq 
  800421729c:	c3                   	retq   

000000800421729d <initializeRxDescriptors>:
	uint8_t errors;
	uint16_t special;
};
#endif

void initializeRxDescriptors(){
  800421729d:	55                   	push   %rbp
  800421729e:	48 89 e5             	mov    %rsp,%rbp
  80042172a1:	48 83 ec 10          	sub    $0x10,%rsp
    int i;
    struct PageInfo* page;
    for (i = 0; i < NUM_RX_DESC; i++){
  80042172a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042172ac:	eb 46                	jmp    80042172f4 <initializeRxDescriptors+0x57>
        page = page_alloc(1);
  80042172ae:	bf 01 00 00 00       	mov    $0x1,%edi
  80042172b3:	48 b8 4e 2f 20 04 80 	movabs $0x8004202f4e,%rax
  80042172ba:	00 00 00 
  80042172bd:	ff d0                	callq  *%rax
  80042172bf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        rxDescArr[i].addr = page2pa(page);
  80042172c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042172c7:	48 89 c7             	mov    %rax,%rdi
  80042172ca:	48 b8 c6 70 21 04 80 	movabs $0x80042170c6,%rax
  80042172d1:	00 00 00 
  80042172d4:	ff d0                	callq  *%rax
  80042172d6:	48 ba 00 d0 60 04 80 	movabs $0x800460d000,%rdx
  80042172dd:	00 00 00 
  80042172e0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042172e3:	48 63 c9             	movslq %ecx,%rcx
  80042172e6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042172ea:	48 01 ca             	add    %rcx,%rdx
  80042172ed:	48 89 02             	mov    %rax,(%rdx)
#endif

void initializeRxDescriptors(){
    int i;
    struct PageInfo* page;
    for (i = 0; i < NUM_RX_DESC; i++){
  80042172f0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042172f4:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  80042172f8:	7e b4                	jle    80042172ae <initializeRxDescriptors+0x11>
        rxDescArr[i].addr = page2pa(page);
		//no cmd to give
		//length will get set by hardware based on incoming packet size
		//status set deafult as 0 so no need to update here
    }
}
  80042172fa:	c9                   	leaveq 
  80042172fb:	c3                   	retq   

00000080042172fc <pci_transmit_packet>:

int pci_transmit_packet(const void * src,size_t n){ //Need to check for more parameters
  80042172fc:	55                   	push   %rbp
  80042172fd:	48 89 e5             	mov    %rsp,%rbp
  8004217300:	48 83 ec 20          	sub    $0x20,%rsp
  8004217304:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217308:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	{
		cprintf("Inside pci_transmit_packet\n");
		cprintf("String %s size %d\n",src, n);
	}

	if(n > E1000_TXD_BUFFER_LENGTH){
  800421730c:	48 81 7d e0 ee 05 00 	cmpq   $0x5ee,-0x20(%rbp)
  8004217313:	00 
  8004217314:	76 25                	jbe    800421733b <pci_transmit_packet+0x3f>
        cprintf("This should not fail\n");
  8004217316:	48 bf bb af 21 04 80 	movabs $0x800421afbb,%rdi
  800421731d:	00 00 00 
  8004217320:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217325:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421732c:	00 00 00 
  800421732f:	ff d2                	callq  *%rdx
        return -1;
  8004217331:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004217336:	e9 57 01 00 00       	jmpq   8004217492 <pci_transmit_packet+0x196>
    }

	/*check if free descriptors are available*/
    if(!(txDescArr[tx_desc_tail].status & 0x1)){
  800421733b:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  8004217342:	00 00 00 
  8004217345:	8b 10                	mov    (%rax),%edx
  8004217347:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  800421734e:	00 00 00 
  8004217351:	48 63 d2             	movslq %edx,%rdx
  8004217354:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217358:	48 01 d0             	add    %rdx,%rax
  800421735b:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421735f:	0f b6 c0             	movzbl %al,%eax
  8004217362:	83 e0 01             	and    $0x1,%eax
  8004217365:	85 c0                	test   %eax,%eax
  8004217367:	75 0a                	jne    8004217373 <pci_transmit_packet+0x77>
		if (debug)
	        cprintf("Tx Desc is not free [%d] and [%d]\n",txDescArr[tx_desc_tail].status, tx_desc_tail);
        return -1;
  8004217369:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421736e:	e9 1f 01 00 00       	jmpq   8004217492 <pci_transmit_packet+0x196>
    }

    va = page2kva(pa2page(txDescArr[tx_desc_tail].addr));
  8004217373:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  800421737a:	00 00 00 
  800421737d:	8b 10                	mov    (%rax),%edx
  800421737f:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  8004217386:	00 00 00 
  8004217389:	48 63 d2             	movslq %edx,%rdx
  800421738c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217390:	48 01 d0             	add    %rdx,%rax
  8004217393:	48 8b 00             	mov    (%rax),%rax
  8004217396:	48 89 c7             	mov    %rax,%rdi
  8004217399:	48 b8 eb 70 21 04 80 	movabs $0x80042170eb,%rax
  80042173a0:	00 00 00 
  80042173a3:	ff d0                	callq  *%rax
  80042173a5:	48 89 c7             	mov    %rax,%rdi
  80042173a8:	48 b8 5c 71 21 04 80 	movabs $0x800421715c,%rax
  80042173af:	00 00 00 
  80042173b2:	ff d0                	callq  *%rax
  80042173b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    memmove(va, src, n);
  80042173b8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042173bc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042173c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042173c4:	48 89 ce             	mov    %rcx,%rsi
  80042173c7:	48 89 c7             	mov    %rax,%rdi
  80042173ca:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  80042173d1:	00 00 00 
  80042173d4:	ff d0                	callq  *%rax

	//set packet length
	txDescArr[tx_desc_tail].length = n;
  80042173d6:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  80042173dd:	00 00 00 
  80042173e0:	8b 08                	mov    (%rax),%ecx
  80042173e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042173e6:	48 ba 00 c0 60 04 80 	movabs $0x800460c000,%rdx
  80042173ed:	00 00 00 
  80042173f0:	48 63 c9             	movslq %ecx,%rcx
  80042173f3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042173f7:	48 01 ca             	add    %rcx,%rdx
  80042173fa:	66 89 42 08          	mov    %ax,0x8(%rdx)
	//txDescArr[tx_desc_tail].length = n+14;  //taking ethernet header in consideration 
											  //but script is failing with this
	//Reset the status as not free
	txDescArr[tx_desc_tail].status = 0x0;											  
  80042173fe:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  8004217405:	00 00 00 
  8004217408:	8b 10                	mov    (%rax),%edx
  800421740a:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  8004217411:	00 00 00 
  8004217414:	48 63 d2             	movslq %edx,%rdx
  8004217417:	48 c1 e2 04          	shl    $0x4,%rdx
  800421741b:	48 01 d0             	add    %rdx,%rax
  800421741e:	c6 40 0c 00          	movb   $0x0,0xc(%rax)

	//Update the tail pointer
	tx_desc_tail = (tx_desc_tail + 1) % NUM_TX_DESC;
  8004217422:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  8004217429:	00 00 00 
  800421742c:	8b 00                	mov    (%rax),%eax
  800421742e:	8d 50 01             	lea    0x1(%rax),%edx
  8004217431:	89 d0                	mov    %edx,%eax
  8004217433:	c1 f8 1f             	sar    $0x1f,%eax
  8004217436:	c1 e8 1a             	shr    $0x1a,%eax
  8004217439:	01 c2                	add    %eax,%edx
  800421743b:	83 e2 3f             	and    $0x3f,%edx
  800421743e:	29 c2                	sub    %eax,%edx
  8004217440:	89 d0                	mov    %edx,%eax
  8004217442:	89 c2                	mov    %eax,%edx
  8004217444:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  800421744b:	00 00 00 
  800421744e:	89 10                	mov    %edx,(%rax)
	map_region[0x3818 >> 2] = tx_desc_tail;	
  8004217450:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217457:	00 00 00 
  800421745a:	48 8b 00             	mov    (%rax),%rax
  800421745d:	48 8d 90 18 38 00 00 	lea    0x3818(%rax),%rdx
  8004217464:	48 b8 04 d4 60 04 80 	movabs $0x800460d404,%rax
  800421746b:	00 00 00 
  800421746e:	8b 00                	mov    (%rax),%eax
  8004217470:	89 02                	mov    %eax,(%rdx)
	
    cprintf("sending packet\n");
  8004217472:	48 bf d1 af 21 04 80 	movabs $0x800421afd1,%rdi
  8004217479:	00 00 00 
  800421747c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217481:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  8004217488:	00 00 00 
  800421748b:	ff d2                	callq  *%rdx
    return 0;
  800421748d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217492:	c9                   	leaveq 
  8004217493:	c3                   	retq   

0000008004217494 <pci_receive_packet>:

int pci_receive_packet(void * dst){ //Need to check for more parameters
  8004217494:	55                   	push   %rbp
  8004217495:	48 89 e5             	mov    %rsp,%rbp
  8004217498:	48 83 ec 20          	sub    $0x20,%rsp
  800421749c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    const void * va;
	int n = 0;
  80042174a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	if (debug)
		cprintf("Inside pci_receive_packet\n");

	rx_desc_tail = (rx_desc_tail + 1) % NUM_RX_DESC;
  80042174a7:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  80042174ae:	00 00 00 
  80042174b1:	8b 00                	mov    (%rax),%eax
  80042174b3:	8d 50 01             	lea    0x1(%rax),%edx
  80042174b6:	89 d0                	mov    %edx,%eax
  80042174b8:	c1 f8 1f             	sar    $0x1f,%eax
  80042174bb:	c1 e8 1a             	shr    $0x1a,%eax
  80042174be:	01 c2                	add    %eax,%edx
  80042174c0:	83 e2 3f             	and    $0x3f,%edx
  80042174c3:	29 c2                	sub    %eax,%edx
  80042174c5:	89 d0                	mov    %edx,%eax
  80042174c7:	89 c2                	mov    %eax,%edx
  80042174c9:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  80042174d0:	00 00 00 
  80042174d3:	89 10                	mov    %edx,(%rax)

	/*check if descriptors has been filled*/
    if(!(rxDescArr[rx_desc_tail].status & 0x1)){
  80042174d5:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  80042174dc:	00 00 00 
  80042174df:	8b 10                	mov    (%rax),%edx
  80042174e1:	48 b8 00 d0 60 04 80 	movabs $0x800460d000,%rax
  80042174e8:	00 00 00 
  80042174eb:	48 63 d2             	movslq %edx,%rdx
  80042174ee:	48 c1 e2 04          	shl    $0x4,%rdx
  80042174f2:	48 01 d0             	add    %rdx,%rax
  80042174f5:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042174f9:	0f b6 c0             	movzbl %al,%eax
  80042174fc:	83 e0 01             	and    $0x1,%eax
  80042174ff:	85 c0                	test   %eax,%eax
  8004217501:	75 0a                	jne    800421750d <pci_receive_packet+0x79>
		if (debug)
	        cprintf("Rx packet is not available yet [%d] and [%d]\n",rxDescArr[rx_desc_tail].status, rx_desc_tail);
        return -1;
  8004217503:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004217508:	e9 f3 00 00 00       	jmpq   8004217600 <pci_receive_packet+0x16c>
    }
	n = rxDescArr[rx_desc_tail].length;
  800421750d:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  8004217514:	00 00 00 
  8004217517:	8b 10                	mov    (%rax),%edx
  8004217519:	48 b8 00 d0 60 04 80 	movabs $0x800460d000,%rax
  8004217520:	00 00 00 
  8004217523:	48 63 d2             	movslq %edx,%rdx
  8004217526:	48 c1 e2 04          	shl    $0x4,%rdx
  800421752a:	48 01 d0             	add    %rdx,%rax
  800421752d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004217531:	0f b7 c0             	movzwl %ax,%eax
  8004217534:	89 45 fc             	mov    %eax,-0x4(%rbp)

    va = page2kva(pa2page(rxDescArr[rx_desc_tail].addr));
  8004217537:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  800421753e:	00 00 00 
  8004217541:	8b 10                	mov    (%rax),%edx
  8004217543:	48 b8 00 d0 60 04 80 	movabs $0x800460d000,%rax
  800421754a:	00 00 00 
  800421754d:	48 63 d2             	movslq %edx,%rdx
  8004217550:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217554:	48 01 d0             	add    %rdx,%rax
  8004217557:	48 8b 00             	mov    (%rax),%rax
  800421755a:	48 89 c7             	mov    %rax,%rdi
  800421755d:	48 b8 eb 70 21 04 80 	movabs $0x80042170eb,%rax
  8004217564:	00 00 00 
  8004217567:	ff d0                	callq  *%rax
  8004217569:	48 89 c7             	mov    %rax,%rdi
  800421756c:	48 b8 5c 71 21 04 80 	movabs $0x800421715c,%rax
  8004217573:	00 00 00 
  8004217576:	ff d0                	callq  *%rax
  8004217578:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    memmove(dst, va, n);
  800421757c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421757f:	48 63 d0             	movslq %eax,%rdx
  8004217582:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004217586:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421758a:	48 89 ce             	mov    %rcx,%rsi
  800421758d:	48 89 c7             	mov    %rax,%rdi
  8004217590:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  8004217597:	00 00 00 
  800421759a:	ff d0                	callq  *%rax

	//Reset the status as free descriptor
	rxDescArr[rx_desc_tail].status = 0x0;											  
  800421759c:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  80042175a3:	00 00 00 
  80042175a6:	8b 10                	mov    (%rax),%edx
  80042175a8:	48 b8 00 d0 60 04 80 	movabs $0x800460d000,%rax
  80042175af:	00 00 00 
  80042175b2:	48 63 d2             	movslq %edx,%rdx
  80042175b5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042175b9:	48 01 d0             	add    %rdx,%rax
  80042175bc:	c6 40 0c 00          	movb   $0x0,0xc(%rax)

	//Update the tail pointer
	map_region[0x2818 >> 2] = rx_desc_tail;	
  80042175c0:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042175c7:	00 00 00 
  80042175ca:	48 8b 00             	mov    (%rax),%rax
  80042175cd:	48 8d 90 18 28 00 00 	lea    0x2818(%rax),%rdx
  80042175d4:	48 b8 0c d4 60 04 80 	movabs $0x800460d40c,%rax
  80042175db:	00 00 00 
  80042175de:	8b 00                	mov    (%rax),%eax
  80042175e0:	89 02                	mov    %eax,(%rdx)
	
    cprintf("receiving packet\n");
  80042175e2:	48 bf e1 af 21 04 80 	movabs $0x800421afe1,%rdi
  80042175e9:	00 00 00 
  80042175ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042175f1:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042175f8:	00 00 00 
  80042175fb:	ff d2                	callq  *%rdx

	//return length of packet
    return n;
  80042175fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004217600:	c9                   	leaveq 
  8004217601:	c3                   	retq   

0000008004217602 <pci_func_attach_E1000>:

int
pci_func_attach_E1000(struct pci_func *f)
{
  8004217602:	55                   	push   %rbp
  8004217603:	48 89 e5             	mov    %rsp,%rbp
  8004217606:	48 83 ec 20          	sub    $0x20,%rsp
  800421760a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    pci_func_enable(f);
  800421760e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217612:	48 89 c7             	mov    %rax,%rdi
  8004217615:	48 b8 1d 81 21 04 80 	movabs $0x800421811d,%rax
  800421761c:	00 00 00 
  800421761f:	ff d0                	callq  *%rax
    map_region = (uint32_t *)mmio_map_region(f->reg_base[0] ,(size_t)f->reg_size[0]);
  8004217621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217625:	8b 40 30             	mov    0x30(%rax),%eax
  8004217628:	89 c2                	mov    %eax,%edx
  800421762a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421762e:	8b 40 18             	mov    0x18(%rax),%eax
  8004217631:	89 c0                	mov    %eax,%eax
  8004217633:	48 89 d6             	mov    %rdx,%rsi
  8004217636:	48 89 c7             	mov    %rax,%rdi
  8004217639:	48 b8 30 3b 20 04 80 	movabs $0x8004203b30,%rax
  8004217640:	00 00 00 
  8004217643:	ff d0                	callq  *%rax
  8004217645:	48 ba 10 00 69 04 80 	movabs $0x8004690010,%rdx
  800421764c:	00 00 00 
  800421764f:	48 89 02             	mov    %rax,(%rdx)
    cprintf("Device status reg is %x\n",map_region[2]);
  8004217652:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217659:	00 00 00 
  800421765c:	48 8b 00             	mov    (%rax),%rax
  800421765f:	48 83 c0 08          	add    $0x8,%rax
  8004217663:	8b 00                	mov    (%rax),%eax
  8004217665:	89 c6                	mov    %eax,%esi
  8004217667:	48 bf f3 af 21 04 80 	movabs $0x800421aff3,%rdi
  800421766e:	00 00 00 
  8004217671:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217676:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  800421767d:	00 00 00 
  8004217680:	ff d2                	callq  *%rdx

	/*Sending intialize start*/
	map_region[0x3810 >> 2] = 0x0; //TDH set to 0b
  8004217682:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217689:	00 00 00 
  800421768c:	48 8b 00             	mov    (%rax),%rax
  800421768f:	48 05 10 38 00 00    	add    $0x3810,%rax
  8004217695:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	map_region[0x3818 >> 2] = 0x0; //TDT set to 0b
  800421769b:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042176a2:	00 00 00 
  80042176a5:	48 8b 00             	mov    (%rax),%rax
  80042176a8:	48 05 18 38 00 00    	add    $0x3818,%rax
  80042176ae:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    map_region[0x400 >> 2] = 0x4008A; //TCTL
  80042176b4:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042176bb:	00 00 00 
  80042176be:	48 8b 00             	mov    (%rax),%rax
  80042176c1:	48 05 00 04 00 00    	add    $0x400,%rax
  80042176c7:	c7 00 8a 00 04 00    	movl   $0x4008a,(%rax)
    map_region[0x410 >> 2] = 0x60200A; //TIPG  /*binary: 00000000011000000010000000001010*/
  80042176cd:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042176d4:	00 00 00 
  80042176d7:	48 8b 00             	mov    (%rax),%rax
  80042176da:	48 05 10 04 00 00    	add    $0x410,%rax
  80042176e0:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
    map_region[0x3800 >> 2] = PADDR(txDescArr); //TDBAL & TDBAH
  80042176e6:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042176ed:	00 00 00 
  80042176f0:	48 8b 00             	mov    (%rax),%rax
  80042176f3:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  80042176fa:	48 b8 00 c0 60 04 80 	movabs $0x800460c000,%rax
  8004217701:	00 00 00 
  8004217704:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217708:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421770f:	00 00 00 
  8004217712:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004217716:	77 32                	ja     800421774a <pci_func_attach_E1000+0x148>
  8004217718:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421771c:	48 89 c1             	mov    %rax,%rcx
  800421771f:	48 ba 10 b0 21 04 80 	movabs $0x800421b010,%rdx
  8004217726:	00 00 00 
  8004217729:	be 9b 00 00 00       	mov    $0x9b,%esi
  800421772e:	48 bf 34 b0 21 04 80 	movabs $0x800421b034,%rdi
  8004217735:	00 00 00 
  8004217738:	b8 00 00 00 00       	mov    $0x0,%eax
  800421773d:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004217744:	00 00 00 
  8004217747:	41 ff d0             	callq  *%r8
  800421774a:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004217751:	ff ff ff 
  8004217754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217758:	48 01 c8             	add    %rcx,%rax
  800421775b:	89 02                	mov    %eax,(%rdx)
    map_region[0x3808 >> 2] = NUM_TX_DESC << 4;	//TDLEN set to 1024 = 64*16 = 0x400
  800421775d:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217764:	00 00 00 
  8004217767:	48 8b 00             	mov    (%rax),%rax
  800421776a:	48 05 08 38 00 00    	add    $0x3808,%rax
  8004217770:	c7 00 00 04 00 00    	movl   $0x400,(%rax)
    /*Sending intialize end*/

	/*Receiving intialize start*/
	map_region[0x2810 >> 2] = 0x0; //RDH set to 0b
  8004217776:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  800421777d:	00 00 00 
  8004217780:	48 8b 00             	mov    (%rax),%rax
  8004217783:	48 05 10 28 00 00    	add    $0x2810,%rax
  8004217789:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	map_region[0x2818 >> 2] = NUM_RX_DESC - 1; //RDT set to 0b
  800421778f:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217796:	00 00 00 
  8004217799:	48 8b 00             	mov    (%rax),%rax
  800421779c:	48 05 18 28 00 00    	add    $0x2818,%rax
  80042177a2:	c7 00 3f 00 00 00    	movl   $0x3f,(%rax)

    map_region[0x100 >> 2] = 0x4018002; //RCTL  /* Binary 00000100 00000001 10000000 00000010 */
  80042177a8:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042177af:	00 00 00 
  80042177b2:	48 8b 00             	mov    (%rax),%rax
  80042177b5:	48 05 00 01 00 00    	add    $0x100,%rax
  80042177bb:	c7 00 02 80 01 04    	movl   $0x4018002,(%rax)
    										  /* set bits SECRC/BSIZE/BAM/EN */
    map_region[0x2800 >> 2] = PADDR(rxDescArr); //RDBAL & RDBAH
  80042177c1:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  80042177c8:	00 00 00 
  80042177cb:	48 8b 00             	mov    (%rax),%rax
  80042177ce:	48 8d 90 00 28 00 00 	lea    0x2800(%rax),%rdx
  80042177d5:	48 b8 00 d0 60 04 80 	movabs $0x800460d000,%rax
  80042177dc:	00 00 00 
  80042177df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042177e3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042177ea:	00 00 00 
  80042177ed:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042177f1:	77 32                	ja     8004217825 <pci_func_attach_E1000+0x223>
  80042177f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042177f7:	48 89 c1             	mov    %rax,%rcx
  80042177fa:	48 ba 10 b0 21 04 80 	movabs $0x800421b010,%rdx
  8004217801:	00 00 00 
  8004217804:	be a5 00 00 00       	mov    $0xa5,%esi
  8004217809:	48 bf 34 b0 21 04 80 	movabs $0x800421b034,%rdi
  8004217810:	00 00 00 
  8004217813:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217818:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421781f:	00 00 00 
  8004217822:	41 ff d0             	callq  *%r8
  8004217825:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800421782c:	ff ff ff 
  800421782f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217833:	48 01 c8             	add    %rcx,%rax
  8004217836:	89 02                	mov    %eax,(%rdx)
    map_region[0x2808 >> 2] = NUM_RX_DESC << 4;	//RDLEN set to 1024 = 64*16 = 0x400
  8004217838:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  800421783f:	00 00 00 
  8004217842:	48 8b 00             	mov    (%rax),%rax
  8004217845:	48 05 08 28 00 00    	add    $0x2808,%rax
  800421784b:	c7 00 00 04 00 00    	movl   $0x400,(%rax)
    map_region[0x5200 >> 2] = 0x0;	//MTA (Multicast Tablr Array) set to 0 for now
  8004217851:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217858:	00 00 00 
  800421785b:	48 8b 00             	mov    (%rax),%rax
  800421785e:	48 05 00 52 00 00    	add    $0x5200,%rax
  8004217864:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

	map_region[0x5400 >> 2] = 0x12005452;
  800421786a:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  8004217871:	00 00 00 
  8004217874:	48 8b 00             	mov    (%rax),%rax
  8004217877:	48 05 00 54 00 00    	add    $0x5400,%rax
  800421787d:	c7 00 52 54 00 12    	movl   $0x12005452,(%rax)
	map_region[0x5404 >> 2] = 0x5634 | 0x80000000;
  8004217883:	48 b8 10 00 69 04 80 	movabs $0x8004690010,%rax
  800421788a:	00 00 00 
  800421788d:	48 8b 00             	mov    (%rax),%rax
  8004217890:	48 05 04 54 00 00    	add    $0x5404,%rax
  8004217896:	c7 00 34 56 00 80    	movl   $0x80005634,(%rax)

	//cprintf("hex 1 %x vs 0x12005452\n",map_region[0x5400]);
	//cprintf("hex 2 %x vs 0x5634\n",map_region[0x5404]);
	/*Receiving intialize end*/

    initializeTxDescriptors();
  800421789c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178a1:	48 ba e4 71 21 04 80 	movabs $0x80042171e4,%rdx
  80042178a8:	00 00 00 
  80042178ab:	ff d2                	callq  *%rdx
    initializeRxDescriptors();
  80042178ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178b2:	48 ba 9d 72 21 04 80 	movabs $0x800421729d,%rdx
  80042178b9:	00 00 00 
  80042178bc:	ff d2                	callq  *%rdx

    cprintf("Initialized E1000 device\n");
  80042178be:	48 bf 41 b0 21 04 80 	movabs $0x800421b041,%rdi
  80042178c5:	00 00 00 
  80042178c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178cd:	48 ba de 8d 20 04 80 	movabs $0x8004208dde,%rdx
  80042178d4:	00 00 00 
  80042178d7:	ff d2                	callq  *%rdx
    return 0;
  80042178d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042178de:	c9                   	leaveq 
  80042178df:	c3                   	retq   

00000080042178e0 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  80042178e0:	55                   	push   %rbp
  80042178e1:	48 89 e5             	mov    %rsp,%rbp
  80042178e4:	48 83 ec 20          	sub    $0x20,%rsp
  80042178e8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042178eb:	89 75 e8             	mov    %esi,-0x18(%rbp)
  80042178ee:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  80042178f1:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  80042178f4:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  80042178fb:	76 35                	jbe    8004217932 <pci_conf1_set_addr+0x52>
  80042178fd:	48 b9 60 b0 21 04 80 	movabs $0x800421b060,%rcx
  8004217904:	00 00 00 
  8004217907:	48 ba 6a b0 21 04 80 	movabs $0x800421b06a,%rdx
  800421790e:	00 00 00 
  8004217911:	be 2b 00 00 00       	mov    $0x2b,%esi
  8004217916:	48 bf 7f b0 21 04 80 	movabs $0x800421b07f,%rdi
  800421791d:	00 00 00 
  8004217920:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217925:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  800421792c:	00 00 00 
  800421792f:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004217932:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004217936:	76 35                	jbe    800421796d <pci_conf1_set_addr+0x8d>
  8004217938:	48 b9 8a b0 21 04 80 	movabs $0x800421b08a,%rcx
  800421793f:	00 00 00 
  8004217942:	48 ba 6a b0 21 04 80 	movabs $0x800421b06a,%rdx
  8004217949:	00 00 00 
  800421794c:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004217951:	48 bf 7f b0 21 04 80 	movabs $0x800421b07f,%rdi
  8004217958:	00 00 00 
  800421795b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217960:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004217967:	00 00 00 
  800421796a:	41 ff d0             	callq  *%r8
	assert(func < 8);
  800421796d:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004217971:	76 35                	jbe    80042179a8 <pci_conf1_set_addr+0xc8>
  8004217973:	48 b9 93 b0 21 04 80 	movabs $0x800421b093,%rcx
  800421797a:	00 00 00 
  800421797d:	48 ba 6a b0 21 04 80 	movabs $0x800421b06a,%rdx
  8004217984:	00 00 00 
  8004217987:	be 2d 00 00 00       	mov    $0x2d,%esi
  800421798c:	48 bf 7f b0 21 04 80 	movabs $0x800421b07f,%rdi
  8004217993:	00 00 00 
  8004217996:	b8 00 00 00 00       	mov    $0x0,%eax
  800421799b:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042179a2:	00 00 00 
  80042179a5:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042179a8:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  80042179af:	76 35                	jbe    80042179e6 <pci_conf1_set_addr+0x106>
  80042179b1:	48 b9 9c b0 21 04 80 	movabs $0x800421b09c,%rcx
  80042179b8:	00 00 00 
  80042179bb:	48 ba 6a b0 21 04 80 	movabs $0x800421b06a,%rdx
  80042179c2:	00 00 00 
  80042179c5:	be 2e 00 00 00       	mov    $0x2e,%esi
  80042179ca:	48 bf 7f b0 21 04 80 	movabs $0x800421b07f,%rdi
  80042179d1:	00 00 00 
  80042179d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179d9:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  80042179e0:	00 00 00 
  80042179e3:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  80042179e6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042179e9:	83 e0 03             	and    $0x3,%eax
  80042179ec:	85 c0                	test   %eax,%eax
  80042179ee:	74 35                	je     8004217a25 <pci_conf1_set_addr+0x145>
  80042179f0:	48 b9 a9 b0 21 04 80 	movabs $0x800421b0a9,%rcx
  80042179f7:	00 00 00 
  80042179fa:	48 ba 6a b0 21 04 80 	movabs $0x800421b06a,%rdx
  8004217a01:	00 00 00 
  8004217a04:	be 2f 00 00 00       	mov    $0x2f,%esi
  8004217a09:	48 bf 7f b0 21 04 80 	movabs $0x800421b07f,%rdi
  8004217a10:	00 00 00 
  8004217a13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a18:	49 b8 3e 05 20 04 80 	movabs $0x800420053e,%r8
  8004217a1f:	00 00 00 
  8004217a22:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004217a25:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217a28:	c1 e0 10             	shl    $0x10,%eax
  8004217a2b:	89 c2                	mov    %eax,%edx
  8004217a2d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217a30:	c1 e0 0b             	shl    $0xb,%eax
  8004217a33:	09 c2                	or     %eax,%edx
  8004217a35:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217a38:	c1 e0 08             	shl    $0x8,%eax
  8004217a3b:	09 d0                	or     %edx,%eax
  8004217a3d:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004217a40:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004217a45:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004217a48:	48 b8 04 e8 22 04 80 	movabs $0x800422e804,%rax
  8004217a4f:	00 00 00 
  8004217a52:	8b 00                	mov    (%rax),%eax
  8004217a54:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004217a57:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217a5a:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004217a5d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217a60:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217a63:	ef                   	out    %eax,(%dx)
}
  8004217a64:	c9                   	leaveq 
  8004217a65:	c3                   	retq   

0000008004217a66 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004217a66:	55                   	push   %rbp
  8004217a67:	48 89 e5             	mov    %rsp,%rbp
  8004217a6a:	48 83 ec 20          	sub    $0x20,%rsp
  8004217a6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217a72:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004217a75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217a79:	8b 50 0c             	mov    0xc(%rax),%edx
  8004217a7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217a80:	8b 70 08             	mov    0x8(%rax),%esi
  8004217a83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217a87:	48 8b 00             	mov    (%rax),%rax
  8004217a8a:	8b 40 08             	mov    0x8(%rax),%eax
  8004217a8d:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004217a90:	89 c7                	mov    %eax,%edi
  8004217a92:	48 b8 e0 78 21 04 80 	movabs $0x80042178e0,%rax
  8004217a99:	00 00 00 
  8004217a9c:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004217a9e:	48 b8 08 e8 22 04 80 	movabs $0x800422e808,%rax
  8004217aa5:	00 00 00 
  8004217aa8:	8b 00                	mov    (%rax),%eax
  8004217aaa:	89 45 fc             	mov    %eax,-0x4(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004217aad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217ab0:	89 c2                	mov    %eax,%edx
  8004217ab2:	ed                   	in     (%dx),%eax
  8004217ab3:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  8004217ab6:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004217ab9:	c9                   	leaveq 
  8004217aba:	c3                   	retq   

0000008004217abb <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004217abb:	55                   	push   %rbp
  8004217abc:	48 89 e5             	mov    %rsp,%rbp
  8004217abf:	48 83 ec 20          	sub    $0x20,%rsp
  8004217ac3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217ac7:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004217aca:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004217acd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ad1:	8b 50 0c             	mov    0xc(%rax),%edx
  8004217ad4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ad8:	8b 70 08             	mov    0x8(%rax),%esi
  8004217adb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217adf:	48 8b 00             	mov    (%rax),%rax
  8004217ae2:	8b 40 08             	mov    0x8(%rax),%eax
  8004217ae5:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004217ae8:	89 c7                	mov    %eax,%edi
  8004217aea:	48 b8 e0 78 21 04 80 	movabs $0x80042178e0,%rax
  8004217af1:	00 00 00 
  8004217af4:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004217af6:	48 b8 08 e8 22 04 80 	movabs $0x800422e808,%rax
  8004217afd:	00 00 00 
  8004217b00:	8b 00                	mov    (%rax),%eax
  8004217b02:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004217b05:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004217b08:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004217b0b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217b0e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217b11:	ef                   	out    %eax,(%dx)
}
  8004217b12:	c9                   	leaveq 
  8004217b13:	c3                   	retq   

0000008004217b14 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004217b14:	55                   	push   %rbp
  8004217b15:	48 89 e5             	mov    %rsp,%rbp
  8004217b18:	48 83 ec 30          	sub    $0x30,%rsp
  8004217b1c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004217b1f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004217b22:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004217b26:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217b2a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217b31:	e9 aa 00 00 00       	jmpq   8004217be0 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004217b36:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217b39:	48 c1 e0 04          	shl    $0x4,%rax
  8004217b3d:	48 89 c2             	mov    %rax,%rdx
  8004217b40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217b44:	48 01 d0             	add    %rdx,%rax
  8004217b47:	8b 00                	mov    (%rax),%eax
  8004217b49:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004217b4c:	0f 85 8a 00 00 00    	jne    8004217bdc <pci_attach_match+0xc8>
  8004217b52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217b55:	48 c1 e0 04          	shl    $0x4,%rax
  8004217b59:	48 89 c2             	mov    %rax,%rdx
  8004217b5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217b60:	48 01 d0             	add    %rdx,%rax
  8004217b63:	8b 40 04             	mov    0x4(%rax),%eax
  8004217b66:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004217b69:	75 71                	jne    8004217bdc <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  8004217b6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217b6e:	48 c1 e0 04          	shl    $0x4,%rax
  8004217b72:	48 89 c2             	mov    %rax,%rdx
  8004217b75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217b79:	48 01 d0             	add    %rdx,%rax
  8004217b7c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217b80:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004217b84:	48 89 d7             	mov    %rdx,%rdi
  8004217b87:	ff d0                	callq  *%rax
  8004217b89:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  8004217b8c:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004217b90:	7e 05                	jle    8004217b97 <pci_attach_match+0x83>
				return r;
  8004217b92:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217b95:	eb 6c                	jmp    8004217c03 <pci_attach_match+0xef>
			if (r < 0)
  8004217b97:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004217b9b:	79 3f                	jns    8004217bdc <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004217b9d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217ba0:	48 c1 e0 04          	shl    $0x4,%rax
  8004217ba4:	48 89 c2             	mov    %rax,%rdx
  8004217ba7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bab:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004217bae:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004217bb2:	8b 75 f8             	mov    -0x8(%rbp),%esi
  8004217bb5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004217bb8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217bbb:	41 89 f0             	mov    %esi,%r8d
  8004217bbe:	89 c6                	mov    %eax,%esi
  8004217bc0:	48 bf c0 b0 21 04 80 	movabs $0x800421b0c0,%rdi
  8004217bc7:	00 00 00 
  8004217bca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217bcf:	49 b9 de 8d 20 04 80 	movabs $0x8004208dde,%r9
  8004217bd6:	00 00 00 
  8004217bd9:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217bdc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217be0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217be3:	48 c1 e0 04          	shl    $0x4,%rax
  8004217be7:	48 89 c2             	mov    %rax,%rdx
  8004217bea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bee:	48 01 d0             	add    %rdx,%rax
  8004217bf1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217bf5:	48 85 c0             	test   %rax,%rax
  8004217bf8:	0f 85 38 ff ff ff    	jne    8004217b36 <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004217bfe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217c03:	c9                   	leaveq 
  8004217c04:	c3                   	retq   

0000008004217c05 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004217c05:	55                   	push   %rbp
  8004217c06:	48 89 e5             	mov    %rsp,%rbp
  8004217c09:	48 83 ec 10          	sub    $0x10,%rsp
  8004217c0d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004217c11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217c15:	8b 40 14             	mov    0x14(%rax),%eax
  8004217c18:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004217c1b:	0f b6 c0             	movzbl %al,%eax
  8004217c1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217c22:	8b 52 14             	mov    0x14(%rdx),%edx
  8004217c25:	89 d7                	mov    %edx,%edi
  8004217c27:	c1 ef 18             	shr    $0x18,%edi
  8004217c2a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217c2e:	48 89 d1             	mov    %rdx,%rcx
  8004217c31:	48 ba 20 e8 22 04 80 	movabs $0x800422e820,%rdx
  8004217c38:	00 00 00 
  8004217c3b:	89 c6                	mov    %eax,%esi
  8004217c3d:	48 b8 14 7b 21 04 80 	movabs $0x8004217b14,%rax
  8004217c44:	00 00 00 
  8004217c47:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004217c49:	85 c0                	test   %eax,%eax
  8004217c4b:	75 39                	jne    8004217c86 <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  8004217c4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217c51:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004217c54:	c1 e8 10             	shr    $0x10,%eax
  8004217c57:	89 c6                	mov    %eax,%esi
  8004217c59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217c5d:	8b 40 10             	mov    0x10(%rax),%eax
  8004217c60:	0f b7 c0             	movzwl %ax,%eax
  8004217c63:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217c67:	48 89 d1             	mov    %rdx,%rcx
  8004217c6a:	48 ba 40 e8 22 04 80 	movabs $0x800422e840,%rdx
  8004217c71:	00 00 00 
  8004217c74:	89 c7                	mov    %eax,%edi
  8004217c76:	48 b8 14 7b 21 04 80 	movabs $0x8004217b14,%rax
  8004217c7d:	00 00 00 
  8004217c80:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004217c82:	85 c0                	test   %eax,%eax
  8004217c84:	74 07                	je     8004217c8d <pci_attach+0x88>
  8004217c86:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217c8b:	eb 05                	jmp    8004217c92 <pci_attach+0x8d>
  8004217c8d:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  8004217c92:	c9                   	leaveq 
  8004217c93:	c3                   	retq   

0000008004217c94 <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  8004217c94:	55                   	push   %rbp
  8004217c95:	48 89 e5             	mov    %rsp,%rbp
  8004217c98:	48 83 ec 40          	sub    $0x40,%rsp
  8004217c9c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004217ca0:	48 b8 80 e8 22 04 80 	movabs $0x800422e880,%rax
  8004217ca7:	00 00 00 
  8004217caa:	48 8b 00             	mov    (%rax),%rax
  8004217cad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004217cb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217cb5:	8b 40 14             	mov    0x14(%rax),%eax
  8004217cb8:	c1 e8 18             	shr    $0x18,%eax
  8004217cbb:	83 f8 06             	cmp    $0x6,%eax
  8004217cbe:	77 20                	ja     8004217ce0 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004217cc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217cc4:	8b 40 14             	mov    0x14(%rax),%eax
  8004217cc7:	c1 e8 18             	shr    $0x18,%eax
  8004217cca:	89 c2                	mov    %eax,%edx
  8004217ccc:	48 b8 80 e8 22 04 80 	movabs $0x800422e880,%rax
  8004217cd3:	00 00 00 
  8004217cd6:	89 d2                	mov    %edx,%edx
  8004217cd8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004217cdc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004217ce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ce4:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217ce8:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217ceb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217cef:	8b 40 14             	mov    0x14(%rax),%eax
  8004217cf2:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217cf5:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217cf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217cfc:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217cff:	c1 e8 18             	shr    $0x18,%eax
  8004217d02:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217d05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d09:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217d0c:	c1 e8 10             	shr    $0x10,%eax
  8004217d0f:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217d12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d16:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217d19:	44 0f b7 c0          	movzwl %ax,%r8d
  8004217d1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d21:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217d24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d28:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004217d2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d2f:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217d32:	8b 40 08             	mov    0x8(%rax),%eax
  8004217d35:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  8004217d39:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8004217d3d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004217d42:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004217d46:	44 89 0c 24          	mov    %r9d,(%rsp)
  8004217d4a:	45 89 d1             	mov    %r10d,%r9d
  8004217d4d:	89 c6                	mov    %eax,%esi
  8004217d4f:	48 bf 60 b1 21 04 80 	movabs $0x800421b160,%rdi
  8004217d56:	00 00 00 
  8004217d59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217d5e:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  8004217d65:	00 00 00 
  8004217d68:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  8004217d6b:	c9                   	leaveq 
  8004217d6c:	c3                   	retq   

0000008004217d6d <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  8004217d6d:	55                   	push   %rbp
  8004217d6e:	48 89 e5             	mov    %rsp,%rbp
  8004217d71:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004217d78:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  8004217d7f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  8004217d86:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217d8a:	ba 50 00 00 00       	mov    $0x50,%edx
  8004217d8f:	be 00 00 00 00       	mov    $0x0,%esi
  8004217d94:	48 89 c7             	mov    %rax,%rdi
  8004217d97:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004217d9e:	00 00 00 
  8004217da1:	ff d0                	callq  *%rax
	df.bus = bus;
  8004217da3:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004217daa:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217dae:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  8004217db5:	e9 22 02 00 00       	jmpq   8004217fdc <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004217dba:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217dbe:	be 0c 00 00 00       	mov    $0xc,%esi
  8004217dc3:	48 89 c7             	mov    %rax,%rdi
  8004217dc6:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004217dcd:	00 00 00 
  8004217dd0:	ff d0                	callq  *%rax
  8004217dd2:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004217dd5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217dd8:	c1 e8 10             	shr    $0x10,%eax
  8004217ddb:	83 e0 7f             	and    $0x7f,%eax
  8004217dde:	83 f8 01             	cmp    $0x1,%eax
  8004217de1:	0f 87 ec 01 00 00    	ja     8004217fd3 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  8004217de7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004217deb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004217def:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004217df6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004217dfa:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004217e01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217e05:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004217e0c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004217e10:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004217e17:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004217e1b:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004217e22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217e26:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004217e2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217e31:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004217e38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217e3c:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004217e43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217e47:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004217e4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217e52:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217e59:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  8004217e60:	00 00 00 
  8004217e63:	e9 45 01 00 00       	jmpq   8004217fad <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  8004217e68:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004217e6f:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004217e76:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004217e7d:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004217e84:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004217e8b:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004217e92:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004217e99:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004217ea0:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004217ea7:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004217eae:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004217eb5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004217ebc:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004217ec3:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004217ec7:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004217ece:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004217ed2:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004217ed9:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004217edd:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004217ee4:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004217ee8:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004217eef:	be 00 00 00 00       	mov    $0x0,%esi
  8004217ef4:	48 89 c7             	mov    %rax,%rdi
  8004217ef7:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004217efe:	00 00 00 
  8004217f01:	ff d0                	callq  *%rax
  8004217f03:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004217f09:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004217f0f:	0f b7 c0             	movzwl %ax,%eax
  8004217f12:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004217f17:	0f 84 81 00 00 00    	je     8004217f9e <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004217f1d:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217f24:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004217f29:	48 89 c7             	mov    %rax,%rdi
  8004217f2c:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004217f33:	00 00 00 
  8004217f36:	ff d0                	callq  *%rax
  8004217f38:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004217f3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217f3e:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004217f41:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217f48:	be 08 00 00 00       	mov    $0x8,%esi
  8004217f4d:	48 89 c7             	mov    %rax,%rdi
  8004217f50:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004217f57:	00 00 00 
  8004217f5a:	ff d0                	callq  *%rax
  8004217f5c:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004217f62:	48 b8 00 e8 22 04 80 	movabs $0x800422e800,%rax
  8004217f69:	00 00 00 
  8004217f6c:	8b 00                	mov    (%rax),%eax
  8004217f6e:	85 c0                	test   %eax,%eax
  8004217f70:	74 16                	je     8004217f88 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  8004217f72:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217f79:	48 89 c7             	mov    %rax,%rdi
  8004217f7c:	48 b8 94 7c 21 04 80 	movabs $0x8004217c94,%rax
  8004217f83:	00 00 00 
  8004217f86:	ff d0                	callq  *%rax
			pci_attach(&af);
  8004217f88:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217f8f:	48 89 c7             	mov    %rax,%rdi
  8004217f92:	48 b8 05 7c 21 04 80 	movabs $0x8004217c05,%rax
  8004217f99:	00 00 00 
  8004217f9c:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004217f9e:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004217fa4:	83 c0 01             	add    $0x1,%eax
  8004217fa7:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217fad:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004217fb3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217fb6:	25 00 00 80 00       	and    $0x800000,%eax
  8004217fbb:	85 c0                	test   %eax,%eax
  8004217fbd:	74 07                	je     8004217fc6 <pci_scan_bus+0x259>
  8004217fbf:	b8 08 00 00 00       	mov    $0x8,%eax
  8004217fc4:	eb 05                	jmp    8004217fcb <pci_scan_bus+0x25e>
  8004217fc6:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217fcb:	39 c2                	cmp    %eax,%edx
  8004217fcd:	0f 82 95 fe ff ff    	jb     8004217e68 <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217fd3:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004217fd6:	83 c0 01             	add    $0x1,%eax
  8004217fd9:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004217fdc:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004217fdf:	83 f8 1f             	cmp    $0x1f,%eax
  8004217fe2:	0f 86 d2 fd ff ff    	jbe    8004217dba <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  8004217fe8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004217feb:	c9                   	leaveq 
  8004217fec:	c3                   	retq   

0000008004217fed <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004217fed:	55                   	push   %rbp
  8004217fee:	48 89 e5             	mov    %rsp,%rbp
  8004217ff1:	48 83 ec 30          	sub    $0x30,%rsp
  8004217ff5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  8004217ff9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217ffd:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004218002:	48 89 c7             	mov    %rax,%rdi
  8004218005:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  800421800c:	00 00 00 
  800421800f:	ff d0                	callq  *%rax
  8004218011:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  8004218014:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218018:	be 18 00 00 00       	mov    $0x18,%esi
  800421801d:	48 89 c7             	mov    %rax,%rdi
  8004218020:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004218027:	00 00 00 
  800421802a:	ff d0                	callq  *%rax
  800421802c:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  800421802f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218032:	83 e0 0f             	and    $0xf,%eax
  8004218035:	83 f8 01             	cmp    $0x1,%eax
  8004218038:	75 40                	jne    800421807a <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  800421803a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421803e:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218041:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218045:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004218048:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421804c:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  800421804f:	8b 40 08             	mov    0x8(%rax),%eax
  8004218052:	89 c6                	mov    %eax,%esi
  8004218054:	48 bf a0 b1 21 04 80 	movabs $0x800421b1a0,%rdi
  800421805b:	00 00 00 
  800421805e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218063:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  800421806a:	00 00 00 
  800421806d:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  8004218070:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218075:	e9 a1 00 00 00       	jmpq   800421811b <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  800421807a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421807e:	ba 10 00 00 00       	mov    $0x10,%edx
  8004218083:	be 00 00 00 00       	mov    $0x0,%esi
  8004218088:	48 89 c7             	mov    %rax,%rdi
  800421808b:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  8004218092:	00 00 00 
  8004218095:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004218097:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421809b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  800421809f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042180a2:	c1 e8 08             	shr    $0x8,%eax
  80042180a5:	0f b6 c0             	movzbl %al,%eax
  80042180a8:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  80042180ab:	48 b8 00 e8 22 04 80 	movabs $0x800422e800,%rax
  80042180b2:	00 00 00 
  80042180b5:	8b 00                	mov    (%rax),%eax
  80042180b7:	85 c0                	test   %eax,%eax
  80042180b9:	74 48                	je     8004218103 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  80042180bb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042180be:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042180c1:	0f b6 f8             	movzbl %al,%edi
  80042180c4:	8b 75 e8             	mov    -0x18(%rbp),%esi
  80042180c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042180cb:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042180ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042180d2:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  80042180d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042180d9:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042180dc:	8b 40 08             	mov    0x8(%rax),%eax
  80042180df:	41 89 f9             	mov    %edi,%r9d
  80042180e2:	41 89 f0             	mov    %esi,%r8d
  80042180e5:	89 c6                	mov    %eax,%esi
  80042180e7:	48 bf d8 b1 21 04 80 	movabs $0x800421b1d8,%rdi
  80042180ee:	00 00 00 
  80042180f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042180f6:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  80042180fd:	00 00 00 
  8004218100:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004218103:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004218107:	48 89 c7             	mov    %rax,%rdi
  800421810a:	48 b8 6d 7d 21 04 80 	movabs $0x8004217d6d,%rax
  8004218111:	00 00 00 
  8004218114:	ff d0                	callq  *%rax
	return 1;
  8004218116:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421811b:	c9                   	leaveq 
  800421811c:	c3                   	retq   

000000800421811d <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  800421811d:	55                   	push   %rbp
  800421811e:	48 89 e5             	mov    %rsp,%rbp
  8004218121:	48 83 ec 40          	sub    $0x40,%rsp
  8004218125:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004218129:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421812d:	ba 07 00 00 00       	mov    $0x7,%edx
  8004218132:	be 04 00 00 00       	mov    $0x4,%esi
  8004218137:	48 89 c7             	mov    %rax,%rdi
  800421813a:	48 b8 bb 7a 21 04 80 	movabs $0x8004217abb,%rax
  8004218141:	00 00 00 
  8004218144:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218146:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  800421814d:	e9 ee 01 00 00       	jmpq   8004218340 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004218152:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218155:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218159:	89 d6                	mov    %edx,%esi
  800421815b:	48 89 c7             	mov    %rax,%rdi
  800421815e:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  8004218165:	00 00 00 
  8004218168:	ff d0                	callq  *%rax
  800421816a:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  800421816d:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004218174:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218177:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421817b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004218180:	89 ce                	mov    %ecx,%esi
  8004218182:	48 89 c7             	mov    %rax,%rdi
  8004218185:	48 b8 bb 7a 21 04 80 	movabs $0x8004217abb,%rax
  800421818c:	00 00 00 
  800421818f:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004218191:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218194:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218198:	89 d6                	mov    %edx,%esi
  800421819a:	48 89 c7             	mov    %rax,%rdi
  800421819d:	48 b8 66 7a 21 04 80 	movabs $0x8004217a66,%rax
  80042181a4:	00 00 00 
  80042181a7:	ff d0                	callq  *%rax
  80042181a9:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  80042181ac:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042181b0:	75 05                	jne    80042181b7 <pci_func_enable+0x9a>
			continue;
  80042181b2:	e9 83 01 00 00       	jmpq   800421833a <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  80042181b7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042181ba:	83 e8 10             	sub    $0x10,%eax
  80042181bd:	c1 e8 02             	shr    $0x2,%eax
  80042181c0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  80042181c3:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042181c6:	83 e0 01             	and    $0x1,%eax
  80042181c9:	85 c0                	test   %eax,%eax
  80042181cb:	75 65                	jne    8004218232 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  80042181cd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042181d0:	83 e0 06             	and    $0x6,%eax
  80042181d3:	83 f8 04             	cmp    $0x4,%eax
  80042181d6:	75 07                	jne    80042181df <pci_func_enable+0xc2>
				bar_width = 8;
  80042181d8:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  80042181df:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042181e2:	83 e0 f0             	and    $0xfffffff0,%eax
  80042181e5:	f7 d8                	neg    %eax
  80042181e7:	23 45 e8             	and    -0x18(%rbp),%eax
  80042181ea:	83 e0 f0             	and    $0xfffffff0,%eax
  80042181ed:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  80042181f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042181f3:	83 e0 f0             	and    $0xfffffff0,%eax
  80042181f6:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  80042181f9:	48 b8 10 d4 60 04 80 	movabs $0x800460d410,%rax
  8004218200:	00 00 00 
  8004218203:	8b 00                	mov    (%rax),%eax
  8004218205:	85 c0                	test   %eax,%eax
  8004218207:	74 7a                	je     8004218283 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004218209:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421820c:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421820f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218212:	89 c6                	mov    %eax,%esi
  8004218214:	48 bf 08 b2 21 04 80 	movabs $0x800421b208,%rdi
  800421821b:	00 00 00 
  800421821e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218223:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  800421822a:	00 00 00 
  800421822d:	41 ff d0             	callq  *%r8
  8004218230:	eb 51                	jmp    8004218283 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004218232:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218235:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218238:	f7 d8                	neg    %eax
  800421823a:	23 45 e8             	and    -0x18(%rbp),%eax
  800421823d:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218240:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004218243:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218246:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218249:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  800421824c:	48 b8 10 d4 60 04 80 	movabs $0x800460d410,%rax
  8004218253:	00 00 00 
  8004218256:	8b 00                	mov    (%rax),%eax
  8004218258:	85 c0                	test   %eax,%eax
  800421825a:	74 27                	je     8004218283 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  800421825c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421825f:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218262:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218265:	89 c6                	mov    %eax,%esi
  8004218267:	48 bf 30 b2 21 04 80 	movabs $0x800421b230,%rdi
  800421826e:	00 00 00 
  8004218271:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218276:	49 b8 de 8d 20 04 80 	movabs $0x8004208dde,%r8
  800421827d:	00 00 00 
  8004218280:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004218283:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004218286:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218289:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421828d:	89 ce                	mov    %ecx,%esi
  800421828f:	48 89 c7             	mov    %rax,%rdi
  8004218292:	48 b8 bb 7a 21 04 80 	movabs $0x8004217abb,%rax
  8004218299:	00 00 00 
  800421829c:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  800421829e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182a2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042182a5:	48 63 d2             	movslq %edx,%rdx
  80042182a8:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  80042182ac:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042182af:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  80042182b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182b7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042182ba:	48 63 d2             	movslq %edx,%rdx
  80042182bd:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  80042182c1:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042182c4:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  80042182c7:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042182cb:	74 6d                	je     800421833a <pci_func_enable+0x21d>
  80042182cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042182d1:	75 67                	jne    800421833a <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  80042182d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182d7:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042182da:	c1 e8 10             	shr    $0x10,%eax
  80042182dd:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  80042182e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182e4:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042182e7:	0f b7 f8             	movzwl %ax,%edi
  80042182ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182ee:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042182f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182f5:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  80042182f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042182fc:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042182ff:	8b 40 08             	mov    0x8(%rax),%eax
  8004218302:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004218305:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004218309:	8b 75 f4             	mov    -0xc(%rbp),%esi
  800421830c:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004218310:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004218313:	89 34 24             	mov    %esi,(%rsp)
  8004218316:	45 89 c1             	mov    %r8d,%r9d
  8004218319:	41 89 f8             	mov    %edi,%r8d
  800421831c:	89 c6                	mov    %eax,%esi
  800421831e:	48 bf 58 b2 21 04 80 	movabs $0x800421b258,%rdi
  8004218325:	00 00 00 
  8004218328:	b8 00 00 00 00       	mov    $0x0,%eax
  800421832d:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  8004218334:	00 00 00 
  8004218337:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  800421833a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421833d:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218340:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004218344:	0f 86 08 fe ff ff    	jbe    8004218152 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  800421834a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421834e:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218351:	c1 e8 10             	shr    $0x10,%eax
  8004218354:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218356:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421835a:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  800421835d:	0f b7 f0             	movzwl %ax,%esi
  8004218360:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218364:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218367:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421836b:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  800421836e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218372:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218375:	8b 40 08             	mov    0x8(%rax),%eax
  8004218378:	41 89 f9             	mov    %edi,%r9d
  800421837b:	41 89 f0             	mov    %esi,%r8d
  800421837e:	89 c6                	mov    %eax,%esi
  8004218380:	48 bf b8 b2 21 04 80 	movabs $0x800421b2b8,%rdi
  8004218387:	00 00 00 
  800421838a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421838f:	49 ba de 8d 20 04 80 	movabs $0x8004208dde,%r10
  8004218396:	00 00 00 
  8004218399:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  800421839c:	c9                   	leaveq 
  800421839d:	c3                   	retq   

000000800421839e <pci_init>:

int
pci_init(void)
{
  800421839e:	55                   	push   %rbp
  800421839f:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  80042183a2:	ba 10 00 00 00       	mov    $0x10,%edx
  80042183a7:	be 00 00 00 00       	mov    $0x0,%esi
  80042183ac:	48 bf 20 d4 60 04 80 	movabs $0x800460d420,%rdi
  80042183b3:	00 00 00 
  80042183b6:	48 b8 55 fa 20 04 80 	movabs $0x800420fa55,%rax
  80042183bd:	00 00 00 
  80042183c0:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  80042183c2:	48 bf 20 d4 60 04 80 	movabs $0x800460d420,%rdi
  80042183c9:	00 00 00 
  80042183cc:	48 b8 6d 7d 21 04 80 	movabs $0x8004217d6d,%rax
  80042183d3:	00 00 00 
  80042183d6:	ff d0                	callq  *%rax
}
  80042183d8:	5d                   	pop    %rbp
  80042183d9:	c3                   	retq   

00000080042183da <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  80042183da:	55                   	push   %rbp
  80042183db:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  80042183de:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  80042183e5:	00 00 00 
  80042183e8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  80042183ee:	5d                   	pop    %rbp
  80042183ef:	c3                   	retq   

00000080042183f0 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  80042183f0:	55                   	push   %rbp
  80042183f1:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  80042183f4:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  80042183fb:	00 00 00 
  80042183fe:	8b 00                	mov    (%rax),%eax
  8004218400:	8d 50 01             	lea    0x1(%rax),%edx
  8004218403:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  800421840a:	00 00 00 
  800421840d:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  800421840f:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  8004218416:	00 00 00 
  8004218419:	8b 10                	mov    (%rax),%edx
  800421841b:	89 d0                	mov    %edx,%eax
  800421841d:	c1 e0 02             	shl    $0x2,%eax
  8004218420:	01 d0                	add    %edx,%eax
  8004218422:	01 c0                	add    %eax,%eax
  8004218424:	89 c2                	mov    %eax,%edx
  8004218426:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  800421842d:	00 00 00 
  8004218430:	8b 00                	mov    (%rax),%eax
  8004218432:	39 c2                	cmp    %eax,%edx
  8004218434:	73 2a                	jae    8004218460 <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004218436:	48 ba e7 b2 21 04 80 	movabs $0x800421b2e7,%rdx
  800421843d:	00 00 00 
  8004218440:	be 13 00 00 00       	mov    $0x13,%esi
  8004218445:	48 bf 02 b3 21 04 80 	movabs $0x800421b302,%rdi
  800421844c:	00 00 00 
  800421844f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218454:	48 b9 3e 05 20 04 80 	movabs $0x800420053e,%rcx
  800421845b:	00 00 00 
  800421845e:	ff d1                	callq  *%rcx
}
  8004218460:	5d                   	pop    %rbp
  8004218461:	c3                   	retq   

0000008004218462 <time_msec>:

unsigned int
time_msec(void)
{
  8004218462:	55                   	push   %rbp
  8004218463:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004218466:	48 b8 30 d4 60 04 80 	movabs $0x800460d430,%rax
  800421846d:	00 00 00 
  8004218470:	8b 10                	mov    (%rax),%edx
  8004218472:	89 d0                	mov    %edx,%eax
  8004218474:	c1 e0 02             	shl    $0x2,%eax
  8004218477:	01 d0                	add    %edx,%eax
  8004218479:	01 c0                	add    %eax,%eax
}
  800421847b:	5d                   	pop    %rbp
  800421847c:	c3                   	retq   
