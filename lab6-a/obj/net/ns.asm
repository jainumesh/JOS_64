
obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 5f 10 00 00       	callq  8010a0 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 04          	sub    $0x4,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 04          	sub    $0x4,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 22                	jmp    8000cd <get_buffer+0x34>
        if (!buse[i]) break;
  8000ab:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	74 02                	je     8000c8 <get_buffer+0x2f>
  8000c6:	eb 0c                	jmp    8000d4 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cd:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d2:	7e d7                	jle    8000ab <get_buffer+0x12>
        if (!buse[i]) break;

    if (i == QUEUE_SIZE) {
  8000d4:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000d9:	75 2a                	jne    800105 <get_buffer+0x6c>
        panic("NS: buffer overflow");
  8000db:	48 ba 20 09 82 00 00 	movabs $0x820920,%rdx
  8000e2:	00 00 00 
  8000e5:	be 3f 00 00 00       	mov    $0x3f,%esi
  8000ea:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  8000f1:	00 00 00 
  8000f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8000f9:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  800100:	00 00 00 
  800103:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800109:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  80010f:	48 c1 e0 0c          	shl    $0xc,%rax
  800113:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800117:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  80011e:	00 00 00 
  800121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800125:	48 01 d0             	add    %rdx,%rax
  800128:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80012f:	c9                   	leaveq 
  800130:	c3                   	retq   

0000000000800131 <put_buffer>:

static void
put_buffer(void *va) {
  800131:	55                   	push   %rbp
  800132:	48 89 e5             	mov    %rsp,%rbp
  800135:	48 83 ec 18          	sub    $0x18,%rsp
  800139:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800141:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800147:	48 c1 e8 0c          	shr    $0xc,%rax
  80014b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  80014f:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800156:	00 00 00 
  800159:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015d:	48 01 d0             	add    %rdx,%rax
  800160:	c6 00 00             	movb   $0x0,(%rax)
}
  800163:	c9                   	leaveq 
  800164:	c3                   	retq   

0000000000800165 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800165:	55                   	push   %rbp
  800166:	48 89 e5             	mov    %rsp,%rbp
  800169:	53                   	push   %rbx
  80016a:	48 83 ec 68          	sub    $0x68,%rsp
  80016e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800172:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800176:	89 55 ac             	mov    %edx,-0x54(%rbp)
  800179:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  80017c:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800180:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800183:	89 45 e0             	mov    %eax,-0x20(%rbp)
    netmask.addr = init_mask;
  800186:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800189:	89 45 d0             	mov    %eax,-0x30(%rbp)
    gateway.addr = init_gw;
  80018c:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80018f:	89 45 c0             	mov    %eax,-0x40(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800192:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  800196:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80019a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80019e:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8001a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8001a6:	48 bb 6f 0d 81 00 00 	movabs $0x810d6f,%rbx
  8001ad:	00 00 00 
  8001b0:	48 89 1c 24          	mov    %rbx,(%rsp)
  8001b4:	49 b9 03 98 81 00 00 	movabs $0x819803,%r9
  8001bb:	00 00 00 
  8001be:	49 89 f8             	mov    %rdi,%r8
  8001c1:	48 89 c7             	mov    %rax,%rdi
  8001c4:	48 b8 63 ce 80 00 00 	movabs $0x80ce63,%rax
  8001cb:	00 00 00 
  8001ce:	ff d0                	callq  *%rax
  8001d0:	48 85 c0             	test   %rax,%rax
  8001d3:	75 2a                	jne    8001ff <lwip_init+0x9a>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001d5:	48 ba 40 09 82 00 00 	movabs $0x820940,%rdx
  8001dc:	00 00 00 
  8001df:	be 5c 00 00 00       	mov    $0x5c,%esi
  8001e4:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  8001eb:	00 00 00 
  8001ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8001fa:	00 00 00 
  8001fd:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  8001ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800203:	48 89 c7             	mov    %rax,%rdi
  800206:	48 b8 63 d2 80 00 00 	movabs $0x80d263,%rax
  80020d:	00 00 00 
  800210:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800212:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800216:	48 89 c7             	mov    %rax,%rdi
  800219:	48 b8 82 d2 80 00 00 	movabs $0x80d282,%rax
  800220:	00 00 00 
  800223:	ff d0                	callq  *%rax
}
  800225:	48 83 c4 68          	add    $0x68,%rsp
  800229:	5b                   	pop    %rbx
  80022a:	5d                   	pop    %rbp
  80022b:	c3                   	retq   

000000000080022c <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022c:	55                   	push   %rbp
  80022d:	48 89 e5             	mov    %rsp,%rbp
  800230:	48 83 ec 20          	sub    $0x20,%rsp
  800234:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  800238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800240:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  800247:	00 00 00 
  80024a:	ff d0                	callq  *%rax
  80024c:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  80024f:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  800256:	00 00 00 
  800259:	ff d0                	callq  *%rax
        t->func();
  80025b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80025f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800263:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800265:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  80026c:	00 00 00 
  80026f:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800275:	8b 10                	mov    (%rax),%edx
  800277:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027a:	01 d0                	add    %edx,%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 f8 8a 81 00 00 	movabs $0x818af8,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
    }
  800294:	eb aa                	jmp    800240 <net_timer+0x14>

0000000000800296 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2c 02 80 00 00 	movabs $0x80022c,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 6d 8d 81 00 00 	movabs $0x818d6d,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 f5 93 81 00 00 	movabs $0x8193f5,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 60 09 82 00 00 	movabs $0x820960,%rdx
  80031b:	00 00 00 
  80031e:	be 7a 00 00 00       	mov    $0x7a,%esi
  800323:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 a5 8a 81 00 00 	movabs $0x818aa5,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 30          	sub    $0x30,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  800385:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 2a 8c 80 00 00 	movabs $0x808c2a,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003b5:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 f8 8a 81 00 00 	movabs $0x818af8,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003de:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800401:	00 00 00 
  800404:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 65 01 80 00 00 	movabs $0x800165,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 7f 09 82 00 00 	movabs $0x82097f,%rdx
  800426:	00 00 00 
  800429:	48 be 6c 59 81 00 00 	movabs $0x81596c,%rsi
  800430:	00 00 00 
  800433:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba 89 09 82 00 00 	movabs $0x820989,%rdx
  800455:	00 00 00 
  800458:	48 be fa 01 81 00 00 	movabs $0x8101fa,%rsi
  80045f:	00 00 00 
  800462:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba 95 09 82 00 00 	movabs $0x820995,%rdx
  800484:	00 00 00 
  800487:	48 be be f9 80 00 00 	movabs $0x80f9be,%rsi
  80048e:	00 00 00 
  800491:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 bc 2d 81 00 00 	movabs $0x812dbc,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004be:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004c5:	00 00 00 
  8004c8:	0f b6 52 46          	movzbl 0x46(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cc:	0f b6 fa             	movzbl %dl,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004cf:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004d6:	00 00 00 
  8004d9:	0f b6 52 45          	movzbl 0x45(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004dd:	44 0f b6 ca          	movzbl %dl,%r9d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e1:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004e8:	00 00 00 
  8004eb:	0f b6 52 44          	movzbl 0x44(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ef:	44 0f b6 c2          	movzbl %dl,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f3:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004fa:	00 00 00 
  8004fd:	0f b6 52 43          	movzbl 0x43(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800501:	0f b6 ca             	movzbl %dl,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800504:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  80050b:	00 00 00 
  80050e:	0f b6 52 42          	movzbl 0x42(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800512:	0f b6 d2             	movzbl %dl,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800515:	48 be 20 75 b5 00 00 	movabs $0xb57520,%rsi
  80051c:	00 00 00 
  80051f:	0f b6 76 41          	movzbl 0x41(%rsi),%esi
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800523:	40 0f b6 f6          	movzbl %sil,%esi
  800527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  80052c:	89 3c 24             	mov    %edi,(%rsp)
  80052f:	48 bf a8 09 82 00 00 	movabs $0x8209a8,%rdi
  800536:	00 00 00 
  800539:	b8 00 00 00 00       	mov    $0x0,%eax
  80053e:	49 ba 87 13 80 00 00 	movabs $0x801387,%r10
  800545:	00 00 00 
  800548:	41 ff d2             	callq  *%r10
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  80054b:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  800552:	00 00 00 
  800555:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800557:	48 bf e1 09 82 00 00 	movabs $0x8209e1,%rdi
  80055e:	00 00 00 
  800561:	b8 00 00 00 00       	mov    $0x0,%eax
  800566:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  80056d:	00 00 00 
  800570:	ff d2                	callq  *%rdx
}
  800572:	c9                   	leaveq 
  800573:	c3                   	retq   

0000000000800574 <process_timer>:

static void
process_timer(envid_t envid) {
  800574:	55                   	push   %rbp
  800575:	48 89 e5             	mov    %rsp,%rbp
  800578:	48 83 ec 20          	sub    $0x20,%rsp
  80057c:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80057f:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800586:	00 00 00 
  800589:	8b 00                	mov    (%rax),%eax
  80058b:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80058e:	74 22                	je     8005b2 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800590:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800593:	89 c6                	mov    %eax,%esi
  800595:	48 bf 00 0a 82 00 00 	movabs $0x820a00,%rdi
  80059c:	00 00 00 
  80059f:	b8 00 00 00 00       	mov    $0x0,%eax
  8005a4:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8005ab:	00 00 00 
  8005ae:	ff d2                	callq  *%rdx
        return;
  8005b0:	eb 5a                	jmp    80060c <process_timer+0x98>
    }

    start = sys_time_msec();
  8005b2:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  8005b9:	00 00 00 
  8005bc:	ff d0                	callq  *%rax
  8005be:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005c1:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  8005c8:	00 00 00 
  8005cb:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005cd:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  8005d4:	00 00 00 
  8005d7:	ff d0                	callq  *%rax
  8005d9:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8005df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8005e2:	29 c2                	sub    %eax,%edx
  8005e4:	89 d0                	mov    %edx,%eax
  8005e6:	05 fa 00 00 00       	add    $0xfa,%eax
  8005eb:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005ee:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005f9:	ba 00 00 00 00       	mov    $0x0,%edx
  8005fe:	89 c7                	mov    %eax,%edi
  800600:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  800607:	00 00 00 
  80060a:	ff d0                	callq  *%rax
}
  80060c:	c9                   	leaveq 
  80060d:	c3                   	retq   

000000000080060e <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  80060e:	55                   	push   %rbp
  80060f:	48 89 e5             	mov    %rsp,%rbp
  800612:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800619:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  800620:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800627:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  80062b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80062f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800633:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063b:	8b 00                	mov    (%rax),%eax
  80063d:	83 f8 0a             	cmp    $0xa,%eax
  800640:	0f 87 d8 01 00 00    	ja     80081e <serve_thread+0x210>
  800646:	89 c0                	mov    %eax,%eax
  800648:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80064f:	00 
  800650:	48 b8 78 0a 82 00 00 	movabs $0x820a78,%rax
  800657:	00 00 00 
  80065a:	48 01 d0             	add    %rdx,%rax
  80065d:	48 8b 00             	mov    (%rax),%rax
  800660:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800666:	8b 00                	mov    (%rax),%eax
  800668:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80066c:	48 83 c2 10          	add    $0x10,%rdx
  800670:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800674:	48 89 ce             	mov    %rcx,%rsi
  800677:	89 c7                	mov    %eax,%edi
  800679:	48 b8 40 5e 80 00 00 	movabs $0x805e40,%rax
  800680:	00 00 00 
  800683:	ff d0                	callq  *%rax
  800685:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  800688:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80068c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800690:	ba 14 00 00 00       	mov    $0x14,%edx
  800695:	48 89 ce             	mov    %rcx,%rsi
  800698:	48 89 c7             	mov    %rax,%rdi
  80069b:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8006a2:	00 00 00 
  8006a5:	ff d0                	callq  *%rax
                break;
  8006a7:	90                   	nop
  8006a8:	e9 a5 01 00 00       	jmpq   800852 <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b1:	8b 50 14             	mov    0x14(%rax),%edx
  8006b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b8:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c0:	8b 00                	mov    (%rax),%eax
  8006c2:	48 89 ce             	mov    %rcx,%rsi
  8006c5:	89 c7                	mov    %eax,%edi
  8006c7:	48 b8 73 61 80 00 00 	movabs $0x806173,%rax
  8006ce:	00 00 00 
  8006d1:	ff d0                	callq  *%rax
  8006d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006d6:	e9 77 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006df:	8b 50 04             	mov    0x4(%rax),%edx
  8006e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e6:	8b 00                	mov    (%rax),%eax
  8006e8:	89 d6                	mov    %edx,%esi
  8006ea:	89 c7                	mov    %eax,%edi
  8006ec:	48 b8 d7 78 80 00 00 	movabs $0x8078d7,%rax
  8006f3:	00 00 00 
  8006f6:	ff d0                	callq  *%rax
  8006f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  8006fb:	e9 52 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  800700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800704:	8b 00                	mov    (%rax),%eax
  800706:	89 c7                	mov    %eax,%edi
  800708:	48 b8 a8 62 80 00 00 	movabs $0x8062a8,%rax
  80070f:	00 00 00 
  800712:	ff d0                	callq  *%rax
  800714:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800717:	e9 36 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80071c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800720:	8b 50 14             	mov    0x14(%rax),%edx
  800723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800727:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072f:	8b 00                	mov    (%rax),%eax
  800731:	48 89 ce             	mov    %rcx,%rsi
  800734:	89 c7                	mov    %eax,%edi
  800736:	48 b8 8d 63 80 00 00 	movabs $0x80638d,%rax
  80073d:	00 00 00 
  800740:	ff d0                	callq  *%rax
  800742:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  800745:	e9 08 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80074e:	8b 50 04             	mov    0x4(%rax),%edx
  800751:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800755:	8b 00                	mov    (%rax),%eax
  800757:	89 d6                	mov    %edx,%esi
  800759:	89 c7                	mov    %eax,%edi
  80075b:	48 b8 e9 64 80 00 00 	movabs $0x8064e9,%rax
  800762:	00 00 00 
  800765:	ff d0                	callq  *%rax
  800767:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80076a:	e9 e3 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80076f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800773:	8b 48 08             	mov    0x8(%rax),%ecx
  800776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077a:	8b 50 04             	mov    0x4(%rax),%edx
  80077d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800785:	8b 00                	mov    (%rax),%eax
  800787:	89 c7                	mov    %eax,%edi
  800789:	48 b8 e8 69 80 00 00 	movabs $0x8069e8,%rax
  800790:	00 00 00 
  800793:	ff d0                	callq  *%rax
  800795:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  800798:	e9 b5 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  80079d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a1:	8b 48 08             	mov    0x8(%rax),%ecx
  8007a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a8:	8b 50 04             	mov    0x4(%rax),%edx
  8007ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007af:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b7:	8b 00                	mov    (%rax),%eax
  8007b9:	89 c7                	mov    %eax,%edi
  8007bb:	48 b8 26 6a 80 00 00 	movabs $0x806a26,%rax
  8007c2:	00 00 00 
  8007c5:	ff d0                	callq  *%rax
  8007c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007ca:	e9 83 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007d3:	8b 50 08             	mov    0x8(%rax),%edx
  8007d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007da:	8b 48 04             	mov    0x4(%rax),%ecx
  8007dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e1:	8b 00                	mov    (%rax),%eax
  8007e3:	89 ce                	mov    %ecx,%esi
  8007e5:	89 c7                	mov    %eax,%edi
  8007e7:	48 b8 43 6d 80 00 00 	movabs $0x806d43,%rax
  8007ee:	00 00 00 
  8007f1:	ff d0                	callq  *%rax
  8007f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  8007f6:	eb 5a                	jmp    800852 <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  8007f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007fc:	48 89 c6             	mov    %rax,%rsi
  8007ff:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800806:	00 00 00 
  800809:	48 b8 08 97 81 00 00 	movabs $0x819708,%rax
  800810:	00 00 00 
  800813:	ff d0                	callq  *%rax
            r = 0;
  800815:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  80081c:	eb 34                	jmp    800852 <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80081e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800822:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800826:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082a:	8b 40 04             	mov    0x4(%rax),%eax
  80082d:	89 c6                	mov    %eax,%esi
  80082f:	48 bf 40 0a 82 00 00 	movabs $0x820a40,%rdi
  800836:	00 00 00 
  800839:	b8 00 00 00 00       	mov    $0x0,%eax
  80083e:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  800845:	00 00 00 
  800848:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  80084a:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  800851:	90                   	nop
    }

    if (r == -1) {
  800852:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800856:	75 49                	jne    8008a1 <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80085c:	8b 10                	mov    (%rax),%edx
  80085e:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800865:	89 d1                	mov    %edx,%ecx
  800867:	48 ba 63 0a 82 00 00 	movabs $0x820a63,%rdx
  80086e:	00 00 00 
  800871:	be 64 00 00 00       	mov    $0x64,%esi
  800876:	48 89 c7             	mov    %rax,%rdi
  800879:	b8 00 00 00 00       	mov    $0x0,%eax
  80087e:	49 b8 ef 1d 80 00 00 	movabs $0x801def,%r8
  800885:	00 00 00 
  800888:	41 ff d0             	callq  *%r8
        perror(buf);
  80088b:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800892:	48 89 c7             	mov    %rax,%rdi
  800895:	48 b8 a2 93 81 00 00 	movabs $0x8193a2,%rax
  80089c:	00 00 00 
  80089f:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a5:	8b 00                	mov    (%rax),%eax
  8008a7:	83 f8 0a             	cmp    $0xa,%eax
  8008aa:	74 22                	je     8008ce <serve_thread+0x2c0>
        ipc_send(args->whom, r, 0, 0);
  8008ac:	8b 75 fc             	mov    -0x4(%rbp),%esi
  8008af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008b3:	8b 40 04             	mov    0x4(%rax),%eax
  8008b6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008bb:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c0:	89 c7                	mov    %eax,%edi
  8008c2:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  8008c9:	00 00 00 
  8008cc:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008d6:	48 89 c7             	mov    %rax,%rdi
  8008d9:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8008e0:	00 00 00 
  8008e3:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008ed:	48 89 c6             	mov    %rax,%rsi
  8008f0:	bf 00 00 00 00       	mov    $0x0,%edi
  8008f5:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8008fc:	00 00 00 
  8008ff:	ff d0                	callq  *%rax
    free(args);
  800901:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800905:	48 89 c7             	mov    %rax,%rdi
  800908:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  80090f:	00 00 00 
  800912:	ff d0                	callq  *%rax
}
  800914:	c9                   	leaveq 
  800915:	c3                   	retq   

0000000000800916 <serve>:

void
serve(void) {
  800916:	55                   	push   %rbp
  800917:	48 89 e5             	mov    %rsp,%rbp
  80091a:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80091e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800925:	eb 10                	jmp    800937 <serve+0x21>
            thread_yield();
  800927:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  80092e:	00 00 00 
  800931:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800933:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800937:	48 b8 d6 8b 81 00 00 	movabs $0x818bd6,%rax
  80093e:	00 00 00 
  800941:	ff d0                	callq  *%rax
  800943:	85 c0                	test   %eax,%eax
  800945:	74 06                	je     80094d <serve+0x37>
  800947:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80094b:	7e da                	jle    800927 <serve+0x11>
            thread_yield();

        perm = 0;
  80094d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800954:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  80095b:	00 00 00 
  80095e:	ff d0                	callq  *%rax
  800960:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800964:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800968:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80096c:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800970:	48 89 ce             	mov    %rcx,%rsi
  800973:	48 89 c7             	mov    %rax,%rdi
  800976:	48 b8 3e 32 80 00 00 	movabs $0x80323e,%rax
  80097d:	00 00 00 
  800980:	ff d0                	callq  *%rax
  800982:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800985:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  800989:	75 29                	jne    8009b4 <serve+0x9e>
            process_timer(whom);
  80098b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80098e:	89 c7                	mov    %eax,%edi
  800990:	48 b8 74 05 80 00 00 	movabs $0x800574,%rax
  800997:	00 00 00 
  80099a:	ff d0                	callq  *%rax
            put_buffer(va);
  80099c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a0:	48 89 c7             	mov    %rax,%rdi
  8009a3:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8009aa:	00 00 00 
  8009ad:	ff d0                	callq  *%rax
            continue;
  8009af:	e9 d1 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009b4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009b7:	83 e0 01             	and    $0x1,%eax
  8009ba:	85 c0                	test   %eax,%eax
  8009bc:	75 25                	jne    8009e3 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009be:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c1:	89 c6                	mov    %eax,%esi
  8009c3:	48 bf d0 0a 82 00 00 	movabs $0x820ad0,%rdi
  8009ca:	00 00 00 
  8009cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d2:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8009d9:	00 00 00 
  8009dc:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009de:	e9 a2 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009e3:	bf 10 00 00 00       	mov    $0x10,%edi
  8009e8:	48 b8 d6 4c 80 00 00 	movabs $0x804cd6,%rax
  8009ef:	00 00 00 
  8009f2:	ff d0                	callq  *%rax
  8009f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  8009f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8009fd:	75 2a                	jne    800a29 <serve+0x113>
            panic("could not allocate thread args structure");
  8009ff:	48 ba 00 0b 82 00 00 	movabs $0x820b00,%rdx
  800a06:	00 00 00 
  800a09:	be 26 01 00 00       	mov    $0x126,%esi
  800a0e:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  800a15:	00 00 00 
  800a18:	b8 00 00 00 00       	mov    $0x0,%eax
  800a1d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  800a24:	00 00 00 
  800a27:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a2d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a30:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a32:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a39:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a44:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4c:	48 89 c1             	mov    %rax,%rcx
  800a4f:	48 ba 0e 06 80 00 00 	movabs $0x80060e,%rdx
  800a56:	00 00 00 
  800a59:	48 be 29 0b 82 00 00 	movabs $0x820b29,%rsi
  800a60:	00 00 00 
  800a63:	bf 00 00 00 00       	mov    $0x0,%edi
  800a68:	48 b8 6d 8d 81 00 00 	movabs $0x818d6d,%rax
  800a6f:	00 00 00 
  800a72:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a74:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  800a7b:	00 00 00 
  800a7e:	ff d0                	callq  *%rax
    }
  800a80:	e9 99 fe ff ff       	jmpq   80091e <serve+0x8>
  800a85:	e9 94 fe ff ff       	jmpq   80091e <serve+0x8>

0000000000800a8a <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8a:	55                   	push   %rbp
  800a8b:	48 89 e5             	mov    %rsp,%rbp
  800a8e:	41 54                	push   %r12
  800a90:	53                   	push   %rbx
  800a91:	48 83 ec 10          	sub    $0x10,%rsp
  800a95:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800a99:	48 bf 36 0b 82 00 00 	movabs $0x820b36,%rdi
  800aa0:	00 00 00 
  800aa3:	48 b8 df 2a 81 00 00 	movabs $0x812adf,%rax
  800aaa:	00 00 00 
  800aad:	ff d0                	callq  *%rax
  800aaf:	41 89 c4             	mov    %eax,%r12d
  800ab2:	48 bf 3f 0b 82 00 00 	movabs $0x820b3f,%rdi
  800ab9:	00 00 00 
  800abc:	48 b8 df 2a 81 00 00 	movabs $0x812adf,%rax
  800ac3:	00 00 00 
  800ac6:	ff d0                	callq  *%rax
  800ac8:	89 c3                	mov    %eax,%ebx
  800aca:	48 bf 4d 0b 82 00 00 	movabs $0x820b4d,%rdi
  800ad1:	00 00 00 
  800ad4:	48 b8 df 2a 81 00 00 	movabs $0x812adf,%rax
  800adb:	00 00 00 
  800ade:	ff d0                	callq  *%rax
  800ae0:	44 89 e2             	mov    %r12d,%edx
  800ae3:	89 de                	mov    %ebx,%esi
  800ae5:	89 c7                	mov    %eax,%edi
  800ae7:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aee:	00 00 00 
  800af1:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800af3:	48 b8 16 09 80 00 00 	movabs $0x800916,%rax
  800afa:	00 00 00 
  800afd:	ff d0                	callq  *%rax
}
  800aff:	48 83 c4 10          	add    $0x10,%rsp
  800b03:	5b                   	pop    %rbx
  800b04:	41 5c                	pop    %r12
  800b06:	5d                   	pop    %rbp
  800b07:	c3                   	retq   

0000000000800b08 <umain>:

    void
umain(int argc, char **argv)
{
  800b08:	55                   	push   %rbp
  800b09:	48 89 e5             	mov    %rsp,%rbp
  800b0c:	53                   	push   %rbx
  800b0d:	48 83 ec 28          	sub    $0x28,%rsp
  800b11:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800b14:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 ef 27 80 00 00 	movabs $0x8027ef,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns";
  800b27:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  800b2e:	00 00 00 
  800b31:	48 bb 57 0b 82 00 00 	movabs $0x820b57,%rbx
  800b38:	00 00 00 
  800b3b:	48 89 18             	mov    %rbx,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b3e:	48 b8 8d 2f 80 00 00 	movabs $0x802f8d,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	48 ba 58 90 82 00 00 	movabs $0x829058,%rdx
  800b51:	00 00 00 
  800b54:	89 02                	mov    %eax,(%rdx)
    if (timer_envid < 0)
  800b56:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5d:	00 00 00 
  800b60:	8b 00                	mov    (%rax),%eax
  800b62:	85 c0                	test   %eax,%eax
  800b64:	79 2a                	jns    800b90 <umain+0x88>
        panic("error forking");
  800b66:	48 ba 5a 0b 82 00 00 	movabs $0x820b5a,%rdx
  800b6d:	00 00 00 
  800b70:	be 43 01 00 00       	mov    $0x143,%esi
  800b75:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  800b7c:	00 00 00 
  800b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800b84:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  800b8b:	00 00 00 
  800b8e:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b90:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b97:	00 00 00 
  800b9a:	8b 00                	mov    (%rax),%eax
  800b9c:	85 c0                	test   %eax,%eax
  800b9e:	75 1b                	jne    800bbb <umain+0xb3>
        timer(ns_envid, TIMER_INTERVAL);
  800ba0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ba3:	be fa 00 00 00       	mov    $0xfa,%esi
  800ba8:	89 c7                	mov    %eax,%edi
  800baa:	48 b8 f1 0c 80 00 00 	movabs $0x800cf1,%rax
  800bb1:	00 00 00 
  800bb4:	ff d0                	callq  *%rax
        return;
  800bb6:	e9 2f 01 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bbb:	48 b8 8d 2f 80 00 00 	movabs $0x802f8d,%rax
  800bc2:	00 00 00 
  800bc5:	ff d0                	callq  *%rax
  800bc7:	48 ba 5c 90 82 00 00 	movabs $0x82905c,%rdx
  800bce:	00 00 00 
  800bd1:	89 02                	mov    %eax,(%rdx)
    if (input_envid < 0)
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	8b 00                	mov    (%rax),%eax
  800bdf:	85 c0                	test   %eax,%eax
  800be1:	79 2a                	jns    800c0d <umain+0x105>
        panic("error forking");
  800be3:	48 ba 5a 0b 82 00 00 	movabs $0x820b5a,%rdx
  800bea:	00 00 00 
  800bed:	be 4d 01 00 00       	mov    $0x14d,%esi
  800bf2:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  800bf9:	00 00 00 
  800bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  800c01:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  800c08:	00 00 00 
  800c0b:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c0d:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c14:	00 00 00 
  800c17:	8b 00                	mov    (%rax),%eax
  800c19:	85 c0                	test   %eax,%eax
  800c1b:	75 16                	jne    800c33 <umain+0x12b>
        input(ns_envid);
  800c1d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c20:	89 c7                	mov    %eax,%edi
  800c22:	48 b8 12 0e 80 00 00 	movabs $0x800e12,%rax
  800c29:	00 00 00 
  800c2c:	ff d0                	callq  *%rax
        return;
  800c2e:	e9 b7 00 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c33:	48 b8 8d 2f 80 00 00 	movabs $0x802f8d,%rax
  800c3a:	00 00 00 
  800c3d:	ff d0                	callq  *%rax
  800c3f:	48 ba 60 90 82 00 00 	movabs $0x829060,%rdx
  800c46:	00 00 00 
  800c49:	89 02                	mov    %eax,(%rdx)
    if (output_envid < 0)
  800c4b:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c52:	00 00 00 
  800c55:	8b 00                	mov    (%rax),%eax
  800c57:	85 c0                	test   %eax,%eax
  800c59:	79 2a                	jns    800c85 <umain+0x17d>
        panic("error forking");
  800c5b:	48 ba 5a 0b 82 00 00 	movabs $0x820b5a,%rdx
  800c62:	00 00 00 
  800c65:	be 57 01 00 00       	mov    $0x157,%esi
  800c6a:	48 bf 34 09 82 00 00 	movabs $0x820934,%rdi
  800c71:	00 00 00 
  800c74:	b8 00 00 00 00       	mov    $0x0,%eax
  800c79:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  800c80:	00 00 00 
  800c83:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c85:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c8c:	00 00 00 
  800c8f:	8b 00                	mov    (%rax),%eax
  800c91:	85 c0                	test   %eax,%eax
  800c93:	75 13                	jne    800ca8 <umain+0x1a0>
        output(ns_envid);
  800c95:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c98:	89 c7                	mov    %eax,%edi
  800c9a:	48 b8 18 0f 80 00 00 	movabs $0x800f18,%rax
  800ca1:	00 00 00 
  800ca4:	ff d0                	callq  *%rax
        return;
  800ca6:	eb 42                	jmp    800cea <umain+0x1e2>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800ca8:	48 b8 64 8a 81 00 00 	movabs $0x818a64,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cb9:	48 ba 8a 0a 80 00 00 	movabs $0x800a8a,%rdx
  800cc0:	00 00 00 
  800cc3:	48 be 68 0b 82 00 00 	movabs $0x820b68,%rsi
  800cca:	00 00 00 
  800ccd:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd2:	48 b8 6d 8d 81 00 00 	movabs $0x818d6d,%rax
  800cd9:	00 00 00 
  800cdc:	ff d0                	callq  *%rax
    thread_yield();
  800cde:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  800ce5:	00 00 00 
  800ce8:	ff d0                	callq  *%rax
    // never coming here!
}
  800cea:	48 83 c4 28          	add    $0x28,%rsp
  800cee:	5b                   	pop    %rbx
  800cef:	5d                   	pop    %rbp
  800cf0:	c3                   	retq   

0000000000800cf1 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cf1:	55                   	push   %rbp
  800cf2:	48 89 e5             	mov    %rsp,%rbp
  800cf5:	53                   	push   %rbx
  800cf6:	48 83 ec 28          	sub    $0x28,%rsp
  800cfa:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800cfd:	89 75 d8             	mov    %esi,-0x28(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d00:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  800d07:	00 00 00 
  800d0a:	ff d0                	callq  *%rax
  800d0c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800d0f:	01 d0                	add    %edx,%eax
  800d11:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns_timer";
  800d14:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  800d1b:	00 00 00 
  800d1e:	48 bb 70 0b 82 00 00 	movabs $0x820b70,%rbx
  800d25:	00 00 00 
  800d28:	48 89 18             	mov    %rbx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d2b:	eb 0c                	jmp    800d39 <timer+0x48>
            sys_yield();
  800d2d:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  800d34:	00 00 00 
  800d37:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d39:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  800d40:	00 00 00 
  800d43:	ff d0                	callq  *%rax
  800d45:	89 45 e8             	mov    %eax,-0x18(%rbp)
  800d48:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d4b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800d4e:	73 06                	jae    800d56 <timer+0x65>
  800d50:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d54:	79 d7                	jns    800d2d <timer+0x3c>
            sys_yield();
        }
        if (r < 0)
  800d56:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d5a:	79 30                	jns    800d8c <timer+0x9b>
            panic("sys_time_msec: %e", r);
  800d5c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d5f:	89 c1                	mov    %eax,%ecx
  800d61:	48 ba 79 0b 82 00 00 	movabs $0x820b79,%rdx
  800d68:	00 00 00 
  800d6b:	be 0f 00 00 00       	mov    $0xf,%esi
  800d70:	48 bf 8b 0b 82 00 00 	movabs $0x820b8b,%rdi
  800d77:	00 00 00 
  800d7a:	b8 00 00 00 00       	mov    $0x0,%eax
  800d7f:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  800d86:	00 00 00 
  800d89:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d8c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800d8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d94:	ba 00 00 00 00       	mov    $0x0,%edx
  800d99:	be 0c 00 00 00       	mov    $0xc,%esi
  800d9e:	89 c7                	mov    %eax,%edi
  800da0:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  800da7:	00 00 00 
  800daa:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800dac:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800db0:	ba 00 00 00 00       	mov    $0x0,%edx
  800db5:	be 00 00 00 00       	mov    $0x0,%esi
  800dba:	48 89 c7             	mov    %rax,%rdi
  800dbd:	48 b8 3e 32 80 00 00 	movabs $0x80323e,%rax
  800dc4:	00 00 00 
  800dc7:	ff d0                	callq  *%rax
  800dc9:	89 45 e4             	mov    %eax,-0x1c(%rbp)

            if (whom != ns_envid) {
  800dcc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800dcf:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd2:	39 c2                	cmp    %eax,%edx
  800dd4:	74 22                	je     800df8 <timer+0x107>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dd6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd9:	89 c6                	mov    %eax,%esi
  800ddb:	48 bf 98 0b 82 00 00 	movabs $0x820b98,%rdi
  800de2:	00 00 00 
  800de5:	b8 00 00 00 00       	mov    $0x0,%eax
  800dea:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  800df1:	00 00 00 
  800df4:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800df6:	eb b4                	jmp    800dac <timer+0xbb>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800df8:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  800dff:	00 00 00 
  800e02:	ff d0                	callq  *%rax
  800e04:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800e07:	01 d0                	add    %edx,%eax
  800e09:	89 45 ec             	mov    %eax,-0x14(%rbp)
            break;
        }
    }
  800e0c:	90                   	nop
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800e0d:	e9 27 ff ff ff       	jmpq   800d39 <timer+0x48>

0000000000800e12 <input>:

#define debug 0

void
input(envid_t ns_envid)
{
  800e12:	55                   	push   %rbp
  800e13:	48 89 e5             	mov    %rsp,%rbp
  800e16:	53                   	push   %rbx
  800e17:	48 81 ec 28 08 00 00 	sub    $0x828,%rsp
  800e1e:	89 bd dc f7 ff ff    	mov    %edi,-0x824(%rbp)
    binaryname = "ns_input";
  800e24:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  800e2b:	00 00 00 
  800e2e:	48 bb d3 0b 82 00 00 	movabs $0x820bd3,%rbx
  800e35:	00 00 00 
  800e38:	48 89 18             	mov    %rbx,(%rax)
		//If allocating new page each time		
        //sys_page_unmap(0, &nsipcbuf.pkt.jp_data);
	}
#else
	char buf[2048];
	int perm = PTE_U | PTE_P | PTE_W; //This is needed for page allocation from kern to user environment. (Remember no transfer can happen (that is sys_page_map)
  800e3b:	c7 45 ec 07 00 00 00 	movl   $0x7,-0x14(%rbp)
	int len = 2047; // Buffer length
  800e42:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%rbp)
	int r = 0;
  800e49:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	while (1) {
		while ((r = sys_net_rx(&buf)) < 0) {
  800e50:	eb 0c                	jmp    800e5e <input+0x4c>
			sys_yield(); //This was neat.
  800e52:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  800e59:	00 00 00 
  800e5c:	ff d0                	callq  *%rax
	char buf[2048];
	int perm = PTE_U | PTE_P | PTE_W; //This is needed for page allocation from kern to user environment. (Remember no transfer can happen (that is sys_page_map)
	int len = 2047; // Buffer length
	int r = 0;
	while (1) {
		while ((r = sys_net_rx(&buf)) < 0) {
  800e5e:	48 8d 85 e0 f7 ff ff 	lea    -0x820(%rbp),%rax
  800e65:	48 89 c7             	mov    %rax,%rdi
  800e68:	48 b8 22 2b 80 00 00 	movabs $0x802b22,%rax
  800e6f:	00 00 00 
  800e72:	ff d0                	callq  *%rax
  800e74:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800e77:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800e7b:	78 d5                	js     800e52 <input+0x40>
			sys_yield(); //This was neat.
		}
		len = r;
  800e7d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800e80:	89 45 e8             	mov    %eax,-0x18(%rbp)
		// Get the page received from the PCI. (Don't use sys_page_map..use alloc)
		while ((r = sys_page_alloc(0, &nsipcbuf, perm)) < 0);
  800e83:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800e86:	89 c2                	mov    %eax,%edx
  800e88:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800e8f:	00 00 00 
  800e92:	bf 00 00 00 00       	mov    $0x0,%edi
  800e97:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  800e9e:	00 00 00 
  800ea1:	ff d0                	callq  *%rax
  800ea3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800ea6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800eaa:	78 d7                	js     800e83 <input+0x71>
		nsipcbuf.pkt.jp_len = len;
  800eac:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800eb3:	00 00 00 
  800eb6:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800eb9:	89 10                	mov    %edx,(%rax)
		memmove(nsipcbuf.pkt.jp_data, buf, len);
  800ebb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800ebe:	48 63 d0             	movslq %eax,%rdx
  800ec1:	48 8d 85 e0 f7 ff ff 	lea    -0x820(%rbp),%rax
  800ec8:	48 89 c6             	mov    %rax,%rsi
  800ecb:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  800ed2:	00 00 00 
  800ed5:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  800edc:	00 00 00 
  800edf:	ff d0                	callq  *%rax
		while ((r = sys_ipc_try_send(ns_envid, NSREQ_INPUT, &nsipcbuf, perm)) < 0);
  800ee1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800ee4:	8b 85 dc f7 ff ff    	mov    -0x824(%rbp),%eax
  800eea:	89 d1                	mov    %edx,%ecx
  800eec:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  800ef3:	00 00 00 
  800ef6:	be 0a 00 00 00       	mov    $0xa,%esi
  800efb:	89 c7                	mov    %eax,%edi
  800efd:	48 b8 3f 2a 80 00 00 	movabs $0x802a3f,%rax
  800f04:	00 00 00 
  800f07:	ff d0                	callq  *%rax
  800f09:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800f0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800f10:	78 cf                	js     800ee1 <input+0xcf>
	}
  800f12:	90                   	nop
	char buf[2048];
	int perm = PTE_U | PTE_P | PTE_W; //This is needed for page allocation from kern to user environment. (Remember no transfer can happen (that is sys_page_map)
	int len = 2047; // Buffer length
	int r = 0;
	while (1) {
		while ((r = sys_net_rx(&buf)) < 0) {
  800f13:	e9 46 ff ff ff       	jmpq   800e5e <input+0x4c>

0000000000800f18 <output>:
// Virtual address at which to receive page mappings containing client requests.
struct jif_pkt *sendReq = (struct jif_pkt *)(0x0ffff000 - PGSIZE);

void
output(envid_t ns_envid)
{
  800f18:	55                   	push   %rbp
  800f19:	48 89 e5             	mov    %rsp,%rbp
  800f1c:	53                   	push   %rbx
  800f1d:	48 83 ec 38          	sub    $0x38,%rsp
  800f21:	89 7d cc             	mov    %edi,-0x34(%rbp)
    binaryname = "ns_output";
  800f24:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  800f2b:	00 00 00 
  800f2e:	48 bb e0 0b 82 00 00 	movabs $0x820be0,%rbx
  800f35:	00 00 00 
  800f38:	48 89 18             	mov    %rbx,(%rax)

    // LAB 6: Your code here:
    // 	- read a packet from the network server
    //	- send the packet to the device driver
#if 1
	void* buf = NULL;
  800f3b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800f42:	00 
	size_t len = 0;
  800f43:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800f4a:	00 
	//struct jif_pkt *sendReq;
	uint32_t req, whom;
	int perm, r;

	while (1) {
		perm = 0;
  800f4b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)

		cprintf("output env id %d \n", thisenv->env_id);
  800f52:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  800f59:	00 00 00 
  800f5c:	48 8b 00             	mov    (%rax),%rax
  800f5f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800f65:	89 c6                	mov    %eax,%esi
  800f67:	48 bf ea 0b 82 00 00 	movabs $0x820bea,%rdi
  800f6e:	00 00 00 
  800f71:	b8 00 00 00 00       	mov    $0x0,%eax
  800f76:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  800f7d:	00 00 00 
  800f80:	ff d2                	callq  *%rdx

		req = ipc_recv((int32_t *) &whom, sendReq, &perm);
  800f82:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800f89:	00 00 00 
  800f8c:	48 8b 08             	mov    (%rax),%rcx
  800f8f:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800f93:	48 8d 45 d4          	lea    -0x2c(%rbp),%rax
  800f97:	48 89 ce             	mov    %rcx,%rsi
  800f9a:	48 89 c7             	mov    %rax,%rdi
  800f9d:	48 b8 3e 32 80 00 00 	movabs $0x80323e,%rax
  800fa4:	00 00 00 
  800fa7:	ff d0                	callq  *%rax
  800fa9:	89 45 dc             	mov    %eax,-0x24(%rbp)
		while(thisenv->env_ipc_recving == 1)
  800fac:	eb 0c                	jmp    800fba <output+0xa2>
			sys_yield();
  800fae:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  800fb5:	00 00 00 
  800fb8:	ff d0                	callq  *%rax
		perm = 0;

		cprintf("output env id %d \n", thisenv->env_id);

		req = ipc_recv((int32_t *) &whom, sendReq, &perm);
		while(thisenv->env_ipc_recving == 1)
  800fba:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  800fc1:	00 00 00 
  800fc4:	48 8b 00             	mov    (%rax),%rax
  800fc7:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800fce:	84 c0                	test   %al,%al
  800fd0:	75 dc                	jne    800fae <output+0x96>
		if (debug)
			cprintf("net packet send req %d from %08x [page %08x: %s]\n",
				req, whom, uvpt[PGNUM(sendReq)], sendReq);

		// All requests must contain an argument page
		if (!(perm & PTE_P)) {
  800fd2:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800fd5:	83 e0 01             	and    $0x1,%eax
  800fd8:	85 c0                	test   %eax,%eax
  800fda:	75 26                	jne    801002 <output+0xea>
			cprintf("Invalid request from %08x: no argument page\n",
  800fdc:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800fdf:	89 c6                	mov    %eax,%esi
  800fe1:	48 bf 00 0c 82 00 00 	movabs $0x820c00,%rdi
  800fe8:	00 00 00 
  800feb:	b8 00 00 00 00       	mov    $0x0,%eax
  800ff0:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  800ff7:	00 00 00 
  800ffa:	ff d2                	callq  *%rdx
				whom);
			continue; // just leave it hanging...
  800ffc:	90                   	nop
			continue;
		}
		while ((r = sys_net_tx(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0);		
		//cprintf("buffer %s len %d\n", nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
#endif		
    }
  800ffd:	e9 49 ff ff ff       	jmpq   800f4b <output+0x33>
			continue; // just leave it hanging...
		}
		//if(debug)
		//	cprintf("output data %s",sendReq->jp_data);

		if(req == NSREQ_OUTPUT)
  801002:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  801006:	75 48                	jne    801050 <output+0x138>
		{	
			while(sys_net_tx((void*)sendReq->jp_data, sendReq->jp_len) != 0)
  801008:	eb 0c                	jmp    801016 <output+0xfe>
			{
				sys_yield();
  80100a:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  801011:	00 00 00 
  801014:	ff d0                	callq  *%rax
		//if(debug)
		//	cprintf("output data %s",sendReq->jp_data);

		if(req == NSREQ_OUTPUT)
		{	
			while(sys_net_tx((void*)sendReq->jp_data, sendReq->jp_len) != 0)
  801016:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  80101d:	00 00 00 
  801020:	48 8b 00             	mov    (%rax),%rax
  801023:	8b 00                	mov    (%rax),%eax
  801025:	48 98                	cltq   
  801027:	48 ba 00 80 82 00 00 	movabs $0x828000,%rdx
  80102e:	00 00 00 
  801031:	48 8b 12             	mov    (%rdx),%rdx
  801034:	48 83 c2 04          	add    $0x4,%rdx
  801038:	48 89 c6             	mov    %rax,%rsi
  80103b:	48 89 d7             	mov    %rdx,%rdi
  80103e:	48 b8 d8 2a 80 00 00 	movabs $0x802ad8,%rax
  801045:	00 00 00 
  801048:	ff d0                	callq  *%rax
  80104a:	85 c0                	test   %eax,%eax
  80104c:	75 bc                	jne    80100a <output+0xf2>
  80104e:	eb 2a                	jmp    80107a <output+0x162>
			{
				sys_yield();
			}
		}else {
			cprintf("Invalid request code %d from %08x\n", req, whom);
  801050:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  801053:	8b 45 dc             	mov    -0x24(%rbp),%eax
  801056:	89 c6                	mov    %eax,%esi
  801058:	48 bf 30 0c 82 00 00 	movabs $0x820c30,%rdi
  80105f:	00 00 00 
  801062:	b8 00 00 00 00       	mov    $0x0,%eax
  801067:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  80106e:	00 00 00 
  801071:	ff d1                	callq  *%rcx
			r = -E_INVAL;
  801073:	c7 45 d8 fd ff ff ff 	movl   $0xfffffffd,-0x28(%rbp)
		}
		
		if(debug)
			cprintf("Net Output: Sent packet to kernel %d to %x\n", r, whom);
		sys_page_unmap(0, sendReq);
  80107a:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  801081:	00 00 00 
  801084:	48 8b 00             	mov    (%rax),%rax
  801087:	48 89 c6             	mov    %rax,%rsi
  80108a:	bf 00 00 00 00       	mov    $0x0,%edi
  80108f:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  801096:	00 00 00 
  801099:	ff d0                	callq  *%rax
			continue;
		}
		while ((r = sys_net_tx(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0);		
		//cprintf("buffer %s len %d\n", nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
#endif		
    }
  80109b:	e9 ab fe ff ff       	jmpq   800f4b <output+0x33>

00000000008010a0 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  8010a0:	55                   	push   %rbp
  8010a1:	48 89 e5             	mov    %rsp,%rbp
  8010a4:	48 83 ec 10          	sub    $0x10,%rsp
  8010a8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8010ab:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  8010af:	48 b8 ef 27 80 00 00 	movabs $0x8027ef,%rax
  8010b6:	00 00 00 
  8010b9:	ff d0                	callq  *%rax
  8010bb:	25 ff 03 00 00       	and    $0x3ff,%eax
  8010c0:	48 63 d0             	movslq %eax,%rdx
  8010c3:	48 89 d0             	mov    %rdx,%rax
  8010c6:	48 c1 e0 03          	shl    $0x3,%rax
  8010ca:	48 01 d0             	add    %rdx,%rax
  8010cd:	48 c1 e0 05          	shl    $0x5,%rax
  8010d1:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8010d8:	00 00 00 
  8010db:	48 01 c2             	add    %rax,%rdx
  8010de:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8010e5:	00 00 00 
  8010e8:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("I am entering libmain\n");
	// save the name of the program so that panic() can use it
	if (argc > 0)
  8010eb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8010ef:	7e 14                	jle    801105 <libmain+0x65>
		binaryname = argv[0];
  8010f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010f5:	48 8b 10             	mov    (%rax),%rdx
  8010f8:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  8010ff:	00 00 00 
  801102:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  801105:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801109:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80110c:	48 89 d6             	mov    %rdx,%rsi
  80110f:	89 c7                	mov    %eax,%edi
  801111:	48 b8 08 0b 80 00 00 	movabs $0x800b08,%rax
  801118:	00 00 00 
  80111b:	ff d0                	callq  *%rax
	// exit gracefully
	exit();
  80111d:	48 b8 2b 11 80 00 00 	movabs $0x80112b,%rax
  801124:	00 00 00 
  801127:	ff d0                	callq  *%rax
}
  801129:	c9                   	leaveq 
  80112a:	c3                   	retq   

000000000080112b <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80112b:	55                   	push   %rbp
  80112c:	48 89 e5             	mov    %rsp,%rbp
	close_all();
  80112f:	48 b8 69 37 80 00 00 	movabs $0x803769,%rax
  801136:	00 00 00 
  801139:	ff d0                	callq  *%rax
	sys_env_destroy(0);
  80113b:	bf 00 00 00 00       	mov    $0x0,%edi
  801140:	48 b8 ab 27 80 00 00 	movabs $0x8027ab,%rax
  801147:	00 00 00 
  80114a:	ff d0                	callq  *%rax

}
  80114c:	5d                   	pop    %rbp
  80114d:	c3                   	retq   

000000000080114e <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80114e:	55                   	push   %rbp
  80114f:	48 89 e5             	mov    %rsp,%rbp
  801152:	53                   	push   %rbx
  801153:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  80115a:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  801161:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  801167:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  80116e:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  801175:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  80117c:	84 c0                	test   %al,%al
  80117e:	74 23                	je     8011a3 <_panic+0x55>
  801180:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  801187:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  80118b:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  80118f:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  801193:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  801197:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  80119b:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  80119f:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  8011a3:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8011aa:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  8011b1:	00 00 00 
  8011b4:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  8011bb:	00 00 00 
  8011be:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8011c2:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8011c9:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  8011d0:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  8011d7:	48 b8 08 80 82 00 00 	movabs $0x828008,%rax
  8011de:	00 00 00 
  8011e1:	48 8b 18             	mov    (%rax),%rbx
  8011e4:	48 b8 ef 27 80 00 00 	movabs $0x8027ef,%rax
  8011eb:	00 00 00 
  8011ee:	ff d0                	callq  *%rax
  8011f0:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  8011f6:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8011fd:	41 89 c8             	mov    %ecx,%r8d
  801200:	48 89 d1             	mov    %rdx,%rcx
  801203:	48 89 da             	mov    %rbx,%rdx
  801206:	89 c6                	mov    %eax,%esi
  801208:	48 bf 60 0c 82 00 00 	movabs $0x820c60,%rdi
  80120f:	00 00 00 
  801212:	b8 00 00 00 00       	mov    $0x0,%eax
  801217:	49 b9 87 13 80 00 00 	movabs $0x801387,%r9
  80121e:	00 00 00 
  801221:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  801224:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  80122b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801232:	48 89 d6             	mov    %rdx,%rsi
  801235:	48 89 c7             	mov    %rax,%rdi
  801238:	48 b8 db 12 80 00 00 	movabs $0x8012db,%rax
  80123f:	00 00 00 
  801242:	ff d0                	callq  *%rax
	cprintf("\n");
  801244:	48 bf 83 0c 82 00 00 	movabs $0x820c83,%rdi
  80124b:	00 00 00 
  80124e:	b8 00 00 00 00       	mov    $0x0,%eax
  801253:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  80125a:	00 00 00 
  80125d:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80125f:	cc                   	int3   
  801260:	eb fd                	jmp    80125f <_panic+0x111>

0000000000801262 <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  801262:	55                   	push   %rbp
  801263:	48 89 e5             	mov    %rsp,%rbp
  801266:	48 83 ec 10          	sub    $0x10,%rsp
  80126a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80126d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  801271:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801275:	8b 00                	mov    (%rax),%eax
  801277:	8d 48 01             	lea    0x1(%rax),%ecx
  80127a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80127e:	89 0a                	mov    %ecx,(%rdx)
  801280:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801283:	89 d1                	mov    %edx,%ecx
  801285:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801289:	48 98                	cltq   
  80128b:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  80128f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801293:	8b 00                	mov    (%rax),%eax
  801295:	3d ff 00 00 00       	cmp    $0xff,%eax
  80129a:	75 2c                	jne    8012c8 <putch+0x66>
        sys_cputs(b->buf, b->idx);
  80129c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8012a0:	8b 00                	mov    (%rax),%eax
  8012a2:	48 98                	cltq   
  8012a4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8012a8:	48 83 c2 08          	add    $0x8,%rdx
  8012ac:	48 89 c6             	mov    %rax,%rsi
  8012af:	48 89 d7             	mov    %rdx,%rdi
  8012b2:	48 b8 23 27 80 00 00 	movabs $0x802723,%rax
  8012b9:	00 00 00 
  8012bc:	ff d0                	callq  *%rax
        b->idx = 0;
  8012be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8012c2:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  8012c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8012cc:	8b 40 04             	mov    0x4(%rax),%eax
  8012cf:	8d 50 01             	lea    0x1(%rax),%edx
  8012d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8012d6:	89 50 04             	mov    %edx,0x4(%rax)
}
  8012d9:	c9                   	leaveq 
  8012da:	c3                   	retq   

00000000008012db <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  8012db:	55                   	push   %rbp
  8012dc:	48 89 e5             	mov    %rsp,%rbp
  8012df:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  8012e6:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  8012ed:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  8012f4:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  8012fb:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  801302:	48 8b 0a             	mov    (%rdx),%rcx
  801305:	48 89 08             	mov    %rcx,(%rax)
  801308:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80130c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801310:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801314:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  801318:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  80131f:	00 00 00 
    b.cnt = 0;
  801322:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  801329:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  80132c:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  801333:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  80133a:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  801341:	48 89 c6             	mov    %rax,%rsi
  801344:	48 bf 62 12 80 00 00 	movabs $0x801262,%rdi
  80134b:	00 00 00 
  80134e:	48 b8 3a 17 80 00 00 	movabs $0x80173a,%rax
  801355:	00 00 00 
  801358:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  80135a:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  801360:	48 98                	cltq   
  801362:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  801369:	48 83 c2 08          	add    $0x8,%rdx
  80136d:	48 89 c6             	mov    %rax,%rsi
  801370:	48 89 d7             	mov    %rdx,%rdi
  801373:	48 b8 23 27 80 00 00 	movabs $0x802723,%rax
  80137a:	00 00 00 
  80137d:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  80137f:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801385:	c9                   	leaveq 
  801386:	c3                   	retq   

0000000000801387 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801387:	55                   	push   %rbp
  801388:	48 89 e5             	mov    %rsp,%rbp
  80138b:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  801392:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  801399:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8013a0:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8013a7:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8013ae:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8013b5:	84 c0                	test   %al,%al
  8013b7:	74 20                	je     8013d9 <cprintf+0x52>
  8013b9:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8013bd:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8013c1:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8013c5:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8013c9:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8013cd:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8013d1:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8013d5:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8013d9:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  8013e0:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8013e7:	00 00 00 
  8013ea:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8013f1:	00 00 00 
  8013f4:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8013f8:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8013ff:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801406:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  80140d:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801414:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80141b:	48 8b 0a             	mov    (%rdx),%rcx
  80141e:	48 89 08             	mov    %rcx,(%rax)
  801421:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801425:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801429:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80142d:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  801431:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  801438:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80143f:	48 89 d6             	mov    %rdx,%rsi
  801442:	48 89 c7             	mov    %rax,%rdi
  801445:	48 b8 db 12 80 00 00 	movabs $0x8012db,%rax
  80144c:	00 00 00 
  80144f:	ff d0                	callq  *%rax
  801451:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  801457:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80145d:	c9                   	leaveq 
  80145e:	c3                   	retq   

000000000080145f <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80145f:	55                   	push   %rbp
  801460:	48 89 e5             	mov    %rsp,%rbp
  801463:	53                   	push   %rbx
  801464:	48 83 ec 38          	sub    $0x38,%rsp
  801468:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80146c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801470:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  801474:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  801477:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  80147b:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80147f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  801482:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801486:	77 3b                	ja     8014c3 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801488:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80148b:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  80148f:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  801492:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801496:	ba 00 00 00 00       	mov    $0x0,%edx
  80149b:	48 f7 f3             	div    %rbx
  80149e:	48 89 c2             	mov    %rax,%rdx
  8014a1:	8b 7d cc             	mov    -0x34(%rbp),%edi
  8014a4:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  8014a7:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8014ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014af:	41 89 f9             	mov    %edi,%r9d
  8014b2:	48 89 c7             	mov    %rax,%rdi
  8014b5:	48 b8 5f 14 80 00 00 	movabs $0x80145f,%rax
  8014bc:	00 00 00 
  8014bf:	ff d0                	callq  *%rax
  8014c1:	eb 1e                	jmp    8014e1 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  8014c3:	eb 12                	jmp    8014d7 <printnum+0x78>
			putch(padc, putdat);
  8014c5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8014c9:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8014cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014d0:	48 89 ce             	mov    %rcx,%rsi
  8014d3:	89 d7                	mov    %edx,%edi
  8014d5:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  8014d7:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  8014db:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  8014df:	7f e4                	jg     8014c5 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8014e1:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  8014e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8014e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8014ed:	48 f7 f1             	div    %rcx
  8014f0:	48 89 d0             	mov    %rdx,%rax
  8014f3:	48 ba 90 0e 82 00 00 	movabs $0x820e90,%rdx
  8014fa:	00 00 00 
  8014fd:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  801501:	0f be d0             	movsbl %al,%edx
  801504:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  801508:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80150c:	48 89 ce             	mov    %rcx,%rsi
  80150f:	89 d7                	mov    %edx,%edi
  801511:	ff d0                	callq  *%rax
}
  801513:	48 83 c4 38          	add    $0x38,%rsp
  801517:	5b                   	pop    %rbx
  801518:	5d                   	pop    %rbp
  801519:	c3                   	retq   

000000000080151a <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80151a:	55                   	push   %rbp
  80151b:	48 89 e5             	mov    %rsp,%rbp
  80151e:	48 83 ec 1c          	sub    $0x1c,%rsp
  801522:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801526:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  801529:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80152d:	7e 52                	jle    801581 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  80152f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801533:	8b 00                	mov    (%rax),%eax
  801535:	83 f8 30             	cmp    $0x30,%eax
  801538:	73 24                	jae    80155e <getuint+0x44>
  80153a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80153e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801546:	8b 00                	mov    (%rax),%eax
  801548:	89 c0                	mov    %eax,%eax
  80154a:	48 01 d0             	add    %rdx,%rax
  80154d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801551:	8b 12                	mov    (%rdx),%edx
  801553:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801556:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80155a:	89 0a                	mov    %ecx,(%rdx)
  80155c:	eb 17                	jmp    801575 <getuint+0x5b>
  80155e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801562:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801566:	48 89 d0             	mov    %rdx,%rax
  801569:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80156d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801571:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801575:	48 8b 00             	mov    (%rax),%rax
  801578:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80157c:	e9 a3 00 00 00       	jmpq   801624 <getuint+0x10a>
	else if (lflag)
  801581:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801585:	74 4f                	je     8015d6 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  801587:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80158b:	8b 00                	mov    (%rax),%eax
  80158d:	83 f8 30             	cmp    $0x30,%eax
  801590:	73 24                	jae    8015b6 <getuint+0x9c>
  801592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801596:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80159a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80159e:	8b 00                	mov    (%rax),%eax
  8015a0:	89 c0                	mov    %eax,%eax
  8015a2:	48 01 d0             	add    %rdx,%rax
  8015a5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015a9:	8b 12                	mov    (%rdx),%edx
  8015ab:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8015ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015b2:	89 0a                	mov    %ecx,(%rdx)
  8015b4:	eb 17                	jmp    8015cd <getuint+0xb3>
  8015b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ba:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8015be:	48 89 d0             	mov    %rdx,%rax
  8015c1:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8015c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015c9:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8015cd:	48 8b 00             	mov    (%rax),%rax
  8015d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8015d4:	eb 4e                	jmp    801624 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  8015d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015da:	8b 00                	mov    (%rax),%eax
  8015dc:	83 f8 30             	cmp    $0x30,%eax
  8015df:	73 24                	jae    801605 <getuint+0xeb>
  8015e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015e5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8015e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ed:	8b 00                	mov    (%rax),%eax
  8015ef:	89 c0                	mov    %eax,%eax
  8015f1:	48 01 d0             	add    %rdx,%rax
  8015f4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015f8:	8b 12                	mov    (%rdx),%edx
  8015fa:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8015fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801601:	89 0a                	mov    %ecx,(%rdx)
  801603:	eb 17                	jmp    80161c <getuint+0x102>
  801605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801609:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80160d:	48 89 d0             	mov    %rdx,%rax
  801610:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801614:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801618:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80161c:	8b 00                	mov    (%rax),%eax
  80161e:	89 c0                	mov    %eax,%eax
  801620:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  801624:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801628:	c9                   	leaveq 
  801629:	c3                   	retq   

000000000080162a <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  80162a:	55                   	push   %rbp
  80162b:	48 89 e5             	mov    %rsp,%rbp
  80162e:	48 83 ec 1c          	sub    $0x1c,%rsp
  801632:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801636:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  801639:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80163d:	7e 52                	jle    801691 <getint+0x67>
		x=va_arg(*ap, long long);
  80163f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801643:	8b 00                	mov    (%rax),%eax
  801645:	83 f8 30             	cmp    $0x30,%eax
  801648:	73 24                	jae    80166e <getint+0x44>
  80164a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80164e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801656:	8b 00                	mov    (%rax),%eax
  801658:	89 c0                	mov    %eax,%eax
  80165a:	48 01 d0             	add    %rdx,%rax
  80165d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801661:	8b 12                	mov    (%rdx),%edx
  801663:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801666:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80166a:	89 0a                	mov    %ecx,(%rdx)
  80166c:	eb 17                	jmp    801685 <getint+0x5b>
  80166e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801672:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801676:	48 89 d0             	mov    %rdx,%rax
  801679:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80167d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801681:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801685:	48 8b 00             	mov    (%rax),%rax
  801688:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80168c:	e9 a3 00 00 00       	jmpq   801734 <getint+0x10a>
	else if (lflag)
  801691:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801695:	74 4f                	je     8016e6 <getint+0xbc>
		x=va_arg(*ap, long);
  801697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80169b:	8b 00                	mov    (%rax),%eax
  80169d:	83 f8 30             	cmp    $0x30,%eax
  8016a0:	73 24                	jae    8016c6 <getint+0x9c>
  8016a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016a6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8016aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016ae:	8b 00                	mov    (%rax),%eax
  8016b0:	89 c0                	mov    %eax,%eax
  8016b2:	48 01 d0             	add    %rdx,%rax
  8016b5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016b9:	8b 12                	mov    (%rdx),%edx
  8016bb:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8016be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016c2:	89 0a                	mov    %ecx,(%rdx)
  8016c4:	eb 17                	jmp    8016dd <getint+0xb3>
  8016c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016ca:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8016ce:	48 89 d0             	mov    %rdx,%rax
  8016d1:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8016d5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016d9:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8016dd:	48 8b 00             	mov    (%rax),%rax
  8016e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8016e4:	eb 4e                	jmp    801734 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  8016e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016ea:	8b 00                	mov    (%rax),%eax
  8016ec:	83 f8 30             	cmp    $0x30,%eax
  8016ef:	73 24                	jae    801715 <getint+0xeb>
  8016f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016f5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8016f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016fd:	8b 00                	mov    (%rax),%eax
  8016ff:	89 c0                	mov    %eax,%eax
  801701:	48 01 d0             	add    %rdx,%rax
  801704:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801708:	8b 12                	mov    (%rdx),%edx
  80170a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80170d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801711:	89 0a                	mov    %ecx,(%rdx)
  801713:	eb 17                	jmp    80172c <getint+0x102>
  801715:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801719:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80171d:	48 89 d0             	mov    %rdx,%rax
  801720:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801724:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801728:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80172c:	8b 00                	mov    (%rax),%eax
  80172e:	48 98                	cltq   
  801730:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  801734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801738:	c9                   	leaveq 
  801739:	c3                   	retq   

000000000080173a <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80173a:	55                   	push   %rbp
  80173b:	48 89 e5             	mov    %rsp,%rbp
  80173e:	41 54                	push   %r12
  801740:	53                   	push   %rbx
  801741:	48 83 ec 60          	sub    $0x60,%rsp
  801745:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  801749:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80174d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801751:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  801755:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801759:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80175d:	48 8b 0a             	mov    (%rdx),%rcx
  801760:	48 89 08             	mov    %rcx,(%rax)
  801763:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801767:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80176b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80176f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801773:	eb 17                	jmp    80178c <vprintfmt+0x52>
			if (ch == '\0')
  801775:	85 db                	test   %ebx,%ebx
  801777:	0f 84 cc 04 00 00    	je     801c49 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  80177d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801781:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801785:	48 89 d6             	mov    %rdx,%rsi
  801788:	89 df                	mov    %ebx,%edi
  80178a:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80178c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801790:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801794:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801798:	0f b6 00             	movzbl (%rax),%eax
  80179b:	0f b6 d8             	movzbl %al,%ebx
  80179e:	83 fb 25             	cmp    $0x25,%ebx
  8017a1:	75 d2                	jne    801775 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  8017a3:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  8017a7:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  8017ae:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  8017b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  8017bc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  8017c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8017c7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8017cb:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8017cf:	0f b6 00             	movzbl (%rax),%eax
  8017d2:	0f b6 d8             	movzbl %al,%ebx
  8017d5:	8d 43 dd             	lea    -0x23(%rbx),%eax
  8017d8:	83 f8 55             	cmp    $0x55,%eax
  8017db:	0f 87 34 04 00 00    	ja     801c15 <vprintfmt+0x4db>
  8017e1:	89 c0                	mov    %eax,%eax
  8017e3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8017ea:	00 
  8017eb:	48 b8 b8 0e 82 00 00 	movabs $0x820eb8,%rax
  8017f2:	00 00 00 
  8017f5:	48 01 d0             	add    %rdx,%rax
  8017f8:	48 8b 00             	mov    (%rax),%rax
  8017fb:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  8017fd:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  801801:	eb c0                	jmp    8017c3 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  801803:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  801807:	eb ba                	jmp    8017c3 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  801809:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  801810:	8b 55 d8             	mov    -0x28(%rbp),%edx
  801813:	89 d0                	mov    %edx,%eax
  801815:	c1 e0 02             	shl    $0x2,%eax
  801818:	01 d0                	add    %edx,%eax
  80181a:	01 c0                	add    %eax,%eax
  80181c:	01 d8                	add    %ebx,%eax
  80181e:	83 e8 30             	sub    $0x30,%eax
  801821:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  801824:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801828:	0f b6 00             	movzbl (%rax),%eax
  80182b:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  80182e:	83 fb 2f             	cmp    $0x2f,%ebx
  801831:	7e 0c                	jle    80183f <vprintfmt+0x105>
  801833:	83 fb 39             	cmp    $0x39,%ebx
  801836:	7f 07                	jg     80183f <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  801838:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80183d:	eb d1                	jmp    801810 <vprintfmt+0xd6>
			goto process_precision;
  80183f:	eb 58                	jmp    801899 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  801841:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801844:	83 f8 30             	cmp    $0x30,%eax
  801847:	73 17                	jae    801860 <vprintfmt+0x126>
  801849:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80184d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801850:	89 c0                	mov    %eax,%eax
  801852:	48 01 d0             	add    %rdx,%rax
  801855:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801858:	83 c2 08             	add    $0x8,%edx
  80185b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80185e:	eb 0f                	jmp    80186f <vprintfmt+0x135>
  801860:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801864:	48 89 d0             	mov    %rdx,%rax
  801867:	48 83 c2 08          	add    $0x8,%rdx
  80186b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80186f:	8b 00                	mov    (%rax),%eax
  801871:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  801874:	eb 23                	jmp    801899 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  801876:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80187a:	79 0c                	jns    801888 <vprintfmt+0x14e>
				width = 0;
  80187c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  801883:	e9 3b ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>
  801888:	e9 36 ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80188d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  801894:	e9 2a ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  801899:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80189d:	79 12                	jns    8018b1 <vprintfmt+0x177>
				width = precision, precision = -1;
  80189f:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8018a2:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8018a5:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  8018ac:	e9 12 ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>
  8018b1:	e9 0d ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  8018b6:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  8018ba:	e9 04 ff ff ff       	jmpq   8017c3 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  8018bf:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8018c2:	83 f8 30             	cmp    $0x30,%eax
  8018c5:	73 17                	jae    8018de <vprintfmt+0x1a4>
  8018c7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8018cb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8018ce:	89 c0                	mov    %eax,%eax
  8018d0:	48 01 d0             	add    %rdx,%rax
  8018d3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8018d6:	83 c2 08             	add    $0x8,%edx
  8018d9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8018dc:	eb 0f                	jmp    8018ed <vprintfmt+0x1b3>
  8018de:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8018e2:	48 89 d0             	mov    %rdx,%rax
  8018e5:	48 83 c2 08          	add    $0x8,%rdx
  8018e9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8018ed:	8b 10                	mov    (%rax),%edx
  8018ef:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8018f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018f7:	48 89 ce             	mov    %rcx,%rsi
  8018fa:	89 d7                	mov    %edx,%edi
  8018fc:	ff d0                	callq  *%rax
			break;
  8018fe:	e9 40 03 00 00       	jmpq   801c43 <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  801903:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801906:	83 f8 30             	cmp    $0x30,%eax
  801909:	73 17                	jae    801922 <vprintfmt+0x1e8>
  80190b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80190f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801912:	89 c0                	mov    %eax,%eax
  801914:	48 01 d0             	add    %rdx,%rax
  801917:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80191a:	83 c2 08             	add    $0x8,%edx
  80191d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801920:	eb 0f                	jmp    801931 <vprintfmt+0x1f7>
  801922:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801926:	48 89 d0             	mov    %rdx,%rax
  801929:	48 83 c2 08          	add    $0x8,%rdx
  80192d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801931:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  801933:	85 db                	test   %ebx,%ebx
  801935:	79 02                	jns    801939 <vprintfmt+0x1ff>
				err = -err;
  801937:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  801939:	83 fb 15             	cmp    $0x15,%ebx
  80193c:	7f 16                	jg     801954 <vprintfmt+0x21a>
  80193e:	48 b8 e0 0d 82 00 00 	movabs $0x820de0,%rax
  801945:	00 00 00 
  801948:	48 63 d3             	movslq %ebx,%rdx
  80194b:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  80194f:	4d 85 e4             	test   %r12,%r12
  801952:	75 2e                	jne    801982 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  801954:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801958:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80195c:	89 d9                	mov    %ebx,%ecx
  80195e:	48 ba a1 0e 82 00 00 	movabs $0x820ea1,%rdx
  801965:	00 00 00 
  801968:	48 89 c7             	mov    %rax,%rdi
  80196b:	b8 00 00 00 00       	mov    $0x0,%eax
  801970:	49 b8 52 1c 80 00 00 	movabs $0x801c52,%r8
  801977:	00 00 00 
  80197a:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  80197d:	e9 c1 02 00 00       	jmpq   801c43 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  801982:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801986:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80198a:	4c 89 e1             	mov    %r12,%rcx
  80198d:	48 ba aa 0e 82 00 00 	movabs $0x820eaa,%rdx
  801994:	00 00 00 
  801997:	48 89 c7             	mov    %rax,%rdi
  80199a:	b8 00 00 00 00       	mov    $0x0,%eax
  80199f:	49 b8 52 1c 80 00 00 	movabs $0x801c52,%r8
  8019a6:	00 00 00 
  8019a9:	41 ff d0             	callq  *%r8
			break;
  8019ac:	e9 92 02 00 00       	jmpq   801c43 <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  8019b1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8019b4:	83 f8 30             	cmp    $0x30,%eax
  8019b7:	73 17                	jae    8019d0 <vprintfmt+0x296>
  8019b9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8019bd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8019c0:	89 c0                	mov    %eax,%eax
  8019c2:	48 01 d0             	add    %rdx,%rax
  8019c5:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8019c8:	83 c2 08             	add    $0x8,%edx
  8019cb:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8019ce:	eb 0f                	jmp    8019df <vprintfmt+0x2a5>
  8019d0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8019d4:	48 89 d0             	mov    %rdx,%rax
  8019d7:	48 83 c2 08          	add    $0x8,%rdx
  8019db:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8019df:	4c 8b 20             	mov    (%rax),%r12
  8019e2:	4d 85 e4             	test   %r12,%r12
  8019e5:	75 0a                	jne    8019f1 <vprintfmt+0x2b7>
				p = "(null)";
  8019e7:	49 bc ad 0e 82 00 00 	movabs $0x820ead,%r12
  8019ee:	00 00 00 
			if (width > 0 && padc != '-')
  8019f1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8019f5:	7e 3f                	jle    801a36 <vprintfmt+0x2fc>
  8019f7:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  8019fb:	74 39                	je     801a36 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  8019fd:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801a00:	48 98                	cltq   
  801a02:	48 89 c6             	mov    %rax,%rsi
  801a05:	4c 89 e7             	mov    %r12,%rdi
  801a08:	48 b8 fe 1e 80 00 00 	movabs $0x801efe,%rax
  801a0f:	00 00 00 
  801a12:	ff d0                	callq  *%rax
  801a14:	29 45 dc             	sub    %eax,-0x24(%rbp)
  801a17:	eb 17                	jmp    801a30 <vprintfmt+0x2f6>
					putch(padc, putdat);
  801a19:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  801a1d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801a21:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a25:	48 89 ce             	mov    %rcx,%rsi
  801a28:	89 d7                	mov    %edx,%edi
  801a2a:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  801a2c:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a30:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801a34:	7f e3                	jg     801a19 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  801a36:	eb 37                	jmp    801a6f <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  801a38:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  801a3c:	74 1e                	je     801a5c <vprintfmt+0x322>
  801a3e:	83 fb 1f             	cmp    $0x1f,%ebx
  801a41:	7e 05                	jle    801a48 <vprintfmt+0x30e>
  801a43:	83 fb 7e             	cmp    $0x7e,%ebx
  801a46:	7e 14                	jle    801a5c <vprintfmt+0x322>
					putch('?', putdat);
  801a48:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a4c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a50:	48 89 d6             	mov    %rdx,%rsi
  801a53:	bf 3f 00 00 00       	mov    $0x3f,%edi
  801a58:	ff d0                	callq  *%rax
  801a5a:	eb 0f                	jmp    801a6b <vprintfmt+0x331>
				else
					putch(ch, putdat);
  801a5c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a60:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a64:	48 89 d6             	mov    %rdx,%rsi
  801a67:	89 df                	mov    %ebx,%edi
  801a69:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  801a6b:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a6f:	4c 89 e0             	mov    %r12,%rax
  801a72:	4c 8d 60 01          	lea    0x1(%rax),%r12
  801a76:	0f b6 00             	movzbl (%rax),%eax
  801a79:	0f be d8             	movsbl %al,%ebx
  801a7c:	85 db                	test   %ebx,%ebx
  801a7e:	74 10                	je     801a90 <vprintfmt+0x356>
  801a80:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a84:	78 b2                	js     801a38 <vprintfmt+0x2fe>
  801a86:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801a8a:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a8e:	79 a8                	jns    801a38 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a90:	eb 16                	jmp    801aa8 <vprintfmt+0x36e>
				putch(' ', putdat);
  801a92:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a96:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a9a:	48 89 d6             	mov    %rdx,%rsi
  801a9d:	bf 20 00 00 00       	mov    $0x20,%edi
  801aa2:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801aa4:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801aa8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801aac:	7f e4                	jg     801a92 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  801aae:	e9 90 01 00 00       	jmpq   801c43 <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801ab3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801ab7:	be 03 00 00 00       	mov    $0x3,%esi
  801abc:	48 89 c7             	mov    %rax,%rdi
  801abf:	48 b8 2a 16 80 00 00 	movabs $0x80162a,%rax
  801ac6:	00 00 00 
  801ac9:	ff d0                	callq  *%rax
  801acb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801acf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ad3:	48 85 c0             	test   %rax,%rax
  801ad6:	79 1d                	jns    801af5 <vprintfmt+0x3bb>
				putch('-', putdat);
  801ad8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801adc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ae0:	48 89 d6             	mov    %rdx,%rsi
  801ae3:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801ae8:	ff d0                	callq  *%rax
				num = -(long long) num;
  801aea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801aee:	48 f7 d8             	neg    %rax
  801af1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  801af5:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801afc:	e9 d5 00 00 00       	jmpq   801bd6 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801b01:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b05:	be 03 00 00 00       	mov    $0x3,%esi
  801b0a:	48 89 c7             	mov    %rax,%rdi
  801b0d:	48 b8 1a 15 80 00 00 	movabs $0x80151a,%rax
  801b14:	00 00 00 
  801b17:	ff d0                	callq  *%rax
  801b19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801b1d:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801b24:	e9 ad 00 00 00       	jmpq   801bd6 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  801b29:	8b 55 e0             	mov    -0x20(%rbp),%edx
  801b2c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b30:	89 d6                	mov    %edx,%esi
  801b32:	48 89 c7             	mov    %rax,%rdi
  801b35:	48 b8 2a 16 80 00 00 	movabs $0x80162a,%rax
  801b3c:	00 00 00 
  801b3f:	ff d0                	callq  *%rax
  801b41:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  801b45:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  801b4c:	e9 85 00 00 00       	jmpq   801bd6 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  801b51:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b55:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b59:	48 89 d6             	mov    %rdx,%rsi
  801b5c:	bf 30 00 00 00       	mov    $0x30,%edi
  801b61:	ff d0                	callq  *%rax
			putch('x', putdat);
  801b63:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b67:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b6b:	48 89 d6             	mov    %rdx,%rsi
  801b6e:	bf 78 00 00 00       	mov    $0x78,%edi
  801b73:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801b75:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b78:	83 f8 30             	cmp    $0x30,%eax
  801b7b:	73 17                	jae    801b94 <vprintfmt+0x45a>
  801b7d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801b81:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b84:	89 c0                	mov    %eax,%eax
  801b86:	48 01 d0             	add    %rdx,%rax
  801b89:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b8c:	83 c2 08             	add    $0x8,%edx
  801b8f:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b92:	eb 0f                	jmp    801ba3 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  801b94:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801b98:	48 89 d0             	mov    %rdx,%rax
  801b9b:	48 83 c2 08          	add    $0x8,%rdx
  801b9f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801ba3:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801ba6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  801baa:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801bb1:	eb 23                	jmp    801bd6 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  801bb3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801bb7:	be 03 00 00 00       	mov    $0x3,%esi
  801bbc:	48 89 c7             	mov    %rax,%rdi
  801bbf:	48 b8 1a 15 80 00 00 	movabs $0x80151a,%rax
  801bc6:	00 00 00 
  801bc9:	ff d0                	callq  *%rax
  801bcb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801bcf:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  801bd6:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801bdb:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801bde:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801be1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801be5:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801be9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801bed:	45 89 c1             	mov    %r8d,%r9d
  801bf0:	41 89 f8             	mov    %edi,%r8d
  801bf3:	48 89 c7             	mov    %rax,%rdi
  801bf6:	48 b8 5f 14 80 00 00 	movabs $0x80145f,%rax
  801bfd:	00 00 00 
  801c00:	ff d0                	callq  *%rax
			break;
  801c02:	eb 3f                	jmp    801c43 <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  801c04:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801c08:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801c0c:	48 89 d6             	mov    %rdx,%rsi
  801c0f:	89 df                	mov    %ebx,%edi
  801c11:	ff d0                	callq  *%rax
			break;
  801c13:	eb 2e                	jmp    801c43 <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801c15:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801c19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801c1d:	48 89 d6             	mov    %rdx,%rsi
  801c20:	bf 25 00 00 00       	mov    $0x25,%edi
  801c25:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  801c27:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801c2c:	eb 05                	jmp    801c33 <vprintfmt+0x4f9>
  801c2e:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801c33:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801c37:	48 83 e8 01          	sub    $0x1,%rax
  801c3b:	0f b6 00             	movzbl (%rax),%eax
  801c3e:	3c 25                	cmp    $0x25,%al
  801c40:	75 ec                	jne    801c2e <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  801c42:	90                   	nop
		}
	}
  801c43:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801c44:	e9 43 fb ff ff       	jmpq   80178c <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801c49:	48 83 c4 60          	add    $0x60,%rsp
  801c4d:	5b                   	pop    %rbx
  801c4e:	41 5c                	pop    %r12
  801c50:	5d                   	pop    %rbp
  801c51:	c3                   	retq   

0000000000801c52 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801c52:	55                   	push   %rbp
  801c53:	48 89 e5             	mov    %rsp,%rbp
  801c56:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801c5d:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801c64:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801c6b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801c72:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c79:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c80:	84 c0                	test   %al,%al
  801c82:	74 20                	je     801ca4 <printfmt+0x52>
  801c84:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c88:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c8c:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c90:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c94:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c98:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c9c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801ca0:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801ca4:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801cab:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801cb2:	00 00 00 
  801cb5:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801cbc:	00 00 00 
  801cbf:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801cc3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801cca:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801cd1:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801cd8:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801cdf:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801ce6:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801ced:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801cf4:	48 89 c7             	mov    %rax,%rdi
  801cf7:	48 b8 3a 17 80 00 00 	movabs $0x80173a,%rax
  801cfe:	00 00 00 
  801d01:	ff d0                	callq  *%rax
	va_end(ap);
}
  801d03:	c9                   	leaveq 
  801d04:	c3                   	retq   

0000000000801d05 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801d05:	55                   	push   %rbp
  801d06:	48 89 e5             	mov    %rsp,%rbp
  801d09:	48 83 ec 10          	sub    $0x10,%rsp
  801d0d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801d10:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801d14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801d18:	8b 40 10             	mov    0x10(%rax),%eax
  801d1b:	8d 50 01             	lea    0x1(%rax),%edx
  801d1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801d22:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801d25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801d29:	48 8b 10             	mov    (%rax),%rdx
  801d2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801d30:	48 8b 40 08          	mov    0x8(%rax),%rax
  801d34:	48 39 c2             	cmp    %rax,%rdx
  801d37:	73 17                	jae    801d50 <sprintputch+0x4b>
		*b->buf++ = ch;
  801d39:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801d3d:	48 8b 00             	mov    (%rax),%rax
  801d40:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801d44:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801d48:	48 89 0a             	mov    %rcx,(%rdx)
  801d4b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801d4e:	88 10                	mov    %dl,(%rax)
}
  801d50:	c9                   	leaveq 
  801d51:	c3                   	retq   

0000000000801d52 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801d52:	55                   	push   %rbp
  801d53:	48 89 e5             	mov    %rsp,%rbp
  801d56:	48 83 ec 50          	sub    $0x50,%rsp
  801d5a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801d5e:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801d61:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801d65:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801d69:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801d6d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801d71:	48 8b 0a             	mov    (%rdx),%rcx
  801d74:	48 89 08             	mov    %rcx,(%rax)
  801d77:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801d7b:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801d7f:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801d83:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801d87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d8b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801d8f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801d92:	48 98                	cltq   
  801d94:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801d98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d9c:	48 01 d0             	add    %rdx,%rax
  801d9f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801da3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801daa:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801daf:	74 06                	je     801db7 <vsnprintf+0x65>
  801db1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801db5:	7f 07                	jg     801dbe <vsnprintf+0x6c>
		return -E_INVAL;
  801db7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801dbc:	eb 2f                	jmp    801ded <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801dbe:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801dc2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801dc6:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801dca:	48 89 c6             	mov    %rax,%rsi
  801dcd:	48 bf 05 1d 80 00 00 	movabs $0x801d05,%rdi
  801dd4:	00 00 00 
  801dd7:	48 b8 3a 17 80 00 00 	movabs $0x80173a,%rax
  801dde:	00 00 00 
  801de1:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801de3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801de7:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801dea:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801ded:	c9                   	leaveq 
  801dee:	c3                   	retq   

0000000000801def <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801def:	55                   	push   %rbp
  801df0:	48 89 e5             	mov    %rsp,%rbp
  801df3:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801dfa:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801e01:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801e07:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801e0e:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801e15:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801e1c:	84 c0                	test   %al,%al
  801e1e:	74 20                	je     801e40 <snprintf+0x51>
  801e20:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801e24:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801e28:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801e2c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801e30:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801e34:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801e38:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801e3c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801e40:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801e47:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801e4e:	00 00 00 
  801e51:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801e58:	00 00 00 
  801e5b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801e5f:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801e66:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801e6d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801e74:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801e7b:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801e82:	48 8b 0a             	mov    (%rdx),%rcx
  801e85:	48 89 08             	mov    %rcx,(%rax)
  801e88:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801e8c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801e90:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801e94:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801e98:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801e9f:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801ea6:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801eac:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801eb3:	48 89 c7             	mov    %rax,%rdi
  801eb6:	48 b8 52 1d 80 00 00 	movabs $0x801d52,%rax
  801ebd:	00 00 00 
  801ec0:	ff d0                	callq  *%rax
  801ec2:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801ec8:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801ece:	c9                   	leaveq 
  801ecf:	c3                   	retq   

0000000000801ed0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801ed0:	55                   	push   %rbp
  801ed1:	48 89 e5             	mov    %rsp,%rbp
  801ed4:	48 83 ec 18          	sub    $0x18,%rsp
  801ed8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801edc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801ee3:	eb 09                	jmp    801eee <strlen+0x1e>
		n++;
  801ee5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801ee9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801eee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ef2:	0f b6 00             	movzbl (%rax),%eax
  801ef5:	84 c0                	test   %al,%al
  801ef7:	75 ec                	jne    801ee5 <strlen+0x15>
		n++;
	return n;
  801ef9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801efc:	c9                   	leaveq 
  801efd:	c3                   	retq   

0000000000801efe <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801efe:	55                   	push   %rbp
  801eff:	48 89 e5             	mov    %rsp,%rbp
  801f02:	48 83 ec 20          	sub    $0x20,%rsp
  801f06:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f0a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801f0e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801f15:	eb 0e                	jmp    801f25 <strnlen+0x27>
		n++;
  801f17:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801f1b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801f20:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801f25:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801f2a:	74 0b                	je     801f37 <strnlen+0x39>
  801f2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f30:	0f b6 00             	movzbl (%rax),%eax
  801f33:	84 c0                	test   %al,%al
  801f35:	75 e0                	jne    801f17 <strnlen+0x19>
		n++;
	return n;
  801f37:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801f3a:	c9                   	leaveq 
  801f3b:	c3                   	retq   

0000000000801f3c <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801f3c:	55                   	push   %rbp
  801f3d:	48 89 e5             	mov    %rsp,%rbp
  801f40:	48 83 ec 20          	sub    $0x20,%rsp
  801f44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f48:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801f4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801f54:	90                   	nop
  801f55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f59:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801f5d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801f61:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f65:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801f69:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801f6d:	0f b6 12             	movzbl (%rdx),%edx
  801f70:	88 10                	mov    %dl,(%rax)
  801f72:	0f b6 00             	movzbl (%rax),%eax
  801f75:	84 c0                	test   %al,%al
  801f77:	75 dc                	jne    801f55 <strcpy+0x19>
		/* do nothing */;
	return ret;
  801f79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f7d:	c9                   	leaveq 
  801f7e:	c3                   	retq   

0000000000801f7f <strcat>:

char *
strcat(char *dst, const char *src)
{
  801f7f:	55                   	push   %rbp
  801f80:	48 89 e5             	mov    %rsp,%rbp
  801f83:	48 83 ec 20          	sub    $0x20,%rsp
  801f87:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f8b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801f8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f93:	48 89 c7             	mov    %rax,%rdi
  801f96:	48 b8 d0 1e 80 00 00 	movabs $0x801ed0,%rax
  801f9d:	00 00 00 
  801fa0:	ff d0                	callq  *%rax
  801fa2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801fa5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801fa8:	48 63 d0             	movslq %eax,%rdx
  801fab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801faf:	48 01 c2             	add    %rax,%rdx
  801fb2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801fb6:	48 89 c6             	mov    %rax,%rsi
  801fb9:	48 89 d7             	mov    %rdx,%rdi
  801fbc:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  801fc3:	00 00 00 
  801fc6:	ff d0                	callq  *%rax
	return dst;
  801fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801fcc:	c9                   	leaveq 
  801fcd:	c3                   	retq   

0000000000801fce <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801fce:	55                   	push   %rbp
  801fcf:	48 89 e5             	mov    %rsp,%rbp
  801fd2:	48 83 ec 28          	sub    $0x28,%rsp
  801fd6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fda:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fde:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801fe2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fe6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801fea:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801ff1:	00 
  801ff2:	eb 2a                	jmp    80201e <strncpy+0x50>
		*dst++ = *src;
  801ff4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ff8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801ffc:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  802000:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  802004:	0f b6 12             	movzbl (%rdx),%edx
  802007:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  802009:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80200d:	0f b6 00             	movzbl (%rax),%eax
  802010:	84 c0                	test   %al,%al
  802012:	74 05                	je     802019 <strncpy+0x4b>
			src++;
  802014:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  802019:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80201e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802022:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  802026:	72 cc                	jb     801ff4 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  802028:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80202c:	c9                   	leaveq 
  80202d:	c3                   	retq   

000000000080202e <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80202e:	55                   	push   %rbp
  80202f:	48 89 e5             	mov    %rsp,%rbp
  802032:	48 83 ec 28          	sub    $0x28,%rsp
  802036:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80203a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80203e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  802042:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802046:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  80204a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80204f:	74 3d                	je     80208e <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  802051:	eb 1d                	jmp    802070 <strlcpy+0x42>
			*dst++ = *src++;
  802053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802057:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80205b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80205f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  802063:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  802067:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80206b:	0f b6 12             	movzbl (%rdx),%edx
  80206e:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  802070:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  802075:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80207a:	74 0b                	je     802087 <strlcpy+0x59>
  80207c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802080:	0f b6 00             	movzbl (%rax),%eax
  802083:	84 c0                	test   %al,%al
  802085:	75 cc                	jne    802053 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  802087:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80208b:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  80208e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802096:	48 29 c2             	sub    %rax,%rdx
  802099:	48 89 d0             	mov    %rdx,%rax
}
  80209c:	c9                   	leaveq 
  80209d:	c3                   	retq   

000000000080209e <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80209e:	55                   	push   %rbp
  80209f:	48 89 e5             	mov    %rsp,%rbp
  8020a2:	48 83 ec 10          	sub    $0x10,%rsp
  8020a6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020aa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  8020ae:	eb 0a                	jmp    8020ba <strcmp+0x1c>
		p++, q++;
  8020b0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8020b5:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8020ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020be:	0f b6 00             	movzbl (%rax),%eax
  8020c1:	84 c0                	test   %al,%al
  8020c3:	74 12                	je     8020d7 <strcmp+0x39>
  8020c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020c9:	0f b6 10             	movzbl (%rax),%edx
  8020cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020d0:	0f b6 00             	movzbl (%rax),%eax
  8020d3:	38 c2                	cmp    %al,%dl
  8020d5:	74 d9                	je     8020b0 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  8020d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020db:	0f b6 00             	movzbl (%rax),%eax
  8020de:	0f b6 d0             	movzbl %al,%edx
  8020e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020e5:	0f b6 00             	movzbl (%rax),%eax
  8020e8:	0f b6 c0             	movzbl %al,%eax
  8020eb:	29 c2                	sub    %eax,%edx
  8020ed:	89 d0                	mov    %edx,%eax
}
  8020ef:	c9                   	leaveq 
  8020f0:	c3                   	retq   

00000000008020f1 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8020f1:	55                   	push   %rbp
  8020f2:	48 89 e5             	mov    %rsp,%rbp
  8020f5:	48 83 ec 18          	sub    $0x18,%rsp
  8020f9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020fd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802101:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  802105:	eb 0f                	jmp    802116 <strncmp+0x25>
		n--, p++, q++;
  802107:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  80210c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802111:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  802116:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80211b:	74 1d                	je     80213a <strncmp+0x49>
  80211d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802121:	0f b6 00             	movzbl (%rax),%eax
  802124:	84 c0                	test   %al,%al
  802126:	74 12                	je     80213a <strncmp+0x49>
  802128:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80212c:	0f b6 10             	movzbl (%rax),%edx
  80212f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802133:	0f b6 00             	movzbl (%rax),%eax
  802136:	38 c2                	cmp    %al,%dl
  802138:	74 cd                	je     802107 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  80213a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80213f:	75 07                	jne    802148 <strncmp+0x57>
		return 0;
  802141:	b8 00 00 00 00       	mov    $0x0,%eax
  802146:	eb 18                	jmp    802160 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  802148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80214c:	0f b6 00             	movzbl (%rax),%eax
  80214f:	0f b6 d0             	movzbl %al,%edx
  802152:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802156:	0f b6 00             	movzbl (%rax),%eax
  802159:	0f b6 c0             	movzbl %al,%eax
  80215c:	29 c2                	sub    %eax,%edx
  80215e:	89 d0                	mov    %edx,%eax
}
  802160:	c9                   	leaveq 
  802161:	c3                   	retq   

0000000000802162 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  802162:	55                   	push   %rbp
  802163:	48 89 e5             	mov    %rsp,%rbp
  802166:	48 83 ec 0c          	sub    $0xc,%rsp
  80216a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80216e:	89 f0                	mov    %esi,%eax
  802170:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  802173:	eb 17                	jmp    80218c <strchr+0x2a>
		if (*s == c)
  802175:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802179:	0f b6 00             	movzbl (%rax),%eax
  80217c:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80217f:	75 06                	jne    802187 <strchr+0x25>
			return (char *) s;
  802181:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802185:	eb 15                	jmp    80219c <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  802187:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80218c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802190:	0f b6 00             	movzbl (%rax),%eax
  802193:	84 c0                	test   %al,%al
  802195:	75 de                	jne    802175 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  802197:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80219c:	c9                   	leaveq 
  80219d:	c3                   	retq   

000000000080219e <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80219e:	55                   	push   %rbp
  80219f:	48 89 e5             	mov    %rsp,%rbp
  8021a2:	48 83 ec 0c          	sub    $0xc,%rsp
  8021a6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8021aa:	89 f0                	mov    %esi,%eax
  8021ac:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8021af:	eb 13                	jmp    8021c4 <strfind+0x26>
		if (*s == c)
  8021b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021b5:	0f b6 00             	movzbl (%rax),%eax
  8021b8:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8021bb:	75 02                	jne    8021bf <strfind+0x21>
			break;
  8021bd:	eb 10                	jmp    8021cf <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  8021bf:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8021c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021c8:	0f b6 00             	movzbl (%rax),%eax
  8021cb:	84 c0                	test   %al,%al
  8021cd:	75 e2                	jne    8021b1 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  8021cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8021d3:	c9                   	leaveq 
  8021d4:	c3                   	retq   

00000000008021d5 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8021d5:	55                   	push   %rbp
  8021d6:	48 89 e5             	mov    %rsp,%rbp
  8021d9:	48 83 ec 18          	sub    $0x18,%rsp
  8021dd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8021e1:	89 75 f4             	mov    %esi,-0xc(%rbp)
  8021e4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  8021e8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8021ed:	75 06                	jne    8021f5 <memset+0x20>
		return v;
  8021ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021f3:	eb 69                	jmp    80225e <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  8021f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021f9:	83 e0 03             	and    $0x3,%eax
  8021fc:	48 85 c0             	test   %rax,%rax
  8021ff:	75 48                	jne    802249 <memset+0x74>
  802201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802205:	83 e0 03             	and    $0x3,%eax
  802208:	48 85 c0             	test   %rax,%rax
  80220b:	75 3c                	jne    802249 <memset+0x74>
		c &= 0xFF;
  80220d:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  802214:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802217:	c1 e0 18             	shl    $0x18,%eax
  80221a:	89 c2                	mov    %eax,%edx
  80221c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80221f:	c1 e0 10             	shl    $0x10,%eax
  802222:	09 c2                	or     %eax,%edx
  802224:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802227:	c1 e0 08             	shl    $0x8,%eax
  80222a:	09 d0                	or     %edx,%eax
  80222c:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  80222f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802233:	48 c1 e8 02          	shr    $0x2,%rax
  802237:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80223a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80223e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802241:	48 89 d7             	mov    %rdx,%rdi
  802244:	fc                   	cld    
  802245:	f3 ab                	rep stos %eax,%es:(%rdi)
  802247:	eb 11                	jmp    80225a <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  802249:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80224d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802250:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802254:	48 89 d7             	mov    %rdx,%rdi
  802257:	fc                   	cld    
  802258:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  80225a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80225e:	c9                   	leaveq 
  80225f:	c3                   	retq   

0000000000802260 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  802260:	55                   	push   %rbp
  802261:	48 89 e5             	mov    %rsp,%rbp
  802264:	48 83 ec 28          	sub    $0x28,%rsp
  802268:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80226c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802270:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  802274:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802278:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  80227c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802280:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  802284:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802288:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80228c:	0f 83 88 00 00 00    	jae    80231a <memmove+0xba>
  802292:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802296:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80229a:	48 01 d0             	add    %rdx,%rax
  80229d:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8022a1:	76 77                	jbe    80231a <memmove+0xba>
		s += n;
  8022a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022a7:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  8022ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022af:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8022b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022b7:	83 e0 03             	and    $0x3,%eax
  8022ba:	48 85 c0             	test   %rax,%rax
  8022bd:	75 3b                	jne    8022fa <memmove+0x9a>
  8022bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022c3:	83 e0 03             	and    $0x3,%eax
  8022c6:	48 85 c0             	test   %rax,%rax
  8022c9:	75 2f                	jne    8022fa <memmove+0x9a>
  8022cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022cf:	83 e0 03             	and    $0x3,%eax
  8022d2:	48 85 c0             	test   %rax,%rax
  8022d5:	75 23                	jne    8022fa <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8022d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022db:	48 83 e8 04          	sub    $0x4,%rax
  8022df:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022e3:	48 83 ea 04          	sub    $0x4,%rdx
  8022e7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8022eb:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  8022ef:	48 89 c7             	mov    %rax,%rdi
  8022f2:	48 89 d6             	mov    %rdx,%rsi
  8022f5:	fd                   	std    
  8022f6:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8022f8:	eb 1d                	jmp    802317 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  8022fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022fe:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802306:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80230a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80230e:	48 89 d7             	mov    %rdx,%rdi
  802311:	48 89 c1             	mov    %rax,%rcx
  802314:	fd                   	std    
  802315:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  802317:	fc                   	cld    
  802318:	eb 57                	jmp    802371 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80231a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80231e:	83 e0 03             	and    $0x3,%eax
  802321:	48 85 c0             	test   %rax,%rax
  802324:	75 36                	jne    80235c <memmove+0xfc>
  802326:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80232a:	83 e0 03             	and    $0x3,%eax
  80232d:	48 85 c0             	test   %rax,%rax
  802330:	75 2a                	jne    80235c <memmove+0xfc>
  802332:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802336:	83 e0 03             	and    $0x3,%eax
  802339:	48 85 c0             	test   %rax,%rax
  80233c:	75 1e                	jne    80235c <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80233e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802342:	48 c1 e8 02          	shr    $0x2,%rax
  802346:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  802349:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80234d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802351:	48 89 c7             	mov    %rax,%rdi
  802354:	48 89 d6             	mov    %rdx,%rsi
  802357:	fc                   	cld    
  802358:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80235a:	eb 15                	jmp    802371 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80235c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802360:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802364:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802368:	48 89 c7             	mov    %rax,%rdi
  80236b:	48 89 d6             	mov    %rdx,%rsi
  80236e:	fc                   	cld    
  80236f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  802371:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802375:	c9                   	leaveq 
  802376:	c3                   	retq   

0000000000802377 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  802377:	55                   	push   %rbp
  802378:	48 89 e5             	mov    %rsp,%rbp
  80237b:	48 83 ec 18          	sub    $0x18,%rsp
  80237f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802383:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802387:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  80238b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80238f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802393:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802397:	48 89 ce             	mov    %rcx,%rsi
  80239a:	48 89 c7             	mov    %rax,%rdi
  80239d:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8023a4:	00 00 00 
  8023a7:	ff d0                	callq  *%rax
}
  8023a9:	c9                   	leaveq 
  8023aa:	c3                   	retq   

00000000008023ab <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  8023ab:	55                   	push   %rbp
  8023ac:	48 89 e5             	mov    %rsp,%rbp
  8023af:	48 83 ec 28          	sub    $0x28,%rsp
  8023b3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8023b7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8023bb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8023bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  8023c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8023cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8023cf:	eb 36                	jmp    802407 <memcmp+0x5c>
		if (*s1 != *s2)
  8023d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8023d5:	0f b6 10             	movzbl (%rax),%edx
  8023d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8023dc:	0f b6 00             	movzbl (%rax),%eax
  8023df:	38 c2                	cmp    %al,%dl
  8023e1:	74 1a                	je     8023fd <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  8023e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8023e7:	0f b6 00             	movzbl (%rax),%eax
  8023ea:	0f b6 d0             	movzbl %al,%edx
  8023ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8023f1:	0f b6 00             	movzbl (%rax),%eax
  8023f4:	0f b6 c0             	movzbl %al,%eax
  8023f7:	29 c2                	sub    %eax,%edx
  8023f9:	89 d0                	mov    %edx,%eax
  8023fb:	eb 20                	jmp    80241d <memcmp+0x72>
		s1++, s2++;
  8023fd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802402:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  802407:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80240b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80240f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  802413:	48 85 c0             	test   %rax,%rax
  802416:	75 b9                	jne    8023d1 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  802418:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80241d:	c9                   	leaveq 
  80241e:	c3                   	retq   

000000000080241f <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80241f:	55                   	push   %rbp
  802420:	48 89 e5             	mov    %rsp,%rbp
  802423:	48 83 ec 28          	sub    $0x28,%rsp
  802427:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80242b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80242e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  802432:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802436:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80243a:	48 01 d0             	add    %rdx,%rax
  80243d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  802441:	eb 15                	jmp    802458 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  802443:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802447:	0f b6 10             	movzbl (%rax),%edx
  80244a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80244d:	38 c2                	cmp    %al,%dl
  80244f:	75 02                	jne    802453 <memfind+0x34>
			break;
  802451:	eb 0f                	jmp    802462 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  802453:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  802458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80245c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  802460:	72 e1                	jb     802443 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  802462:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802466:	c9                   	leaveq 
  802467:	c3                   	retq   

0000000000802468 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  802468:	55                   	push   %rbp
  802469:	48 89 e5             	mov    %rsp,%rbp
  80246c:	48 83 ec 34          	sub    $0x34,%rsp
  802470:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802474:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802478:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  80247b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  802482:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802489:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80248a:	eb 05                	jmp    802491 <strtol+0x29>
		s++;
  80248c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802491:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802495:	0f b6 00             	movzbl (%rax),%eax
  802498:	3c 20                	cmp    $0x20,%al
  80249a:	74 f0                	je     80248c <strtol+0x24>
  80249c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024a0:	0f b6 00             	movzbl (%rax),%eax
  8024a3:	3c 09                	cmp    $0x9,%al
  8024a5:	74 e5                	je     80248c <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  8024a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024ab:	0f b6 00             	movzbl (%rax),%eax
  8024ae:	3c 2b                	cmp    $0x2b,%al
  8024b0:	75 07                	jne    8024b9 <strtol+0x51>
		s++;
  8024b2:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024b7:	eb 17                	jmp    8024d0 <strtol+0x68>
	else if (*s == '-')
  8024b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024bd:	0f b6 00             	movzbl (%rax),%eax
  8024c0:	3c 2d                	cmp    $0x2d,%al
  8024c2:	75 0c                	jne    8024d0 <strtol+0x68>
		s++, neg = 1;
  8024c4:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024c9:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  8024d0:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024d4:	74 06                	je     8024dc <strtol+0x74>
  8024d6:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  8024da:	75 28                	jne    802504 <strtol+0x9c>
  8024dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024e0:	0f b6 00             	movzbl (%rax),%eax
  8024e3:	3c 30                	cmp    $0x30,%al
  8024e5:	75 1d                	jne    802504 <strtol+0x9c>
  8024e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024eb:	48 83 c0 01          	add    $0x1,%rax
  8024ef:	0f b6 00             	movzbl (%rax),%eax
  8024f2:	3c 78                	cmp    $0x78,%al
  8024f4:	75 0e                	jne    802504 <strtol+0x9c>
		s += 2, base = 16;
  8024f6:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  8024fb:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  802502:	eb 2c                	jmp    802530 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  802504:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802508:	75 19                	jne    802523 <strtol+0xbb>
  80250a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80250e:	0f b6 00             	movzbl (%rax),%eax
  802511:	3c 30                	cmp    $0x30,%al
  802513:	75 0e                	jne    802523 <strtol+0xbb>
		s++, base = 8;
  802515:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80251a:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  802521:	eb 0d                	jmp    802530 <strtol+0xc8>
	else if (base == 0)
  802523:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802527:	75 07                	jne    802530 <strtol+0xc8>
		base = 10;
  802529:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  802530:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802534:	0f b6 00             	movzbl (%rax),%eax
  802537:	3c 2f                	cmp    $0x2f,%al
  802539:	7e 1d                	jle    802558 <strtol+0xf0>
  80253b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80253f:	0f b6 00             	movzbl (%rax),%eax
  802542:	3c 39                	cmp    $0x39,%al
  802544:	7f 12                	jg     802558 <strtol+0xf0>
			dig = *s - '0';
  802546:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80254a:	0f b6 00             	movzbl (%rax),%eax
  80254d:	0f be c0             	movsbl %al,%eax
  802550:	83 e8 30             	sub    $0x30,%eax
  802553:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802556:	eb 4e                	jmp    8025a6 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  802558:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80255c:	0f b6 00             	movzbl (%rax),%eax
  80255f:	3c 60                	cmp    $0x60,%al
  802561:	7e 1d                	jle    802580 <strtol+0x118>
  802563:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802567:	0f b6 00             	movzbl (%rax),%eax
  80256a:	3c 7a                	cmp    $0x7a,%al
  80256c:	7f 12                	jg     802580 <strtol+0x118>
			dig = *s - 'a' + 10;
  80256e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802572:	0f b6 00             	movzbl (%rax),%eax
  802575:	0f be c0             	movsbl %al,%eax
  802578:	83 e8 57             	sub    $0x57,%eax
  80257b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80257e:	eb 26                	jmp    8025a6 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  802580:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802584:	0f b6 00             	movzbl (%rax),%eax
  802587:	3c 40                	cmp    $0x40,%al
  802589:	7e 48                	jle    8025d3 <strtol+0x16b>
  80258b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80258f:	0f b6 00             	movzbl (%rax),%eax
  802592:	3c 5a                	cmp    $0x5a,%al
  802594:	7f 3d                	jg     8025d3 <strtol+0x16b>
			dig = *s - 'A' + 10;
  802596:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80259a:	0f b6 00             	movzbl (%rax),%eax
  80259d:	0f be c0             	movsbl %al,%eax
  8025a0:	83 e8 37             	sub    $0x37,%eax
  8025a3:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  8025a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8025a9:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8025ac:	7c 02                	jl     8025b0 <strtol+0x148>
			break;
  8025ae:	eb 23                	jmp    8025d3 <strtol+0x16b>
		s++, val = (val * base) + dig;
  8025b0:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8025b5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8025b8:	48 98                	cltq   
  8025ba:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8025bf:	48 89 c2             	mov    %rax,%rdx
  8025c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8025c5:	48 98                	cltq   
  8025c7:	48 01 d0             	add    %rdx,%rax
  8025ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8025ce:	e9 5d ff ff ff       	jmpq   802530 <strtol+0xc8>

	if (endptr)
  8025d3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8025d8:	74 0b                	je     8025e5 <strtol+0x17d>
		*endptr = (char *) s;
  8025da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025de:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8025e2:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  8025e5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8025e9:	74 09                	je     8025f4 <strtol+0x18c>
  8025eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8025ef:	48 f7 d8             	neg    %rax
  8025f2:	eb 04                	jmp    8025f8 <strtol+0x190>
  8025f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8025f8:	c9                   	leaveq 
  8025f9:	c3                   	retq   

00000000008025fa <strstr>:

char * strstr(const char *in, const char *str)
{
  8025fa:	55                   	push   %rbp
  8025fb:	48 89 e5             	mov    %rsp,%rbp
  8025fe:	48 83 ec 30          	sub    $0x30,%rsp
  802602:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802606:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  80260a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80260e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  802612:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802616:	0f b6 00             	movzbl (%rax),%eax
  802619:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  80261c:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  802620:	75 06                	jne    802628 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  802622:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802626:	eb 6b                	jmp    802693 <strstr+0x99>

	len = strlen(str);
  802628:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80262c:	48 89 c7             	mov    %rax,%rdi
  80262f:	48 b8 d0 1e 80 00 00 	movabs $0x801ed0,%rax
  802636:	00 00 00 
  802639:	ff d0                	callq  *%rax
  80263b:	48 98                	cltq   
  80263d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  802641:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802645:	48 8d 50 01          	lea    0x1(%rax),%rdx
  802649:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80264d:	0f b6 00             	movzbl (%rax),%eax
  802650:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  802653:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  802657:	75 07                	jne    802660 <strstr+0x66>
				return (char *) 0;
  802659:	b8 00 00 00 00       	mov    $0x0,%eax
  80265e:	eb 33                	jmp    802693 <strstr+0x99>
		} while (sc != c);
  802660:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  802664:	3a 45 ff             	cmp    -0x1(%rbp),%al
  802667:	75 d8                	jne    802641 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  802669:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80266d:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  802671:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802675:	48 89 ce             	mov    %rcx,%rsi
  802678:	48 89 c7             	mov    %rax,%rdi
  80267b:	48 b8 f1 20 80 00 00 	movabs $0x8020f1,%rax
  802682:	00 00 00 
  802685:	ff d0                	callq  *%rax
  802687:	85 c0                	test   %eax,%eax
  802689:	75 b6                	jne    802641 <strstr+0x47>

	return (char *) (in - 1);
  80268b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80268f:	48 83 e8 01          	sub    $0x1,%rax
}
  802693:	c9                   	leaveq 
  802694:	c3                   	retq   

0000000000802695 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802695:	55                   	push   %rbp
  802696:	48 89 e5             	mov    %rsp,%rbp
  802699:	53                   	push   %rbx
  80269a:	48 83 ec 48          	sub    $0x48,%rsp
  80269e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8026a1:	89 75 d8             	mov    %esi,-0x28(%rbp)
  8026a4:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8026a8:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8026ac:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  8026b0:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8026b4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8026b7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8026bb:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8026bf:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8026c3:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8026c7:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8026cb:	4c 89 c3             	mov    %r8,%rbx
  8026ce:	cd 30                	int    $0x30
  8026d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  8026d4:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8026d8:	74 3e                	je     802718 <syscall+0x83>
  8026da:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8026df:	7e 37                	jle    802718 <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  8026e1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8026e5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8026e8:	49 89 d0             	mov    %rdx,%r8
  8026eb:	89 c1                	mov    %eax,%ecx
  8026ed:	48 ba 68 11 82 00 00 	movabs $0x821168,%rdx
  8026f4:	00 00 00 
  8026f7:	be 23 00 00 00       	mov    $0x23,%esi
  8026fc:	48 bf 85 11 82 00 00 	movabs $0x821185,%rdi
  802703:	00 00 00 
  802706:	b8 00 00 00 00       	mov    $0x0,%eax
  80270b:	49 b9 4e 11 80 00 00 	movabs $0x80114e,%r9
  802712:	00 00 00 
  802715:	41 ff d1             	callq  *%r9

	return ret;
  802718:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80271c:	48 83 c4 48          	add    $0x48,%rsp
  802720:	5b                   	pop    %rbx
  802721:	5d                   	pop    %rbp
  802722:	c3                   	retq   

0000000000802723 <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  802723:	55                   	push   %rbp
  802724:	48 89 e5             	mov    %rsp,%rbp
  802727:	48 83 ec 20          	sub    $0x20,%rsp
  80272b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80272f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  802733:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802737:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80273b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802742:	00 
  802743:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802749:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80274f:	48 89 d1             	mov    %rdx,%rcx
  802752:	48 89 c2             	mov    %rax,%rdx
  802755:	be 00 00 00 00       	mov    $0x0,%esi
  80275a:	bf 00 00 00 00       	mov    $0x0,%edi
  80275f:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802766:	00 00 00 
  802769:	ff d0                	callq  *%rax
}
  80276b:	c9                   	leaveq 
  80276c:	c3                   	retq   

000000000080276d <sys_cgetc>:

int
sys_cgetc(void)
{
  80276d:	55                   	push   %rbp
  80276e:	48 89 e5             	mov    %rsp,%rbp
  802771:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802775:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80277c:	00 
  80277d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802783:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802789:	b9 00 00 00 00       	mov    $0x0,%ecx
  80278e:	ba 00 00 00 00       	mov    $0x0,%edx
  802793:	be 00 00 00 00       	mov    $0x0,%esi
  802798:	bf 01 00 00 00       	mov    $0x1,%edi
  80279d:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  8027a4:	00 00 00 
  8027a7:	ff d0                	callq  *%rax
}
  8027a9:	c9                   	leaveq 
  8027aa:	c3                   	retq   

00000000008027ab <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  8027ab:	55                   	push   %rbp
  8027ac:	48 89 e5             	mov    %rsp,%rbp
  8027af:	48 83 ec 10          	sub    $0x10,%rsp
  8027b3:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  8027b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8027b9:	48 98                	cltq   
  8027bb:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027c2:	00 
  8027c3:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027c9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027d4:	48 89 c2             	mov    %rax,%rdx
  8027d7:	be 01 00 00 00       	mov    $0x1,%esi
  8027dc:	bf 03 00 00 00       	mov    $0x3,%edi
  8027e1:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  8027e8:	00 00 00 
  8027eb:	ff d0                	callq  *%rax
}
  8027ed:	c9                   	leaveq 
  8027ee:	c3                   	retq   

00000000008027ef <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  8027ef:	55                   	push   %rbp
  8027f0:	48 89 e5             	mov    %rsp,%rbp
  8027f3:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  8027f7:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027fe:	00 
  8027ff:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802805:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80280b:	b9 00 00 00 00       	mov    $0x0,%ecx
  802810:	ba 00 00 00 00       	mov    $0x0,%edx
  802815:	be 00 00 00 00       	mov    $0x0,%esi
  80281a:	bf 02 00 00 00       	mov    $0x2,%edi
  80281f:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802826:	00 00 00 
  802829:	ff d0                	callq  *%rax
}
  80282b:	c9                   	leaveq 
  80282c:	c3                   	retq   

000000000080282d <sys_yield>:

void
sys_yield(void)
{
  80282d:	55                   	push   %rbp
  80282e:	48 89 e5             	mov    %rsp,%rbp
  802831:	48 83 ec 10          	sub    $0x10,%rsp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  802835:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80283c:	00 
  80283d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802843:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802849:	b9 00 00 00 00       	mov    $0x0,%ecx
  80284e:	ba 00 00 00 00       	mov    $0x0,%edx
  802853:	be 00 00 00 00       	mov    $0x0,%esi
  802858:	bf 0b 00 00 00       	mov    $0xb,%edi
  80285d:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802864:	00 00 00 
  802867:	ff d0                	callq  *%rax
}
  802869:	c9                   	leaveq 
  80286a:	c3                   	retq   

000000000080286b <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80286b:	55                   	push   %rbp
  80286c:	48 89 e5             	mov    %rsp,%rbp
  80286f:	48 83 ec 20          	sub    $0x20,%rsp
  802873:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802876:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80287a:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  80287d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802880:	48 63 c8             	movslq %eax,%rcx
  802883:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802887:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80288a:	48 98                	cltq   
  80288c:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802893:	00 
  802894:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80289a:	49 89 c8             	mov    %rcx,%r8
  80289d:	48 89 d1             	mov    %rdx,%rcx
  8028a0:	48 89 c2             	mov    %rax,%rdx
  8028a3:	be 01 00 00 00       	mov    $0x1,%esi
  8028a8:	bf 04 00 00 00       	mov    $0x4,%edi
  8028ad:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  8028b4:	00 00 00 
  8028b7:	ff d0                	callq  *%rax
}
  8028b9:	c9                   	leaveq 
  8028ba:	c3                   	retq   

00000000008028bb <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8028bb:	55                   	push   %rbp
  8028bc:	48 89 e5             	mov    %rsp,%rbp
  8028bf:	48 83 ec 30          	sub    $0x30,%rsp
  8028c3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028c6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8028ca:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8028cd:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  8028d1:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  8028d5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8028d8:	48 63 c8             	movslq %eax,%rcx
  8028db:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8028df:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8028e2:	48 63 f0             	movslq %eax,%rsi
  8028e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028ec:	48 98                	cltq   
  8028ee:	48 89 0c 24          	mov    %rcx,(%rsp)
  8028f2:	49 89 f9             	mov    %rdi,%r9
  8028f5:	49 89 f0             	mov    %rsi,%r8
  8028f8:	48 89 d1             	mov    %rdx,%rcx
  8028fb:	48 89 c2             	mov    %rax,%rdx
  8028fe:	be 01 00 00 00       	mov    $0x1,%esi
  802903:	bf 05 00 00 00       	mov    $0x5,%edi
  802908:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  80290f:	00 00 00 
  802912:	ff d0                	callq  *%rax
}
  802914:	c9                   	leaveq 
  802915:	c3                   	retq   

0000000000802916 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  802916:	55                   	push   %rbp
  802917:	48 89 e5             	mov    %rsp,%rbp
  80291a:	48 83 ec 20          	sub    $0x20,%rsp
  80291e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802921:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  802925:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802929:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80292c:	48 98                	cltq   
  80292e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802935:	00 
  802936:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80293c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802942:	48 89 d1             	mov    %rdx,%rcx
  802945:	48 89 c2             	mov    %rax,%rdx
  802948:	be 01 00 00 00       	mov    $0x1,%esi
  80294d:	bf 06 00 00 00       	mov    $0x6,%edi
  802952:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802959:	00 00 00 
  80295c:	ff d0                	callq  *%rax
}
  80295e:	c9                   	leaveq 
  80295f:	c3                   	retq   

0000000000802960 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  802960:	55                   	push   %rbp
  802961:	48 89 e5             	mov    %rsp,%rbp
  802964:	48 83 ec 10          	sub    $0x10,%rsp
  802968:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80296b:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  80296e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802971:	48 63 d0             	movslq %eax,%rdx
  802974:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802977:	48 98                	cltq   
  802979:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802980:	00 
  802981:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802987:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80298d:	48 89 d1             	mov    %rdx,%rcx
  802990:	48 89 c2             	mov    %rax,%rdx
  802993:	be 01 00 00 00       	mov    $0x1,%esi
  802998:	bf 08 00 00 00       	mov    $0x8,%edi
  80299d:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  8029a4:	00 00 00 
  8029a7:	ff d0                	callq  *%rax
}
  8029a9:	c9                   	leaveq 
  8029aa:	c3                   	retq   

00000000008029ab <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8029ab:	55                   	push   %rbp
  8029ac:	48 89 e5             	mov    %rsp,%rbp
  8029af:	48 83 ec 20          	sub    $0x20,%rsp
  8029b3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8029b6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  8029ba:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8029be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029c1:	48 98                	cltq   
  8029c3:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8029ca:	00 
  8029cb:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8029d1:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8029d7:	48 89 d1             	mov    %rdx,%rcx
  8029da:	48 89 c2             	mov    %rax,%rdx
  8029dd:	be 01 00 00 00       	mov    $0x1,%esi
  8029e2:	bf 09 00 00 00       	mov    $0x9,%edi
  8029e7:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  8029ee:	00 00 00 
  8029f1:	ff d0                	callq  *%rax
}
  8029f3:	c9                   	leaveq 
  8029f4:	c3                   	retq   

00000000008029f5 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  8029f5:	55                   	push   %rbp
  8029f6:	48 89 e5             	mov    %rsp,%rbp
  8029f9:	48 83 ec 20          	sub    $0x20,%rsp
  8029fd:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802a00:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  802a04:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802a08:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802a0b:	48 98                	cltq   
  802a0d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a14:	00 
  802a15:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a1b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a21:	48 89 d1             	mov    %rdx,%rcx
  802a24:	48 89 c2             	mov    %rax,%rdx
  802a27:	be 01 00 00 00       	mov    $0x1,%esi
  802a2c:	bf 0a 00 00 00       	mov    $0xa,%edi
  802a31:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802a38:	00 00 00 
  802a3b:	ff d0                	callq  *%rax
}
  802a3d:	c9                   	leaveq 
  802a3e:	c3                   	retq   

0000000000802a3f <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  802a3f:	55                   	push   %rbp
  802a40:	48 89 e5             	mov    %rsp,%rbp
  802a43:	48 83 ec 20          	sub    $0x20,%rsp
  802a47:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802a4a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802a4e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  802a52:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  802a55:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802a58:	48 63 f0             	movslq %eax,%rsi
  802a5b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802a5f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802a62:	48 98                	cltq   
  802a64:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802a68:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a6f:	00 
  802a70:	49 89 f1             	mov    %rsi,%r9
  802a73:	49 89 c8             	mov    %rcx,%r8
  802a76:	48 89 d1             	mov    %rdx,%rcx
  802a79:	48 89 c2             	mov    %rax,%rdx
  802a7c:	be 00 00 00 00       	mov    $0x0,%esi
  802a81:	bf 0c 00 00 00       	mov    $0xc,%edi
  802a86:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802a8d:	00 00 00 
  802a90:	ff d0                	callq  *%rax
}
  802a92:	c9                   	leaveq 
  802a93:	c3                   	retq   

0000000000802a94 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802a94:	55                   	push   %rbp
  802a95:	48 89 e5             	mov    %rsp,%rbp
  802a98:	48 83 ec 10          	sub    $0x10,%rsp
  802a9c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802aa0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802aa4:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802aab:	00 
  802aac:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802ab2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802ab8:	b9 00 00 00 00       	mov    $0x0,%ecx
  802abd:	48 89 c2             	mov    %rax,%rdx
  802ac0:	be 01 00 00 00       	mov    $0x1,%esi
  802ac5:	bf 0d 00 00 00       	mov    $0xd,%edi
  802aca:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802ad1:	00 00 00 
  802ad4:	ff d0                	callq  *%rax
}
  802ad6:	c9                   	leaveq 
  802ad7:	c3                   	retq   

0000000000802ad8 <sys_net_tx>:

int
sys_net_tx(void *buf, size_t len)
{
  802ad8:	55                   	push   %rbp
  802ad9:	48 89 e5             	mov    %rsp,%rbp
  802adc:	48 83 ec 20          	sub    $0x20,%rsp
  802ae0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802ae4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_net_tx, 1, (uint64_t)buf, len, 0, 0, 0);
  802ae8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802aec:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802af0:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802af7:	00 
  802af8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802afe:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b04:	48 89 d1             	mov    %rdx,%rcx
  802b07:	48 89 c2             	mov    %rax,%rdx
  802b0a:	be 01 00 00 00       	mov    $0x1,%esi
  802b0f:	bf 0f 00 00 00       	mov    $0xf,%edi
  802b14:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802b1b:	00 00 00 
  802b1e:	ff d0                	callq  *%rax
}
  802b20:	c9                   	leaveq 
  802b21:	c3                   	retq   

0000000000802b22 <sys_net_rx>:

int
sys_net_rx(void *buf)
{
  802b22:	55                   	push   %rbp
  802b23:	48 89 e5             	mov    %rsp,%rbp
  802b26:	48 83 ec 10          	sub    $0x10,%rsp
  802b2a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_net_rx, 0, (uint64_t)buf, 0, 0, 0, 0);
  802b2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b32:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802b39:	00 
  802b3a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b40:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b46:	b9 00 00 00 00       	mov    $0x0,%ecx
  802b4b:	48 89 c2             	mov    %rax,%rdx
  802b4e:	be 00 00 00 00       	mov    $0x0,%esi
  802b53:	bf 10 00 00 00       	mov    $0x10,%edi
  802b58:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802b5f:	00 00 00 
  802b62:	ff d0                	callq  *%rax
}
  802b64:	c9                   	leaveq 
  802b65:	c3                   	retq   

0000000000802b66 <sys_time_msec>:


unsigned int
sys_time_msec(void)
{
  802b66:	55                   	push   %rbp
  802b67:	48 89 e5             	mov    %rsp,%rbp
  802b6a:	48 83 ec 10          	sub    $0x10,%rsp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802b6e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802b75:	00 
  802b76:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b7c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b82:	b9 00 00 00 00       	mov    $0x0,%ecx
  802b87:	ba 00 00 00 00       	mov    $0x0,%edx
  802b8c:	be 00 00 00 00       	mov    $0x0,%esi
  802b91:	bf 0e 00 00 00       	mov    $0xe,%edi
  802b96:	48 b8 95 26 80 00 00 	movabs $0x802695,%rax
  802b9d:	00 00 00 
  802ba0:	ff d0                	callq  *%rax
}
  802ba2:	c9                   	leaveq 
  802ba3:	c3                   	retq   

0000000000802ba4 <pgfault>:
        return esp;
}

static void
pgfault(struct UTrapframe *utf)
{
  802ba4:	55                   	push   %rbp
  802ba5:	48 89 e5             	mov    %rsp,%rbp
  802ba8:	48 83 ec 30          	sub    $0x30,%rsp
  802bac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802bb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802bb4:	48 8b 00             	mov    (%rax),%rax
  802bb7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t err = utf->utf_err;
  802bbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802bbf:	48 8b 40 08          	mov    0x8(%rax),%rax
  802bc3:	89 45 f4             	mov    %eax,-0xc(%rbp)
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	//cprintf("I am in user's page fault handler\n");
	if(!(err &FEC_WR)&&(uvpt[PPN(addr)]& PTE_COW))
  802bc6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802bc9:	83 e0 02             	and    $0x2,%eax
  802bcc:	85 c0                	test   %eax,%eax
  802bce:	75 4d                	jne    802c1d <pgfault+0x79>
  802bd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802bd4:	48 c1 e8 0c          	shr    $0xc,%rax
  802bd8:	48 89 c2             	mov    %rax,%rdx
  802bdb:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802be2:	01 00 00 
  802be5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802be9:	25 00 08 00 00       	and    $0x800,%eax
  802bee:	48 85 c0             	test   %rax,%rax
  802bf1:	74 2a                	je     802c1d <pgfault+0x79>
		panic("Page isnt writable/ COW, why did I get a pagefault \n");
  802bf3:	48 ba 98 11 82 00 00 	movabs $0x821198,%rdx
  802bfa:	00 00 00 
  802bfd:	be 23 00 00 00       	mov    $0x23,%esi
  802c02:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802c09:	00 00 00 
  802c0c:	b8 00 00 00 00       	mov    $0x0,%eax
  802c11:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802c18:	00 00 00 
  802c1b:	ff d1                	callq  *%rcx
	// copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.
	if(0 == sys_page_alloc(0,(void*)PFTEMP,PTE_U|PTE_P|PTE_W)){
  802c1d:	ba 07 00 00 00       	mov    $0x7,%edx
  802c22:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802c27:	bf 00 00 00 00       	mov    $0x0,%edi
  802c2c:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  802c33:	00 00 00 
  802c36:	ff d0                	callq  *%rax
  802c38:	85 c0                	test   %eax,%eax
  802c3a:	0f 85 cd 00 00 00    	jne    802d0d <pgfault+0x169>
		Pageaddr = ROUNDDOWN(addr,PGSIZE);
  802c40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802c44:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802c48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802c4c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802c52:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		memmove(PFTEMP, Pageaddr, PGSIZE);
  802c56:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c5a:	ba 00 10 00 00       	mov    $0x1000,%edx
  802c5f:	48 89 c6             	mov    %rax,%rsi
  802c62:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802c67:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  802c6e:	00 00 00 
  802c71:	ff d0                	callq  *%rax
		if(0> sys_page_map(0,PFTEMP,0,Pageaddr,PTE_U|PTE_P|PTE_W))
  802c73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c77:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802c7d:	48 89 c1             	mov    %rax,%rcx
  802c80:	ba 00 00 00 00       	mov    $0x0,%edx
  802c85:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802c8a:	bf 00 00 00 00       	mov    $0x0,%edi
  802c8f:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  802c96:	00 00 00 
  802c99:	ff d0                	callq  *%rax
  802c9b:	85 c0                	test   %eax,%eax
  802c9d:	79 2a                	jns    802cc9 <pgfault+0x125>
				panic("Page map at temp address failed");
  802c9f:	48 ba d8 11 82 00 00 	movabs $0x8211d8,%rdx
  802ca6:	00 00 00 
  802ca9:	be 30 00 00 00       	mov    $0x30,%esi
  802cae:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802cb5:	00 00 00 
  802cb8:	b8 00 00 00 00       	mov    $0x0,%eax
  802cbd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802cc4:	00 00 00 
  802cc7:	ff d1                	callq  *%rcx
		if(0> sys_page_unmap(0,PFTEMP))
  802cc9:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802cce:	bf 00 00 00 00       	mov    $0x0,%edi
  802cd3:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  802cda:	00 00 00 
  802cdd:	ff d0                	callq  *%rax
  802cdf:	85 c0                	test   %eax,%eax
  802ce1:	79 54                	jns    802d37 <pgfault+0x193>
				panic("Page unmap from temp location failed");
  802ce3:	48 ba f8 11 82 00 00 	movabs $0x8211f8,%rdx
  802cea:	00 00 00 
  802ced:	be 32 00 00 00       	mov    $0x32,%esi
  802cf2:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802cf9:	00 00 00 
  802cfc:	b8 00 00 00 00       	mov    $0x0,%eax
  802d01:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802d08:	00 00 00 
  802d0b:	ff d1                	callq  *%rcx
	}else{
		panic("Page Allocation Failed during handling page fault");
  802d0d:	48 ba 20 12 82 00 00 	movabs $0x821220,%rdx
  802d14:	00 00 00 
  802d17:	be 34 00 00 00       	mov    $0x34,%esi
  802d1c:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802d23:	00 00 00 
  802d26:	b8 00 00 00 00       	mov    $0x0,%eax
  802d2b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802d32:	00 00 00 
  802d35:	ff d1                	callq  *%rcx
	}
	//panic("pgfault not implemented");
}
  802d37:	c9                   	leaveq 
  802d38:	c3                   	retq   

0000000000802d39 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802d39:	55                   	push   %rbp
  802d3a:	48 89 e5             	mov    %rsp,%rbp
  802d3d:	48 83 ec 20          	sub    $0x20,%rsp
  802d41:	89 7d ec             	mov    %edi,-0x14(%rbp)
  802d44:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	int perm = (uvpt[pn]) & PTE_SYSCALL; // Doubtful..
  802d47:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802d4e:	01 00 00 
  802d51:	8b 55 e8             	mov    -0x18(%rbp),%edx
  802d54:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d58:	25 07 0e 00 00       	and    $0xe07,%eax
  802d5d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	void* addr = (void*)((uint64_t)pn *PGSIZE);
  802d60:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802d63:	48 c1 e0 0c          	shl    $0xc,%rax
  802d67:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//cprintf("DuPpage: Incoming addr = [%x], permission = [%d]\n", addr,perm);
	// LAB 4: Your code  here.
	if(perm & PTE_SHARE){
  802d6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802d6e:	25 00 04 00 00       	and    $0x400,%eax
  802d73:	85 c0                	test   %eax,%eax
  802d75:	74 57                	je     802dce <duppage+0x95>
		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802d77:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802d7a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802d7e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802d81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802d85:	41 89 f0             	mov    %esi,%r8d
  802d88:	48 89 c6             	mov    %rax,%rsi
  802d8b:	bf 00 00 00 00       	mov    $0x0,%edi
  802d90:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  802d97:	00 00 00 
  802d9a:	ff d0                	callq  *%rax
  802d9c:	85 c0                	test   %eax,%eax
  802d9e:	0f 8e 52 01 00 00    	jle    802ef6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
  802da4:	48 ba 52 12 82 00 00 	movabs $0x821252,%rdx
  802dab:	00 00 00 
  802dae:	be 4e 00 00 00       	mov    $0x4e,%esi
  802db3:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802dba:	00 00 00 
  802dbd:	b8 00 00 00 00       	mov    $0x0,%eax
  802dc2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802dc9:	00 00 00 
  802dcc:	ff d1                	callq  *%rcx

	}else{
	if((perm & PTE_W || perm & PTE_COW)){
  802dce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802dd1:	83 e0 02             	and    $0x2,%eax
  802dd4:	85 c0                	test   %eax,%eax
  802dd6:	75 10                	jne    802de8 <duppage+0xaf>
  802dd8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802ddb:	25 00 08 00 00       	and    $0x800,%eax
  802de0:	85 c0                	test   %eax,%eax
  802de2:	0f 84 bb 00 00 00    	je     802ea3 <duppage+0x16a>
		perm = (perm|PTE_COW)&(~PTE_W);
  802de8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802deb:	25 fd f7 ff ff       	and    $0xfffff7fd,%eax
  802df0:	80 cc 08             	or     $0x8,%ah
  802df3:	89 45 fc             	mov    %eax,-0x4(%rbp)

		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802df6:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802df9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802dfd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802e00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e04:	41 89 f0             	mov    %esi,%r8d
  802e07:	48 89 c6             	mov    %rax,%rsi
  802e0a:	bf 00 00 00 00       	mov    $0x0,%edi
  802e0f:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  802e16:	00 00 00 
  802e19:	ff d0                	callq  *%rax
  802e1b:	85 c0                	test   %eax,%eax
  802e1d:	7e 2a                	jle    802e49 <duppage+0x110>
			panic("Page alloc with COW  failed.\n");
  802e1f:	48 ba 52 12 82 00 00 	movabs $0x821252,%rdx
  802e26:	00 00 00 
  802e29:	be 55 00 00 00       	mov    $0x55,%esi
  802e2e:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802e35:	00 00 00 
  802e38:	b8 00 00 00 00       	mov    $0x0,%eax
  802e3d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802e44:	00 00 00 
  802e47:	ff d1                	callq  *%rcx
		if(0 <  sys_page_map(0,addr,0,addr,perm))
  802e49:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  802e4c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802e50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e54:	41 89 c8             	mov    %ecx,%r8d
  802e57:	48 89 d1             	mov    %rdx,%rcx
  802e5a:	ba 00 00 00 00       	mov    $0x0,%edx
  802e5f:	48 89 c6             	mov    %rax,%rsi
  802e62:	bf 00 00 00 00       	mov    $0x0,%edi
  802e67:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  802e6e:	00 00 00 
  802e71:	ff d0                	callq  *%rax
  802e73:	85 c0                	test   %eax,%eax
  802e75:	7e 2a                	jle    802ea1 <duppage+0x168>
			panic("Page alloc with COW  failed.\n");
  802e77:	48 ba 52 12 82 00 00 	movabs $0x821252,%rdx
  802e7e:	00 00 00 
  802e81:	be 57 00 00 00       	mov    $0x57,%esi
  802e86:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802e8d:	00 00 00 
  802e90:	b8 00 00 00 00       	mov    $0x0,%eax
  802e95:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802e9c:	00 00 00 
  802e9f:	ff d1                	callq  *%rcx
	if((perm & PTE_W || perm & PTE_COW)){
		perm = (perm|PTE_COW)&(~PTE_W);

		if(0 < sys_page_map(0,addr,envid,addr,perm))
			panic("Page alloc with COW  failed.\n");
		if(0 <  sys_page_map(0,addr,0,addr,perm))
  802ea1:	eb 53                	jmp    802ef6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
	}else{
	
		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802ea3:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802ea6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802eaa:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802ead:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802eb1:	41 89 f0             	mov    %esi,%r8d
  802eb4:	48 89 c6             	mov    %rax,%rsi
  802eb7:	bf 00 00 00 00       	mov    $0x0,%edi
  802ebc:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  802ec3:	00 00 00 
  802ec6:	ff d0                	callq  *%rax
  802ec8:	85 c0                	test   %eax,%eax
  802eca:	7e 2a                	jle    802ef6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
  802ecc:	48 ba 52 12 82 00 00 	movabs $0x821252,%rdx
  802ed3:	00 00 00 
  802ed6:	be 5b 00 00 00       	mov    $0x5b,%esi
  802edb:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802ee2:	00 00 00 
  802ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  802eea:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  802ef1:	00 00 00 
  802ef4:	ff d1                	callq  *%rcx
		}
	}

	//panic("duppage not implemented");
	
	return 0;
  802ef6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802efb:	c9                   	leaveq 
  802efc:	c3                   	retq   

0000000000802efd <pt_is_mapped>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
bool
pt_is_mapped(void *va)
{
  802efd:	55                   	push   %rbp
  802efe:	48 89 e5             	mov    %rsp,%rbp
  802f01:	48 83 ec 18          	sub    $0x18,%rsp
  802f05:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	uint64_t addr = (uint64_t)va;
  802f09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802f0d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return (uvpml4e[VPML4E(addr)] & PTE_P) && (uvpde[VPDPE(addr<<12)] & PTE_P) && (uvpd[VPD(addr<<12)] & PTE_P);
  802f11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f15:	48 c1 e8 27          	shr    $0x27,%rax
  802f19:	48 89 c2             	mov    %rax,%rdx
  802f1c:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  802f23:	01 00 00 
  802f26:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f2a:	83 e0 01             	and    $0x1,%eax
  802f2d:	48 85 c0             	test   %rax,%rax
  802f30:	74 51                	je     802f83 <pt_is_mapped+0x86>
  802f32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f36:	48 c1 e0 0c          	shl    $0xc,%rax
  802f3a:	48 c1 e8 1e          	shr    $0x1e,%rax
  802f3e:	48 89 c2             	mov    %rax,%rdx
  802f41:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  802f48:	01 00 00 
  802f4b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f4f:	83 e0 01             	and    $0x1,%eax
  802f52:	48 85 c0             	test   %rax,%rax
  802f55:	74 2c                	je     802f83 <pt_is_mapped+0x86>
  802f57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f5b:	48 c1 e0 0c          	shl    $0xc,%rax
  802f5f:	48 c1 e8 15          	shr    $0x15,%rax
  802f63:	48 89 c2             	mov    %rax,%rdx
  802f66:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802f6d:	01 00 00 
  802f70:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f74:	83 e0 01             	and    $0x1,%eax
  802f77:	48 85 c0             	test   %rax,%rax
  802f7a:	74 07                	je     802f83 <pt_is_mapped+0x86>
  802f7c:	b8 01 00 00 00       	mov    $0x1,%eax
  802f81:	eb 05                	jmp    802f88 <pt_is_mapped+0x8b>
  802f83:	b8 00 00 00 00       	mov    $0x0,%eax
  802f88:	83 e0 01             	and    $0x1,%eax
}
  802f8b:	c9                   	leaveq 
  802f8c:	c3                   	retq   

0000000000802f8d <fork>:

envid_t
fork(void)
{
  802f8d:	55                   	push   %rbp
  802f8e:	48 89 e5             	mov    %rsp,%rbp
  802f91:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here.
	envid_t envid;
	int r;
	uint64_t i;
	uint64_t addr, last;
	set_pgfault_handler(pgfault);
  802f95:	48 bf a4 2b 80 00 00 	movabs $0x802ba4,%rdi
  802f9c:	00 00 00 
  802f9f:	48 b8 3e 5a 80 00 00 	movabs $0x805a3e,%rax
  802fa6:	00 00 00 
  802fa9:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802fab:	b8 07 00 00 00       	mov    $0x7,%eax
  802fb0:	cd 30                	int    $0x30
  802fb2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802fb5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
	envid = sys_exofork();
  802fb8:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if(envid < 0)
  802fbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  802fbf:	79 30                	jns    802ff1 <fork+0x64>
		panic("\nsys_exofork error: %e\n", envid);
  802fc1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802fc4:	89 c1                	mov    %eax,%ecx
  802fc6:	48 ba 70 12 82 00 00 	movabs $0x821270,%rdx
  802fcd:	00 00 00 
  802fd0:	be 86 00 00 00       	mov    $0x86,%esi
  802fd5:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  802fdc:	00 00 00 
  802fdf:	b8 00 00 00 00       	mov    $0x0,%eax
  802fe4:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  802feb:	00 00 00 
  802fee:	41 ff d0             	callq  *%r8
    else if(envid == 0)
  802ff1:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  802ff5:	75 46                	jne    80303d <fork+0xb0>
	{
		thisenv = &envs[ENVX(sys_getenvid())];
  802ff7:	48 b8 ef 27 80 00 00 	movabs $0x8027ef,%rax
  802ffe:	00 00 00 
  803001:	ff d0                	callq  *%rax
  803003:	25 ff 03 00 00       	and    $0x3ff,%eax
  803008:	48 63 d0             	movslq %eax,%rdx
  80300b:	48 89 d0             	mov    %rdx,%rax
  80300e:	48 c1 e0 03          	shl    $0x3,%rax
  803012:	48 01 d0             	add    %rdx,%rax
  803015:	48 c1 e0 05          	shl    $0x5,%rax
  803019:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803020:	00 00 00 
  803023:	48 01 c2             	add    %rax,%rdx
  803026:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80302d:	00 00 00 
  803030:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  803033:	b8 00 00 00 00       	mov    $0x0,%eax
  803038:	e9 d1 01 00 00       	jmpq   80320e <fork+0x281>
	}
	uint64_t ad = 0;
  80303d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  803044:	00 
	for (addr = (uint64_t)USTACKTOP-PGSIZE; addr >=(uint64_t)UTEXT; addr -= PGSIZE){  // Is this enough, am I leaving a bug for future here???	
  803045:	b8 00 d0 7f ef       	mov    $0xef7fd000,%eax
  80304a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80304e:	e9 df 00 00 00       	jmpq   803132 <fork+0x1a5>
	/*Do we really need to scan all the pages????*/
		if(uvpml4e[VPML4E(addr)]& PTE_P){
  803053:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803057:	48 c1 e8 27          	shr    $0x27,%rax
  80305b:	48 89 c2             	mov    %rax,%rdx
  80305e:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  803065:	01 00 00 
  803068:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80306c:	83 e0 01             	and    $0x1,%eax
  80306f:	48 85 c0             	test   %rax,%rax
  803072:	0f 84 9e 00 00 00    	je     803116 <fork+0x189>
			if( uvpde[VPDPE(addr)] & PTE_P){
  803078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80307c:	48 c1 e8 1e          	shr    $0x1e,%rax
  803080:	48 89 c2             	mov    %rax,%rdx
  803083:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  80308a:	01 00 00 
  80308d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803091:	83 e0 01             	and    $0x1,%eax
  803094:	48 85 c0             	test   %rax,%rax
  803097:	74 73                	je     80310c <fork+0x17f>
				if( uvpd[VPD(addr)] & PTE_P){
  803099:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80309d:	48 c1 e8 15          	shr    $0x15,%rax
  8030a1:	48 89 c2             	mov    %rax,%rdx
  8030a4:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8030ab:	01 00 00 
  8030ae:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8030b2:	83 e0 01             	and    $0x1,%eax
  8030b5:	48 85 c0             	test   %rax,%rax
  8030b8:	74 48                	je     803102 <fork+0x175>
					if((ad =uvpt[VPN(addr)])& PTE_P){
  8030ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8030be:	48 c1 e8 0c          	shr    $0xc,%rax
  8030c2:	48 89 c2             	mov    %rax,%rdx
  8030c5:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8030cc:	01 00 00 
  8030cf:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8030d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8030d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8030db:	83 e0 01             	and    $0x1,%eax
  8030de:	48 85 c0             	test   %rax,%rax
  8030e1:	74 47                	je     80312a <fork+0x19d>
						//cprintf("hi\n");
						//cprintf("addr = [%x]\n",ad);
						duppage(envid, VPN(addr));	
  8030e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8030e7:	48 c1 e8 0c          	shr    $0xc,%rax
  8030eb:	89 c2                	mov    %eax,%edx
  8030ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8030f0:	89 d6                	mov    %edx,%esi
  8030f2:	89 c7                	mov    %eax,%edi
  8030f4:	48 b8 39 2d 80 00 00 	movabs $0x802d39,%rax
  8030fb:	00 00 00 
  8030fe:	ff d0                	callq  *%rax
  803100:	eb 28                	jmp    80312a <fork+0x19d>
					}
				}else{
					addr -= NPDENTRIES*PGSIZE;
  803102:	48 81 6d f8 00 00 20 	subq   $0x200000,-0x8(%rbp)
  803109:	00 
  80310a:	eb 1e                	jmp    80312a <fork+0x19d>
					//addr -= ((VPD(addr)+1)<<PDXSHIFT);
				}
			}else{
				addr -= NPDENTRIES*NPDENTRIES*PGSIZE;
  80310c:	48 81 6d f8 00 00 00 	subq   $0x40000000,-0x8(%rbp)
  803113:	40 
  803114:	eb 14                	jmp    80312a <fork+0x19d>
				//addr -= ((VPDPE(addr)+1)<<PDPESHIFT);
			}
	
		}else{
		/*uvpml4e.. move by */
			addr -= ((VPML4E(addr)+1)<<PML4SHIFT)
  803116:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80311a:	48 c1 e8 27          	shr    $0x27,%rax
  80311e:	48 83 c0 01          	add    $0x1,%rax
  803122:	48 c1 e0 27          	shl    $0x27,%rax
  803126:	48 29 45 f8          	sub    %rax,-0x8(%rbp)
	{
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	uint64_t ad = 0;
	for (addr = (uint64_t)USTACKTOP-PGSIZE; addr >=(uint64_t)UTEXT; addr -= PGSIZE){  // Is this enough, am I leaving a bug for future here???	
  80312a:	48 81 6d f8 00 10 00 	subq   $0x1000,-0x8(%rbp)
  803131:	00 
  803132:	48 81 7d f8 ff ff 7f 	cmpq   $0x7fffff,-0x8(%rbp)
  803139:	00 
  80313a:	0f 87 13 ff ff ff    	ja     803053 <fork+0xc6>
		}
	
	}


	sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE),PTE_P|PTE_U|PTE_W); 
  803140:	8b 45 f4             	mov    -0xc(%rbp),%eax
  803143:	ba 07 00 00 00       	mov    $0x7,%edx
  803148:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  80314d:	89 c7                	mov    %eax,%edi
  80314f:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  803156:	00 00 00 
  803159:	ff d0                	callq  *%rax

	sys_page_alloc(envid, (void*)(USTACKTOP - PGSIZE),PTE_P|PTE_U|PTE_W); 
  80315b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80315e:	ba 07 00 00 00       	mov    $0x7,%edx
  803163:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  803168:	89 c7                	mov    %eax,%edi
  80316a:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  803171:	00 00 00 
  803174:	ff d0                	callq  *%rax

	sys_page_map(envid, (void*)(USTACKTOP - PGSIZE), 0, PFTEMP,PTE_P|PTE_U|PTE_W);
  803176:	8b 45 f4             	mov    -0xc(%rbp),%eax
  803179:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  80317f:	b9 00 f0 5f 00       	mov    $0x5ff000,%ecx
  803184:	ba 00 00 00 00       	mov    $0x0,%edx
  803189:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  80318e:	89 c7                	mov    %eax,%edi
  803190:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  803197:	00 00 00 
  80319a:	ff d0                	callq  *%rax

	memmove(PFTEMP, (void*)(USTACKTOP-PGSIZE), PGSIZE);
  80319c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8031a1:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8031a6:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  8031ab:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8031b2:	00 00 00 
  8031b5:	ff d0                	callq  *%rax

	sys_page_unmap(0, PFTEMP);
  8031b7:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  8031bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8031c1:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8031c8:	00 00 00 
  8031cb:	ff d0                	callq  *%rax

    sys_env_set_pgfault_upcall(envid, thisenv->env_pgfault_upcall); 
  8031cd:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8031d4:	00 00 00 
  8031d7:	48 8b 00             	mov    (%rax),%rax
  8031da:	48 8b 90 f0 00 00 00 	mov    0xf0(%rax),%rdx
  8031e1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8031e4:	48 89 d6             	mov    %rdx,%rsi
  8031e7:	89 c7                	mov    %eax,%edi
  8031e9:	48 b8 f5 29 80 00 00 	movabs $0x8029f5,%rax
  8031f0:	00 00 00 
  8031f3:	ff d0                	callq  *%rax
	
	sys_env_set_status(envid, ENV_RUNNABLE);
  8031f5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8031f8:	be 02 00 00 00       	mov    $0x2,%esi
  8031fd:	89 c7                	mov    %eax,%edi
  8031ff:	48 b8 60 29 80 00 00 	movabs $0x802960,%rax
  803206:	00 00 00 
  803209:	ff d0                	callq  *%rax

	return envid;
  80320b:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  80320e:	c9                   	leaveq 
  80320f:	c3                   	retq   

0000000000803210 <sfork>:

	
// Challenge!
int
sfork(void)
{
  803210:	55                   	push   %rbp
  803211:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  803214:	48 ba 88 12 82 00 00 	movabs $0x821288,%rdx
  80321b:	00 00 00 
  80321e:	be bf 00 00 00       	mov    $0xbf,%esi
  803223:	48 bf cd 11 82 00 00 	movabs $0x8211cd,%rdi
  80322a:	00 00 00 
  80322d:	b8 00 00 00 00       	mov    $0x0,%eax
  803232:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  803239:	00 00 00 
  80323c:	ff d1                	callq  *%rcx

000000000080323e <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80323e:	55                   	push   %rbp
  80323f:	48 89 e5             	mov    %rsp,%rbp
  803242:	48 83 ec 30          	sub    $0x30,%rsp
  803246:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80324a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80324e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// LAB 4: Your code here.
	int result;
	if(thisenv->env_status== 0){
  803252:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803259:	00 00 00 
  80325c:	48 8b 00             	mov    (%rax),%rax
  80325f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  803265:	85 c0                	test   %eax,%eax
  803267:	75 3c                	jne    8032a5 <ipc_recv+0x67>
		thisenv = &envs[ENVX(sys_getenvid())];
  803269:	48 b8 ef 27 80 00 00 	movabs $0x8027ef,%rax
  803270:	00 00 00 
  803273:	ff d0                	callq  *%rax
  803275:	25 ff 03 00 00       	and    $0x3ff,%eax
  80327a:	48 63 d0             	movslq %eax,%rdx
  80327d:	48 89 d0             	mov    %rdx,%rax
  803280:	48 c1 e0 03          	shl    $0x3,%rax
  803284:	48 01 d0             	add    %rdx,%rax
  803287:	48 c1 e0 05          	shl    $0x5,%rax
  80328b:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803292:	00 00 00 
  803295:	48 01 c2             	add    %rax,%rdx
  803298:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80329f:	00 00 00 
  8032a2:	48 89 10             	mov    %rdx,(%rax)
	}
	if(!pg)
  8032a5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8032aa:	75 0e                	jne    8032ba <ipc_recv+0x7c>
		pg = (void*) UTOP;
  8032ac:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8032b3:	00 00 00 
  8032b6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	result = sys_ipc_recv(pg);
  8032ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8032be:	48 89 c7             	mov    %rax,%rdi
  8032c1:	48 b8 94 2a 80 00 00 	movabs $0x802a94,%rax
  8032c8:	00 00 00 
  8032cb:	ff d0                	callq  *%rax
  8032cd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result< 0){
  8032d0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8032d4:	79 19                	jns    8032ef <ipc_recv+0xb1>
		*from_env_store = 0;
  8032d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8032da:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		*perm_store =0;
  8032e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8032e4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		return result;
  8032ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8032ed:	eb 53                	jmp    803342 <ipc_recv+0x104>
	}
	if(from_env_store)
  8032ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8032f4:	74 19                	je     80330f <ipc_recv+0xd1>
		*from_env_store = thisenv->env_ipc_from;
  8032f6:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8032fd:	00 00 00 
  803300:	48 8b 00             	mov    (%rax),%rax
  803303:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  803309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80330d:	89 10                	mov    %edx,(%rax)
	if(perm_store)
  80330f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803314:	74 19                	je     80332f <ipc_recv+0xf1>
		*perm_store = thisenv->env_ipc_perm;
  803316:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80331d:	00 00 00 
  803320:	48 8b 00             	mov    (%rax),%rax
  803323:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  803329:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80332d:	89 10                	mov    %edx,(%rax)
	
	//cprintf("I am IPC Recv, sending value[%d] my env id is [%d]and status is [%d] and I am sending to [%d]",thisenv->env_ipc_value,thisenv->env_id,thisenv->env_status,thisenv->env_ipc_from);	
	return thisenv->env_ipc_value;
  80332f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803336:	00 00 00 
  803339:	48 8b 00             	mov    (%rax),%rax
  80333c:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax

	//panic("ipc_recv not implemented");
}
  803342:	c9                   	leaveq 
  803343:	c3                   	retq   

0000000000803344 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  803344:	55                   	push   %rbp
  803345:	48 89 e5             	mov    %rsp,%rbp
  803348:	48 83 ec 30          	sub    $0x30,%rsp
  80334c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80334f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  803352:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  803356:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	// LAB 4: Your code here.
	int result;
	if(!pg)
  803359:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80335e:	75 0e                	jne    80336e <ipc_send+0x2a>
		pg = (void*)UTOP;
  803360:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  803367:	00 00 00 
  80336a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	do{
	 	result = sys_ipc_try_send(to_env,val,pg,perm);
  80336e:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803371:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  803374:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803378:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80337b:	89 c7                	mov    %eax,%edi
  80337d:	48 b8 3f 2a 80 00 00 	movabs $0x802a3f,%rax
  803384:	00 00 00 
  803387:	ff d0                	callq  *%rax
  803389:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(-E_IPC_NOT_RECV == result)
  80338c:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803390:	75 0c                	jne    80339e <ipc_send+0x5a>
			sys_yield();
  803392:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  803399:	00 00 00 
  80339c:	ff d0                	callq  *%rax
	}while(-E_IPC_NOT_RECV == result);
  80339e:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  8033a2:	74 ca                	je     80336e <ipc_send+0x2a>
	
	//panic("ipc_send not implemented");
}
  8033a4:	c9                   	leaveq 
  8033a5:	c3                   	retq   

00000000008033a6 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8033a6:	55                   	push   %rbp
  8033a7:	48 89 e5             	mov    %rsp,%rbp
  8033aa:	48 83 ec 14          	sub    $0x14,%rsp
  8033ae:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8033b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8033b8:	eb 5e                	jmp    803418 <ipc_find_env+0x72>
		if (envs[i].env_type == type)
  8033ba:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8033c1:	00 00 00 
  8033c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033c7:	48 63 d0             	movslq %eax,%rdx
  8033ca:	48 89 d0             	mov    %rdx,%rax
  8033cd:	48 c1 e0 03          	shl    $0x3,%rax
  8033d1:	48 01 d0             	add    %rdx,%rax
  8033d4:	48 c1 e0 05          	shl    $0x5,%rax
  8033d8:	48 01 c8             	add    %rcx,%rax
  8033db:	48 05 d0 00 00 00    	add    $0xd0,%rax
  8033e1:	8b 00                	mov    (%rax),%eax
  8033e3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8033e6:	75 2c                	jne    803414 <ipc_find_env+0x6e>
			return envs[i].env_id;
  8033e8:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8033ef:	00 00 00 
  8033f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033f5:	48 63 d0             	movslq %eax,%rdx
  8033f8:	48 89 d0             	mov    %rdx,%rax
  8033fb:	48 c1 e0 03          	shl    $0x3,%rax
  8033ff:	48 01 d0             	add    %rdx,%rax
  803402:	48 c1 e0 05          	shl    $0x5,%rax
  803406:	48 01 c8             	add    %rcx,%rax
  803409:	48 05 c0 00 00 00    	add    $0xc0,%rax
  80340f:	8b 40 08             	mov    0x8(%rax),%eax
  803412:	eb 12                	jmp    803426 <ipc_find_env+0x80>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  803414:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803418:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  80341f:	7e 99                	jle    8033ba <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  803421:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803426:	c9                   	leaveq 
  803427:	c3                   	retq   

0000000000803428 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  803428:	55                   	push   %rbp
  803429:	48 89 e5             	mov    %rsp,%rbp
  80342c:	48 83 ec 08          	sub    $0x8,%rsp
  803430:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803434:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803438:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  80343f:	ff ff ff 
  803442:	48 01 d0             	add    %rdx,%rax
  803445:	48 c1 e8 0c          	shr    $0xc,%rax
}
  803449:	c9                   	leaveq 
  80344a:	c3                   	retq   

000000000080344b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80344b:	55                   	push   %rbp
  80344c:	48 89 e5             	mov    %rsp,%rbp
  80344f:	48 83 ec 08          	sub    $0x8,%rsp
  803453:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  803457:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80345b:	48 89 c7             	mov    %rax,%rdi
  80345e:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  803465:	00 00 00 
  803468:	ff d0                	callq  *%rax
  80346a:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803470:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803474:	c9                   	leaveq 
  803475:	c3                   	retq   

0000000000803476 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  803476:	55                   	push   %rbp
  803477:	48 89 e5             	mov    %rsp,%rbp
  80347a:	48 83 ec 18          	sub    $0x18,%rsp
  80347e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803482:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803489:	eb 6b                	jmp    8034f6 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  80348b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80348e:	48 98                	cltq   
  803490:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  803496:	48 c1 e0 0c          	shl    $0xc,%rax
  80349a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80349e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8034a2:	48 c1 e8 15          	shr    $0x15,%rax
  8034a6:	48 89 c2             	mov    %rax,%rdx
  8034a9:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8034b0:	01 00 00 
  8034b3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8034b7:	83 e0 01             	and    $0x1,%eax
  8034ba:	48 85 c0             	test   %rax,%rax
  8034bd:	74 21                	je     8034e0 <fd_alloc+0x6a>
  8034bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8034c3:	48 c1 e8 0c          	shr    $0xc,%rax
  8034c7:	48 89 c2             	mov    %rax,%rdx
  8034ca:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8034d1:	01 00 00 
  8034d4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8034d8:	83 e0 01             	and    $0x1,%eax
  8034db:	48 85 c0             	test   %rax,%rax
  8034de:	75 12                	jne    8034f2 <fd_alloc+0x7c>
			*fd_store = fd;
  8034e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8034e4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8034e8:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8034eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8034f0:	eb 1a                	jmp    80350c <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  8034f2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8034f6:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8034fa:	7e 8f                	jle    80348b <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  8034fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803500:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  803507:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80350c:	c9                   	leaveq 
  80350d:	c3                   	retq   

000000000080350e <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80350e:	55                   	push   %rbp
  80350f:	48 89 e5             	mov    %rsp,%rbp
  803512:	48 83 ec 20          	sub    $0x20,%rsp
  803516:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803519:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80351d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803521:	78 06                	js     803529 <fd_lookup+0x1b>
  803523:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  803527:	7e 07                	jle    803530 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803529:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80352e:	eb 6c                	jmp    80359c <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803530:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803533:	48 98                	cltq   
  803535:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80353b:	48 c1 e0 0c          	shl    $0xc,%rax
  80353f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803547:	48 c1 e8 15          	shr    $0x15,%rax
  80354b:	48 89 c2             	mov    %rax,%rdx
  80354e:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803555:	01 00 00 
  803558:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80355c:	83 e0 01             	and    $0x1,%eax
  80355f:	48 85 c0             	test   %rax,%rax
  803562:	74 21                	je     803585 <fd_lookup+0x77>
  803564:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803568:	48 c1 e8 0c          	shr    $0xc,%rax
  80356c:	48 89 c2             	mov    %rax,%rdx
  80356f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803576:	01 00 00 
  803579:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80357d:	83 e0 01             	and    $0x1,%eax
  803580:	48 85 c0             	test   %rax,%rax
  803583:	75 07                	jne    80358c <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803585:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80358a:	eb 10                	jmp    80359c <fd_lookup+0x8e>
	}
	*fd_store = fd;
  80358c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803590:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803594:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  803597:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80359c:	c9                   	leaveq 
  80359d:	c3                   	retq   

000000000080359e <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80359e:	55                   	push   %rbp
  80359f:	48 89 e5             	mov    %rsp,%rbp
  8035a2:	48 83 ec 30          	sub    $0x30,%rsp
  8035a6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8035aa:	89 f0                	mov    %esi,%eax
  8035ac:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8035af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8035b3:	48 89 c7             	mov    %rax,%rdi
  8035b6:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  8035bd:	00 00 00 
  8035c0:	ff d0                	callq  *%rax
  8035c2:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8035c6:	48 89 d6             	mov    %rdx,%rsi
  8035c9:	89 c7                	mov    %eax,%edi
  8035cb:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8035d2:	00 00 00 
  8035d5:	ff d0                	callq  *%rax
  8035d7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8035da:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8035de:	78 0a                	js     8035ea <fd_close+0x4c>
	    || fd != fd2)
  8035e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035e4:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8035e8:	74 12                	je     8035fc <fd_close+0x5e>
		return (must_exist ? r : 0);
  8035ea:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  8035ee:	74 05                	je     8035f5 <fd_close+0x57>
  8035f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035f3:	eb 05                	jmp    8035fa <fd_close+0x5c>
  8035f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8035fa:	eb 69                	jmp    803665 <fd_close+0xc7>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8035fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803600:	8b 00                	mov    (%rax),%eax
  803602:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803606:	48 89 d6             	mov    %rdx,%rsi
  803609:	89 c7                	mov    %eax,%edi
  80360b:	48 b8 67 36 80 00 00 	movabs $0x803667,%rax
  803612:	00 00 00 
  803615:	ff d0                	callq  *%rax
  803617:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80361a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80361e:	78 2a                	js     80364a <fd_close+0xac>
		if (dev->dev_close)
  803620:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803624:	48 8b 40 20          	mov    0x20(%rax),%rax
  803628:	48 85 c0             	test   %rax,%rax
  80362b:	74 16                	je     803643 <fd_close+0xa5>
			r = (*dev->dev_close)(fd);
  80362d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803631:	48 8b 40 20          	mov    0x20(%rax),%rax
  803635:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803639:	48 89 d7             	mov    %rdx,%rdi
  80363c:	ff d0                	callq  *%rax
  80363e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803641:	eb 07                	jmp    80364a <fd_close+0xac>
		else
			r = 0;
  803643:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80364a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80364e:	48 89 c6             	mov    %rax,%rsi
  803651:	bf 00 00 00 00       	mov    $0x0,%edi
  803656:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  80365d:	00 00 00 
  803660:	ff d0                	callq  *%rax
	return r;
  803662:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803665:	c9                   	leaveq 
  803666:	c3                   	retq   

0000000000803667 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  803667:	55                   	push   %rbp
  803668:	48 89 e5             	mov    %rsp,%rbp
  80366b:	48 83 ec 20          	sub    $0x20,%rsp
  80366f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803672:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  803676:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80367d:	eb 41                	jmp    8036c0 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  80367f:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803686:	00 00 00 
  803689:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80368c:	48 63 d2             	movslq %edx,%rdx
  80368f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803693:	8b 00                	mov    (%rax),%eax
  803695:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803698:	75 22                	jne    8036bc <dev_lookup+0x55>
			*dev = devtab[i];
  80369a:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8036a1:	00 00 00 
  8036a4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8036a7:	48 63 d2             	movslq %edx,%rdx
  8036aa:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8036ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8036b2:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8036b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8036ba:	eb 60                	jmp    80371c <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8036bc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8036c0:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8036c7:	00 00 00 
  8036ca:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8036cd:	48 63 d2             	movslq %edx,%rdx
  8036d0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8036d4:	48 85 c0             	test   %rax,%rax
  8036d7:	75 a6                	jne    80367f <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8036d9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8036e0:	00 00 00 
  8036e3:	48 8b 00             	mov    (%rax),%rax
  8036e6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8036ec:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8036ef:	89 c6                	mov    %eax,%esi
  8036f1:	48 bf a0 12 82 00 00 	movabs $0x8212a0,%rdi
  8036f8:	00 00 00 
  8036fb:	b8 00 00 00 00       	mov    $0x0,%eax
  803700:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  803707:	00 00 00 
  80370a:	ff d1                	callq  *%rcx
	*dev = 0;
  80370c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803710:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  803717:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80371c:	c9                   	leaveq 
  80371d:	c3                   	retq   

000000000080371e <close>:

int
close(int fdnum)
{
  80371e:	55                   	push   %rbp
  80371f:	48 89 e5             	mov    %rsp,%rbp
  803722:	48 83 ec 20          	sub    $0x20,%rsp
  803726:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803729:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80372d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803730:	48 89 d6             	mov    %rdx,%rsi
  803733:	89 c7                	mov    %eax,%edi
  803735:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  80373c:	00 00 00 
  80373f:	ff d0                	callq  *%rax
  803741:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803744:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803748:	79 05                	jns    80374f <close+0x31>
		return r;
  80374a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80374d:	eb 18                	jmp    803767 <close+0x49>
	else
		return fd_close(fd, 1);
  80374f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803753:	be 01 00 00 00       	mov    $0x1,%esi
  803758:	48 89 c7             	mov    %rax,%rdi
  80375b:	48 b8 9e 35 80 00 00 	movabs $0x80359e,%rax
  803762:	00 00 00 
  803765:	ff d0                	callq  *%rax
}
  803767:	c9                   	leaveq 
  803768:	c3                   	retq   

0000000000803769 <close_all>:

void
close_all(void)
{
  803769:	55                   	push   %rbp
  80376a:	48 89 e5             	mov    %rsp,%rbp
  80376d:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803771:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803778:	eb 15                	jmp    80378f <close_all+0x26>
		close(i);
  80377a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80377d:	89 c7                	mov    %eax,%edi
  80377f:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  803786:	00 00 00 
  803789:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80378b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80378f:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  803793:	7e e5                	jle    80377a <close_all+0x11>
		close(i);
}
  803795:	c9                   	leaveq 
  803796:	c3                   	retq   

0000000000803797 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  803797:	55                   	push   %rbp
  803798:	48 89 e5             	mov    %rsp,%rbp
  80379b:	48 83 ec 40          	sub    $0x40,%rsp
  80379f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8037a2:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8037a5:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8037a9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8037ac:	48 89 d6             	mov    %rdx,%rsi
  8037af:	89 c7                	mov    %eax,%edi
  8037b1:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8037b8:	00 00 00 
  8037bb:	ff d0                	callq  *%rax
  8037bd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8037c0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8037c4:	79 08                	jns    8037ce <dup+0x37>
		return r;
  8037c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8037c9:	e9 70 01 00 00       	jmpq   80393e <dup+0x1a7>
	close(newfdnum);
  8037ce:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8037d1:	89 c7                	mov    %eax,%edi
  8037d3:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  8037da:	00 00 00 
  8037dd:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  8037df:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8037e2:	48 98                	cltq   
  8037e4:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8037ea:	48 c1 e0 0c          	shl    $0xc,%rax
  8037ee:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  8037f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8037f6:	48 89 c7             	mov    %rax,%rdi
  8037f9:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  803800:	00 00 00 
  803803:	ff d0                	callq  *%rax
  803805:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  803809:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80380d:	48 89 c7             	mov    %rax,%rdi
  803810:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  803817:	00 00 00 
  80381a:	ff d0                	callq  *%rax
  80381c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803820:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803824:	48 c1 e8 15          	shr    $0x15,%rax
  803828:	48 89 c2             	mov    %rax,%rdx
  80382b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803832:	01 00 00 
  803835:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803839:	83 e0 01             	and    $0x1,%eax
  80383c:	48 85 c0             	test   %rax,%rax
  80383f:	74 73                	je     8038b4 <dup+0x11d>
  803841:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803845:	48 c1 e8 0c          	shr    $0xc,%rax
  803849:	48 89 c2             	mov    %rax,%rdx
  80384c:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803853:	01 00 00 
  803856:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80385a:	83 e0 01             	and    $0x1,%eax
  80385d:	48 85 c0             	test   %rax,%rax
  803860:	74 52                	je     8038b4 <dup+0x11d>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803862:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803866:	48 c1 e8 0c          	shr    $0xc,%rax
  80386a:	48 89 c2             	mov    %rax,%rdx
  80386d:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803874:	01 00 00 
  803877:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80387b:	25 07 0e 00 00       	and    $0xe07,%eax
  803880:	89 c1                	mov    %eax,%ecx
  803882:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80388a:	41 89 c8             	mov    %ecx,%r8d
  80388d:	48 89 d1             	mov    %rdx,%rcx
  803890:	ba 00 00 00 00       	mov    $0x0,%edx
  803895:	48 89 c6             	mov    %rax,%rsi
  803898:	bf 00 00 00 00       	mov    $0x0,%edi
  80389d:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  8038a4:	00 00 00 
  8038a7:	ff d0                	callq  *%rax
  8038a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038b0:	79 02                	jns    8038b4 <dup+0x11d>
			goto err;
  8038b2:	eb 57                	jmp    80390b <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8038b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8038b8:	48 c1 e8 0c          	shr    $0xc,%rax
  8038bc:	48 89 c2             	mov    %rax,%rdx
  8038bf:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8038c6:	01 00 00 
  8038c9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8038cd:	25 07 0e 00 00       	and    $0xe07,%eax
  8038d2:	89 c1                	mov    %eax,%ecx
  8038d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8038d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8038dc:	41 89 c8             	mov    %ecx,%r8d
  8038df:	48 89 d1             	mov    %rdx,%rcx
  8038e2:	ba 00 00 00 00       	mov    $0x0,%edx
  8038e7:	48 89 c6             	mov    %rax,%rsi
  8038ea:	bf 00 00 00 00       	mov    $0x0,%edi
  8038ef:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  8038f6:	00 00 00 
  8038f9:	ff d0                	callq  *%rax
  8038fb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803902:	79 02                	jns    803906 <dup+0x16f>
		goto err;
  803904:	eb 05                	jmp    80390b <dup+0x174>

	return newfdnum;
  803906:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803909:	eb 33                	jmp    80393e <dup+0x1a7>

err:
	sys_page_unmap(0, newfd);
  80390b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80390f:	48 89 c6             	mov    %rax,%rsi
  803912:	bf 00 00 00 00       	mov    $0x0,%edi
  803917:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  80391e:	00 00 00 
  803921:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803923:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803927:	48 89 c6             	mov    %rax,%rsi
  80392a:	bf 00 00 00 00       	mov    $0x0,%edi
  80392f:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  803936:	00 00 00 
  803939:	ff d0                	callq  *%rax
	return r;
  80393b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80393e:	c9                   	leaveq 
  80393f:	c3                   	retq   

0000000000803940 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803940:	55                   	push   %rbp
  803941:	48 89 e5             	mov    %rsp,%rbp
  803944:	48 83 ec 40          	sub    $0x40,%rsp
  803948:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80394b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80394f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	//cprintf("Inside Read");
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803953:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803957:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80395a:	48 89 d6             	mov    %rdx,%rsi
  80395d:	89 c7                	mov    %eax,%edi
  80395f:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803966:	00 00 00 
  803969:	ff d0                	callq  *%rax
  80396b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80396e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803972:	78 24                	js     803998 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803978:	8b 00                	mov    (%rax),%eax
  80397a:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80397e:	48 89 d6             	mov    %rdx,%rsi
  803981:	89 c7                	mov    %eax,%edi
  803983:	48 b8 67 36 80 00 00 	movabs $0x803667,%rax
  80398a:	00 00 00 
  80398d:	ff d0                	callq  *%rax
  80398f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803992:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803996:	79 05                	jns    80399d <read+0x5d>
		return r;
  803998:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80399b:	eb 76                	jmp    803a13 <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80399d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039a1:	8b 40 08             	mov    0x8(%rax),%eax
  8039a4:	83 e0 03             	and    $0x3,%eax
  8039a7:	83 f8 01             	cmp    $0x1,%eax
  8039aa:	75 3a                	jne    8039e6 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8039ac:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8039b3:	00 00 00 
  8039b6:	48 8b 00             	mov    (%rax),%rax
  8039b9:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8039bf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8039c2:	89 c6                	mov    %eax,%esi
  8039c4:	48 bf bf 12 82 00 00 	movabs $0x8212bf,%rdi
  8039cb:	00 00 00 
  8039ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8039d3:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  8039da:	00 00 00 
  8039dd:	ff d1                	callq  *%rcx
		return -E_INVAL;
  8039df:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8039e4:	eb 2d                	jmp    803a13 <read+0xd3>
	}
	if (!dev->dev_read)
  8039e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8039ea:	48 8b 40 10          	mov    0x10(%rax),%rax
  8039ee:	48 85 c0             	test   %rax,%rax
  8039f1:	75 07                	jne    8039fa <read+0xba>
		return -E_NOT_SUPP;
  8039f3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  8039f8:	eb 19                	jmp    803a13 <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  8039fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8039fe:	48 8b 40 10          	mov    0x10(%rax),%rax
  803a02:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803a06:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803a0a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803a0e:	48 89 cf             	mov    %rcx,%rdi
  803a11:	ff d0                	callq  *%rax
}
  803a13:	c9                   	leaveq 
  803a14:	c3                   	retq   

0000000000803a15 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803a15:	55                   	push   %rbp
  803a16:	48 89 e5             	mov    %rsp,%rbp
  803a19:	48 83 ec 30          	sub    $0x30,%rsp
  803a1d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803a20:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803a24:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803a28:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803a2f:	eb 49                	jmp    803a7a <readn+0x65>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803a31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a34:	48 98                	cltq   
  803a36:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803a3a:	48 29 c2             	sub    %rax,%rdx
  803a3d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a40:	48 63 c8             	movslq %eax,%rcx
  803a43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803a47:	48 01 c1             	add    %rax,%rcx
  803a4a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803a4d:	48 89 ce             	mov    %rcx,%rsi
  803a50:	89 c7                	mov    %eax,%edi
  803a52:	48 b8 40 39 80 00 00 	movabs $0x803940,%rax
  803a59:	00 00 00 
  803a5c:	ff d0                	callq  *%rax
  803a5e:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803a61:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803a65:	79 05                	jns    803a6c <readn+0x57>
			return m;
  803a67:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a6a:	eb 1c                	jmp    803a88 <readn+0x73>
		if (m == 0)
  803a6c:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803a70:	75 02                	jne    803a74 <readn+0x5f>
			break;
  803a72:	eb 11                	jmp    803a85 <readn+0x70>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803a74:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a77:	01 45 fc             	add    %eax,-0x4(%rbp)
  803a7a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a7d:	48 98                	cltq   
  803a7f:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803a83:	72 ac                	jb     803a31 <readn+0x1c>
		if (m < 0)
			return m;
		if (m == 0)
			break;
	}
	return tot;
  803a85:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803a88:	c9                   	leaveq 
  803a89:	c3                   	retq   

0000000000803a8a <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  803a8a:	55                   	push   %rbp
  803a8b:	48 89 e5             	mov    %rsp,%rbp
  803a8e:	48 83 ec 40          	sub    $0x40,%rsp
  803a92:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803a95:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803a99:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803a9d:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803aa1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803aa4:	48 89 d6             	mov    %rdx,%rsi
  803aa7:	89 c7                	mov    %eax,%edi
  803aa9:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803ab0:	00 00 00 
  803ab3:	ff d0                	callq  *%rax
  803ab5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ab8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803abc:	78 24                	js     803ae2 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803abe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ac2:	8b 00                	mov    (%rax),%eax
  803ac4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803ac8:	48 89 d6             	mov    %rdx,%rsi
  803acb:	89 c7                	mov    %eax,%edi
  803acd:	48 b8 67 36 80 00 00 	movabs $0x803667,%rax
  803ad4:	00 00 00 
  803ad7:	ff d0                	callq  *%rax
  803ad9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803adc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ae0:	79 05                	jns    803ae7 <write+0x5d>
		return r;
  803ae2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ae5:	eb 75                	jmp    803b5c <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803ae7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803aeb:	8b 40 08             	mov    0x8(%rax),%eax
  803aee:	83 e0 03             	and    $0x3,%eax
  803af1:	85 c0                	test   %eax,%eax
  803af3:	75 3a                	jne    803b2f <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803af5:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803afc:	00 00 00 
  803aff:	48 8b 00             	mov    (%rax),%rax
  803b02:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803b08:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803b0b:	89 c6                	mov    %eax,%esi
  803b0d:	48 bf db 12 82 00 00 	movabs $0x8212db,%rdi
  803b14:	00 00 00 
  803b17:	b8 00 00 00 00       	mov    $0x0,%eax
  803b1c:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  803b23:	00 00 00 
  803b26:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803b28:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803b2d:	eb 2d                	jmp    803b5c <write+0xd2>
	{
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
		sys_cputs(buf, n);
	}
	if (!dev->dev_write)
  803b2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b33:	48 8b 40 18          	mov    0x18(%rax),%rax
  803b37:	48 85 c0             	test   %rax,%rax
  803b3a:	75 07                	jne    803b43 <write+0xb9>
		return -E_NOT_SUPP;
  803b3c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803b41:	eb 19                	jmp    803b5c <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803b43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b47:	48 8b 40 18          	mov    0x18(%rax),%rax
  803b4b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803b4f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803b53:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803b57:	48 89 cf             	mov    %rcx,%rdi
  803b5a:	ff d0                	callq  *%rax
}
  803b5c:	c9                   	leaveq 
  803b5d:	c3                   	retq   

0000000000803b5e <seek>:

int
seek(int fdnum, off_t offset)
{
  803b5e:	55                   	push   %rbp
  803b5f:	48 89 e5             	mov    %rsp,%rbp
  803b62:	48 83 ec 18          	sub    $0x18,%rsp
  803b66:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803b69:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803b6c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803b70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b73:	48 89 d6             	mov    %rdx,%rsi
  803b76:	89 c7                	mov    %eax,%edi
  803b78:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803b7f:	00 00 00 
  803b82:	ff d0                	callq  *%rax
  803b84:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b87:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b8b:	79 05                	jns    803b92 <seek+0x34>
		return r;
  803b8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b90:	eb 0f                	jmp    803ba1 <seek+0x43>
	fd->fd_offset = offset;
  803b92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b96:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803b99:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803b9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803ba1:	c9                   	leaveq 
  803ba2:	c3                   	retq   

0000000000803ba3 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803ba3:	55                   	push   %rbp
  803ba4:	48 89 e5             	mov    %rsp,%rbp
  803ba7:	48 83 ec 30          	sub    $0x30,%rsp
  803bab:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803bae:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803bb1:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803bb5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803bb8:	48 89 d6             	mov    %rdx,%rsi
  803bbb:	89 c7                	mov    %eax,%edi
  803bbd:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803bc4:	00 00 00 
  803bc7:	ff d0                	callq  *%rax
  803bc9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bcc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bd0:	78 24                	js     803bf6 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803bd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bd6:	8b 00                	mov    (%rax),%eax
  803bd8:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803bdc:	48 89 d6             	mov    %rdx,%rsi
  803bdf:	89 c7                	mov    %eax,%edi
  803be1:	48 b8 67 36 80 00 00 	movabs $0x803667,%rax
  803be8:	00 00 00 
  803beb:	ff d0                	callq  *%rax
  803bed:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bf0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bf4:	79 05                	jns    803bfb <ftruncate+0x58>
		return r;
  803bf6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bf9:	eb 72                	jmp    803c6d <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803bfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bff:	8b 40 08             	mov    0x8(%rax),%eax
  803c02:	83 e0 03             	and    $0x3,%eax
  803c05:	85 c0                	test   %eax,%eax
  803c07:	75 3a                	jne    803c43 <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803c09:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803c10:	00 00 00 
  803c13:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803c16:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803c1c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803c1f:	89 c6                	mov    %eax,%esi
  803c21:	48 bf f8 12 82 00 00 	movabs $0x8212f8,%rdi
  803c28:	00 00 00 
  803c2b:	b8 00 00 00 00       	mov    $0x0,%eax
  803c30:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  803c37:	00 00 00 
  803c3a:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803c3c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803c41:	eb 2a                	jmp    803c6d <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803c43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c47:	48 8b 40 30          	mov    0x30(%rax),%rax
  803c4b:	48 85 c0             	test   %rax,%rax
  803c4e:	75 07                	jne    803c57 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803c50:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803c55:	eb 16                	jmp    803c6d <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803c57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c5b:	48 8b 40 30          	mov    0x30(%rax),%rax
  803c5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803c63:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803c66:	89 ce                	mov    %ecx,%esi
  803c68:	48 89 d7             	mov    %rdx,%rdi
  803c6b:	ff d0                	callq  *%rax
}
  803c6d:	c9                   	leaveq 
  803c6e:	c3                   	retq   

0000000000803c6f <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803c6f:	55                   	push   %rbp
  803c70:	48 89 e5             	mov    %rsp,%rbp
  803c73:	48 83 ec 30          	sub    $0x30,%rsp
  803c77:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803c7a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803c7e:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803c82:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803c85:	48 89 d6             	mov    %rdx,%rsi
  803c88:	89 c7                	mov    %eax,%edi
  803c8a:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803c91:	00 00 00 
  803c94:	ff d0                	callq  *%rax
  803c96:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c99:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c9d:	78 24                	js     803cc3 <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803c9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ca3:	8b 00                	mov    (%rax),%eax
  803ca5:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803ca9:	48 89 d6             	mov    %rdx,%rsi
  803cac:	89 c7                	mov    %eax,%edi
  803cae:	48 b8 67 36 80 00 00 	movabs $0x803667,%rax
  803cb5:	00 00 00 
  803cb8:	ff d0                	callq  *%rax
  803cba:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803cbd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803cc1:	79 05                	jns    803cc8 <fstat+0x59>
		return r;
  803cc3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803cc6:	eb 5e                	jmp    803d26 <fstat+0xb7>
	if (!dev->dev_stat)
  803cc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ccc:	48 8b 40 28          	mov    0x28(%rax),%rax
  803cd0:	48 85 c0             	test   %rax,%rax
  803cd3:	75 07                	jne    803cdc <fstat+0x6d>
		return -E_NOT_SUPP;
  803cd5:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803cda:	eb 4a                	jmp    803d26 <fstat+0xb7>
	stat->st_name[0] = 0;
  803cdc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ce0:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803ce3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ce7:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803cee:	00 00 00 
	stat->st_isdir = 0;
  803cf1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803cf5:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803cfc:	00 00 00 
	stat->st_dev = dev;
  803cff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803d03:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803d07:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803d0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d12:	48 8b 40 28          	mov    0x28(%rax),%rax
  803d16:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803d1a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803d1e:	48 89 ce             	mov    %rcx,%rsi
  803d21:	48 89 d7             	mov    %rdx,%rdi
  803d24:	ff d0                	callq  *%rax
}
  803d26:	c9                   	leaveq 
  803d27:	c3                   	retq   

0000000000803d28 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803d28:	55                   	push   %rbp
  803d29:	48 89 e5             	mov    %rsp,%rbp
  803d2c:	48 83 ec 20          	sub    $0x20,%rsp
  803d30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803d34:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803d38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d3c:	be 00 00 00 00       	mov    $0x0,%esi
  803d41:	48 89 c7             	mov    %rax,%rdi
  803d44:	48 b8 16 3e 80 00 00 	movabs $0x803e16,%rax
  803d4b:	00 00 00 
  803d4e:	ff d0                	callq  *%rax
  803d50:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d53:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d57:	79 05                	jns    803d5e <stat+0x36>
		return fd;
  803d59:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d5c:	eb 2f                	jmp    803d8d <stat+0x65>
	r = fstat(fd, stat);
  803d5e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803d62:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d65:	48 89 d6             	mov    %rdx,%rsi
  803d68:	89 c7                	mov    %eax,%edi
  803d6a:	48 b8 6f 3c 80 00 00 	movabs $0x803c6f,%rax
  803d71:	00 00 00 
  803d74:	ff d0                	callq  *%rax
  803d76:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803d79:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d7c:	89 c7                	mov    %eax,%edi
  803d7e:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  803d85:	00 00 00 
  803d88:	ff d0                	callq  *%rax
	return r;
  803d8a:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803d8d:	c9                   	leaveq 
  803d8e:	c3                   	retq   

0000000000803d8f <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803d8f:	55                   	push   %rbp
  803d90:	48 89 e5             	mov    %rsp,%rbp
  803d93:	48 83 ec 10          	sub    $0x10,%rsp
  803d97:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803d9a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803d9e:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803da5:	00 00 00 
  803da8:	8b 00                	mov    (%rax),%eax
  803daa:	85 c0                	test   %eax,%eax
  803dac:	75 1d                	jne    803dcb <fsipc+0x3c>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803dae:	bf 01 00 00 00       	mov    $0x1,%edi
  803db3:	48 b8 a6 33 80 00 00 	movabs $0x8033a6,%rax
  803dba:	00 00 00 
  803dbd:	ff d0                	callq  *%rax
  803dbf:	48 ba 84 90 82 00 00 	movabs $0x829084,%rdx
  803dc6:	00 00 00 
  803dc9:	89 02                	mov    %eax,(%rdx)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803dcb:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803dd2:	00 00 00 
  803dd5:	8b 00                	mov    (%rax),%eax
  803dd7:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803dda:	b9 07 00 00 00       	mov    $0x7,%ecx
  803ddf:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803de6:	00 00 00 
  803de9:	89 c7                	mov    %eax,%edi
  803deb:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  803df2:	00 00 00 
  803df5:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803df7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dfb:	ba 00 00 00 00       	mov    $0x0,%edx
  803e00:	48 89 c6             	mov    %rax,%rsi
  803e03:	bf 00 00 00 00       	mov    $0x0,%edi
  803e08:	48 b8 3e 32 80 00 00 	movabs $0x80323e,%rax
  803e0f:	00 00 00 
  803e12:	ff d0                	callq  *%rax
}
  803e14:	c9                   	leaveq 
  803e15:	c3                   	retq   

0000000000803e16 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803e16:	55                   	push   %rbp
  803e17:	48 89 e5             	mov    %rsp,%rbp
  803e1a:	48 83 ec 30          	sub    $0x30,%rsp
  803e1e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  803e22:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	// Return the file descriptor index.
	// If any step after fd_alloc fails, use fd_close to free the
	// file descriptor.

	// LAB 5: Your code here
	int r = -1;
  803e25:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	int d = -1;
  803e2c:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%rbp)
	int len = 0;
  803e33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	void *va;
	if(!path)
  803e3a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803e3f:	75 08                	jne    803e49 <open+0x33>
	{
		return r;
  803e41:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e44:	e9 f2 00 00 00       	jmpq   803f3b <open+0x125>
	}	
	else if((len = strlen(path)) >= MAXPATHLEN) 
  803e49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803e4d:	48 89 c7             	mov    %rax,%rdi
  803e50:	48 b8 d0 1e 80 00 00 	movabs $0x801ed0,%rax
  803e57:	00 00 00 
  803e5a:	ff d0                	callq  *%rax
  803e5c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803e5f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%rbp)
  803e66:	7e 0a                	jle    803e72 <open+0x5c>
	{
		return -E_BAD_PATH;
  803e68:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803e6d:	e9 c9 00 00 00       	jmpq   803f3b <open+0x125>
	}
	else
	{
		struct Fd *fd_store = NULL;
  803e72:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  803e79:	00 
		if((r = fd_alloc(&fd_store)) < 0 || fd_store == NULL)
  803e7a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  803e7e:	48 89 c7             	mov    %rax,%rdi
  803e81:	48 b8 76 34 80 00 00 	movabs $0x803476,%rax
  803e88:	00 00 00 
  803e8b:	ff d0                	callq  *%rax
  803e8d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803e90:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e94:	78 09                	js     803e9f <open+0x89>
  803e96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e9a:	48 85 c0             	test   %rax,%rax
  803e9d:	75 08                	jne    803ea7 <open+0x91>
		{
			return r;
  803e9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ea2:	e9 94 00 00 00       	jmpq   803f3b <open+0x125>
		}	
		strncpy(fsipcbuf.open.req_path,  path, MAXPATHLEN);
  803ea7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803eab:	ba 00 04 00 00       	mov    $0x400,%edx
  803eb0:	48 89 c6             	mov    %rax,%rsi
  803eb3:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803eba:	00 00 00 
  803ebd:	48 b8 ce 1f 80 00 00 	movabs $0x801fce,%rax
  803ec4:	00 00 00 
  803ec7:	ff d0                	callq  *%rax
		fsipcbuf.open.req_omode = mode;
  803ec9:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803ed0:	00 00 00 
  803ed3:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  803ed6:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)
		if ((r = fsipc(FSREQ_OPEN, fd_store)) < 0)
  803edc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ee0:	48 89 c6             	mov    %rax,%rsi
  803ee3:	bf 01 00 00 00       	mov    $0x1,%edi
  803ee8:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  803eef:	00 00 00 
  803ef2:	ff d0                	callq  *%rax
  803ef4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ef7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803efb:	79 2b                	jns    803f28 <open+0x112>
		{
			if((d = fd_close(fd_store, 0)) < 0)
  803efd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f01:	be 00 00 00 00       	mov    $0x0,%esi
  803f06:	48 89 c7             	mov    %rax,%rdi
  803f09:	48 b8 9e 35 80 00 00 	movabs $0x80359e,%rax
  803f10:	00 00 00 
  803f13:	ff d0                	callq  *%rax
  803f15:	89 45 f8             	mov    %eax,-0x8(%rbp)
  803f18:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803f1c:	79 05                	jns    803f23 <open+0x10d>
			{
				return d;
  803f1e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803f21:	eb 18                	jmp    803f3b <open+0x125>
			}
			return r;
  803f23:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f26:	eb 13                	jmp    803f3b <open+0x125>
		}	
		return fd2num(fd_store);
  803f28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f2c:	48 89 c7             	mov    %rax,%rdi
  803f2f:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  803f36:	00 00 00 
  803f39:	ff d0                	callq  *%rax
	}
	//panic ("open not implemented");
}
  803f3b:	c9                   	leaveq 
  803f3c:	c3                   	retq   

0000000000803f3d <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803f3d:	55                   	push   %rbp
  803f3e:	48 89 e5             	mov    %rsp,%rbp
  803f41:	48 83 ec 10          	sub    $0x10,%rsp
  803f45:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  803f49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803f4d:	8b 50 0c             	mov    0xc(%rax),%edx
  803f50:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f57:	00 00 00 
  803f5a:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  803f5c:	be 00 00 00 00       	mov    $0x0,%esi
  803f61:	bf 06 00 00 00       	mov    $0x6,%edi
  803f66:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  803f6d:	00 00 00 
  803f70:	ff d0                	callq  *%rax
}
  803f72:	c9                   	leaveq 
  803f73:	c3                   	retq   

0000000000803f74 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  803f74:	55                   	push   %rbp
  803f75:	48 89 e5             	mov    %rsp,%rbp
  803f78:	48 83 ec 30          	sub    $0x30,%rsp
  803f7c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803f80:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803f84:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Make an FSREQ_READ request to the file system server after
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
	int r = 0;
  803f88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if(!fd || !buf)
  803f8f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803f94:	74 07                	je     803f9d <devfile_read+0x29>
  803f96:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803f9b:	75 07                	jne    803fa4 <devfile_read+0x30>
		return -E_INVAL;
  803f9d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803fa2:	eb 77                	jmp    80401b <devfile_read+0xa7>
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  803fa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803fa8:	8b 50 0c             	mov    0xc(%rax),%edx
  803fab:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fb2:	00 00 00 
  803fb5:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  803fb7:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fbe:	00 00 00 
  803fc1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803fc5:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) <= 0){
  803fc9:	be 00 00 00 00       	mov    $0x0,%esi
  803fce:	bf 03 00 00 00       	mov    $0x3,%edi
  803fd3:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  803fda:	00 00 00 
  803fdd:	ff d0                	callq  *%rax
  803fdf:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803fe2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803fe6:	7f 05                	jg     803fed <devfile_read+0x79>
		//cprintf("devfile_read r is [%d]\n",r);
		return r;
  803fe8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803feb:	eb 2e                	jmp    80401b <devfile_read+0xa7>
	}
	//cprintf("devfile_read %x %x %x %x\n",fsipcbuf.readRet.ret_buf[0], fsipcbuf.readRet.ret_buf[1], fsipcbuf.readRet.ret_buf[2], fsipcbuf.readRet.ret_buf[3]);
	memmove(buf, (char*)fsipcbuf.readRet.ret_buf, r);
  803fed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ff0:	48 63 d0             	movslq %eax,%rdx
  803ff3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803ff7:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803ffe:	00 00 00 
  804001:	48 89 c7             	mov    %rax,%rdi
  804004:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  80400b:	00 00 00 
  80400e:	ff d0                	callq  *%rax
	char* buf1 = (char*)buf;
  804010:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804014:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//cprintf("devfile_read ri is [%d] %x %x %x %x\n",r,buf1[0],buf1[1],buf1[2],buf1[3]);
	return r;
  804018:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("devfile_read not implemented");
}
  80401b:	c9                   	leaveq 
  80401c:	c3                   	retq   

000000000080401d <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80401d:	55                   	push   %rbp
  80401e:	48 89 e5             	mov    %rsp,%rbp
  804021:	48 83 ec 30          	sub    $0x30,%rsp
  804025:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804029:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80402d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	int r = -1;
  804031:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	if(!fd || !buf)
  804038:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80403d:	74 07                	je     804046 <devfile_write+0x29>
  80403f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  804044:	75 08                	jne    80404e <devfile_write+0x31>
		return r;
  804046:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804049:	e9 9a 00 00 00       	jmpq   8040e8 <devfile_write+0xcb>
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80404e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804052:	8b 50 0c             	mov    0xc(%rax),%edx
  804055:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80405c:	00 00 00 
  80405f:	89 10                	mov    %edx,(%rax)
	if(n > PGSIZE - (sizeof(int) + sizeof(size_t)))
  804061:	48 81 7d d8 f4 0f 00 	cmpq   $0xff4,-0x28(%rbp)
  804068:	00 
  804069:	76 08                	jbe    804073 <devfile_write+0x56>
	{
		n = PGSIZE - (sizeof(int) + sizeof(size_t));
  80406b:	48 c7 45 d8 f4 0f 00 	movq   $0xff4,-0x28(%rbp)
  804072:	00 
	}
	fsipcbuf.write.req_n = n;
  804073:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80407a:	00 00 00 
  80407d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804081:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	memmove((void*)fsipcbuf.write.req_buf, (void*)buf, n);
  804085:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804089:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80408d:	48 89 c6             	mov    %rax,%rsi
  804090:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  804097:	00 00 00 
  80409a:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8040a1:	00 00 00 
  8040a4:	ff d0                	callq  *%rax
	if ((r = fsipc(FSREQ_WRITE, NULL)) <= 0){
  8040a6:	be 00 00 00 00       	mov    $0x0,%esi
  8040ab:	bf 04 00 00 00       	mov    $0x4,%edi
  8040b0:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  8040b7:	00 00 00 
  8040ba:	ff d0                	callq  *%rax
  8040bc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8040bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8040c3:	7f 20                	jg     8040e5 <devfile_write+0xc8>
		cprintf("fsipc-FSREQ_WRITE returns 0");
  8040c5:	48 bf 1e 13 82 00 00 	movabs $0x82131e,%rdi
  8040cc:	00 00 00 
  8040cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8040d4:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8040db:	00 00 00 
  8040de:	ff d2                	callq  *%rdx
		return r;
  8040e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040e3:	eb 03                	jmp    8040e8 <devfile_write+0xcb>
	}
	return r;
  8040e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("devfile_write not implemented");
}
  8040e8:	c9                   	leaveq 
  8040e9:	c3                   	retq   

00000000008040ea <devfile_stat>:


static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8040ea:	55                   	push   %rbp
  8040eb:	48 89 e5             	mov    %rsp,%rbp
  8040ee:	48 83 ec 20          	sub    $0x20,%rsp
  8040f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8040f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8040fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8040fe:	8b 50 0c             	mov    0xc(%rax),%edx
  804101:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804108:	00 00 00 
  80410b:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80410d:	be 00 00 00 00       	mov    $0x0,%esi
  804112:	bf 05 00 00 00       	mov    $0x5,%edi
  804117:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  80411e:	00 00 00 
  804121:	ff d0                	callq  *%rax
  804123:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804126:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80412a:	79 05                	jns    804131 <devfile_stat+0x47>
		return r;
  80412c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80412f:	eb 56                	jmp    804187 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  804131:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804135:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  80413c:	00 00 00 
  80413f:	48 89 c7             	mov    %rax,%rdi
  804142:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  804149:	00 00 00 
  80414c:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  80414e:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804155:	00 00 00 
  804158:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  80415e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804162:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  804168:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80416f:	00 00 00 
  804172:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  804178:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80417c:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  804182:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804187:	c9                   	leaveq 
  804188:	c3                   	retq   

0000000000804189 <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  804189:	55                   	push   %rbp
  80418a:	48 89 e5             	mov    %rsp,%rbp
  80418d:	48 83 ec 10          	sub    $0x10,%rsp
  804191:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804195:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  804198:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80419c:	8b 50 0c             	mov    0xc(%rax),%edx
  80419f:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8041a6:	00 00 00 
  8041a9:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  8041ab:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8041b2:	00 00 00 
  8041b5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8041b8:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  8041bb:	be 00 00 00 00       	mov    $0x0,%esi
  8041c0:	bf 02 00 00 00       	mov    $0x2,%edi
  8041c5:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  8041cc:	00 00 00 
  8041cf:	ff d0                	callq  *%rax
}
  8041d1:	c9                   	leaveq 
  8041d2:	c3                   	retq   

00000000008041d3 <remove>:

// Delete a file
int
remove(const char *path)
{
  8041d3:	55                   	push   %rbp
  8041d4:	48 89 e5             	mov    %rsp,%rbp
  8041d7:	48 83 ec 10          	sub    $0x10,%rsp
  8041db:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  8041df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8041e3:	48 89 c7             	mov    %rax,%rdi
  8041e6:	48 b8 d0 1e 80 00 00 	movabs $0x801ed0,%rax
  8041ed:	00 00 00 
  8041f0:	ff d0                	callq  *%rax
  8041f2:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8041f7:	7e 07                	jle    804200 <remove+0x2d>
		return -E_BAD_PATH;
  8041f9:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  8041fe:	eb 33                	jmp    804233 <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  804200:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804204:	48 89 c6             	mov    %rax,%rsi
  804207:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  80420e:	00 00 00 
  804211:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  804218:	00 00 00 
  80421b:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  80421d:	be 00 00 00 00       	mov    $0x0,%esi
  804222:	bf 07 00 00 00       	mov    $0x7,%edi
  804227:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  80422e:	00 00 00 
  804231:	ff d0                	callq  *%rax
}
  804233:	c9                   	leaveq 
  804234:	c3                   	retq   

0000000000804235 <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  804235:	55                   	push   %rbp
  804236:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  804239:	be 00 00 00 00       	mov    $0x0,%esi
  80423e:	bf 08 00 00 00       	mov    $0x8,%edi
  804243:	48 b8 8f 3d 80 00 00 	movabs $0x803d8f,%rax
  80424a:	00 00 00 
  80424d:	ff d0                	callq  *%rax
}
  80424f:	5d                   	pop    %rbp
  804250:	c3                   	retq   

0000000000804251 <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  804251:	55                   	push   %rbp
  804252:	48 89 e5             	mov    %rsp,%rbp
  804255:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  80425c:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  804263:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  80426a:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  804271:	be 00 00 00 00       	mov    $0x0,%esi
  804276:	48 89 c7             	mov    %rax,%rdi
  804279:	48 b8 16 3e 80 00 00 	movabs $0x803e16,%rax
  804280:	00 00 00 
  804283:	ff d0                	callq  *%rax
  804285:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  804288:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80428c:	79 28                	jns    8042b6 <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  80428e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804291:	89 c6                	mov    %eax,%esi
  804293:	48 bf 3a 13 82 00 00 	movabs $0x82133a,%rdi
  80429a:	00 00 00 
  80429d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042a2:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8042a9:	00 00 00 
  8042ac:	ff d2                	callq  *%rdx
		return fd_src;
  8042ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042b1:	e9 74 01 00 00       	jmpq   80442a <copy+0x1d9>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  8042b6:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  8042bd:	be 01 01 00 00       	mov    $0x101,%esi
  8042c2:	48 89 c7             	mov    %rax,%rdi
  8042c5:	48 b8 16 3e 80 00 00 	movabs $0x803e16,%rax
  8042cc:	00 00 00 
  8042cf:	ff d0                	callq  *%rax
  8042d1:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  8042d4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8042d8:	79 39                	jns    804313 <copy+0xc2>
		cprintf("cp create dest  error:%e\n", fd_dest);
  8042da:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8042dd:	89 c6                	mov    %eax,%esi
  8042df:	48 bf 50 13 82 00 00 	movabs $0x821350,%rdi
  8042e6:	00 00 00 
  8042e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8042ee:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8042f5:	00 00 00 
  8042f8:	ff d2                	callq  *%rdx
		close(fd_src);
  8042fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042fd:	89 c7                	mov    %eax,%edi
  8042ff:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  804306:	00 00 00 
  804309:	ff d0                	callq  *%rax
		return fd_dest;
  80430b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80430e:	e9 17 01 00 00       	jmpq   80442a <copy+0x1d9>
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  804313:	eb 74                	jmp    804389 <copy+0x138>
		write_size = write(fd_dest, buffer, read_size);
  804315:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804318:	48 63 d0             	movslq %eax,%rdx
  80431b:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804322:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804325:	48 89 ce             	mov    %rcx,%rsi
  804328:	89 c7                	mov    %eax,%edi
  80432a:	48 b8 8a 3a 80 00 00 	movabs $0x803a8a,%rax
  804331:	00 00 00 
  804334:	ff d0                	callq  *%rax
  804336:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  804339:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80433d:	79 4a                	jns    804389 <copy+0x138>
			cprintf("cp write error:%e\n", write_size);
  80433f:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804342:	89 c6                	mov    %eax,%esi
  804344:	48 bf 6a 13 82 00 00 	movabs $0x82136a,%rdi
  80434b:	00 00 00 
  80434e:	b8 00 00 00 00       	mov    $0x0,%eax
  804353:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  80435a:	00 00 00 
  80435d:	ff d2                	callq  *%rdx
			close(fd_src);
  80435f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804362:	89 c7                	mov    %eax,%edi
  804364:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  80436b:	00 00 00 
  80436e:	ff d0                	callq  *%rax
			close(fd_dest);
  804370:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804373:	89 c7                	mov    %eax,%edi
  804375:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  80437c:	00 00 00 
  80437f:	ff d0                	callq  *%rax
			return write_size;
  804381:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804384:	e9 a1 00 00 00       	jmpq   80442a <copy+0x1d9>
		cprintf("cp create dest  error:%e\n", fd_dest);
		close(fd_src);
		return fd_dest;
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  804389:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804390:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804393:	ba 00 02 00 00       	mov    $0x200,%edx
  804398:	48 89 ce             	mov    %rcx,%rsi
  80439b:	89 c7                	mov    %eax,%edi
  80439d:	48 b8 40 39 80 00 00 	movabs $0x803940,%rax
  8043a4:	00 00 00 
  8043a7:	ff d0                	callq  *%rax
  8043a9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8043ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8043b0:	0f 8f 5f ff ff ff    	jg     804315 <copy+0xc4>
			close(fd_src);
			close(fd_dest);
			return write_size;
		}		
	}
	if (read_size < 0) {
  8043b6:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8043ba:	79 47                	jns    804403 <copy+0x1b2>
		cprintf("cp read src error:%e\n", read_size);
  8043bc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8043bf:	89 c6                	mov    %eax,%esi
  8043c1:	48 bf 7d 13 82 00 00 	movabs $0x82137d,%rdi
  8043c8:	00 00 00 
  8043cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8043d0:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8043d7:	00 00 00 
  8043da:	ff d2                	callq  *%rdx
		close(fd_src);
  8043dc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043df:	89 c7                	mov    %eax,%edi
  8043e1:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  8043e8:	00 00 00 
  8043eb:	ff d0                	callq  *%rax
		close(fd_dest);
  8043ed:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8043f0:	89 c7                	mov    %eax,%edi
  8043f2:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  8043f9:	00 00 00 
  8043fc:	ff d0                	callq  *%rax
		return read_size;
  8043fe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804401:	eb 27                	jmp    80442a <copy+0x1d9>
	}
	close(fd_src);
  804403:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804406:	89 c7                	mov    %eax,%edi
  804408:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  80440f:	00 00 00 
  804412:	ff d0                	callq  *%rax
	close(fd_dest);
  804414:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804417:	89 c7                	mov    %eax,%edi
  804419:	48 b8 1e 37 80 00 00 	movabs $0x80371e,%rax
  804420:	00 00 00 
  804423:	ff d0                	callq  *%rax
	return 0;
  804425:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  80442a:	c9                   	leaveq 
  80442b:	c3                   	retq   

000000000080442c <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80442c:	55                   	push   %rbp
  80442d:	48 89 e5             	mov    %rsp,%rbp
  804430:	48 83 ec 20          	sub    $0x20,%rsp
  804434:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  804437:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80443b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80443e:	48 89 d6             	mov    %rdx,%rsi
  804441:	89 c7                	mov    %eax,%edi
  804443:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  80444a:	00 00 00 
  80444d:	ff d0                	callq  *%rax
  80444f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804452:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804456:	79 05                	jns    80445d <fd2sockid+0x31>
		return r;
  804458:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80445b:	eb 24                	jmp    804481 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  80445d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804461:	8b 10                	mov    (%rax),%edx
  804463:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  80446a:	00 00 00 
  80446d:	8b 00                	mov    (%rax),%eax
  80446f:	39 c2                	cmp    %eax,%edx
  804471:	74 07                	je     80447a <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  804473:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  804478:	eb 07                	jmp    804481 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  80447a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80447e:	8b 40 0c             	mov    0xc(%rax),%eax
}
  804481:	c9                   	leaveq 
  804482:	c3                   	retq   

0000000000804483 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  804483:	55                   	push   %rbp
  804484:	48 89 e5             	mov    %rsp,%rbp
  804487:	48 83 ec 20          	sub    $0x20,%rsp
  80448b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80448e:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  804492:	48 89 c7             	mov    %rax,%rdi
  804495:	48 b8 76 34 80 00 00 	movabs $0x803476,%rax
  80449c:	00 00 00 
  80449f:	ff d0                	callq  *%rax
  8044a1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8044a4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8044a8:	78 26                	js     8044d0 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  8044aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8044ae:	ba 07 04 00 00       	mov    $0x407,%edx
  8044b3:	48 89 c6             	mov    %rax,%rsi
  8044b6:	bf 00 00 00 00       	mov    $0x0,%edi
  8044bb:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  8044c2:	00 00 00 
  8044c5:	ff d0                	callq  *%rax
  8044c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8044ca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8044ce:	79 16                	jns    8044e6 <alloc_sockfd+0x63>
		nsipc_close(sockid);
  8044d0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8044d3:	89 c7                	mov    %eax,%edi
  8044d5:	48 b8 90 49 80 00 00 	movabs $0x804990,%rax
  8044dc:	00 00 00 
  8044df:	ff d0                	callq  *%rax
		return r;
  8044e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044e4:	eb 3a                	jmp    804520 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  8044e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8044ea:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  8044f1:	00 00 00 
  8044f4:	8b 12                	mov    (%rdx),%edx
  8044f6:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  8044f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8044fc:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  804503:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804507:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80450a:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  80450d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804511:	48 89 c7             	mov    %rax,%rdi
  804514:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  80451b:	00 00 00 
  80451e:	ff d0                	callq  *%rax
}
  804520:	c9                   	leaveq 
  804521:	c3                   	retq   

0000000000804522 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804522:	55                   	push   %rbp
  804523:	48 89 e5             	mov    %rsp,%rbp
  804526:	48 83 ec 30          	sub    $0x30,%rsp
  80452a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80452d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804531:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804535:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804538:	89 c7                	mov    %eax,%edi
  80453a:	48 b8 2c 44 80 00 00 	movabs $0x80442c,%rax
  804541:	00 00 00 
  804544:	ff d0                	callq  *%rax
  804546:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804549:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80454d:	79 05                	jns    804554 <accept+0x32>
		return r;
  80454f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804552:	eb 3b                	jmp    80458f <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  804554:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804558:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80455c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80455f:	48 89 ce             	mov    %rcx,%rsi
  804562:	89 c7                	mov    %eax,%edi
  804564:	48 b8 6d 48 80 00 00 	movabs $0x80486d,%rax
  80456b:	00 00 00 
  80456e:	ff d0                	callq  *%rax
  804570:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804573:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804577:	79 05                	jns    80457e <accept+0x5c>
		return r;
  804579:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80457c:	eb 11                	jmp    80458f <accept+0x6d>
	return alloc_sockfd(r);
  80457e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804581:	89 c7                	mov    %eax,%edi
  804583:	48 b8 83 44 80 00 00 	movabs $0x804483,%rax
  80458a:	00 00 00 
  80458d:	ff d0                	callq  *%rax
}
  80458f:	c9                   	leaveq 
  804590:	c3                   	retq   

0000000000804591 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804591:	55                   	push   %rbp
  804592:	48 89 e5             	mov    %rsp,%rbp
  804595:	48 83 ec 20          	sub    $0x20,%rsp
  804599:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80459c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8045a0:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8045a3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8045a6:	89 c7                	mov    %eax,%edi
  8045a8:	48 b8 2c 44 80 00 00 	movabs $0x80442c,%rax
  8045af:	00 00 00 
  8045b2:	ff d0                	callq  *%rax
  8045b4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045b7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045bb:	79 05                	jns    8045c2 <bind+0x31>
		return r;
  8045bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045c0:	eb 1b                	jmp    8045dd <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  8045c2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8045c5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8045c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045cc:	48 89 ce             	mov    %rcx,%rsi
  8045cf:	89 c7                	mov    %eax,%edi
  8045d1:	48 b8 ec 48 80 00 00 	movabs $0x8048ec,%rax
  8045d8:	00 00 00 
  8045db:	ff d0                	callq  *%rax
}
  8045dd:	c9                   	leaveq 
  8045de:	c3                   	retq   

00000000008045df <shutdown>:

int
shutdown(int s, int how)
{
  8045df:	55                   	push   %rbp
  8045e0:	48 89 e5             	mov    %rsp,%rbp
  8045e3:	48 83 ec 20          	sub    $0x20,%rsp
  8045e7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8045ea:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8045ed:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8045f0:	89 c7                	mov    %eax,%edi
  8045f2:	48 b8 2c 44 80 00 00 	movabs $0x80442c,%rax
  8045f9:	00 00 00 
  8045fc:	ff d0                	callq  *%rax
  8045fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804601:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804605:	79 05                	jns    80460c <shutdown+0x2d>
		return r;
  804607:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80460a:	eb 16                	jmp    804622 <shutdown+0x43>
	return nsipc_shutdown(r, how);
  80460c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80460f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804612:	89 d6                	mov    %edx,%esi
  804614:	89 c7                	mov    %eax,%edi
  804616:	48 b8 50 49 80 00 00 	movabs $0x804950,%rax
  80461d:	00 00 00 
  804620:	ff d0                	callq  *%rax
}
  804622:	c9                   	leaveq 
  804623:	c3                   	retq   

0000000000804624 <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  804624:	55                   	push   %rbp
  804625:	48 89 e5             	mov    %rsp,%rbp
  804628:	48 83 ec 10          	sub    $0x10,%rsp
  80462c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804630:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804634:	48 89 c7             	mov    %rax,%rdi
  804637:	48 b8 7e 5b 80 00 00 	movabs $0x805b7e,%rax
  80463e:	00 00 00 
  804641:	ff d0                	callq  *%rax
  804643:	83 f8 01             	cmp    $0x1,%eax
  804646:	75 17                	jne    80465f <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  804648:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80464c:	8b 40 0c             	mov    0xc(%rax),%eax
  80464f:	89 c7                	mov    %eax,%edi
  804651:	48 b8 90 49 80 00 00 	movabs $0x804990,%rax
  804658:	00 00 00 
  80465b:	ff d0                	callq  *%rax
  80465d:	eb 05                	jmp    804664 <devsock_close+0x40>
	else
		return 0;
  80465f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804664:	c9                   	leaveq 
  804665:	c3                   	retq   

0000000000804666 <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804666:	55                   	push   %rbp
  804667:	48 89 e5             	mov    %rsp,%rbp
  80466a:	48 83 ec 20          	sub    $0x20,%rsp
  80466e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804671:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804675:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804678:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80467b:	89 c7                	mov    %eax,%edi
  80467d:	48 b8 2c 44 80 00 00 	movabs $0x80442c,%rax
  804684:	00 00 00 
  804687:	ff d0                	callq  *%rax
  804689:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80468c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804690:	79 05                	jns    804697 <connect+0x31>
		return r;
  804692:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804695:	eb 1b                	jmp    8046b2 <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  804697:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80469a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80469e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046a1:	48 89 ce             	mov    %rcx,%rsi
  8046a4:	89 c7                	mov    %eax,%edi
  8046a6:	48 b8 bd 49 80 00 00 	movabs $0x8049bd,%rax
  8046ad:	00 00 00 
  8046b0:	ff d0                	callq  *%rax
}
  8046b2:	c9                   	leaveq 
  8046b3:	c3                   	retq   

00000000008046b4 <listen>:

int
listen(int s, int backlog)
{
  8046b4:	55                   	push   %rbp
  8046b5:	48 89 e5             	mov    %rsp,%rbp
  8046b8:	48 83 ec 20          	sub    $0x20,%rsp
  8046bc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8046bf:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8046c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8046c5:	89 c7                	mov    %eax,%edi
  8046c7:	48 b8 2c 44 80 00 00 	movabs $0x80442c,%rax
  8046ce:	00 00 00 
  8046d1:	ff d0                	callq  *%rax
  8046d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8046d6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8046da:	79 05                	jns    8046e1 <listen+0x2d>
		return r;
  8046dc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046df:	eb 16                	jmp    8046f7 <listen+0x43>
	return nsipc_listen(r, backlog);
  8046e1:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8046e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046e7:	89 d6                	mov    %edx,%esi
  8046e9:	89 c7                	mov    %eax,%edi
  8046eb:	48 b8 21 4a 80 00 00 	movabs $0x804a21,%rax
  8046f2:	00 00 00 
  8046f5:	ff d0                	callq  *%rax
}
  8046f7:	c9                   	leaveq 
  8046f8:	c3                   	retq   

00000000008046f9 <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8046f9:	55                   	push   %rbp
  8046fa:	48 89 e5             	mov    %rsp,%rbp
  8046fd:	48 83 ec 20          	sub    $0x20,%rsp
  804701:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804705:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804709:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80470d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804711:	89 c2                	mov    %eax,%edx
  804713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804717:	8b 40 0c             	mov    0xc(%rax),%eax
  80471a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80471e:	b9 00 00 00 00       	mov    $0x0,%ecx
  804723:	89 c7                	mov    %eax,%edi
  804725:	48 b8 61 4a 80 00 00 	movabs $0x804a61,%rax
  80472c:	00 00 00 
  80472f:	ff d0                	callq  *%rax
}
  804731:	c9                   	leaveq 
  804732:	c3                   	retq   

0000000000804733 <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  804733:	55                   	push   %rbp
  804734:	48 89 e5             	mov    %rsp,%rbp
  804737:	48 83 ec 20          	sub    $0x20,%rsp
  80473b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80473f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804743:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  804747:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80474b:	89 c2                	mov    %eax,%edx
  80474d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804751:	8b 40 0c             	mov    0xc(%rax),%eax
  804754:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804758:	b9 00 00 00 00       	mov    $0x0,%ecx
  80475d:	89 c7                	mov    %eax,%edi
  80475f:	48 b8 2d 4b 80 00 00 	movabs $0x804b2d,%rax
  804766:	00 00 00 
  804769:	ff d0                	callq  *%rax
}
  80476b:	c9                   	leaveq 
  80476c:	c3                   	retq   

000000000080476d <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80476d:	55                   	push   %rbp
  80476e:	48 89 e5             	mov    %rsp,%rbp
  804771:	48 83 ec 10          	sub    $0x10,%rsp
  804775:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804779:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  80477d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804781:	48 be 98 13 82 00 00 	movabs $0x821398,%rsi
  804788:	00 00 00 
  80478b:	48 89 c7             	mov    %rax,%rdi
  80478e:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  804795:	00 00 00 
  804798:	ff d0                	callq  *%rax
	return 0;
  80479a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80479f:	c9                   	leaveq 
  8047a0:	c3                   	retq   

00000000008047a1 <socket>:

int
socket(int domain, int type, int protocol)
{
  8047a1:	55                   	push   %rbp
  8047a2:	48 89 e5             	mov    %rsp,%rbp
  8047a5:	48 83 ec 20          	sub    $0x20,%rsp
  8047a9:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8047ac:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8047af:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8047b2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8047b5:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  8047b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8047bb:	89 ce                	mov    %ecx,%esi
  8047bd:	89 c7                	mov    %eax,%edi
  8047bf:	48 b8 e5 4b 80 00 00 	movabs $0x804be5,%rax
  8047c6:	00 00 00 
  8047c9:	ff d0                	callq  *%rax
  8047cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8047ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8047d2:	79 05                	jns    8047d9 <socket+0x38>
		return r;
  8047d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047d7:	eb 11                	jmp    8047ea <socket+0x49>
	return alloc_sockfd(r);
  8047d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047dc:	89 c7                	mov    %eax,%edi
  8047de:	48 b8 83 44 80 00 00 	movabs $0x804483,%rax
  8047e5:	00 00 00 
  8047e8:	ff d0                	callq  *%rax
}
  8047ea:	c9                   	leaveq 
  8047eb:	c3                   	retq   

00000000008047ec <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8047ec:	55                   	push   %rbp
  8047ed:	48 89 e5             	mov    %rsp,%rbp
  8047f0:	48 83 ec 10          	sub    $0x10,%rsp
  8047f4:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  8047f7:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  8047fe:	00 00 00 
  804801:	8b 00                	mov    (%rax),%eax
  804803:	85 c0                	test   %eax,%eax
  804805:	75 1d                	jne    804824 <nsipc+0x38>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  804807:	bf 02 00 00 00       	mov    $0x2,%edi
  80480c:	48 b8 a6 33 80 00 00 	movabs $0x8033a6,%rax
  804813:	00 00 00 
  804816:	ff d0                	callq  *%rax
  804818:	48 ba 88 90 82 00 00 	movabs $0x829088,%rdx
  80481f:	00 00 00 
  804822:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  804824:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  80482b:	00 00 00 
  80482e:	8b 00                	mov    (%rax),%eax
  804830:	8b 75 fc             	mov    -0x4(%rbp),%esi
  804833:	b9 07 00 00 00       	mov    $0x7,%ecx
  804838:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  80483f:	00 00 00 
  804842:	89 c7                	mov    %eax,%edi
  804844:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  80484b:	00 00 00 
  80484e:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804850:	ba 00 00 00 00       	mov    $0x0,%edx
  804855:	be 00 00 00 00       	mov    $0x0,%esi
  80485a:	bf 00 00 00 00       	mov    $0x0,%edi
  80485f:	48 b8 3e 32 80 00 00 	movabs $0x80323e,%rax
  804866:	00 00 00 
  804869:	ff d0                	callq  *%rax
}
  80486b:	c9                   	leaveq 
  80486c:	c3                   	retq   

000000000080486d <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80486d:	55                   	push   %rbp
  80486e:	48 89 e5             	mov    %rsp,%rbp
  804871:	48 83 ec 30          	sub    $0x30,%rsp
  804875:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804878:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80487c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  804880:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804887:	00 00 00 
  80488a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80488d:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80488f:	bf 01 00 00 00       	mov    $0x1,%edi
  804894:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  80489b:	00 00 00 
  80489e:	ff d0                	callq  *%rax
  8048a0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8048a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8048a7:	78 3e                	js     8048e7 <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  8048a9:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8048b0:	00 00 00 
  8048b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8048b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8048bb:	8b 40 10             	mov    0x10(%rax),%eax
  8048be:	89 c2                	mov    %eax,%edx
  8048c0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8048c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8048c8:	48 89 ce             	mov    %rcx,%rsi
  8048cb:	48 89 c7             	mov    %rax,%rdi
  8048ce:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8048d5:	00 00 00 
  8048d8:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  8048da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8048de:	8b 50 10             	mov    0x10(%rax),%edx
  8048e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8048e5:	89 10                	mov    %edx,(%rax)
	}
	return r;
  8048e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8048ea:	c9                   	leaveq 
  8048eb:	c3                   	retq   

00000000008048ec <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8048ec:	55                   	push   %rbp
  8048ed:	48 89 e5             	mov    %rsp,%rbp
  8048f0:	48 83 ec 10          	sub    $0x10,%rsp
  8048f4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8048f7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8048fb:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  8048fe:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804905:	00 00 00 
  804908:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80490b:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80490d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804910:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804914:	48 89 c6             	mov    %rax,%rsi
  804917:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  80491e:	00 00 00 
  804921:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  804928:	00 00 00 
  80492b:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  80492d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804934:	00 00 00 
  804937:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80493a:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  80493d:	bf 02 00 00 00       	mov    $0x2,%edi
  804942:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804949:	00 00 00 
  80494c:	ff d0                	callq  *%rax
}
  80494e:	c9                   	leaveq 
  80494f:	c3                   	retq   

0000000000804950 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804950:	55                   	push   %rbp
  804951:	48 89 e5             	mov    %rsp,%rbp
  804954:	48 83 ec 10          	sub    $0x10,%rsp
  804958:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80495b:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  80495e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804965:	00 00 00 
  804968:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80496b:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  80496d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804974:	00 00 00 
  804977:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80497a:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  80497d:	bf 03 00 00 00       	mov    $0x3,%edi
  804982:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804989:	00 00 00 
  80498c:	ff d0                	callq  *%rax
}
  80498e:	c9                   	leaveq 
  80498f:	c3                   	retq   

0000000000804990 <nsipc_close>:

int
nsipc_close(int s)
{
  804990:	55                   	push   %rbp
  804991:	48 89 e5             	mov    %rsp,%rbp
  804994:	48 83 ec 10          	sub    $0x10,%rsp
  804998:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  80499b:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049a2:	00 00 00 
  8049a5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8049a8:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  8049aa:	bf 04 00 00 00       	mov    $0x4,%edi
  8049af:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  8049b6:	00 00 00 
  8049b9:	ff d0                	callq  *%rax
}
  8049bb:	c9                   	leaveq 
  8049bc:	c3                   	retq   

00000000008049bd <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8049bd:	55                   	push   %rbp
  8049be:	48 89 e5             	mov    %rsp,%rbp
  8049c1:	48 83 ec 10          	sub    $0x10,%rsp
  8049c5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8049c8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8049cc:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  8049cf:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049d6:	00 00 00 
  8049d9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8049dc:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8049de:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8049e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8049e5:	48 89 c6             	mov    %rax,%rsi
  8049e8:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  8049ef:	00 00 00 
  8049f2:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8049f9:	00 00 00 
  8049fc:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  8049fe:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a05:	00 00 00 
  804a08:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a0b:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804a0e:	bf 05 00 00 00       	mov    $0x5,%edi
  804a13:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804a1a:	00 00 00 
  804a1d:	ff d0                	callq  *%rax
}
  804a1f:	c9                   	leaveq 
  804a20:	c3                   	retq   

0000000000804a21 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804a21:	55                   	push   %rbp
  804a22:	48 89 e5             	mov    %rsp,%rbp
  804a25:	48 83 ec 10          	sub    $0x10,%rsp
  804a29:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804a2c:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804a2f:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a36:	00 00 00 
  804a39:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804a3c:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804a3e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a45:	00 00 00 
  804a48:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a4b:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804a4e:	bf 06 00 00 00       	mov    $0x6,%edi
  804a53:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804a5a:	00 00 00 
  804a5d:	ff d0                	callq  *%rax
}
  804a5f:	c9                   	leaveq 
  804a60:	c3                   	retq   

0000000000804a61 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804a61:	55                   	push   %rbp
  804a62:	48 89 e5             	mov    %rsp,%rbp
  804a65:	48 83 ec 30          	sub    $0x30,%rsp
  804a69:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804a6c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804a70:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804a73:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  804a76:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a7d:	00 00 00 
  804a80:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804a83:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804a85:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a8c:	00 00 00 
  804a8f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804a92:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804a95:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a9c:	00 00 00 
  804a9f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804aa2:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804aa5:	bf 07 00 00 00       	mov    $0x7,%edi
  804aaa:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804ab1:	00 00 00 
  804ab4:	ff d0                	callq  *%rax
  804ab6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804ab9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804abd:	78 69                	js     804b28 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  804abf:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  804ac6:	7f 08                	jg     804ad0 <nsipc_recv+0x6f>
  804ac8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804acb:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804ace:	7e 35                	jle    804b05 <nsipc_recv+0xa4>
  804ad0:	48 b9 9f 13 82 00 00 	movabs $0x82139f,%rcx
  804ad7:	00 00 00 
  804ada:	48 ba b4 13 82 00 00 	movabs $0x8213b4,%rdx
  804ae1:	00 00 00 
  804ae4:	be 61 00 00 00       	mov    $0x61,%esi
  804ae9:	48 bf c9 13 82 00 00 	movabs $0x8213c9,%rdi
  804af0:	00 00 00 
  804af3:	b8 00 00 00 00       	mov    $0x0,%eax
  804af8:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  804aff:	00 00 00 
  804b02:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  804b05:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804b08:	48 63 d0             	movslq %eax,%rdx
  804b0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804b0f:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  804b16:	00 00 00 
  804b19:	48 89 c7             	mov    %rax,%rdi
  804b1c:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  804b23:	00 00 00 
  804b26:	ff d0                	callq  *%rax
	}

	return r;
  804b28:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804b2b:	c9                   	leaveq 
  804b2c:	c3                   	retq   

0000000000804b2d <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804b2d:	55                   	push   %rbp
  804b2e:	48 89 e5             	mov    %rsp,%rbp
  804b31:	48 83 ec 20          	sub    $0x20,%rsp
  804b35:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b38:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804b3c:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804b3f:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804b42:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b49:	00 00 00 
  804b4c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b4f:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804b51:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804b58:	7e 35                	jle    804b8f <nsipc_send+0x62>
  804b5a:	48 b9 d5 13 82 00 00 	movabs $0x8213d5,%rcx
  804b61:	00 00 00 
  804b64:	48 ba b4 13 82 00 00 	movabs $0x8213b4,%rdx
  804b6b:	00 00 00 
  804b6e:	be 6c 00 00 00       	mov    $0x6c,%esi
  804b73:	48 bf c9 13 82 00 00 	movabs $0x8213c9,%rdi
  804b7a:	00 00 00 
  804b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  804b82:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  804b89:	00 00 00 
  804b8c:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804b8f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804b92:	48 63 d0             	movslq %eax,%rdx
  804b95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804b99:	48 89 c6             	mov    %rax,%rsi
  804b9c:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804ba3:	00 00 00 
  804ba6:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  804bad:	00 00 00 
  804bb0:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  804bb2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bb9:	00 00 00 
  804bbc:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804bbf:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  804bc2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bc9:	00 00 00 
  804bcc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804bcf:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  804bd2:	bf 08 00 00 00       	mov    $0x8,%edi
  804bd7:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804bde:	00 00 00 
  804be1:	ff d0                	callq  *%rax
}
  804be3:	c9                   	leaveq 
  804be4:	c3                   	retq   

0000000000804be5 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804be5:	55                   	push   %rbp
  804be6:	48 89 e5             	mov    %rsp,%rbp
  804be9:	48 83 ec 10          	sub    $0x10,%rsp
  804bed:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804bf0:	89 75 f8             	mov    %esi,-0x8(%rbp)
  804bf3:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  804bf6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bfd:	00 00 00 
  804c00:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804c03:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  804c05:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c0c:	00 00 00 
  804c0f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804c12:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804c15:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c1c:	00 00 00 
  804c1f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804c22:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804c25:	bf 09 00 00 00       	mov    $0x9,%edi
  804c2a:	48 b8 ec 47 80 00 00 	movabs $0x8047ec,%rax
  804c31:	00 00 00 
  804c34:	ff d0                	callq  *%rax
}
  804c36:	c9                   	leaveq 
  804c37:	c3                   	retq   

0000000000804c38 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804c38:	55                   	push   %rbp
  804c39:	48 89 e5             	mov    %rsp,%rbp
  804c3c:	48 83 ec 20          	sub    $0x20,%rsp
  804c40:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804c44:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804c48:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804c4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804c50:	48 01 d0             	add    %rdx,%rax
  804c53:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804c57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804c5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804c5f:	eb 64                	jmp    804cc5 <isfree+0x8d>
		if (va >= (uintptr_t) mend
  804c61:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804c68:	00 00 00 
  804c6b:	48 8b 00             	mov    (%rax),%rax
  804c6e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804c72:	76 42                	jbe    804cb6 <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804c74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804c78:	48 c1 e8 15          	shr    $0x15,%rax
  804c7c:	48 89 c2             	mov    %rax,%rdx
  804c7f:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804c86:	01 00 00 
  804c89:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804c8d:	83 e0 01             	and    $0x1,%eax
  804c90:	48 85 c0             	test   %rax,%rax
  804c93:	74 28                	je     804cbd <isfree+0x85>
  804c95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804c99:	48 c1 e8 0c          	shr    $0xc,%rax
  804c9d:	48 89 c2             	mov    %rax,%rdx
  804ca0:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804ca7:	01 00 00 
  804caa:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804cae:	83 e0 01             	and    $0x1,%eax
  804cb1:	48 85 c0             	test   %rax,%rax
  804cb4:	74 07                	je     804cbd <isfree+0x85>
			return 0;
  804cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  804cbb:	eb 17                	jmp    804cd4 <isfree+0x9c>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804cbd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804cc4:	00 
  804cc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804cc9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804ccd:	72 92                	jb     804c61 <isfree+0x29>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804ccf:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804cd4:	c9                   	leaveq 
  804cd5:	c3                   	retq   

0000000000804cd6 <malloc>:

void*
malloc(size_t n)
{
  804cd6:	55                   	push   %rbp
  804cd7:	48 89 e5             	mov    %rsp,%rbp
  804cda:	48 83 ec 60          	sub    $0x60,%rsp
  804cde:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804ce2:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ce9:	00 00 00 
  804cec:	48 8b 00             	mov    (%rax),%rax
  804cef:	48 85 c0             	test   %rax,%rax
  804cf2:	75 1a                	jne    804d0e <malloc+0x38>
		mptr = mbegin;
  804cf4:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804cfb:	00 00 00 
  804cfe:	48 8b 10             	mov    (%rax),%rdx
  804d01:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d08:	00 00 00 
  804d0b:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804d0e:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804d15:	00 
  804d16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804d1a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804d1e:	48 01 d0             	add    %rdx,%rax
  804d21:	48 83 e8 01          	sub    $0x1,%rax
  804d25:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804d29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804d2d:	ba 00 00 00 00       	mov    $0x0,%edx
  804d32:	48 f7 75 f0          	divq   -0x10(%rbp)
  804d36:	48 89 d0             	mov    %rdx,%rax
  804d39:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804d3d:	48 29 c2             	sub    %rax,%rdx
  804d40:	48 89 d0             	mov    %rdx,%rax
  804d43:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  804d47:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804d4e:	00 
  804d4f:	76 0a                	jbe    804d5b <malloc+0x85>
		return 0;
  804d51:	b8 00 00 00 00       	mov    $0x0,%eax
  804d56:	e9 f7 02 00 00       	jmpq   805052 <malloc+0x37c>

	if ((uintptr_t) mptr % PGSIZE){
  804d5b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d62:	00 00 00 
  804d65:	48 8b 00             	mov    (%rax),%rax
  804d68:	25 ff 0f 00 00       	and    $0xfff,%eax
  804d6d:	48 85 c0             	test   %rax,%rax
  804d70:	0f 84 15 01 00 00    	je     804e8b <malloc+0x1b5>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804d76:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804d7d:	00 
  804d7e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d85:	00 00 00 
  804d88:	48 8b 00             	mov    (%rax),%rax
  804d8b:	48 89 c2             	mov    %rax,%rdx
  804d8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d92:	48 01 d0             	add    %rdx,%rax
  804d95:	48 83 e8 01          	sub    $0x1,%rax
  804d99:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804d9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804da1:	ba 00 00 00 00       	mov    $0x0,%edx
  804da6:	48 f7 75 e0          	divq   -0x20(%rbp)
  804daa:	48 89 d0             	mov    %rdx,%rax
  804dad:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804db1:	48 29 c2             	sub    %rax,%rdx
  804db4:	48 89 d0             	mov    %rdx,%rax
  804db7:	48 83 e8 04          	sub    $0x4,%rax
  804dbb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804dbf:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804dc6:	00 00 00 
  804dc9:	48 8b 00             	mov    (%rax),%rax
  804dcc:	48 c1 e8 0c          	shr    $0xc,%rax
  804dd0:	48 89 c1             	mov    %rax,%rcx
  804dd3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804dda:	00 00 00 
  804ddd:	48 8b 00             	mov    (%rax),%rax
  804de0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804de4:	48 83 c2 03          	add    $0x3,%rdx
  804de8:	48 01 d0             	add    %rdx,%rax
  804deb:	48 c1 e8 0c          	shr    $0xc,%rax
  804def:	48 39 c1             	cmp    %rax,%rcx
  804df2:	75 4a                	jne    804e3e <malloc+0x168>
			(*ref)++;
  804df4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804df8:	8b 00                	mov    (%rax),%eax
  804dfa:	8d 50 01             	lea    0x1(%rax),%edx
  804dfd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804e01:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804e03:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e0a:	00 00 00 
  804e0d:	48 8b 00             	mov    (%rax),%rax
  804e10:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804e14:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e1b:	00 00 00 
  804e1e:	48 8b 10             	mov    (%rax),%rdx
  804e21:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804e25:	48 01 c2             	add    %rax,%rdx
  804e28:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e2f:	00 00 00 
  804e32:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804e35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804e39:	e9 14 02 00 00       	jmpq   805052 <malloc+0x37c>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804e3e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e45:	00 00 00 
  804e48:	48 8b 00             	mov    (%rax),%rax
  804e4b:	48 89 c7             	mov    %rax,%rdi
  804e4e:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  804e55:	00 00 00 
  804e58:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804e5a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e61:	00 00 00 
  804e64:	48 8b 00             	mov    (%rax),%rax
  804e67:	48 05 00 10 00 00    	add    $0x1000,%rax
  804e6d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804e71:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804e75:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804e7b:	48 89 c2             	mov    %rax,%rdx
  804e7e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e85:	00 00 00 
  804e88:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804e8b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  804e92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804e96:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804e9a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ea1:	00 00 00 
  804ea4:	48 8b 00             	mov    (%rax),%rax
  804ea7:	48 89 d6             	mov    %rdx,%rsi
  804eaa:	48 89 c7             	mov    %rax,%rdi
  804ead:	48 b8 38 4c 80 00 00 	movabs $0x804c38,%rax
  804eb4:	00 00 00 
  804eb7:	ff d0                	callq  *%rax
  804eb9:	85 c0                	test   %eax,%eax
  804ebb:	74 0d                	je     804eca <malloc+0x1f4>
			break;
  804ebd:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804ebe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804ec5:	e9 14 01 00 00       	jmpq   804fde <malloc+0x308>
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
  804eca:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ed1:	00 00 00 
  804ed4:	48 8b 00             	mov    (%rax),%rax
  804ed7:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  804ede:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ee5:	00 00 00 
  804ee8:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  804eeb:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ef2:	00 00 00 
  804ef5:	48 8b 10             	mov    (%rax),%rdx
  804ef8:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804eff:	00 00 00 
  804f02:	48 8b 00             	mov    (%rax),%rax
  804f05:	48 39 c2             	cmp    %rax,%rdx
  804f08:	75 2e                	jne    804f38 <malloc+0x262>
			mptr = mbegin;
  804f0a:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804f11:	00 00 00 
  804f14:	48 8b 10             	mov    (%rax),%rdx
  804f17:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f1e:	00 00 00 
  804f21:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804f24:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804f28:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  804f2c:	75 0a                	jne    804f38 <malloc+0x262>
				return 0;	/* out of address space */
  804f2e:	b8 00 00 00 00       	mov    $0x0,%eax
  804f33:	e9 1a 01 00 00       	jmpq   805052 <malloc+0x37c>
		}
	}
  804f38:	e9 55 ff ff ff       	jmpq   804e92 <malloc+0x1bc>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  804f3d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804f40:	05 00 10 00 00       	add    $0x1000,%eax
  804f45:	48 98                	cltq   
  804f47:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804f4b:	48 83 c2 04          	add    $0x4,%rdx
  804f4f:	48 39 d0             	cmp    %rdx,%rax
  804f52:	73 07                	jae    804f5b <malloc+0x285>
  804f54:	b8 00 04 00 00       	mov    $0x400,%eax
  804f59:	eb 05                	jmp    804f60 <malloc+0x28a>
  804f5b:	b8 00 00 00 00       	mov    $0x0,%eax
  804f60:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  804f63:	8b 45 bc             	mov    -0x44(%rbp),%eax
  804f66:	83 c8 07             	or     $0x7,%eax
  804f69:	89 c2                	mov    %eax,%edx
  804f6b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f72:	00 00 00 
  804f75:	48 8b 08             	mov    (%rax),%rcx
  804f78:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804f7b:	48 98                	cltq   
  804f7d:	48 01 c8             	add    %rcx,%rax
  804f80:	48 89 c6             	mov    %rax,%rsi
  804f83:	bf 00 00 00 00       	mov    $0x0,%edi
  804f88:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  804f8f:	00 00 00 
  804f92:	ff d0                	callq  *%rax
  804f94:	85 c0                	test   %eax,%eax
  804f96:	79 3f                	jns    804fd7 <malloc+0x301>
			for (; i >= 0; i -= PGSIZE)
  804f98:	eb 30                	jmp    804fca <malloc+0x2f4>
				sys_page_unmap(0, mptr + i);
  804f9a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fa1:	00 00 00 
  804fa4:	48 8b 10             	mov    (%rax),%rdx
  804fa7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804faa:	48 98                	cltq   
  804fac:	48 01 d0             	add    %rdx,%rax
  804faf:	48 89 c6             	mov    %rax,%rsi
  804fb2:	bf 00 00 00 00       	mov    $0x0,%edi
  804fb7:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  804fbe:	00 00 00 
  804fc1:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  804fc3:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  804fca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804fce:	79 ca                	jns    804f9a <malloc+0x2c4>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  804fd0:	b8 00 00 00 00       	mov    $0x0,%eax
  804fd5:	eb 7b                	jmp    805052 <malloc+0x37c>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804fd7:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  804fde:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804fe1:	48 98                	cltq   
  804fe3:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804fe7:	48 83 c2 04          	add    $0x4,%rdx
  804feb:	48 39 d0             	cmp    %rdx,%rax
  804fee:	0f 82 49 ff ff ff    	jb     804f3d <malloc+0x267>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  804ff4:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ffb:	00 00 00 
  804ffe:	48 8b 00             	mov    (%rax),%rax
  805001:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805004:	48 63 d2             	movslq %edx,%rdx
  805007:	48 83 ea 04          	sub    $0x4,%rdx
  80500b:	48 01 d0             	add    %rdx,%rax
  80500e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  805012:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805016:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  80501c:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805023:	00 00 00 
  805026:	48 8b 00             	mov    (%rax),%rax
  805029:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  80502d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805034:	00 00 00 
  805037:	48 8b 10             	mov    (%rax),%rdx
  80503a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80503e:	48 01 c2             	add    %rax,%rdx
  805041:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805048:	00 00 00 
  80504b:	48 89 10             	mov    %rdx,(%rax)
	return v;
  80504e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  805052:	c9                   	leaveq 
  805053:	c3                   	retq   

0000000000805054 <free>:

void
free(void *v)
{
  805054:	55                   	push   %rbp
  805055:	48 89 e5             	mov    %rsp,%rbp
  805058:	48 83 ec 30          	sub    $0x30,%rsp
  80505c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  805060:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805065:	75 05                	jne    80506c <free+0x18>
		return;
  805067:	e9 54 01 00 00       	jmpq   8051c0 <free+0x16c>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  80506c:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  805073:	00 00 00 
  805076:	48 8b 00             	mov    (%rax),%rax
  805079:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80507d:	77 13                	ja     805092 <free+0x3e>
  80507f:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805086:	00 00 00 
  805089:	48 8b 00             	mov    (%rax),%rax
  80508c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  805090:	72 35                	jb     8050c7 <free+0x73>
  805092:	48 b9 e8 13 82 00 00 	movabs $0x8213e8,%rcx
  805099:	00 00 00 
  80509c:	48 ba 16 14 82 00 00 	movabs $0x821416,%rdx
  8050a3:	00 00 00 
  8050a6:	be 7a 00 00 00       	mov    $0x7a,%esi
  8050ab:	48 bf 2b 14 82 00 00 	movabs $0x82142b,%rdi
  8050b2:	00 00 00 
  8050b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8050ba:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8050c1:	00 00 00 
  8050c4:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  8050c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8050cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8050cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050d3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8050d9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8050dd:	eb 7b                	jmp    80515a <free+0x106>
		sys_page_unmap(0, c);
  8050df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8050e3:	48 89 c6             	mov    %rax,%rsi
  8050e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8050eb:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8050f2:	00 00 00 
  8050f5:	ff d0                	callq  *%rax
		c += PGSIZE;
  8050f7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8050fe:	00 
		assert(mbegin <= c && c < mend);
  8050ff:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  805106:	00 00 00 
  805109:	48 8b 00             	mov    (%rax),%rax
  80510c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  805110:	77 13                	ja     805125 <free+0xd1>
  805112:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805119:	00 00 00 
  80511c:	48 8b 00             	mov    (%rax),%rax
  80511f:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  805123:	72 35                	jb     80515a <free+0x106>
  805125:	48 b9 38 14 82 00 00 	movabs $0x821438,%rcx
  80512c:	00 00 00 
  80512f:	48 ba 16 14 82 00 00 	movabs $0x821416,%rdx
  805136:	00 00 00 
  805139:	be 81 00 00 00       	mov    $0x81,%esi
  80513e:	48 bf 2b 14 82 00 00 	movabs $0x82142b,%rdi
  805145:	00 00 00 
  805148:	b8 00 00 00 00       	mov    $0x0,%eax
  80514d:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  805154:	00 00 00 
  805157:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  80515a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80515e:	48 c1 e8 0c          	shr    $0xc,%rax
  805162:	48 89 c2             	mov    %rax,%rdx
  805165:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80516c:	01 00 00 
  80516f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805173:	25 00 04 00 00       	and    $0x400,%eax
  805178:	48 85 c0             	test   %rax,%rax
  80517b:	0f 85 5e ff ff ff    	jne    8050df <free+0x8b>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  805181:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805185:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  80518b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  80518f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805193:	8b 00                	mov    (%rax),%eax
  805195:	8d 50 ff             	lea    -0x1(%rax),%edx
  805198:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80519c:	89 10                	mov    %edx,(%rax)
  80519e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8051a2:	8b 00                	mov    (%rax),%eax
  8051a4:	85 c0                	test   %eax,%eax
  8051a6:	75 18                	jne    8051c0 <free+0x16c>
		sys_page_unmap(0, c);
  8051a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8051ac:	48 89 c6             	mov    %rax,%rsi
  8051af:	bf 00 00 00 00       	mov    $0x0,%edi
  8051b4:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8051bb:	00 00 00 
  8051be:	ff d0                	callq  *%rax
}
  8051c0:	c9                   	leaveq 
  8051c1:	c3                   	retq   

00000000008051c2 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8051c2:	55                   	push   %rbp
  8051c3:	48 89 e5             	mov    %rsp,%rbp
  8051c6:	53                   	push   %rbx
  8051c7:	48 83 ec 38          	sub    $0x38,%rsp
  8051cb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8051cf:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  8051d3:	48 89 c7             	mov    %rax,%rdi
  8051d6:	48 b8 76 34 80 00 00 	movabs $0x803476,%rax
  8051dd:	00 00 00 
  8051e0:	ff d0                	callq  *%rax
  8051e2:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8051e5:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8051e9:	0f 88 bf 01 00 00    	js     8053ae <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8051ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8051f3:	ba 07 04 00 00       	mov    $0x407,%edx
  8051f8:	48 89 c6             	mov    %rax,%rsi
  8051fb:	bf 00 00 00 00       	mov    $0x0,%edi
  805200:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  805207:	00 00 00 
  80520a:	ff d0                	callq  *%rax
  80520c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80520f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805213:	0f 88 95 01 00 00    	js     8053ae <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  805219:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80521d:	48 89 c7             	mov    %rax,%rdi
  805220:	48 b8 76 34 80 00 00 	movabs $0x803476,%rax
  805227:	00 00 00 
  80522a:	ff d0                	callq  *%rax
  80522c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80522f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805233:	0f 88 5d 01 00 00    	js     805396 <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805239:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80523d:	ba 07 04 00 00       	mov    $0x407,%edx
  805242:	48 89 c6             	mov    %rax,%rsi
  805245:	bf 00 00 00 00       	mov    $0x0,%edi
  80524a:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  805251:	00 00 00 
  805254:	ff d0                	callq  *%rax
  805256:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805259:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80525d:	0f 88 33 01 00 00    	js     805396 <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  805263:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805267:	48 89 c7             	mov    %rax,%rdi
  80526a:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  805271:	00 00 00 
  805274:	ff d0                	callq  *%rax
  805276:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80527a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80527e:	ba 07 04 00 00       	mov    $0x407,%edx
  805283:	48 89 c6             	mov    %rax,%rsi
  805286:	bf 00 00 00 00       	mov    $0x0,%edi
  80528b:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  805292:	00 00 00 
  805295:	ff d0                	callq  *%rax
  805297:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80529a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80529e:	79 05                	jns    8052a5 <pipe+0xe3>
		goto err2;
  8052a0:	e9 d9 00 00 00       	jmpq   80537e <pipe+0x1bc>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8052a5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8052a9:	48 89 c7             	mov    %rax,%rdi
  8052ac:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  8052b3:	00 00 00 
  8052b6:	ff d0                	callq  *%rax
  8052b8:	48 89 c2             	mov    %rax,%rdx
  8052bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8052bf:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  8052c5:	48 89 d1             	mov    %rdx,%rcx
  8052c8:	ba 00 00 00 00       	mov    $0x0,%edx
  8052cd:	48 89 c6             	mov    %rax,%rsi
  8052d0:	bf 00 00 00 00       	mov    $0x0,%edi
  8052d5:	48 b8 bb 28 80 00 00 	movabs $0x8028bb,%rax
  8052dc:	00 00 00 
  8052df:	ff d0                	callq  *%rax
  8052e1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8052e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8052e8:	79 1b                	jns    805305 <pipe+0x143>
		goto err3;
  8052ea:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  8052eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8052ef:	48 89 c6             	mov    %rax,%rsi
  8052f2:	bf 00 00 00 00       	mov    $0x0,%edi
  8052f7:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8052fe:	00 00 00 
  805301:	ff d0                	callq  *%rax
  805303:	eb 79                	jmp    80537e <pipe+0x1bc>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  805305:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805309:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805310:	00 00 00 
  805313:	8b 12                	mov    (%rdx),%edx
  805315:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  805317:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80531b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  805322:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805326:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  80532d:	00 00 00 
  805330:	8b 12                	mov    (%rdx),%edx
  805332:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  805334:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805338:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  80533f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805343:	48 89 c7             	mov    %rax,%rdi
  805346:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  80534d:	00 00 00 
  805350:	ff d0                	callq  *%rax
  805352:	89 c2                	mov    %eax,%edx
  805354:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805358:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  80535a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80535e:	48 8d 58 04          	lea    0x4(%rax),%rbx
  805362:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805366:	48 89 c7             	mov    %rax,%rdi
  805369:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  805370:	00 00 00 
  805373:	ff d0                	callq  *%rax
  805375:	89 03                	mov    %eax,(%rbx)
	return 0;
  805377:	b8 00 00 00 00       	mov    $0x0,%eax
  80537c:	eb 33                	jmp    8053b1 <pipe+0x1ef>

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  80537e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805382:	48 89 c6             	mov    %rax,%rsi
  805385:	bf 00 00 00 00       	mov    $0x0,%edi
  80538a:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  805391:	00 00 00 
  805394:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  805396:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80539a:	48 89 c6             	mov    %rax,%rsi
  80539d:	bf 00 00 00 00       	mov    $0x0,%edi
  8053a2:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8053a9:	00 00 00 
  8053ac:	ff d0                	callq  *%rax
err:
	return r;
  8053ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  8053b1:	48 83 c4 38          	add    $0x38,%rsp
  8053b5:	5b                   	pop    %rbx
  8053b6:	5d                   	pop    %rbp
  8053b7:	c3                   	retq   

00000000008053b8 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  8053b8:	55                   	push   %rbp
  8053b9:	48 89 e5             	mov    %rsp,%rbp
  8053bc:	53                   	push   %rbx
  8053bd:	48 83 ec 28          	sub    $0x28,%rsp
  8053c1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8053c5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  8053c9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8053d0:	00 00 00 
  8053d3:	48 8b 00             	mov    (%rax),%rax
  8053d6:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8053dc:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  8053df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053e3:	48 89 c7             	mov    %rax,%rdi
  8053e6:	48 b8 7e 5b 80 00 00 	movabs $0x805b7e,%rax
  8053ed:	00 00 00 
  8053f0:	ff d0                	callq  *%rax
  8053f2:	89 c3                	mov    %eax,%ebx
  8053f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053f8:	48 89 c7             	mov    %rax,%rdi
  8053fb:	48 b8 7e 5b 80 00 00 	movabs $0x805b7e,%rax
  805402:	00 00 00 
  805405:	ff d0                	callq  *%rax
  805407:	39 c3                	cmp    %eax,%ebx
  805409:	0f 94 c0             	sete   %al
  80540c:	0f b6 c0             	movzbl %al,%eax
  80540f:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  805412:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805419:	00 00 00 
  80541c:	48 8b 00             	mov    (%rax),%rax
  80541f:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  805425:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  805428:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80542b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80542e:	75 05                	jne    805435 <_pipeisclosed+0x7d>
			return ret;
  805430:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805433:	eb 4f                	jmp    805484 <_pipeisclosed+0xcc>
		if (n != nn && ret == 1)
  805435:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805438:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80543b:	74 42                	je     80547f <_pipeisclosed+0xc7>
  80543d:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  805441:	75 3c                	jne    80547f <_pipeisclosed+0xc7>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  805443:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80544a:	00 00 00 
  80544d:	48 8b 00             	mov    (%rax),%rax
  805450:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  805456:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  805459:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80545c:	89 c6                	mov    %eax,%esi
  80545e:	48 bf 55 14 82 00 00 	movabs $0x821455,%rdi
  805465:	00 00 00 
  805468:	b8 00 00 00 00       	mov    $0x0,%eax
  80546d:	49 b8 87 13 80 00 00 	movabs $0x801387,%r8
  805474:	00 00 00 
  805477:	41 ff d0             	callq  *%r8
	}
  80547a:	e9 4a ff ff ff       	jmpq   8053c9 <_pipeisclosed+0x11>
  80547f:	e9 45 ff ff ff       	jmpq   8053c9 <_pipeisclosed+0x11>
}
  805484:	48 83 c4 28          	add    $0x28,%rsp
  805488:	5b                   	pop    %rbx
  805489:	5d                   	pop    %rbp
  80548a:	c3                   	retq   

000000000080548b <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  80548b:	55                   	push   %rbp
  80548c:	48 89 e5             	mov    %rsp,%rbp
  80548f:	48 83 ec 30          	sub    $0x30,%rsp
  805493:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805496:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80549a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80549d:	48 89 d6             	mov    %rdx,%rsi
  8054a0:	89 c7                	mov    %eax,%edi
  8054a2:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8054a9:	00 00 00 
  8054ac:	ff d0                	callq  *%rax
  8054ae:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8054b1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8054b5:	79 05                	jns    8054bc <pipeisclosed+0x31>
		return r;
  8054b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8054ba:	eb 31                	jmp    8054ed <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  8054bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8054c0:	48 89 c7             	mov    %rax,%rdi
  8054c3:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  8054ca:	00 00 00 
  8054cd:	ff d0                	callq  *%rax
  8054cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  8054d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8054d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8054db:	48 89 d6             	mov    %rdx,%rsi
  8054de:	48 89 c7             	mov    %rax,%rdi
  8054e1:	48 b8 b8 53 80 00 00 	movabs $0x8053b8,%rax
  8054e8:	00 00 00 
  8054eb:	ff d0                	callq  *%rax
}
  8054ed:	c9                   	leaveq 
  8054ee:	c3                   	retq   

00000000008054ef <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8054ef:	55                   	push   %rbp
  8054f0:	48 89 e5             	mov    %rsp,%rbp
  8054f3:	48 83 ec 40          	sub    $0x40,%rsp
  8054f7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8054fb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8054ff:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  805503:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805507:	48 89 c7             	mov    %rax,%rdi
  80550a:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  805511:	00 00 00 
  805514:	ff d0                	callq  *%rax
  805516:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  80551a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80551e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805522:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  805529:	00 
  80552a:	e9 92 00 00 00       	jmpq   8055c1 <devpipe_read+0xd2>
		while (p->p_rpos == p->p_wpos) {
  80552f:	eb 41                	jmp    805572 <devpipe_read+0x83>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  805531:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805536:	74 09                	je     805541 <devpipe_read+0x52>
				return i;
  805538:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80553c:	e9 92 00 00 00       	jmpq   8055d3 <devpipe_read+0xe4>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805541:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805545:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805549:	48 89 d6             	mov    %rdx,%rsi
  80554c:	48 89 c7             	mov    %rax,%rdi
  80554f:	48 b8 b8 53 80 00 00 	movabs $0x8053b8,%rax
  805556:	00 00 00 
  805559:	ff d0                	callq  *%rax
  80555b:	85 c0                	test   %eax,%eax
  80555d:	74 07                	je     805566 <devpipe_read+0x77>
				return 0;
  80555f:	b8 00 00 00 00       	mov    $0x0,%eax
  805564:	eb 6d                	jmp    8055d3 <devpipe_read+0xe4>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  805566:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  80556d:	00 00 00 
  805570:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  805572:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805576:	8b 10                	mov    (%rax),%edx
  805578:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80557c:	8b 40 04             	mov    0x4(%rax),%eax
  80557f:	39 c2                	cmp    %eax,%edx
  805581:	74 ae                	je     805531 <devpipe_read+0x42>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  805583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805587:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80558b:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80558f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805593:	8b 00                	mov    (%rax),%eax
  805595:	99                   	cltd   
  805596:	c1 ea 1b             	shr    $0x1b,%edx
  805599:	01 d0                	add    %edx,%eax
  80559b:	83 e0 1f             	and    $0x1f,%eax
  80559e:	29 d0                	sub    %edx,%eax
  8055a0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8055a4:	48 98                	cltq   
  8055a6:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  8055ab:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  8055ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8055b1:	8b 00                	mov    (%rax),%eax
  8055b3:	8d 50 01             	lea    0x1(%rax),%edx
  8055b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8055ba:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8055bc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8055c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8055c5:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8055c9:	0f 82 60 ff ff ff    	jb     80552f <devpipe_read+0x40>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8055cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8055d3:	c9                   	leaveq 
  8055d4:	c3                   	retq   

00000000008055d5 <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8055d5:	55                   	push   %rbp
  8055d6:	48 89 e5             	mov    %rsp,%rbp
  8055d9:	48 83 ec 40          	sub    $0x40,%rsp
  8055dd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8055e1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8055e5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8055e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8055ed:	48 89 c7             	mov    %rax,%rdi
  8055f0:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  8055f7:	00 00 00 
  8055fa:	ff d0                	callq  *%rax
  8055fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  805600:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805604:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805608:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80560f:	00 
  805610:	e9 8e 00 00 00       	jmpq   8056a3 <devpipe_write+0xce>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805615:	eb 31                	jmp    805648 <devpipe_write+0x73>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  805617:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80561b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80561f:	48 89 d6             	mov    %rdx,%rsi
  805622:	48 89 c7             	mov    %rax,%rdi
  805625:	48 b8 b8 53 80 00 00 	movabs $0x8053b8,%rax
  80562c:	00 00 00 
  80562f:	ff d0                	callq  *%rax
  805631:	85 c0                	test   %eax,%eax
  805633:	74 07                	je     80563c <devpipe_write+0x67>
				return 0;
  805635:	b8 00 00 00 00       	mov    $0x0,%eax
  80563a:	eb 79                	jmp    8056b5 <devpipe_write+0xe0>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  80563c:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  805643:	00 00 00 
  805646:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805648:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80564c:	8b 40 04             	mov    0x4(%rax),%eax
  80564f:	48 63 d0             	movslq %eax,%rdx
  805652:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805656:	8b 00                	mov    (%rax),%eax
  805658:	48 98                	cltq   
  80565a:	48 83 c0 20          	add    $0x20,%rax
  80565e:	48 39 c2             	cmp    %rax,%rdx
  805661:	73 b4                	jae    805617 <devpipe_write+0x42>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  805663:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805667:	8b 40 04             	mov    0x4(%rax),%eax
  80566a:	99                   	cltd   
  80566b:	c1 ea 1b             	shr    $0x1b,%edx
  80566e:	01 d0                	add    %edx,%eax
  805670:	83 e0 1f             	and    $0x1f,%eax
  805673:	29 d0                	sub    %edx,%eax
  805675:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805679:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80567d:	48 01 ca             	add    %rcx,%rdx
  805680:	0f b6 0a             	movzbl (%rdx),%ecx
  805683:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805687:	48 98                	cltq   
  805689:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  80568d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805691:	8b 40 04             	mov    0x4(%rax),%eax
  805694:	8d 50 01             	lea    0x1(%rax),%edx
  805697:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80569b:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  80569e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8056a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056a7:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8056ab:	0f 82 64 ff ff ff    	jb     805615 <devpipe_write+0x40>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8056b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8056b5:	c9                   	leaveq 
  8056b6:	c3                   	retq   

00000000008056b7 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8056b7:	55                   	push   %rbp
  8056b8:	48 89 e5             	mov    %rsp,%rbp
  8056bb:	48 83 ec 20          	sub    $0x20,%rsp
  8056bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8056c3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8056c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8056cb:	48 89 c7             	mov    %rax,%rdi
  8056ce:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  8056d5:	00 00 00 
  8056d8:	ff d0                	callq  *%rax
  8056da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  8056de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8056e2:	48 be 68 14 82 00 00 	movabs $0x821468,%rsi
  8056e9:	00 00 00 
  8056ec:	48 89 c7             	mov    %rax,%rdi
  8056ef:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  8056f6:	00 00 00 
  8056f9:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  8056fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056ff:	8b 50 04             	mov    0x4(%rax),%edx
  805702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805706:	8b 00                	mov    (%rax),%eax
  805708:	29 c2                	sub    %eax,%edx
  80570a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80570e:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  805714:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805718:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  80571f:	00 00 00 
	stat->st_dev = &devpipe;
  805722:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805726:	48 b9 00 81 82 00 00 	movabs $0x828100,%rcx
  80572d:	00 00 00 
  805730:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  805737:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80573c:	c9                   	leaveq 
  80573d:	c3                   	retq   

000000000080573e <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  80573e:	55                   	push   %rbp
  80573f:	48 89 e5             	mov    %rsp,%rbp
  805742:	48 83 ec 10          	sub    $0x10,%rsp
  805746:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	(void) sys_page_unmap(0, fd);
  80574a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80574e:	48 89 c6             	mov    %rax,%rsi
  805751:	bf 00 00 00 00       	mov    $0x0,%edi
  805756:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  80575d:	00 00 00 
  805760:	ff d0                	callq  *%rax
	return sys_page_unmap(0, fd2data(fd));
  805762:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805766:	48 89 c7             	mov    %rax,%rdi
  805769:	48 b8 4b 34 80 00 00 	movabs $0x80344b,%rax
  805770:	00 00 00 
  805773:	ff d0                	callq  *%rax
  805775:	48 89 c6             	mov    %rax,%rsi
  805778:	bf 00 00 00 00       	mov    $0x0,%edi
  80577d:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  805784:	00 00 00 
  805787:	ff d0                	callq  *%rax
}
  805789:	c9                   	leaveq 
  80578a:	c3                   	retq   

000000000080578b <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  80578b:	55                   	push   %rbp
  80578c:	48 89 e5             	mov    %rsp,%rbp
  80578f:	48 83 ec 20          	sub    $0x20,%rsp
  805793:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  805796:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805799:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  80579c:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  8057a0:	be 01 00 00 00       	mov    $0x1,%esi
  8057a5:	48 89 c7             	mov    %rax,%rdi
  8057a8:	48 b8 23 27 80 00 00 	movabs $0x802723,%rax
  8057af:	00 00 00 
  8057b2:	ff d0                	callq  *%rax
}
  8057b4:	c9                   	leaveq 
  8057b5:	c3                   	retq   

00000000008057b6 <getchar>:

int
getchar(void)
{
  8057b6:	55                   	push   %rbp
  8057b7:	48 89 e5             	mov    %rsp,%rbp
  8057ba:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8057be:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8057c2:	ba 01 00 00 00       	mov    $0x1,%edx
  8057c7:	48 89 c6             	mov    %rax,%rsi
  8057ca:	bf 00 00 00 00       	mov    $0x0,%edi
  8057cf:	48 b8 40 39 80 00 00 	movabs $0x803940,%rax
  8057d6:	00 00 00 
  8057d9:	ff d0                	callq  *%rax
  8057db:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  8057de:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8057e2:	79 05                	jns    8057e9 <getchar+0x33>
		return r;
  8057e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8057e7:	eb 14                	jmp    8057fd <getchar+0x47>
	if (r < 1)
  8057e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8057ed:	7f 07                	jg     8057f6 <getchar+0x40>
		return -E_EOF;
  8057ef:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8057f4:	eb 07                	jmp    8057fd <getchar+0x47>
	return c;
  8057f6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8057fa:	0f b6 c0             	movzbl %al,%eax
}
  8057fd:	c9                   	leaveq 
  8057fe:	c3                   	retq   

00000000008057ff <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8057ff:	55                   	push   %rbp
  805800:	48 89 e5             	mov    %rsp,%rbp
  805803:	48 83 ec 20          	sub    $0x20,%rsp
  805807:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80580a:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80580e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805811:	48 89 d6             	mov    %rdx,%rsi
  805814:	89 c7                	mov    %eax,%edi
  805816:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  80581d:	00 00 00 
  805820:	ff d0                	callq  *%rax
  805822:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805825:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805829:	79 05                	jns    805830 <iscons+0x31>
		return r;
  80582b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80582e:	eb 1a                	jmp    80584a <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  805830:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805834:	8b 10                	mov    (%rax),%edx
  805836:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  80583d:	00 00 00 
  805840:	8b 00                	mov    (%rax),%eax
  805842:	39 c2                	cmp    %eax,%edx
  805844:	0f 94 c0             	sete   %al
  805847:	0f b6 c0             	movzbl %al,%eax
}
  80584a:	c9                   	leaveq 
  80584b:	c3                   	retq   

000000000080584c <opencons>:

int
opencons(void)
{
  80584c:	55                   	push   %rbp
  80584d:	48 89 e5             	mov    %rsp,%rbp
  805850:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  805854:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805858:	48 89 c7             	mov    %rax,%rdi
  80585b:	48 b8 76 34 80 00 00 	movabs $0x803476,%rax
  805862:	00 00 00 
  805865:	ff d0                	callq  *%rax
  805867:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80586a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80586e:	79 05                	jns    805875 <opencons+0x29>
		return r;
  805870:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805873:	eb 5b                	jmp    8058d0 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  805875:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805879:	ba 07 04 00 00       	mov    $0x407,%edx
  80587e:	48 89 c6             	mov    %rax,%rsi
  805881:	bf 00 00 00 00       	mov    $0x0,%edi
  805886:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  80588d:	00 00 00 
  805890:	ff d0                	callq  *%rax
  805892:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805895:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805899:	79 05                	jns    8058a0 <opencons+0x54>
		return r;
  80589b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80589e:	eb 30                	jmp    8058d0 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  8058a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8058a4:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  8058ab:	00 00 00 
  8058ae:	8b 12                	mov    (%rdx),%edx
  8058b0:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  8058b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8058b6:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8058bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8058c1:	48 89 c7             	mov    %rax,%rdi
  8058c4:	48 b8 28 34 80 00 00 	movabs $0x803428,%rax
  8058cb:	00 00 00 
  8058ce:	ff d0                	callq  *%rax
}
  8058d0:	c9                   	leaveq 
  8058d1:	c3                   	retq   

00000000008058d2 <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8058d2:	55                   	push   %rbp
  8058d3:	48 89 e5             	mov    %rsp,%rbp
  8058d6:	48 83 ec 30          	sub    $0x30,%rsp
  8058da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8058de:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8058e2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  8058e6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8058eb:	75 07                	jne    8058f4 <devcons_read+0x22>
		return 0;
  8058ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8058f2:	eb 4b                	jmp    80593f <devcons_read+0x6d>

	while ((c = sys_cgetc()) == 0)
  8058f4:	eb 0c                	jmp    805902 <devcons_read+0x30>
		sys_yield();
  8058f6:	48 b8 2d 28 80 00 00 	movabs $0x80282d,%rax
  8058fd:	00 00 00 
  805900:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  805902:	48 b8 6d 27 80 00 00 	movabs $0x80276d,%rax
  805909:	00 00 00 
  80590c:	ff d0                	callq  *%rax
  80590e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805911:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805915:	74 df                	je     8058f6 <devcons_read+0x24>
		sys_yield();
	if (c < 0)
  805917:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80591b:	79 05                	jns    805922 <devcons_read+0x50>
		return c;
  80591d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805920:	eb 1d                	jmp    80593f <devcons_read+0x6d>
	if (c == 0x04)	// ctl-d is eof
  805922:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  805926:	75 07                	jne    80592f <devcons_read+0x5d>
		return 0;
  805928:	b8 00 00 00 00       	mov    $0x0,%eax
  80592d:	eb 10                	jmp    80593f <devcons_read+0x6d>
	*(char*)vbuf = c;
  80592f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805932:	89 c2                	mov    %eax,%edx
  805934:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805938:	88 10                	mov    %dl,(%rax)
	return 1;
  80593a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80593f:	c9                   	leaveq 
  805940:	c3                   	retq   

0000000000805941 <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805941:	55                   	push   %rbp
  805942:	48 89 e5             	mov    %rsp,%rbp
  805945:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80594c:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805953:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  80595a:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805961:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805968:	eb 76                	jmp    8059e0 <devcons_write+0x9f>
		m = n - tot;
  80596a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805971:	89 c2                	mov    %eax,%edx
  805973:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805976:	29 c2                	sub    %eax,%edx
  805978:	89 d0                	mov    %edx,%eax
  80597a:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  80597d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805980:	83 f8 7f             	cmp    $0x7f,%eax
  805983:	76 07                	jbe    80598c <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  805985:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  80598c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80598f:	48 63 d0             	movslq %eax,%rdx
  805992:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805995:	48 63 c8             	movslq %eax,%rcx
  805998:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80599f:	48 01 c1             	add    %rax,%rcx
  8059a2:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8059a9:	48 89 ce             	mov    %rcx,%rsi
  8059ac:	48 89 c7             	mov    %rax,%rdi
  8059af:	48 b8 60 22 80 00 00 	movabs $0x802260,%rax
  8059b6:	00 00 00 
  8059b9:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  8059bb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8059be:	48 63 d0             	movslq %eax,%rdx
  8059c1:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8059c8:	48 89 d6             	mov    %rdx,%rsi
  8059cb:	48 89 c7             	mov    %rax,%rdi
  8059ce:	48 b8 23 27 80 00 00 	movabs $0x802723,%rax
  8059d5:	00 00 00 
  8059d8:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8059da:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8059dd:	01 45 fc             	add    %eax,-0x4(%rbp)
  8059e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059e3:	48 98                	cltq   
  8059e5:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  8059ec:	0f 82 78 ff ff ff    	jb     80596a <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  8059f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8059f5:	c9                   	leaveq 
  8059f6:	c3                   	retq   

00000000008059f7 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  8059f7:	55                   	push   %rbp
  8059f8:	48 89 e5             	mov    %rsp,%rbp
  8059fb:	48 83 ec 08          	sub    $0x8,%rsp
  8059ff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  805a03:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805a08:	c9                   	leaveq 
  805a09:	c3                   	retq   

0000000000805a0a <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805a0a:	55                   	push   %rbp
  805a0b:	48 89 e5             	mov    %rsp,%rbp
  805a0e:	48 83 ec 10          	sub    $0x10,%rsp
  805a12:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805a16:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805a1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805a1e:	48 be 74 14 82 00 00 	movabs $0x821474,%rsi
  805a25:	00 00 00 
  805a28:	48 89 c7             	mov    %rax,%rdi
  805a2b:	48 b8 3c 1f 80 00 00 	movabs $0x801f3c,%rax
  805a32:	00 00 00 
  805a35:	ff d0                	callq  *%rax
	return 0;
  805a37:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805a3c:	c9                   	leaveq 
  805a3d:	c3                   	retq   

0000000000805a3e <set_pgfault_handler>:
// _pgfault_upcall routine when a page fault occurs.


void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805a3e:	55                   	push   %rbp
  805a3f:	48 89 e5             	mov    %rsp,%rbp
  805a42:	48 83 ec 10          	sub    $0x10,%rsp
  805a46:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        int r;
        //struct Env *thisenv = NULL;
        if (_pgfault_handler == 0) {
  805a4a:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805a51:	00 00 00 
  805a54:	48 8b 00             	mov    (%rax),%rax
  805a57:	48 85 c0             	test   %rax,%rax
  805a5a:	0f 85 84 00 00 00    	jne    805ae4 <set_pgfault_handler+0xa6>
                // First time through!
                // LAB 4: Your code here.
                //cprintf("Inside set_pgfault_handler");
                if(0> sys_page_alloc(thisenv->env_id, (void*)UXSTACKTOP - PGSIZE,PTE_U|PTE_P|PTE_W)){
  805a60:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805a67:	00 00 00 
  805a6a:	48 8b 00             	mov    (%rax),%rax
  805a6d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  805a73:	ba 07 00 00 00       	mov    $0x7,%edx
  805a78:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  805a7d:	89 c7                	mov    %eax,%edi
  805a7f:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  805a86:	00 00 00 
  805a89:	ff d0                	callq  *%rax
  805a8b:	85 c0                	test   %eax,%eax
  805a8d:	79 2a                	jns    805ab9 <set_pgfault_handler+0x7b>
                        panic("Page not available for exception stack");
  805a8f:	48 ba 80 14 82 00 00 	movabs $0x821480,%rdx
  805a96:	00 00 00 
  805a99:	be 23 00 00 00       	mov    $0x23,%esi
  805a9e:	48 bf a7 14 82 00 00 	movabs $0x8214a7,%rdi
  805aa5:	00 00 00 
  805aa8:	b8 00 00 00 00       	mov    $0x0,%eax
  805aad:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  805ab4:	00 00 00 
  805ab7:	ff d1                	callq  *%rcx
                }
                sys_env_set_pgfault_upcall(thisenv->env_id, (void*)_pgfault_upcall);
  805ab9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805ac0:	00 00 00 
  805ac3:	48 8b 00             	mov    (%rax),%rax
  805ac6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  805acc:	48 be f7 5a 80 00 00 	movabs $0x805af7,%rsi
  805ad3:	00 00 00 
  805ad6:	89 c7                	mov    %eax,%edi
  805ad8:	48 b8 f5 29 80 00 00 	movabs $0x8029f5,%rax
  805adf:	00 00 00 
  805ae2:	ff d0                	callq  *%rax
				
               // sys_env_set_pgfault_upcall(thisenv->env_id,handler);
        }

        // Save handler pointer for assembly to call.
        _pgfault_handler = handler;
  805ae4:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805aeb:	00 00 00 
  805aee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805af2:	48 89 10             	mov    %rdx,(%rax)
}
  805af5:	c9                   	leaveq 
  805af6:	c3                   	retq   

0000000000805af7 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  805af7:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  805afa:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  805b01:	00 00 00 
call *%rax
  805b04:	ff d0                	callq  *%rax
    // LAB 4: Your code here.

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.

	movq 136(%rsp), %rbx  //Load RIP 
  805b06:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  805b0d:	00 
	movq 152(%rsp), %rcx  //Load RSP
  805b0e:	48 8b 8c 24 98 00 00 	mov    0x98(%rsp),%rcx
  805b15:	00 
	//Move pointer on the stack and save the RIP on trap time stack 
	subq $8, %rcx          
  805b16:	48 83 e9 08          	sub    $0x8,%rcx
	movq %rbx, (%rcx) 
  805b1a:	48 89 19             	mov    %rbx,(%rcx)
	//Now update value of trap time stack rsp after pushing rip in UXSTACKTOP
	movq %rcx, 152(%rsp)
  805b1d:	48 89 8c 24 98 00 00 	mov    %rcx,0x98(%rsp)
  805b24:	00 
	
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addq $16,%rsp
  805b25:	48 83 c4 10          	add    $0x10,%rsp
	POPA_ 
  805b29:	4c 8b 3c 24          	mov    (%rsp),%r15
  805b2d:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805b32:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  805b37:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805b3c:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805b41:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  805b46:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805b4b:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805b50:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  805b55:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805b5a:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805b5f:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  805b64:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  805b69:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805b6e:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805b73:	48 83 c4 78          	add    $0x78,%rsp
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addq $8, %rsp
  805b77:	48 83 c4 08          	add    $0x8,%rsp
	popfq
  805b7b:	9d                   	popfq  
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popq %rsp
  805b7c:	5c                   	pop    %rsp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  805b7d:	c3                   	retq   

0000000000805b7e <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  805b7e:	55                   	push   %rbp
  805b7f:	48 89 e5             	mov    %rsp,%rbp
  805b82:	48 83 ec 18          	sub    $0x18,%rsp
  805b86:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805b8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805b8e:	48 c1 e8 15          	shr    $0x15,%rax
  805b92:	48 89 c2             	mov    %rax,%rdx
  805b95:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  805b9c:	01 00 00 
  805b9f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805ba3:	83 e0 01             	and    $0x1,%eax
  805ba6:	48 85 c0             	test   %rax,%rax
  805ba9:	75 07                	jne    805bb2 <pageref+0x34>
		return 0;
  805bab:	b8 00 00 00 00       	mov    $0x0,%eax
  805bb0:	eb 53                	jmp    805c05 <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  805bb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805bb6:	48 c1 e8 0c          	shr    $0xc,%rax
  805bba:	48 89 c2             	mov    %rax,%rdx
  805bbd:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  805bc4:	01 00 00 
  805bc7:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805bcb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  805bcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805bd3:	83 e0 01             	and    $0x1,%eax
  805bd6:	48 85 c0             	test   %rax,%rax
  805bd9:	75 07                	jne    805be2 <pageref+0x64>
		return 0;
  805bdb:	b8 00 00 00 00       	mov    $0x0,%eax
  805be0:	eb 23                	jmp    805c05 <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  805be2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805be6:	48 c1 e8 0c          	shr    $0xc,%rax
  805bea:	48 89 c2             	mov    %rax,%rdx
  805bed:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  805bf4:	00 00 00 
  805bf7:	48 c1 e2 04          	shl    $0x4,%rdx
  805bfb:	48 01 d0             	add    %rdx,%rax
  805bfe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  805c02:	0f b7 c0             	movzwl %ax,%eax
}
  805c05:	c9                   	leaveq 
  805c06:	c3                   	retq   

0000000000805c07 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805c07:	55                   	push   %rbp
  805c08:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805c0b:	bf 01 00 00 00       	mov    $0x1,%edi
  805c10:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  805c17:	00 00 00 
  805c1a:	ff d0                	callq  *%rax
  805c1c:	48 ba a8 94 82 00 00 	movabs $0x8294a8,%rdx
  805c23:	00 00 00 
  805c26:	89 02                	mov    %eax,(%rdx)
  selectsem = sys_sem_new(1);
  805c28:	bf 01 00 00 00       	mov    $0x1,%edi
  805c2d:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  805c34:	00 00 00 
  805c37:	ff d0                	callq  *%rax
  805c39:	48 ba ac 94 82 00 00 	movabs $0x8294ac,%rdx
  805c40:	00 00 00 
  805c43:	89 02                	mov    %eax,(%rdx)
}
  805c45:	5d                   	pop    %rbp
  805c46:	c3                   	retq   

0000000000805c47 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805c47:	55                   	push   %rbp
  805c48:	48 89 e5             	mov    %rsp,%rbp
  805c4b:	48 83 ec 14          	sub    $0x14,%rsp
  805c4f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805c52:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805c56:	78 06                	js     805c5e <get_socket+0x17>
  805c58:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805c5c:	7e 17                	jle    805c75 <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805c5e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805c65:	00 00 00 
  805c68:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805c6e:	b8 00 00 00 00       	mov    $0x0,%eax
  805c73:	eb 44                	jmp    805cb9 <get_socket+0x72>
  }

  sock = &sockets[s];
  805c75:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805c78:	48 98                	cltq   
  805c7a:	48 c1 e0 05          	shl    $0x5,%rax
  805c7e:	48 89 c2             	mov    %rax,%rdx
  805c81:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805c88:	00 00 00 
  805c8b:	48 01 d0             	add    %rdx,%rax
  805c8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  805c92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c96:	48 8b 00             	mov    (%rax),%rax
  805c99:	48 85 c0             	test   %rax,%rax
  805c9c:	75 17                	jne    805cb5 <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805c9e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805ca5:	00 00 00 
  805ca8:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805cae:	b8 00 00 00 00       	mov    $0x0,%eax
  805cb3:	eb 04                	jmp    805cb9 <get_socket+0x72>
  }

  return sock;
  805cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805cb9:	c9                   	leaveq 
  805cba:	c3                   	retq   

0000000000805cbb <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805cbb:	55                   	push   %rbp
  805cbc:	48 89 e5             	mov    %rsp,%rbp
  805cbf:	48 83 ec 20          	sub    $0x20,%rsp
  805cc3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  805cc7:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805cce:	00 00 00 
  805cd1:	8b 00                	mov    (%rax),%eax
  805cd3:	89 c7                	mov    %eax,%edi
  805cd5:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  805cdc:	00 00 00 
  805cdf:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805ce1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805ce8:	e9 28 01 00 00       	jmpq   805e15 <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  805ced:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805cf4:	00 00 00 
  805cf7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805cfa:	48 63 d2             	movslq %edx,%rdx
  805cfd:	48 c1 e2 05          	shl    $0x5,%rdx
  805d01:	48 01 d0             	add    %rdx,%rax
  805d04:	48 8b 00             	mov    (%rax),%rax
  805d07:	48 85 c0             	test   %rax,%rax
  805d0a:	0f 85 01 01 00 00    	jne    805e11 <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805d10:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d17:	00 00 00 
  805d1a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805d1d:	48 63 d2             	movslq %edx,%rdx
  805d20:	48 c1 e2 05          	shl    $0x5,%rdx
  805d24:	48 01 c2             	add    %rax,%rdx
  805d27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805d2b:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805d2e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d35:	00 00 00 
  805d38:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805d3b:	48 63 d2             	movslq %edx,%rdx
  805d3e:	48 c1 e2 05          	shl    $0x5,%rdx
  805d42:	48 01 d0             	add    %rdx,%rax
  805d45:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805d4c:	00 
      sockets[i].lastoffset = 0;
  805d4d:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d54:	00 00 00 
  805d57:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805d5a:	48 63 d2             	movslq %edx,%rdx
  805d5d:	48 c1 e2 05          	shl    $0x5,%rdx
  805d61:	48 01 d0             	add    %rdx,%rax
  805d64:	48 83 c0 10          	add    $0x10,%rax
  805d68:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805d6d:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d74:	00 00 00 
  805d77:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805d7a:	48 63 d2             	movslq %edx,%rdx
  805d7d:	48 c1 e2 05          	shl    $0x5,%rdx
  805d81:	48 01 d0             	add    %rdx,%rax
  805d84:	48 83 c0 10          	add    $0x10,%rax
  805d88:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805d8e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d95:	00 00 00 
  805d98:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805d9b:	48 63 d2             	movslq %edx,%rdx
  805d9e:	48 c1 e2 05          	shl    $0x5,%rdx
  805da2:	48 01 d0             	add    %rdx,%rax
  805da5:	48 83 c0 10          	add    $0x10,%rax
  805da9:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  805daf:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805db6:	00 00 00 
  805db9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805dbc:	48 63 d2             	movslq %edx,%rdx
  805dbf:	48 c1 e2 05          	shl    $0x5,%rdx
  805dc3:	48 01 d0             	add    %rdx,%rax
  805dc6:	48 83 c0 10          	add    $0x10,%rax
  805dca:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  805dd0:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805dd7:	00 00 00 
  805dda:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ddd:	48 63 d2             	movslq %edx,%rdx
  805de0:	48 c1 e2 05          	shl    $0x5,%rdx
  805de4:	48 01 d0             	add    %rdx,%rax
  805de7:	48 83 c0 10          	add    $0x10,%rax
  805deb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  805df2:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805df9:	00 00 00 
  805dfc:	8b 00                	mov    (%rax),%eax
  805dfe:	89 c7                	mov    %eax,%edi
  805e00:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  805e07:	00 00 00 
  805e0a:	ff d0                	callq  *%rax
      return i;
  805e0c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805e0f:	eb 2d                	jmp    805e3e <alloc_socket+0x183>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805e11:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805e15:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805e19:	0f 8e ce fe ff ff    	jle    805ced <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805e1f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805e26:	00 00 00 
  805e29:	8b 00                	mov    (%rax),%eax
  805e2b:	89 c7                	mov    %eax,%edi
  805e2d:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  805e34:	00 00 00 
  805e37:	ff d0                	callq  *%rax
  return -1;
  805e39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805e3e:	c9                   	leaveq 
  805e3f:	c3                   	retq   

0000000000805e40 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805e40:	55                   	push   %rbp
  805e41:	48 89 e5             	mov    %rsp,%rbp
  805e44:	53                   	push   %rbx
  805e45:	48 83 ec 78          	sub    $0x78,%rsp
  805e49:	89 7d 9c             	mov    %edi,-0x64(%rbp)
  805e4c:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  805e50:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805e54:	8b 45 9c             	mov    -0x64(%rbp),%eax
  805e57:	89 c7                	mov    %eax,%edi
  805e59:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  805e60:	00 00 00 
  805e63:	ff d0                	callq  *%rax
  805e65:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (!sock)
  805e69:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  805e6e:	75 0a                	jne    805e7a <lwip_accept+0x3a>
    return -1;
  805e70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805e75:	e9 f2 02 00 00       	jmpq   80616c <lwip_accept+0x32c>

  newconn = netconn_accept(sock->conn);
  805e7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e7e:	48 8b 00             	mov    (%rax),%rax
  805e81:	48 89 c7             	mov    %rax,%rdi
  805e84:	48 b8 4b 9e 81 00 00 	movabs $0x819e4b,%rax
  805e8b:	00 00 00 
  805e8e:	ff d0                	callq  *%rax
  805e90:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (!newconn) {
  805e94:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  805e99:	75 62                	jne    805efd <lwip_accept+0xbd>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805e9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e9f:	48 8b 00             	mov    (%rax),%rax
  805ea2:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805ea6:	0f be c0             	movsbl %al,%eax
  805ea9:	f7 d8                	neg    %eax
  805eab:	83 f8 0e             	cmp    $0xe,%eax
  805eae:	77 24                	ja     805ed4 <lwip_accept+0x94>
  805eb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805eb4:	48 8b 00             	mov    (%rax),%rax
  805eb7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805ebb:	0f be c0             	movsbl %al,%eax
  805ebe:	f7 d8                	neg    %eax
  805ec0:	89 c2                	mov    %eax,%edx
  805ec2:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  805ec9:	00 00 00 
  805ecc:	48 63 d2             	movslq %edx,%rdx
  805ecf:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805ed2:	eb 05                	jmp    805ed9 <lwip_accept+0x99>
  805ed4:	b8 05 00 00 00       	mov    $0x5,%eax
  805ed9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805edd:	89 42 18             	mov    %eax,0x18(%rdx)
  805ee0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805ee4:	8b 50 18             	mov    0x18(%rax),%edx
  805ee7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805eee:	00 00 00 
  805ef1:	89 10                	mov    %edx,(%rax)
    return -1;
  805ef3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805ef8:	e9 6f 02 00 00       	jmpq   80616c <lwip_accept+0x32c>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  805efd:	48 8d 55 be          	lea    -0x42(%rbp),%rdx
  805f01:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  805f05:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805f09:	b9 00 00 00 00       	mov    $0x0,%ecx
  805f0e:	48 89 c7             	mov    %rax,%rdi
  805f11:	48 b8 5c 9b 81 00 00 	movabs $0x819b5c,%rax
  805f18:	00 00 00 
  805f1b:	ff d0                	callq  *%rax
  805f1d:	88 45 df             	mov    %al,-0x21(%rbp)
  if (err != ERR_OK) {
  805f20:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  805f24:	74 61                	je     805f87 <lwip_accept+0x147>
    netconn_delete(newconn);
  805f26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805f2a:	48 89 c7             	mov    %rax,%rdi
  805f2d:	48 b8 ae 9a 81 00 00 	movabs $0x819aae,%rax
  805f34:	00 00 00 
  805f37:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805f39:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  805f3d:	f7 d8                	neg    %eax
  805f3f:	83 f8 0e             	cmp    $0xe,%eax
  805f42:	77 1a                	ja     805f5e <lwip_accept+0x11e>
  805f44:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  805f48:	f7 d8                	neg    %eax
  805f4a:	89 c2                	mov    %eax,%edx
  805f4c:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  805f53:	00 00 00 
  805f56:	48 63 d2             	movslq %edx,%rdx
  805f59:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805f5c:	eb 05                	jmp    805f63 <lwip_accept+0x123>
  805f5e:	b8 05 00 00 00       	mov    $0x5,%eax
  805f63:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805f67:	89 42 18             	mov    %eax,0x18(%rdx)
  805f6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805f6e:	8b 50 18             	mov    0x18(%rax),%edx
  805f71:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805f78:	00 00 00 
  805f7b:	89 10                	mov    %edx,(%rax)
    return -1;
  805f7d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f82:	e9 e5 01 00 00       	jmpq   80616c <lwip_accept+0x32c>
  }

  memset(&sin, 0, sizeof(sin));
  805f87:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  805f8b:	ba 10 00 00 00       	mov    $0x10,%edx
  805f90:	be 00 00 00 00       	mov    $0x0,%esi
  805f95:	48 89 c7             	mov    %rax,%rdi
  805f98:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  805f9f:	00 00 00 
  805fa2:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  805fa4:	c6 45 a0 10          	movb   $0x10,-0x60(%rbp)
  sin.sin_family = AF_INET;
  805fa8:	c6 45 a1 02          	movb   $0x2,-0x5f(%rbp)
  sin.sin_port = htons(port);
  805fac:	0f b7 45 be          	movzwl -0x42(%rbp),%eax
  805fb0:	0f b7 c0             	movzwl %ax,%eax
  805fb3:	89 c7                	mov    %eax,%edi
  805fb5:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  805fbc:	00 00 00 
  805fbf:	ff d0                	callq  *%rax
  805fc1:	66 89 45 a2          	mov    %ax,-0x5e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  805fc5:	8b 45 c0             	mov    -0x40(%rbp),%eax
  805fc8:	89 45 a4             	mov    %eax,-0x5c(%rbp)

  if (*addrlen > sizeof(sin))
  805fcb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805fcf:	8b 00                	mov    (%rax),%eax
  805fd1:	83 f8 10             	cmp    $0x10,%eax
  805fd4:	76 0a                	jbe    805fe0 <lwip_accept+0x1a0>
    *addrlen = sizeof(sin);
  805fd6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805fda:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  805fe0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805fe4:	8b 00                	mov    (%rax),%eax
  805fe6:	89 c2                	mov    %eax,%edx
  805fe8:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  805fec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  805ff0:	48 89 ce             	mov    %rcx,%rsi
  805ff3:	48 89 c7             	mov    %rax,%rdi
  805ff6:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  805ffd:	00 00 00 
  806000:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  806002:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806006:	48 89 c7             	mov    %rax,%rdi
  806009:	48 b8 bb 5c 80 00 00 	movabs $0x805cbb,%rax
  806010:	00 00 00 
  806013:	ff d0                	callq  *%rax
  806015:	89 45 d8             	mov    %eax,-0x28(%rbp)
  if (newsock == -1) {
  806018:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%rbp)
  80601c:	75 3b                	jne    806059 <lwip_accept+0x219>
    netconn_delete(newconn);
  80601e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806022:	48 89 c7             	mov    %rax,%rdi
  806025:	48 b8 ae 9a 81 00 00 	movabs $0x819aae,%rax
  80602c:	00 00 00 
  80602f:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  806031:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806035:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  80603c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806040:	8b 50 18             	mov    0x18(%rax),%edx
  806043:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80604a:	00 00 00 
  80604d:	89 10                	mov    %edx,(%rax)
    return -1;
  80604f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806054:	e9 13 01 00 00       	jmpq   80616c <lwip_accept+0x32c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  806059:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80605d:	78 06                	js     806065 <lwip_accept+0x225>
  80605f:	83 7d d8 1f          	cmpl   $0x1f,-0x28(%rbp)
  806063:	7e 2a                	jle    80608f <lwip_accept+0x24f>
  806065:	48 ba fc 14 82 00 00 	movabs $0x8214fc,%rdx
  80606c:	00 00 00 
  80606f:	be 25 01 00 00       	mov    $0x125,%esi
  806074:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  80607b:	00 00 00 
  80607e:	b8 00 00 00 00       	mov    $0x0,%eax
  806083:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80608a:	00 00 00 
  80608d:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  80608f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806093:	48 bb ff 75 80 00 00 	movabs $0x8075ff,%rbx
  80609a:	00 00 00 
  80609d:	48 89 58 38          	mov    %rbx,0x38(%rax)
  nsock = &sockets[newsock];
  8060a1:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8060a4:	48 98                	cltq   
  8060a6:	48 c1 e0 05          	shl    $0x5,%rax
  8060aa:	48 89 c2             	mov    %rax,%rdx
  8060ad:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8060b4:	00 00 00 
  8060b7:	48 01 d0             	add    %rdx,%rax
  8060ba:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  8060be:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8060c3:	75 2a                	jne    8060ef <lwip_accept+0x2af>
  8060c5:	48 ba 28 15 82 00 00 	movabs $0x821528,%rdx
  8060cc:	00 00 00 
  8060cf:	be 28 01 00 00       	mov    $0x128,%esi
  8060d4:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8060db:	00 00 00 
  8060de:	b8 00 00 00 00       	mov    $0x0,%eax
  8060e3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8060ea:	00 00 00 
  8060ed:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  8060ef:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8060f6:	00 00 00 
  8060f9:	8b 00                	mov    (%rax),%eax
  8060fb:	89 c7                	mov    %eax,%edi
  8060fd:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  806104:	00 00 00 
  806107:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  806109:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80610d:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  806111:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806115:	8b 40 20             	mov    0x20(%rax),%eax
  806118:	29 c2                	sub    %eax,%edx
  80611a:	89 d0                	mov    %edx,%eax
  80611c:	8d 50 ff             	lea    -0x1(%rax),%edx
  80611f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806123:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  806127:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80612b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80612e:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  806131:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806138:	00 00 00 
  80613b:	8b 00                	mov    (%rax),%eax
  80613d:	89 c7                	mov    %eax,%edi
  80613f:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  806146:	00 00 00 
  806149:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  80614b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80614f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806156:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80615a:	8b 50 18             	mov    0x18(%rax),%edx
  80615d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806164:	00 00 00 
  806167:	89 10                	mov    %edx,(%rax)
  return newsock;
  806169:	8b 45 d8             	mov    -0x28(%rbp),%eax
}
  80616c:	48 83 c4 78          	add    $0x78,%rsp
  806170:	5b                   	pop    %rbx
  806171:	5d                   	pop    %rbp
  806172:	c3                   	retq   

0000000000806173 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  806173:	55                   	push   %rbp
  806174:	48 89 e5             	mov    %rsp,%rbp
  806177:	48 83 ec 20          	sub    $0x20,%rsp
  80617b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80617e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806182:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  806185:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806188:	89 c7                	mov    %eax,%edi
  80618a:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806191:	00 00 00 
  806194:	ff d0                	callq  *%rax
  806196:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  80619a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80619f:	75 0a                	jne    8061ab <lwip_bind+0x38>
    return -1;
  8061a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8061a6:	e9 fb 00 00 00       	jmpq   8062a6 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8061ab:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  8061af:	75 0c                	jne    8061bd <lwip_bind+0x4a>
  8061b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061b5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8061b9:	3c 02                	cmp    $0x2,%al
  8061bb:	74 2a                	je     8061e7 <lwip_bind+0x74>
  8061bd:	48 ba 3f 15 82 00 00 	movabs $0x82153f,%rdx
  8061c4:	00 00 00 
  8061c7:	be 4a 01 00 00       	mov    $0x14a,%esi
  8061cc:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8061d3:	00 00 00 
  8061d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8061db:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8061e2:	00 00 00 
  8061e5:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8061e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061eb:	8b 40 04             	mov    0x4(%rax),%eax
  8061ee:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  8061f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061f5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8061f9:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8061fd:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806201:	89 c7                	mov    %eax,%edi
  806203:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  80620a:	00 00 00 
  80620d:	ff d0                	callq  *%rax
  80620f:	0f b7 d0             	movzwl %ax,%edx
  806212:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806216:	48 8b 00             	mov    (%rax),%rax
  806219:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80621d:	48 89 ce             	mov    %rcx,%rsi
  806220:	48 89 c7             	mov    %rax,%rdi
  806223:	48 b8 52 9c 81 00 00 	movabs $0x819c52,%rax
  80622a:	00 00 00 
  80622d:	ff d0                	callq  *%rax
  80622f:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  806232:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  806236:	74 4b                	je     806283 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806238:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  80623c:	f7 d8                	neg    %eax
  80623e:	83 f8 0e             	cmp    $0xe,%eax
  806241:	77 1a                	ja     80625d <lwip_bind+0xea>
  806243:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  806247:	f7 d8                	neg    %eax
  806249:	89 c2                	mov    %eax,%edx
  80624b:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  806252:	00 00 00 
  806255:	48 63 d2             	movslq %edx,%rdx
  806258:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80625b:	eb 05                	jmp    806262 <lwip_bind+0xef>
  80625d:	b8 05 00 00 00       	mov    $0x5,%eax
  806262:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806266:	89 42 18             	mov    %eax,0x18(%rdx)
  806269:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80626d:	8b 50 18             	mov    0x18(%rax),%edx
  806270:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806277:	00 00 00 
  80627a:	89 10                	mov    %edx,(%rax)
    return -1;
  80627c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806281:	eb 23                	jmp    8062a6 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  806283:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806287:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80628e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806292:	8b 50 18             	mov    0x18(%rax),%edx
  806295:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80629c:	00 00 00 
  80629f:	89 10                	mov    %edx,(%rax)
  return 0;
  8062a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8062a6:	c9                   	leaveq 
  8062a7:	c3                   	retq   

00000000008062a8 <lwip_close>:

int
lwip_close(int s)
{
  8062a8:	55                   	push   %rbp
  8062a9:	48 89 e5             	mov    %rsp,%rbp
  8062ac:	48 83 ec 20          	sub    $0x20,%rsp
  8062b0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8062b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8062b6:	89 c7                	mov    %eax,%edi
  8062b8:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  8062bf:	00 00 00 
  8062c2:	ff d0                	callq  *%rax
  8062c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  8062c8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8062cd:	75 0a                	jne    8062d9 <lwip_close+0x31>
    return -1;
  8062cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8062d4:	e9 b2 00 00 00       	jmpq   80638b <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  8062d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062dd:	48 8b 00             	mov    (%rax),%rax
  8062e0:	48 89 c7             	mov    %rax,%rdi
  8062e3:	48 b8 ae 9a 81 00 00 	movabs $0x819aae,%rax
  8062ea:	00 00 00 
  8062ed:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  8062ef:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8062f6:	00 00 00 
  8062f9:	8b 00                	mov    (%rax),%eax
  8062fb:	89 c7                	mov    %eax,%edi
  8062fd:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  806304:	00 00 00 
  806307:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  806309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80630d:	48 8b 40 08          	mov    0x8(%rax),%rax
  806311:	48 85 c0             	test   %rax,%rax
  806314:	74 17                	je     80632d <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  806316:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80631a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80631e:	48 89 c7             	mov    %rax,%rdi
  806321:	48 b8 94 8d 80 00 00 	movabs $0x808d94,%rax
  806328:	00 00 00 
  80632b:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  80632d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806331:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806338:	00 
  sock->lastoffset = 0;
  806339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80633d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  806343:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806347:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  80634e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806352:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80635d:	8b 50 18             	mov    0x18(%rax),%edx
  806360:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806367:	00 00 00 
  80636a:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  80636c:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806373:	00 00 00 
  806376:	8b 00                	mov    (%rax),%eax
  806378:	89 c7                	mov    %eax,%edi
  80637a:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  806381:	00 00 00 
  806384:	ff d0                	callq  *%rax
  return 0;
  806386:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80638b:	c9                   	leaveq 
  80638c:	c3                   	retq   

000000000080638d <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80638d:	55                   	push   %rbp
  80638e:	48 89 e5             	mov    %rsp,%rbp
  806391:	48 83 ec 30          	sub    $0x30,%rsp
  806395:	89 7d dc             	mov    %edi,-0x24(%rbp)
  806398:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80639c:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80639f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8063a2:	89 c7                	mov    %eax,%edi
  8063a4:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  8063ab:	00 00 00 
  8063ae:	ff d0                	callq  *%rax
  8063b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8063b4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8063b9:	75 0a                	jne    8063c5 <lwip_connect+0x38>
    return -1;
  8063bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063c0:	e9 22 01 00 00       	jmpq   8064e7 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8063c5:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8063c9:	75 0c                	jne    8063d7 <lwip_connect+0x4a>
  8063cb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8063cf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8063d3:	3c 02                	cmp    $0x2,%al
  8063d5:	74 2a                	je     806401 <lwip_connect+0x74>
  8063d7:	48 ba 5a 15 82 00 00 	movabs $0x82155a,%rdx
  8063de:	00 00 00 
  8063e1:	be 86 01 00 00       	mov    $0x186,%esi
  8063e6:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8063ed:	00 00 00 
  8063f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8063f5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8063fc:	00 00 00 
  8063ff:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  806401:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806405:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806409:	84 c0                	test   %al,%al
  80640b:	75 1b                	jne    806428 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  80640d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806411:	48 8b 00             	mov    (%rax),%rax
  806414:	48 89 c7             	mov    %rax,%rdi
  806417:	48 b8 66 9d 81 00 00 	movabs $0x819d66,%rax
  80641e:	00 00 00 
  806421:	ff d0                	callq  *%rax
  806423:	88 45 ff             	mov    %al,-0x1(%rbp)
  806426:	eb 4b                	jmp    806473 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  806428:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80642c:	8b 40 04             	mov    0x4(%rax),%eax
  80642f:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  806432:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806436:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80643a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80643e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806442:	89 c7                	mov    %eax,%edi
  806444:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  80644b:	00 00 00 
  80644e:	ff d0                	callq  *%rax
  806450:	0f b7 d0             	movzwl %ax,%edx
  806453:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806457:	48 8b 00             	mov    (%rax),%rax
  80645a:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80645e:	48 89 ce             	mov    %rcx,%rsi
  806461:	48 89 c7             	mov    %rax,%rdi
  806464:	48 b8 dc 9c 81 00 00 	movabs $0x819cdc,%rax
  80646b:	00 00 00 
  80646e:	ff d0                	callq  *%rax
  806470:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  806473:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  806477:	74 4b                	je     8064c4 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806479:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  80647d:	f7 d8                	neg    %eax
  80647f:	83 f8 0e             	cmp    $0xe,%eax
  806482:	77 1a                	ja     80649e <lwip_connect+0x111>
  806484:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  806488:	f7 d8                	neg    %eax
  80648a:	89 c2                	mov    %eax,%edx
  80648c:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  806493:	00 00 00 
  806496:	48 63 d2             	movslq %edx,%rdx
  806499:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80649c:	eb 05                	jmp    8064a3 <lwip_connect+0x116>
  80649e:	b8 05 00 00 00       	mov    $0x5,%eax
  8064a3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8064a7:	89 42 18             	mov    %eax,0x18(%rdx)
  8064aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064ae:	8b 50 18             	mov    0x18(%rax),%edx
  8064b1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8064b8:	00 00 00 
  8064bb:	89 10                	mov    %edx,(%rax)
    return -1;
  8064bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064c2:	eb 23                	jmp    8064e7 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8064c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064c8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8064cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064d3:	8b 50 18             	mov    0x18(%rax),%edx
  8064d6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8064dd:	00 00 00 
  8064e0:	89 10                	mov    %edx,(%rax)
  return 0;
  8064e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8064e7:	c9                   	leaveq 
  8064e8:	c3                   	retq   

00000000008064e9 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8064e9:	55                   	push   %rbp
  8064ea:	48 89 e5             	mov    %rsp,%rbp
  8064ed:	48 83 ec 20          	sub    $0x20,%rsp
  8064f1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8064f4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8064f7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8064fa:	89 c7                	mov    %eax,%edi
  8064fc:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806503:	00 00 00 
  806506:	ff d0                	callq  *%rax
  806508:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  80650c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806511:	75 0a                	jne    80651d <lwip_listen+0x34>
    return -1;
  806513:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806518:	e9 b2 00 00 00       	jmpq   8065cf <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  80651d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806521:	79 07                	jns    80652a <lwip_listen+0x41>
    backlog = 0;
  806523:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80652a:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806531:	7e 07                	jle    80653a <lwip_listen+0x51>
    backlog = 0xff;
  806533:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80653a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80653d:	0f b6 d0             	movzbl %al,%edx
  806540:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806544:	48 8b 00             	mov    (%rax),%rax
  806547:	89 d6                	mov    %edx,%esi
  806549:	48 89 c7             	mov    %rax,%rdi
  80654c:	48 b8 d6 9d 81 00 00 	movabs $0x819dd6,%rax
  806553:	00 00 00 
  806556:	ff d0                	callq  *%rax
  806558:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80655b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80655f:	74 4b                	je     8065ac <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806561:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806565:	f7 d8                	neg    %eax
  806567:	83 f8 0e             	cmp    $0xe,%eax
  80656a:	77 1a                	ja     806586 <lwip_listen+0x9d>
  80656c:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806570:	f7 d8                	neg    %eax
  806572:	89 c2                	mov    %eax,%edx
  806574:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  80657b:	00 00 00 
  80657e:	48 63 d2             	movslq %edx,%rdx
  806581:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806584:	eb 05                	jmp    80658b <lwip_listen+0xa2>
  806586:	b8 05 00 00 00       	mov    $0x5,%eax
  80658b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80658f:	89 42 18             	mov    %eax,0x18(%rdx)
  806592:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806596:	8b 50 18             	mov    0x18(%rax),%edx
  806599:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8065a0:	00 00 00 
  8065a3:	89 10                	mov    %edx,(%rax)
    return -1;
  8065a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8065aa:	eb 23                	jmp    8065cf <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  8065ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065b0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8065b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065bb:	8b 50 18             	mov    0x18(%rax),%edx
  8065be:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8065c5:	00 00 00 
  8065c8:	89 10                	mov    %edx,(%rax)
  return 0;
  8065ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8065cf:	c9                   	leaveq 
  8065d0:	c3                   	retq   

00000000008065d1 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8065d1:	55                   	push   %rbp
  8065d2:	48 89 e5             	mov    %rsp,%rbp
  8065d5:	48 83 ec 70          	sub    $0x70,%rsp
  8065d9:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8065dc:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8065e0:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8065e3:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  8065e6:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  8065ea:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  8065ee:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  8065f4:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8065f8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8065fb:	89 c7                	mov    %eax,%edi
  8065fd:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806604:	00 00 00 
  806607:	ff d0                	callq  *%rax
  806609:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  80660d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806612:	75 0a                	jne    80661e <lwip_recvfrom+0x4d>
    return -1;
  806614:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806619:	e9 8b 03 00 00       	jmpq   8069a9 <lwip_recvfrom+0x3d8>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80661e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806622:	48 8b 40 08          	mov    0x8(%rax),%rax
  806626:	48 85 c0             	test   %rax,%rax
  806629:	74 11                	je     80663c <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80662b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80662f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806633:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806637:	e9 0c 01 00 00       	jmpq   806748 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80663c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80663f:	83 e0 08             	and    $0x8,%eax
  806642:	85 c0                	test   %eax,%eax
  806644:	75 14                	jne    80665a <lwip_recvfrom+0x89>
  806646:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80664a:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80664e:	0f b7 c0             	movzwl %ax,%eax
  806651:	25 00 08 00 00       	and    $0x800,%eax
  806656:	85 c0                	test   %eax,%eax
  806658:	74 35                	je     80668f <lwip_recvfrom+0xbe>
  80665a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80665e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806662:	66 85 c0             	test   %ax,%ax
  806665:	75 28                	jne    80668f <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  806667:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80666b:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806672:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806676:	8b 50 18             	mov    0x18(%rax),%edx
  806679:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806680:	00 00 00 
  806683:	89 10                	mov    %edx,(%rax)
        return -1;
  806685:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80668a:	e9 1a 03 00 00       	jmpq   8069a9 <lwip_recvfrom+0x3d8>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80668f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806693:	48 8b 00             	mov    (%rax),%rax
  806696:	48 89 c7             	mov    %rax,%rdi
  806699:	48 b8 0d 9f 81 00 00 	movabs $0x819f0d,%rax
  8066a0:	00 00 00 
  8066a3:	ff d0                	callq  *%rax
  8066a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8066a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066ad:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8066b1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8066b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8066ba:	0f 85 88 00 00 00    	jne    806748 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8066c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066c4:	48 8b 00             	mov    (%rax),%rax
  8066c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8066cb:	48 85 c0             	test   %rax,%rax
  8066ce:	74 0f                	je     8066df <lwip_recvfrom+0x10e>
  8066d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066d4:	48 8b 00             	mov    (%rax),%rax
  8066d7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8066db:	84 c0                	test   %al,%al
  8066dd:	74 40                	je     80671f <lwip_recvfrom+0x14e>
  8066df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066e3:	48 8b 00             	mov    (%rax),%rax
  8066e6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8066ea:	0f be c0             	movsbl %al,%eax
  8066ed:	f7 d8                	neg    %eax
  8066ef:	83 f8 0e             	cmp    $0xe,%eax
  8066f2:	77 24                	ja     806718 <lwip_recvfrom+0x147>
  8066f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066f8:	48 8b 00             	mov    (%rax),%rax
  8066fb:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8066ff:	0f be c0             	movsbl %al,%eax
  806702:	f7 d8                	neg    %eax
  806704:	89 c2                	mov    %eax,%edx
  806706:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  80670d:	00 00 00 
  806710:	48 63 d2             	movslq %edx,%rdx
  806713:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806716:	eb 05                	jmp    80671d <lwip_recvfrom+0x14c>
  806718:	b8 05 00 00 00       	mov    $0x5,%eax
  80671d:	eb 05                	jmp    806724 <lwip_recvfrom+0x153>
  80671f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806724:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  806728:	89 42 18             	mov    %eax,0x18(%rdx)
  80672b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80672f:	8b 50 18             	mov    0x18(%rax),%edx
  806732:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806739:	00 00 00 
  80673c:	89 10                	mov    %edx,(%rax)
        return 0;
  80673e:	b8 00 00 00 00       	mov    $0x0,%eax
  806743:	e9 61 02 00 00       	jmpq   8069a9 <lwip_recvfrom+0x3d8>
      }
    }

    buflen = netbuf_len(buf);
  806748:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80674c:	48 8b 00             	mov    (%rax),%rax
  80674f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806753:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  806757:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80675b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80675f:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806763:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806767:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80676a:	7d 0a                	jge    806776 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80676c:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806770:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806774:	eb 07                	jmp    80677d <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806776:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806779:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80677d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806781:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806785:	0f b7 c8             	movzwl %ax,%ecx
  806788:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80678c:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  806790:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  806794:	48 01 c6             	add    %rax,%rsi
  806797:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80679b:	48 8b 00             	mov    (%rax),%rax
  80679e:	48 89 c7             	mov    %rax,%rdi
  8067a1:	48 b8 2d e3 80 00 00 	movabs $0x80e32d,%rax
  8067a8:	00 00 00 
  8067ab:	ff d0                	callq  *%rax

    off += copylen;
  8067ad:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8067b1:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8067b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067b9:	48 8b 00             	mov    (%rax),%rax
  8067bc:	48 89 c7             	mov    %rax,%rdi
  8067bf:	48 b8 17 9b 81 00 00 	movabs $0x819b17,%rax
  8067c6:	00 00 00 
  8067c9:	ff d0                	callq  *%rax
  8067cb:	83 f8 10             	cmp    $0x10,%eax
  8067ce:	75 35                	jne    806805 <lwip_recvfrom+0x234>
      len -= copylen;
  8067d0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8067d4:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8067d7:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8067db:	7e 22                	jle    8067ff <lwip_recvfrom+0x22e>
  8067dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8067e1:	48 8b 00             	mov    (%rax),%rax
  8067e4:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  8067e8:	0f b6 c0             	movzbl %al,%eax
  8067eb:	83 e0 01             	and    $0x1,%eax
  8067ee:	85 c0                	test   %eax,%eax
  8067f0:	75 0d                	jne    8067ff <lwip_recvfrom+0x22e>
  8067f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067f6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8067fa:	66 85 c0             	test   %ax,%ax
  8067fd:	75 0a                	jne    806809 <lwip_recvfrom+0x238>
        done = 1;
  8067ff:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  806803:	eb 04                	jmp    806809 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  806805:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  806809:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80680c:	83 e0 01             	and    $0x1,%eax
  80680f:	85 c0                	test   %eax,%eax
  806811:	75 6e                	jne    806881 <lwip_recvfrom+0x2b0>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806813:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806817:	48 8b 00             	mov    (%rax),%rax
  80681a:	8b 00                	mov    (%rax),%eax
  80681c:	83 f8 10             	cmp    $0x10,%eax
  80681f:	75 35                	jne    806856 <lwip_recvfrom+0x285>
  806821:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806825:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806829:	29 c2                	sub    %eax,%edx
  80682b:	89 d0                	mov    %edx,%eax
  80682d:	85 c0                	test   %eax,%eax
  80682f:	7e 25                	jle    806856 <lwip_recvfrom+0x285>
        sock->lastdata = buf;
  806831:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806835:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806839:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  80683d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806841:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  806845:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806849:	01 c2                	add    %eax,%edx
  80684b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80684f:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806853:	90                   	nop
  806854:	eb 2f                	jmp    806885 <lwip_recvfrom+0x2b4>
      } else {
        sock->lastdata = NULL;
  806856:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80685a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806861:	00 
        sock->lastoffset = 0;
  806862:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806866:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80686c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806870:	48 89 c7             	mov    %rax,%rdi
  806873:	48 b8 94 8d 80 00 00 	movabs $0x808d94,%rax
  80687a:	00 00 00 
  80687d:	ff d0                	callq  *%rax
  80687f:	eb 04                	jmp    806885 <lwip_recvfrom+0x2b4>
      }
    } else {
      done = 1;
  806881:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  806885:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  806889:	0f 84 8f fd ff ff    	je     80661e <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80688f:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806894:	0f 84 ed 00 00 00    	je     806987 <lwip_recvfrom+0x3b6>
  80689a:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  80689f:	0f 84 e2 00 00 00    	je     806987 <lwip_recvfrom+0x3b6>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8068a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068a9:	48 8b 00             	mov    (%rax),%rax
  8068ac:	48 89 c7             	mov    %rax,%rdi
  8068af:	48 b8 17 9b 81 00 00 	movabs $0x819b17,%rax
  8068b6:	00 00 00 
  8068b9:	ff d0                	callq  *%rax
  8068bb:	83 f8 10             	cmp    $0x10,%eax
  8068be:	75 31                	jne    8068f1 <lwip_recvfrom+0x320>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8068c0:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8068c4:	48 83 c0 04          	add    $0x4,%rax
  8068c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8068cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068d0:	48 8b 00             	mov    (%rax),%rax
  8068d3:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8068d7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8068db:	b9 00 00 00 00       	mov    $0x0,%ecx
  8068e0:	48 89 c7             	mov    %rax,%rdi
  8068e3:	48 b8 5c 9b 81 00 00 	movabs $0x819b5c,%rax
  8068ea:	00 00 00 
  8068ed:	ff d0                	callq  *%rax
  8068ef:	eb 18                	jmp    806909 <lwip_recvfrom+0x338>
    } else {
      addr = netbuf_fromaddr(buf);
  8068f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8068f5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8068f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  8068fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806901:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  806905:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  806909:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80690d:	ba 10 00 00 00       	mov    $0x10,%edx
  806912:	be 00 00 00 00       	mov    $0x0,%esi
  806917:	48 89 c7             	mov    %rax,%rdi
  80691a:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  806921:	00 00 00 
  806924:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806926:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  80692a:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  80692e:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806932:	0f b7 c0             	movzwl %ax,%eax
  806935:	89 c7                	mov    %eax,%edi
  806937:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  80693e:	00 00 00 
  806941:	ff d0                	callq  *%rax
  806943:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806947:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80694b:	8b 00                	mov    (%rax),%eax
  80694d:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806950:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806954:	8b 00                	mov    (%rax),%eax
  806956:	83 f8 10             	cmp    $0x10,%eax
  806959:	76 0a                	jbe    806965 <lwip_recvfrom+0x394>
      *fromlen = sizeof(sin);
  80695b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80695f:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806965:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806969:	8b 00                	mov    (%rax),%eax
  80696b:	89 c2                	mov    %eax,%edx
  80696d:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806971:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806975:	48 89 ce             	mov    %rcx,%rsi
  806978:	48 89 c7             	mov    %rax,%rdi
  80697b:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  806982:	00 00 00 
  806985:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806987:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80698b:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806992:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806996:	8b 50 18             	mov    0x18(%rax),%edx
  806999:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8069a0:	00 00 00 
  8069a3:	89 10                	mov    %edx,(%rax)
  return off;
  8069a5:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  8069a9:	c9                   	leaveq 
  8069aa:	c3                   	retq   

00000000008069ab <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8069ab:	55                   	push   %rbp
  8069ac:	48 89 e5             	mov    %rsp,%rbp
  8069af:	48 83 ec 10          	sub    $0x10,%rsp
  8069b3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8069b6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8069ba:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8069bd:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8069c0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8069c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8069c7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8069cd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8069d3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8069d8:	89 c7                	mov    %eax,%edi
  8069da:	48 b8 d1 65 80 00 00 	movabs $0x8065d1,%rax
  8069e1:	00 00 00 
  8069e4:	ff d0                	callq  *%rax
}
  8069e6:	c9                   	leaveq 
  8069e7:	c3                   	retq   

00000000008069e8 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8069e8:	55                   	push   %rbp
  8069e9:	48 89 e5             	mov    %rsp,%rbp
  8069ec:	48 83 ec 20          	sub    $0x20,%rsp
  8069f0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8069f3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8069f7:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8069fa:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8069fd:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  806a00:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806a03:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806a07:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806a0a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806a10:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806a16:	89 c7                	mov    %eax,%edi
  806a18:	48 b8 d1 65 80 00 00 	movabs $0x8065d1,%rax
  806a1f:	00 00 00 
  806a22:	ff d0                	callq  *%rax
}
  806a24:	c9                   	leaveq 
  806a25:	c3                   	retq   

0000000000806a26 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806a26:	55                   	push   %rbp
  806a27:	48 89 e5             	mov    %rsp,%rbp
  806a2a:	48 83 ec 30          	sub    $0x30,%rsp
  806a2e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806a31:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806a35:	89 55 e8             	mov    %edx,-0x18(%rbp)
  806a38:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  806a3b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806a3e:	89 c7                	mov    %eax,%edi
  806a40:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806a47:	00 00 00 
  806a4a:	ff d0                	callq  *%rax
  806a4c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806a50:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806a55:	75 0a                	jne    806a61 <lwip_send+0x3b>
    return -1;
  806a57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806a5c:	e9 c3 00 00 00       	jmpq   806b24 <lwip_send+0xfe>

  if (sock->conn->type!=NETCONN_TCP) {
  806a61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806a65:	48 8b 00             	mov    (%rax),%rax
  806a68:	8b 00                	mov    (%rax),%eax
  806a6a:	83 f8 10             	cmp    $0x10,%eax
  806a6d:	74 2c                	je     806a9b <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806a6f:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806a72:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806a75:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806a79:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806a7c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806a82:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806a88:	89 c7                	mov    %eax,%edi
  806a8a:	48 b8 26 6b 80 00 00 	movabs $0x806b26,%rax
  806a91:	00 00 00 
  806a94:	ff d0                	callq  *%rax
  806a96:	e9 89 00 00 00       	jmpq   806b24 <lwip_send+0xfe>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  806a9b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806a9e:	83 e0 10             	and    $0x10,%eax
  806aa1:	85 c0                	test   %eax,%eax
  806aa3:	74 07                	je     806aac <lwip_send+0x86>
  806aa5:	b8 03 00 00 00       	mov    $0x3,%eax
  806aaa:	eb 05                	jmp    806ab1 <lwip_send+0x8b>
  806aac:	b8 01 00 00 00       	mov    $0x1,%eax
  806ab1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806ab5:	48 8b 3a             	mov    (%rdx),%rdi
  806ab8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806abb:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806abf:	89 c1                	mov    %eax,%ecx
  806ac1:	48 b8 6b a2 81 00 00 	movabs $0x81a26b,%rax
  806ac8:	00 00 00 
  806acb:	ff d0                	callq  *%rax
  806acd:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  806ad0:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806ad4:	f7 d8                	neg    %eax
  806ad6:	83 f8 0e             	cmp    $0xe,%eax
  806ad9:	77 1a                	ja     806af5 <lwip_send+0xcf>
  806adb:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806adf:	f7 d8                	neg    %eax
  806ae1:	89 c2                	mov    %eax,%edx
  806ae3:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  806aea:	00 00 00 
  806aed:	48 63 d2             	movslq %edx,%rdx
  806af0:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806af3:	eb 05                	jmp    806afa <lwip_send+0xd4>
  806af5:	b8 05 00 00 00       	mov    $0x5,%eax
  806afa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806afe:	89 42 18             	mov    %eax,0x18(%rdx)
  806b01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b05:	8b 50 18             	mov    0x18(%rax),%edx
  806b08:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806b0f:	00 00 00 
  806b12:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806b14:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806b18:	75 05                	jne    806b1f <lwip_send+0xf9>
  806b1a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806b1d:	eb 05                	jmp    806b24 <lwip_send+0xfe>
  806b1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806b24:	c9                   	leaveq 
  806b25:	c3                   	retq   

0000000000806b26 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806b26:	55                   	push   %rbp
  806b27:	48 89 e5             	mov    %rsp,%rbp
  806b2a:	48 83 ec 60          	sub    $0x60,%rsp
  806b2e:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806b31:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806b35:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806b38:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806b3b:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806b3f:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806b43:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806b46:	89 c7                	mov    %eax,%edi
  806b48:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806b4f:	00 00 00 
  806b52:	ff d0                	callq  *%rax
  806b54:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806b58:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806b5d:	75 0a                	jne    806b69 <lwip_sendto+0x43>
    return -1;
  806b5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b64:	e9 d8 01 00 00       	jmpq   806d41 <lwip_sendto+0x21b>

  if (sock->conn->type==NETCONN_TCP) {
  806b69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806b6d:	48 8b 00             	mov    (%rax),%rax
  806b70:	8b 00                	mov    (%rax),%eax
  806b72:	83 f8 10             	cmp    $0x10,%eax
  806b75:	75 20                	jne    806b97 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806b77:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  806b7a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  806b7d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806b81:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806b84:	89 c7                	mov    %eax,%edi
  806b86:	48 b8 26 6a 80 00 00 	movabs $0x806a26,%rax
  806b8d:	00 00 00 
  806b90:	ff d0                	callq  *%rax
  806b92:	e9 aa 01 00 00       	jmpq   806d41 <lwip_sendto+0x21b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806b97:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  806b9b:	78 09                	js     806ba6 <lwip_sendto+0x80>
  806b9d:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806ba4:	7e 2a                	jle    806bd0 <lwip_sendto+0xaa>
  806ba6:	48 ba 78 15 82 00 00 	movabs $0x821578,%rdx
  806bad:	00 00 00 
  806bb0:	be 97 02 00 00       	mov    $0x297,%esi
  806bb5:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  806bbc:	00 00 00 
  806bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  806bc4:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  806bcb:	00 00 00 
  806bce:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  806bd0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806bd5:	75 06                	jne    806bdd <lwip_sendto+0xb7>
  806bd7:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  806bdb:	74 3c                	je     806c19 <lwip_sendto+0xf3>
  806bdd:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  806be1:	75 0c                	jne    806bef <lwip_sendto+0xc9>
  806be3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806be7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806beb:	3c 02                	cmp    $0x2,%al
  806bed:	74 2a                	je     806c19 <lwip_sendto+0xf3>
  806bef:	48 ba 9c 15 82 00 00 	movabs $0x82159c,%rdx
  806bf6:	00 00 00 
  806bf9:	be 9b 02 00 00       	mov    $0x29b,%esi
  806bfe:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  806c05:	00 00 00 
  806c08:	b8 00 00 00 00       	mov    $0x0,%eax
  806c0d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  806c14:	00 00 00 
  806c17:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806c19:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806c20:	00 
  806c21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806c25:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806c29:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806c2e:	74 39                	je     806c69 <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806c30:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806c34:	8b 40 04             	mov    0x4(%rax),%eax
  806c37:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806c3a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806c3e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806c42:	0f b7 c0             	movzwl %ax,%eax
  806c45:	89 c7                	mov    %eax,%edi
  806c47:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  806c4e:	00 00 00 
  806c51:	ff d0                	callq  *%rax
  806c53:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806c57:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806c5b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806c5f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806c63:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806c67:	eb 1b                	jmp    806c84 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806c69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806c70:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806c76:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  806c7d:	00 
    buf.port         = 0;
  806c7e:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806c84:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806c87:	0f b7 d0             	movzwl %ax,%edx
  806c8a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806c8e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806c92:	48 89 ce             	mov    %rcx,%rsi
  806c95:	48 89 c7             	mov    %rax,%rdi
  806c98:	48 b8 6c 8f 80 00 00 	movabs $0x808f6c,%rax
  806c9f:	00 00 00 
  806ca2:	ff d0                	callq  *%rax
  806ca4:	0f be c0             	movsbl %al,%eax
  806ca7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806caa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806cae:	75 23                	jne    806cd3 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  806cb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806cb4:	48 8b 00             	mov    (%rax),%rax
  806cb7:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  806cbb:	48 89 d6             	mov    %rdx,%rsi
  806cbe:	48 89 c7             	mov    %rax,%rdi
  806cc1:	48 b8 ef a1 81 00 00 	movabs $0x81a1ef,%rax
  806cc8:	00 00 00 
  806ccb:	ff d0                	callq  *%rax
  806ccd:	0f be c0             	movsbl %al,%eax
  806cd0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  806cd3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806cd7:	48 85 c0             	test   %rax,%rax
  806cda:	74 13                	je     806cef <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  806cdc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806ce0:	48 89 c7             	mov    %rax,%rdi
  806ce3:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  806cea:	00 00 00 
  806ced:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806cef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806cf2:	f7 d8                	neg    %eax
  806cf4:	83 f8 0e             	cmp    $0xe,%eax
  806cf7:	77 19                	ja     806d12 <lwip_sendto+0x1ec>
  806cf9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806cfc:	f7 d8                	neg    %eax
  806cfe:	89 c2                	mov    %eax,%edx
  806d00:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  806d07:	00 00 00 
  806d0a:	48 63 d2             	movslq %edx,%rdx
  806d0d:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806d10:	eb 05                	jmp    806d17 <lwip_sendto+0x1f1>
  806d12:	b8 05 00 00 00       	mov    $0x5,%eax
  806d17:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806d1b:	89 42 18             	mov    %eax,0x18(%rdx)
  806d1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806d22:	8b 50 18             	mov    0x18(%rax),%edx
  806d25:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806d2c:	00 00 00 
  806d2f:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806d31:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806d35:	75 05                	jne    806d3c <lwip_sendto+0x216>
  806d37:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806d3a:	eb 05                	jmp    806d41 <lwip_sendto+0x21b>
  806d3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806d41:	c9                   	leaveq 
  806d42:	c3                   	retq   

0000000000806d43 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806d43:	55                   	push   %rbp
  806d44:	48 89 e5             	mov    %rsp,%rbp
  806d47:	48 83 ec 20          	sub    $0x20,%rsp
  806d4b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806d4e:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806d51:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806d54:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806d57:	83 f8 02             	cmp    $0x2,%eax
  806d5a:	74 38                	je     806d94 <lwip_socket+0x51>
  806d5c:	83 f8 03             	cmp    $0x3,%eax
  806d5f:	74 0a                	je     806d6b <lwip_socket+0x28>
  806d61:	83 f8 01             	cmp    $0x1,%eax
  806d64:	74 66                	je     806dcc <lwip_socket+0x89>
  806d66:	e9 87 00 00 00       	jmpq   806df2 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806d6b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806d6e:	0f b6 c0             	movzbl %al,%eax
  806d71:	48 ba ff 75 80 00 00 	movabs $0x8075ff,%rdx
  806d78:	00 00 00 
  806d7b:	89 c6                	mov    %eax,%esi
  806d7d:	bf 40 00 00 00       	mov    $0x40,%edi
  806d82:	48 b8 0b 99 81 00 00 	movabs $0x81990b,%rax
  806d89:	00 00 00 
  806d8c:	ff d0                	callq  *%rax
  806d8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806d92:	eb 78                	jmp    806e0c <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806d94:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806d9b:	75 07                	jne    806da4 <lwip_socket+0x61>
  806d9d:	b8 21 00 00 00       	mov    $0x21,%eax
  806da2:	eb 05                	jmp    806da9 <lwip_socket+0x66>
  806da4:	b8 20 00 00 00       	mov    $0x20,%eax
  806da9:	48 ba ff 75 80 00 00 	movabs $0x8075ff,%rdx
  806db0:	00 00 00 
  806db3:	be 00 00 00 00       	mov    $0x0,%esi
  806db8:	89 c7                	mov    %eax,%edi
  806dba:	48 b8 0b 99 81 00 00 	movabs $0x81990b,%rax
  806dc1:	00 00 00 
  806dc4:	ff d0                	callq  *%rax
  806dc6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806dca:	eb 40                	jmp    806e0c <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806dcc:	48 ba ff 75 80 00 00 	movabs $0x8075ff,%rdx
  806dd3:	00 00 00 
  806dd6:	be 00 00 00 00       	mov    $0x0,%esi
  806ddb:	bf 10 00 00 00       	mov    $0x10,%edi
  806de0:	48 b8 0b 99 81 00 00 	movabs $0x81990b,%rax
  806de7:	00 00 00 
  806dea:	ff d0                	callq  *%rax
  806dec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806df0:	eb 1a                	jmp    806e0c <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806df2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806df9:	00 00 00 
  806dfc:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806e02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806e07:	e9 81 00 00 00       	jmpq   806e8d <lwip_socket+0x14a>
  }

  if (!conn) {
  806e0c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806e11:	75 17                	jne    806e2a <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806e13:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806e1a:	00 00 00 
  806e1d:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806e23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806e28:	eb 63                	jmp    806e8d <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806e2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806e2e:	48 89 c7             	mov    %rax,%rdi
  806e31:	48 b8 bb 5c 80 00 00 	movabs $0x805cbb,%rax
  806e38:	00 00 00 
  806e3b:	ff d0                	callq  *%rax
  806e3d:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806e40:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806e44:	75 2a                	jne    806e70 <lwip_socket+0x12d>
    netconn_delete(conn);
  806e46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806e4a:	48 89 c7             	mov    %rax,%rdi
  806e4d:	48 b8 ae 9a 81 00 00 	movabs $0x819aae,%rax
  806e54:	00 00 00 
  806e57:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806e59:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806e60:	00 00 00 
  806e63:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806e69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806e6e:	eb 1d                	jmp    806e8d <lwip_socket+0x14a>
  }
  conn->socket = i;
  806e70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806e74:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806e77:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806e7a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806e81:	00 00 00 
  806e84:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806e8a:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806e8d:	c9                   	leaveq 
  806e8e:	c3                   	retq   

0000000000806e8f <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806e8f:	55                   	push   %rbp
  806e90:	48 89 e5             	mov    %rsp,%rbp
  806e93:	48 83 ec 10          	sub    $0x10,%rsp
  806e97:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806e9a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806e9e:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806ea1:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806ea4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806ea8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806eab:	b9 00 00 00 00       	mov    $0x0,%ecx
  806eb0:	89 c7                	mov    %eax,%edi
  806eb2:	48 b8 26 6a 80 00 00 	movabs $0x806a26,%rax
  806eb9:	00 00 00 
  806ebc:	ff d0                	callq  *%rax
}
  806ebe:	c9                   	leaveq 
  806ebf:	c3                   	retq   

0000000000806ec0 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806ec0:	55                   	push   %rbp
  806ec1:	48 89 e5             	mov    %rsp,%rbp
  806ec4:	48 83 ec 60          	sub    $0x60,%rsp
  806ec8:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806ecb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806ecf:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  806ed3:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  806ed7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  806ede:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806ee2:	ba 04 00 00 00       	mov    $0x4,%edx
  806ee7:	be 00 00 00 00       	mov    $0x0,%esi
  806eec:	48 89 c7             	mov    %rax,%rdi
  806eef:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  806ef6:	00 00 00 
  806ef9:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806efb:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806eff:	ba 04 00 00 00       	mov    $0x4,%edx
  806f04:	be 00 00 00 00       	mov    $0x0,%esi
  806f09:	48 89 c7             	mov    %rax,%rdi
  806f0c:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  806f13:	00 00 00 
  806f16:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806f18:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806f1c:	ba 04 00 00 00       	mov    $0x4,%edx
  806f21:	be 00 00 00 00       	mov    $0x0,%esi
  806f26:	48 89 c7             	mov    %rax,%rdi
  806f29:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  806f30:	00 00 00 
  806f33:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806f35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  806f3c:	e9 29 01 00 00       	jmpq   80706a <lwip_selscan+0x1aa>
    if (FD_ISSET(i, readset)) {
  806f41:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f44:	8d 50 07             	lea    0x7(%rax),%edx
  806f47:	85 c0                	test   %eax,%eax
  806f49:	0f 48 c2             	cmovs  %edx,%eax
  806f4c:	c1 f8 03             	sar    $0x3,%eax
  806f4f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  806f53:	48 98                	cltq   
  806f55:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806f59:	0f b6 d0             	movzbl %al,%edx
  806f5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f5f:	83 e0 07             	and    $0x7,%eax
  806f62:	89 c1                	mov    %eax,%ecx
  806f64:	d3 fa                	sar    %cl,%edx
  806f66:	89 d0                	mov    %edx,%eax
  806f68:	83 e0 01             	and    $0x1,%eax
  806f6b:	85 c0                	test   %eax,%eax
  806f6d:	74 6b                	je     806fda <lwip_selscan+0x11a>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  806f6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f72:	89 c7                	mov    %eax,%edi
  806f74:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  806f7b:	00 00 00 
  806f7e:	ff d0                	callq  *%rax
  806f80:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  806f84:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806f89:	74 4f                	je     806fda <lwip_selscan+0x11a>
  806f8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806f8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806f93:	48 85 c0             	test   %rax,%rax
  806f96:	75 0d                	jne    806fa5 <lwip_selscan+0xe5>
  806f98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806f9c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806fa0:	66 85 c0             	test   %ax,%ax
  806fa3:	74 35                	je     806fda <lwip_selscan+0x11a>
        FD_SET(i, &lreadset);
  806fa5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806fa8:	8d 50 07             	lea    0x7(%rax),%edx
  806fab:	85 c0                	test   %eax,%eax
  806fad:	0f 48 c2             	cmovs  %edx,%eax
  806fb0:	c1 f8 03             	sar    $0x3,%eax
  806fb3:	48 63 d0             	movslq %eax,%rdx
  806fb6:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  806fbb:	89 d6                	mov    %edx,%esi
  806fbd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  806fc0:	83 e2 07             	and    $0x7,%edx
  806fc3:	bf 01 00 00 00       	mov    $0x1,%edi
  806fc8:	89 d1                	mov    %edx,%ecx
  806fca:	d3 e7                	shl    %cl,%edi
  806fcc:	89 fa                	mov    %edi,%edx
  806fce:	09 f2                	or     %esi,%edx
  806fd0:	48 98                	cltq   
  806fd2:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  806fd6:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  806fda:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806fdd:	8d 50 07             	lea    0x7(%rax),%edx
  806fe0:	85 c0                	test   %eax,%eax
  806fe2:	0f 48 c2             	cmovs  %edx,%eax
  806fe5:	c1 f8 03             	sar    $0x3,%eax
  806fe8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  806fec:	48 98                	cltq   
  806fee:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806ff2:	0f b6 d0             	movzbl %al,%edx
  806ff5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806ff8:	83 e0 07             	and    $0x7,%eax
  806ffb:	89 c1                	mov    %eax,%ecx
  806ffd:	d3 fa                	sar    %cl,%edx
  806fff:	89 d0                	mov    %edx,%eax
  807001:	83 e0 01             	and    $0x1,%eax
  807004:	85 c0                	test   %eax,%eax
  807006:	74 5e                	je     807066 <lwip_selscan+0x1a6>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  807008:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80700b:	89 c7                	mov    %eax,%edi
  80700d:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  807014:	00 00 00 
  807017:	ff d0                	callq  *%rax
  807019:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  80701d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807022:	74 42                	je     807066 <lwip_selscan+0x1a6>
  807024:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807028:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  80702c:	66 85 c0             	test   %ax,%ax
  80702f:	74 35                	je     807066 <lwip_selscan+0x1a6>
        FD_SET(i, &lwriteset);
  807031:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807034:	8d 50 07             	lea    0x7(%rax),%edx
  807037:	85 c0                	test   %eax,%eax
  807039:	0f 48 c2             	cmovs  %edx,%eax
  80703c:	c1 f8 03             	sar    $0x3,%eax
  80703f:	48 63 d0             	movslq %eax,%rdx
  807042:	0f b6 54 15 d0       	movzbl -0x30(%rbp,%rdx,1),%edx
  807047:	89 d6                	mov    %edx,%esi
  807049:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80704c:	83 e2 07             	and    $0x7,%edx
  80704f:	bf 01 00 00 00       	mov    $0x1,%edi
  807054:	89 d1                	mov    %edx,%ecx
  807056:	d3 e7                	shl    %cl,%edi
  807058:	89 fa                	mov    %edi,%edx
  80705a:	09 f2                	or     %esi,%edx
  80705c:	48 98                	cltq   
  80705e:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  807062:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  807066:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80706a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80706d:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  807070:	0f 8c cb fe ff ff    	jl     806f41 <lwip_selscan+0x81>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  807076:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80707a:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80707d:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  80707f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807083:	8b 55 d0             	mov    -0x30(%rbp),%edx
  807086:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  807088:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80708c:	ba 04 00 00 00       	mov    $0x4,%edx
  807091:	be 00 00 00 00       	mov    $0x0,%esi
  807096:	48 89 c7             	mov    %rax,%rdi
  807099:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  8070a0:	00 00 00 
  8070a3:	ff d0                	callq  *%rax
  
  return nready;
  8070a5:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8070a8:	c9                   	leaveq 
  8070a9:	c3                   	retq   

00000000008070aa <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8070aa:	55                   	push   %rbp
  8070ab:	48 89 e5             	mov    %rsp,%rbp
  8070ae:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8070b5:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  8070b8:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8070bc:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8070c3:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8070ca:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  8070d1:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8070d8:	00 
  select_cb.readset = readset;
  8070d9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8070dd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  8070e1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8070e8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  8070ec:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8070f3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  8070f7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  8070fe:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807105:	00 00 00 
  807108:	8b 00                	mov    (%rax),%eax
  80710a:	89 c7                	mov    %eax,%edi
  80710c:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  807113:	00 00 00 
  807116:	ff d0                	callq  *%rax

  if (readset)
  807118:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80711d:	74 0b                	je     80712a <lwip_select+0x80>
    lreadset = *readset;
  80711f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807123:	8b 00                	mov    (%rax),%eax
  807125:	89 45 e0             	mov    %eax,-0x20(%rbp)
  807128:	eb 1d                	jmp    807147 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  80712a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80712e:	ba 04 00 00 00       	mov    $0x4,%edx
  807133:	be 00 00 00 00       	mov    $0x0,%esi
  807138:	48 89 c7             	mov    %rax,%rdi
  80713b:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807142:	00 00 00 
  807145:	ff d0                	callq  *%rax
  if (writeset)
  807147:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80714e:	00 
  80714f:	74 0e                	je     80715f <lwip_select+0xb5>
    lwriteset = *writeset;
  807151:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807158:	8b 00                	mov    (%rax),%eax
  80715a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80715d:	eb 1d                	jmp    80717c <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  80715f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807163:	ba 04 00 00 00       	mov    $0x4,%edx
  807168:	be 00 00 00 00       	mov    $0x0,%esi
  80716d:	48 89 c7             	mov    %rax,%rdi
  807170:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807177:	00 00 00 
  80717a:	ff d0                	callq  *%rax
  if (exceptset)
  80717c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807183:	00 
  807184:	74 0e                	je     807194 <lwip_select+0xea>
    lexceptset = *exceptset;
  807186:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80718d:	8b 00                	mov    (%rax),%eax
  80718f:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807192:	eb 1d                	jmp    8071b1 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  807194:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807198:	ba 04 00 00 00       	mov    $0x4,%edx
  80719d:	be 00 00 00 00       	mov    $0x0,%esi
  8071a2:	48 89 c7             	mov    %rax,%rdi
  8071a5:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  8071ac:	00 00 00 
  8071af:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8071b1:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8071b5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8071b9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8071bd:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8071c0:	89 c7                	mov    %eax,%edi
  8071c2:	48 b8 c0 6e 80 00 00 	movabs $0x806ec0,%rax
  8071c9:	00 00 00 
  8071cc:	ff d0                	callq  *%rax
  8071ce:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8071d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8071d5:	0f 85 b9 03 00 00    	jne    807594 <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8071db:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8071e2:	00 
  8071e3:	0f 84 d3 00 00 00    	je     8072bc <lwip_select+0x212>
  8071e9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8071f0:	48 8b 00             	mov    (%rax),%rax
  8071f3:	48 85 c0             	test   %rax,%rax
  8071f6:	0f 85 c0 00 00 00    	jne    8072bc <lwip_select+0x212>
  8071fc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807203:	48 8b 40 08          	mov    0x8(%rax),%rax
  807207:	48 85 c0             	test   %rax,%rax
  80720a:	0f 85 ac 00 00 00    	jne    8072bc <lwip_select+0x212>
      sys_sem_signal(selectsem);
  807210:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807217:	00 00 00 
  80721a:	8b 00                	mov    (%rax),%eax
  80721c:	89 c7                	mov    %eax,%edi
  80721e:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  807225:	00 00 00 
  807228:	ff d0                	callq  *%rax
      if (readset)
  80722a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80722f:	74 1d                	je     80724e <lwip_select+0x1a4>
        FD_ZERO(readset);
  807231:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807235:	ba 04 00 00 00       	mov    $0x4,%edx
  80723a:	be 00 00 00 00       	mov    $0x0,%esi
  80723f:	48 89 c7             	mov    %rax,%rdi
  807242:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807249:	00 00 00 
  80724c:	ff d0                	callq  *%rax
      if (writeset)
  80724e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807255:	00 
  807256:	74 20                	je     807278 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  807258:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80725f:	ba 04 00 00 00       	mov    $0x4,%edx
  807264:	be 00 00 00 00       	mov    $0x0,%esi
  807269:	48 89 c7             	mov    %rax,%rdi
  80726c:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807273:	00 00 00 
  807276:	ff d0                	callq  *%rax
      if (exceptset)
  807278:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80727f:	00 
  807280:	74 20                	je     8072a2 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  807282:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807289:	ba 04 00 00 00       	mov    $0x4,%edx
  80728e:	be 00 00 00 00       	mov    $0x0,%esi
  807293:	48 89 c7             	mov    %rax,%rdi
  807296:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  80729d:	00 00 00 
  8072a0:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8072a2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8072a9:	00 00 00 
  8072ac:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8072b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8072b7:	e9 41 03 00 00       	jmpq   8075fd <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8072bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8072c1:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  8072c8:	00 00 00 
  8072cb:	ff d0                	callq  *%rax
  8072cd:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8072d0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8072d7:	00 00 00 
  8072da:	48 8b 00             	mov    (%rax),%rax
  8072dd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  8072e1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8072e8:	00 00 00 
  8072eb:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  8072ef:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8072f2:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8072f9:	00 00 00 
  8072fc:	8b 00                	mov    (%rax),%eax
  8072fe:	89 c7                	mov    %eax,%edi
  807300:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  807307:	00 00 00 
  80730a:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  80730c:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807313:	00 
  807314:	75 09                	jne    80731f <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  807316:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80731d:	eb 55                	jmp    807374 <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80731f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807326:	48 8b 00             	mov    (%rax),%rax
  807329:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  80732f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807336:	48 8b 40 08          	mov    0x8(%rax),%rax
  80733a:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  807341:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  807348:	9b c4 20 
  80734b:	48 89 c8             	mov    %rcx,%rax
  80734e:	48 f7 ea             	imul   %rdx
  807351:	48 c1 fa 07          	sar    $0x7,%rdx
  807355:	48 89 c8             	mov    %rcx,%rax
  807358:	48 c1 f8 3f          	sar    $0x3f,%rax
  80735c:	48 29 c2             	sub    %rax,%rdx
  80735f:	48 89 d0             	mov    %rdx,%rax
  807362:	01 f0                	add    %esi,%eax
  807364:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  807367:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80736b:	75 07                	jne    807374 <lwip_select+0x2ca>
        msectimeout = 1;
  80736d:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  807374:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807377:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80737a:	89 d6                	mov    %edx,%esi
  80737c:	89 c7                	mov    %eax,%edi
  80737e:	48 b8 39 ea 80 00 00 	movabs $0x80ea39,%rax
  807385:	00 00 00 
  807388:	ff d0                	callq  *%rax
  80738a:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  80738d:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807394:	00 00 00 
  807397:	8b 00                	mov    (%rax),%eax
  807399:	89 c7                	mov    %eax,%edi
  80739b:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  8073a2:	00 00 00 
  8073a5:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  8073a7:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8073ae:	00 00 00 
  8073b1:	48 8b 10             	mov    (%rax),%rdx
  8073b4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8073b8:	48 39 c2             	cmp    %rax,%rdx
  8073bb:	75 13                	jne    8073d0 <lwip_select+0x326>
      select_cb_list = select_cb.next;
  8073bd:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8073c1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8073c8:	00 00 00 
  8073cb:	48 89 10             	mov    %rdx,(%rax)
  8073ce:	eb 42                	jmp    807412 <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8073d0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8073d7:	00 00 00 
  8073da:	48 8b 00             	mov    (%rax),%rax
  8073dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8073e1:	eb 28                	jmp    80740b <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  8073e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8073e7:	48 8b 10             	mov    (%rax),%rdx
  8073ea:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8073ee:	48 39 c2             	cmp    %rax,%rdx
  8073f1:	75 0d                	jne    807400 <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  8073f3:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8073f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8073fb:	48 89 10             	mov    %rdx,(%rax)
          break;
  8073fe:	eb 12                	jmp    807412 <lwip_select+0x368>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  807400:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807404:	48 8b 00             	mov    (%rax),%rax
  807407:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80740b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807410:	75 d1                	jne    8073e3 <lwip_select+0x339>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  807412:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807419:	00 00 00 
  80741c:	8b 00                	mov    (%rax),%eax
  80741e:	89 c7                	mov    %eax,%edi
  807420:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  807427:	00 00 00 
  80742a:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  80742c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80742f:	89 c7                	mov    %eax,%edi
  807431:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  807438:	00 00 00 
  80743b:	ff d0                	callq  *%rax
    if (i == 0)  {
  80743d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  807441:	0f 85 92 00 00 00    	jne    8074d9 <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  807447:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80744c:	74 1d                	je     80746b <lwip_select+0x3c1>
        FD_ZERO(readset);
  80744e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807452:	ba 04 00 00 00       	mov    $0x4,%edx
  807457:	be 00 00 00 00       	mov    $0x0,%esi
  80745c:	48 89 c7             	mov    %rax,%rdi
  80745f:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807466:	00 00 00 
  807469:	ff d0                	callq  *%rax
      if (writeset)
  80746b:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807472:	00 
  807473:	74 20                	je     807495 <lwip_select+0x3eb>
        FD_ZERO(writeset);
  807475:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80747c:	ba 04 00 00 00       	mov    $0x4,%edx
  807481:	be 00 00 00 00       	mov    $0x0,%esi
  807486:	48 89 c7             	mov    %rax,%rdi
  807489:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807490:	00 00 00 
  807493:	ff d0                	callq  *%rax
      if (exceptset)
  807495:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80749c:	00 
  80749d:	74 20                	je     8074bf <lwip_select+0x415>
        FD_ZERO(exceptset);
  80749f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8074a6:	ba 04 00 00 00       	mov    $0x4,%edx
  8074ab:	be 00 00 00 00       	mov    $0x0,%esi
  8074b0:	48 89 c7             	mov    %rax,%rdi
  8074b3:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  8074ba:	00 00 00 
  8074bd:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8074bf:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8074c6:	00 00 00 
  8074c9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8074cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8074d4:	e9 24 01 00 00       	jmpq   8075fd <lwip_select+0x553>
    }
    
    if (readset)
  8074d9:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8074de:	74 0b                	je     8074eb <lwip_select+0x441>
      lreadset = *readset;
  8074e0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8074e4:	8b 00                	mov    (%rax),%eax
  8074e6:	89 45 e0             	mov    %eax,-0x20(%rbp)
  8074e9:	eb 1d                	jmp    807508 <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  8074eb:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8074ef:	ba 04 00 00 00       	mov    $0x4,%edx
  8074f4:	be 00 00 00 00       	mov    $0x0,%esi
  8074f9:	48 89 c7             	mov    %rax,%rdi
  8074fc:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807503:	00 00 00 
  807506:	ff d0                	callq  *%rax
    if (writeset)
  807508:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80750f:	00 
  807510:	74 0e                	je     807520 <lwip_select+0x476>
      lwriteset = *writeset;
  807512:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807519:	8b 00                	mov    (%rax),%eax
  80751b:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80751e:	eb 1d                	jmp    80753d <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  807520:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807524:	ba 04 00 00 00       	mov    $0x4,%edx
  807529:	be 00 00 00 00       	mov    $0x0,%esi
  80752e:	48 89 c7             	mov    %rax,%rdi
  807531:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  807538:	00 00 00 
  80753b:	ff d0                	callq  *%rax
    if (exceptset)
  80753d:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807544:	00 
  807545:	74 0e                	je     807555 <lwip_select+0x4ab>
      lexceptset = *exceptset;
  807547:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80754e:	8b 00                	mov    (%rax),%eax
  807550:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807553:	eb 1d                	jmp    807572 <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  807555:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807559:	ba 04 00 00 00       	mov    $0x4,%edx
  80755e:	be 00 00 00 00       	mov    $0x0,%esi
  807563:	48 89 c7             	mov    %rax,%rdi
  807566:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  80756d:	00 00 00 
  807570:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807572:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807576:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80757a:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80757e:	8b 45 8c             	mov    -0x74(%rbp),%eax
  807581:	89 c7                	mov    %eax,%edi
  807583:	48 b8 c0 6e 80 00 00 	movabs $0x806ec0,%rax
  80758a:	00 00 00 
  80758d:	ff d0                	callq  *%rax
  80758f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  807592:	eb 1a                	jmp    8075ae <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  807594:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80759b:	00 00 00 
  80759e:	8b 00                	mov    (%rax),%eax
  8075a0:	89 c7                	mov    %eax,%edi
  8075a2:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  8075a9:	00 00 00 
  8075ac:	ff d0                	callq  *%rax
  
  if (readset)
  8075ae:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8075b3:	74 09                	je     8075be <lwip_select+0x514>
    *readset = lreadset;
  8075b5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8075b9:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8075bc:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8075be:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8075c5:	00 
  8075c6:	74 0c                	je     8075d4 <lwip_select+0x52a>
    *writeset = lwriteset;
  8075c8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8075cf:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8075d2:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  8075d4:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8075db:	00 
  8075dc:	74 0c                	je     8075ea <lwip_select+0x540>
    *exceptset = lexceptset;
  8075de:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8075e5:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8075e8:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8075ea:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8075f1:	00 00 00 
  8075f4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  8075fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8075fd:	c9                   	leaveq 
  8075fe:	c3                   	retq   

00000000008075ff <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8075ff:	55                   	push   %rbp
  807600:	48 89 e5             	mov    %rsp,%rbp
  807603:	48 83 ec 30          	sub    $0x30,%rsp
  807607:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80760b:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  80760e:	89 d0                	mov    %edx,%eax
  807610:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807614:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  807619:	0f 84 a6 00 00 00    	je     8076c5 <event_callback+0xc6>
    s = conn->socket;
  80761f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807623:	8b 40 20             	mov    0x20(%rax),%eax
  807626:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  807629:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80762d:	79 75                	jns    8076a4 <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  80762f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807636:	00 00 00 
  807639:	8b 00                	mov    (%rax),%eax
  80763b:	89 c7                	mov    %eax,%edi
  80763d:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  807644:	00 00 00 
  807647:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  807649:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80764d:	8b 40 20             	mov    0x20(%rax),%eax
  807650:	85 c0                	test   %eax,%eax
  807652:	79 36                	jns    80768a <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807654:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  807658:	75 11                	jne    80766b <event_callback+0x6c>
          conn->socket--;
  80765a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80765e:	8b 40 20             	mov    0x20(%rax),%eax
  807661:	8d 50 ff             	lea    -0x1(%rax),%edx
  807664:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807668:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80766b:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807672:	00 00 00 
  807675:	8b 00                	mov    (%rax),%eax
  807677:	89 c7                	mov    %eax,%edi
  807679:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  807680:	00 00 00 
  807683:	ff d0                	callq  *%rax
        return;
  807685:	e9 4b 02 00 00       	jmpq   8078d5 <event_callback+0x2d6>
      }
      sys_sem_signal(socksem);
  80768a:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807691:	00 00 00 
  807694:	8b 00                	mov    (%rax),%eax
  807696:	89 c7                	mov    %eax,%edi
  807698:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80769f:	00 00 00 
  8076a2:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  8076a4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8076a7:	89 c7                	mov    %eax,%edi
  8076a9:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  8076b0:	00 00 00 
  8076b3:	ff d0                	callq  *%rax
  8076b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  8076b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8076be:	75 0a                	jne    8076ca <event_callback+0xcb>
      return;
  8076c0:	e9 10 02 00 00       	jmpq   8078d5 <event_callback+0x2d6>
    }
  } else {
    return;
  8076c5:	e9 0b 02 00 00       	jmpq   8078d5 <event_callback+0x2d6>
  }

  sys_sem_wait(selectsem);
  8076ca:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8076d1:	00 00 00 
  8076d4:	8b 00                	mov    (%rax),%eax
  8076d6:	89 c7                	mov    %eax,%edi
  8076d8:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  8076df:	00 00 00 
  8076e2:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  8076e4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8076e7:	83 f8 01             	cmp    $0x1,%eax
  8076ea:	74 26                	je     807712 <event_callback+0x113>
  8076ec:	83 f8 01             	cmp    $0x1,%eax
  8076ef:	72 0c                	jb     8076fd <event_callback+0xfe>
  8076f1:	83 f8 02             	cmp    $0x2,%eax
  8076f4:	74 31                	je     807727 <event_callback+0x128>
  8076f6:	83 f8 03             	cmp    $0x3,%eax
  8076f9:	74 38                	je     807733 <event_callback+0x134>
  8076fb:	eb 42                	jmp    80773f <event_callback+0x140>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  8076fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807701:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807705:	8d 50 01             	lea    0x1(%rax),%edx
  807708:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80770c:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807710:	eb 57                	jmp    807769 <event_callback+0x16a>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  807712:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807716:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80771a:	8d 50 ff             	lea    -0x1(%rax),%edx
  80771d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807721:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807725:	eb 42                	jmp    807769 <event_callback+0x16a>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80772b:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  807731:	eb 36                	jmp    807769 <event_callback+0x16a>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  807733:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807737:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  80773d:	eb 2a                	jmp    807769 <event_callback+0x16a>
    default:
      LWIP_ASSERT("unknown event", 0);
  80773f:	48 ba b9 15 82 00 00 	movabs $0x8215b9,%rdx
  807746:	00 00 00 
  807749:	be 17 04 00 00       	mov    $0x417,%esi
  80774e:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  807755:	00 00 00 
  807758:	b8 00 00 00 00       	mov    $0x0,%eax
  80775d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  807764:	00 00 00 
  807767:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807769:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807770:	00 00 00 
  807773:	8b 00                	mov    (%rax),%eax
  807775:	89 c7                	mov    %eax,%edi
  807777:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80777e:	00 00 00 
  807781:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  807783:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80778a:	00 00 00 
  80778d:	8b 00                	mov    (%rax),%eax
  80778f:	89 c7                	mov    %eax,%edi
  807791:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  807798:	00 00 00 
  80779b:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  80779d:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8077a4:	00 00 00 
  8077a7:	48 8b 00             	mov    (%rax),%rax
  8077aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8077ae:	e9 b6 00 00 00       	jmpq   807869 <event_callback+0x26a>
      if (scb->sem_signalled == 0) {
  8077b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8077b7:	8b 40 20             	mov    0x20(%rax),%eax
  8077ba:	85 c0                	test   %eax,%eax
  8077bc:	0f 85 9c 00 00 00    	jne    80785e <event_callback+0x25f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8077c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8077c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8077ca:	48 85 c0             	test   %rax,%rax
  8077cd:	74 41                	je     807810 <event_callback+0x211>
  8077cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8077d3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8077d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8077da:	8d 48 07             	lea    0x7(%rax),%ecx
  8077dd:	85 c0                	test   %eax,%eax
  8077df:	0f 48 c1             	cmovs  %ecx,%eax
  8077e2:	c1 f8 03             	sar    $0x3,%eax
  8077e5:	48 98                	cltq   
  8077e7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8077eb:	0f b6 d0             	movzbl %al,%edx
  8077ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8077f1:	83 e0 07             	and    $0x7,%eax
  8077f4:	89 c1                	mov    %eax,%ecx
  8077f6:	d3 fa                	sar    %cl,%edx
  8077f8:	89 d0                	mov    %edx,%eax
  8077fa:	83 e0 01             	and    $0x1,%eax
  8077fd:	85 c0                	test   %eax,%eax
  8077ff:	74 0f                	je     807810 <event_callback+0x211>
          if (sock->rcvevent)
  807801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807805:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807809:	66 85 c0             	test   %ax,%ax
  80780c:	74 02                	je     807810 <event_callback+0x211>
            break;
  80780e:	eb 64                	jmp    807874 <event_callback+0x275>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  807810:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807814:	48 8b 40 10          	mov    0x10(%rax),%rax
  807818:	48 85 c0             	test   %rax,%rax
  80781b:	74 41                	je     80785e <event_callback+0x25f>
  80781d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807821:	48 8b 50 10          	mov    0x10(%rax),%rdx
  807825:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807828:	8d 48 07             	lea    0x7(%rax),%ecx
  80782b:	85 c0                	test   %eax,%eax
  80782d:	0f 48 c1             	cmovs  %ecx,%eax
  807830:	c1 f8 03             	sar    $0x3,%eax
  807833:	48 98                	cltq   
  807835:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807839:	0f b6 d0             	movzbl %al,%edx
  80783c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80783f:	83 e0 07             	and    $0x7,%eax
  807842:	89 c1                	mov    %eax,%ecx
  807844:	d3 fa                	sar    %cl,%edx
  807846:	89 d0                	mov    %edx,%eax
  807848:	83 e0 01             	and    $0x1,%eax
  80784b:	85 c0                	test   %eax,%eax
  80784d:	74 0f                	je     80785e <event_callback+0x25f>
          if (sock->sendevent)
  80784f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807853:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807857:	66 85 c0             	test   %ax,%ax
  80785a:	74 02                	je     80785e <event_callback+0x25f>
            break;
  80785c:	eb 16                	jmp    807874 <event_callback+0x275>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80785e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807862:	48 8b 00             	mov    (%rax),%rax
  807865:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  807869:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80786e:	0f 85 3f ff ff ff    	jne    8077b3 <event_callback+0x1b4>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  807874:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807879:	74 3f                	je     8078ba <event_callback+0x2bb>
      scb->sem_signalled = 1;
  80787b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80787f:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  807886:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80788d:	00 00 00 
  807890:	8b 00                	mov    (%rax),%eax
  807892:	89 c7                	mov    %eax,%edi
  807894:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80789b:	00 00 00 
  80789e:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  8078a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078a4:	8b 40 24             	mov    0x24(%rax),%eax
  8078a7:	89 c7                	mov    %eax,%edi
  8078a9:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  8078b0:	00 00 00 
  8078b3:	ff d0                	callq  *%rax
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8078b5:	e9 c9 fe ff ff       	jmpq   807783 <event_callback+0x184>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8078ba:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8078c1:	00 00 00 
  8078c4:	8b 00                	mov    (%rax),%eax
  8078c6:	89 c7                	mov    %eax,%edi
  8078c8:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  8078cf:	00 00 00 
  8078d2:	ff d0                	callq  *%rax
      break;
  8078d4:	90                   	nop
    }
  }
}
  8078d5:	c9                   	leaveq 
  8078d6:	c3                   	retq   

00000000008078d7 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8078d7:	55                   	push   %rbp
  8078d8:	48 89 e5             	mov    %rsp,%rbp
  8078db:	48 83 ec 10          	sub    $0x10,%rsp
  8078df:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8078e2:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8078e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8078e8:	89 c7                	mov    %eax,%edi
  8078ea:	48 b8 a8 62 80 00 00 	movabs $0x8062a8,%rax
  8078f1:	00 00 00 
  8078f4:	ff d0                	callq  *%rax
}
  8078f6:	c9                   	leaveq 
  8078f7:	c3                   	retq   

00000000008078f8 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8078f8:	55                   	push   %rbp
  8078f9:	48 89 e5             	mov    %rsp,%rbp
  8078fc:	48 83 ec 50          	sub    $0x50,%rsp
  807900:	89 7d cc             	mov    %edi,-0x34(%rbp)
  807903:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  807907:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80790b:	89 c8                	mov    %ecx,%eax
  80790d:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  807910:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807913:	89 c7                	mov    %eax,%edi
  807915:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  80791c:	00 00 00 
  80791f:	ff d0                	callq  *%rax
  807921:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807925:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80792a:	75 0a                	jne    807936 <lwip_getaddrname+0x3e>
    return -1;
  80792c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807931:	e9 c9 00 00 00       	jmpq   8079ff <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807936:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80793a:	ba 10 00 00 00       	mov    $0x10,%edx
  80793f:	be 00 00 00 00       	mov    $0x0,%esi
  807944:	48 89 c7             	mov    %rax,%rdi
  807947:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  80794e:	00 00 00 
  807951:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807953:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807957:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80795b:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  80795f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807963:	48 8b 00             	mov    (%rax),%rax
  807966:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80796a:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  80796e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807972:	89 d1                	mov    %edx,%ecx
  807974:	48 89 fa             	mov    %rdi,%rdx
  807977:	48 89 c7             	mov    %rax,%rdi
  80797a:	48 b8 5c 9b 81 00 00 	movabs $0x819b5c,%rax
  807981:	00 00 00 
  807984:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807986:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  80798a:	0f b7 c0             	movzwl %ax,%eax
  80798d:	89 c7                	mov    %eax,%edi
  80798f:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  807996:	00 00 00 
  807999:	ff d0                	callq  *%rax
  80799b:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  80799f:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8079a2:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  8079a5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8079a9:	8b 00                	mov    (%rax),%eax
  8079ab:	83 f8 10             	cmp    $0x10,%eax
  8079ae:	76 0a                	jbe    8079ba <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  8079b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8079b4:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  8079ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8079be:	8b 00                	mov    (%rax),%eax
  8079c0:	89 c2                	mov    %eax,%edx
  8079c2:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8079c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8079ca:	48 89 ce             	mov    %rcx,%rsi
  8079cd:	48 89 c7             	mov    %rax,%rdi
  8079d0:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8079d7:	00 00 00 
  8079da:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  8079dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079e0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8079e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079eb:	8b 50 18             	mov    0x18(%rax),%edx
  8079ee:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8079f5:	00 00 00 
  8079f8:	89 10                	mov    %edx,(%rax)
  return 0;
  8079fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8079ff:	c9                   	leaveq 
  807a00:	c3                   	retq   

0000000000807a01 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807a01:	55                   	push   %rbp
  807a02:	48 89 e5             	mov    %rsp,%rbp
  807a05:	48 83 ec 20          	sub    $0x20,%rsp
  807a09:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807a0c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807a10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807a14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807a18:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807a1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807a1f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807a24:	89 c7                	mov    %eax,%edi
  807a26:	48 b8 f8 78 80 00 00 	movabs $0x8078f8,%rax
  807a2d:	00 00 00 
  807a30:	ff d0                	callq  *%rax
}
  807a32:	c9                   	leaveq 
  807a33:	c3                   	retq   

0000000000807a34 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807a34:	55                   	push   %rbp
  807a35:	48 89 e5             	mov    %rsp,%rbp
  807a38:	48 83 ec 20          	sub    $0x20,%rsp
  807a3c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807a3f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807a43:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807a47:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807a4b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807a4f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807a52:	b9 01 00 00 00       	mov    $0x1,%ecx
  807a57:	89 c7                	mov    %eax,%edi
  807a59:	48 b8 f8 78 80 00 00 	movabs $0x8078f8,%rax
  807a60:	00 00 00 
  807a63:	ff d0                	callq  *%rax
}
  807a65:	c9                   	leaveq 
  807a66:	c3                   	retq   

0000000000807a67 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807a67:	55                   	push   %rbp
  807a68:	48 89 e5             	mov    %rsp,%rbp
  807a6b:	48 83 ec 60          	sub    $0x60,%rsp
  807a6f:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807a72:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807a75:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807a78:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807a7c:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  807a80:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807a84:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807a87:	89 c7                	mov    %eax,%edi
  807a89:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  807a90:	00 00 00 
  807a93:	ff d0                	callq  *%rax
  807a95:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807a99:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807a9e:	75 0a                	jne    807aaa <lwip_getsockopt+0x43>
    return -1;
  807aa0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807aa5:	e9 15 02 00 00       	jmpq   807cbf <lwip_getsockopt+0x258>

  if ((NULL == optval) || (NULL == optlen)) {
  807aaa:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807aaf:	74 07                	je     807ab8 <lwip_getsockopt+0x51>
  807ab1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  807ab6:	75 28                	jne    807ae0 <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  807ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807abc:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807ac3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ac7:	8b 50 18             	mov    0x18(%rax),%edx
  807aca:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807ad1:	00 00 00 
  807ad4:	89 10                	mov    %edx,(%rax)
    return -1;
  807ad6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807adb:	e9 df 01 00 00       	jmpq   807cbf <lwip_getsockopt+0x258>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807ae0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807ae3:	83 f8 06             	cmp    $0x6,%eax
  807ae6:	0f 84 c3 00 00 00    	je     807baf <lwip_getsockopt+0x148>
  807aec:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807af1:	74 0d                	je     807b00 <lwip_getsockopt+0x99>
  807af3:	85 c0                	test   %eax,%eax
  807af5:	0f 84 8e 00 00 00    	je     807b89 <lwip_getsockopt+0x122>
  807afb:	e9 ec 00 00 00       	jmpq   807bec <lwip_getsockopt+0x185>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807b00:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807b03:	83 f8 20             	cmp    $0x20,%eax
  807b06:	74 28                	je     807b30 <lwip_getsockopt+0xc9>
  807b08:	83 f8 20             	cmp    $0x20,%eax
  807b0b:	7f 0c                	jg     807b19 <lwip_getsockopt+0xb2>
  807b0d:	83 f8 02             	cmp    $0x2,%eax
  807b10:	74 1e                	je     807b30 <lwip_getsockopt+0xc9>
  807b12:	83 f8 08             	cmp    $0x8,%eax
  807b15:	74 19                	je     807b30 <lwip_getsockopt+0xc9>
  807b17:	eb 68                	jmp    807b81 <lwip_getsockopt+0x11a>
  807b19:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807b1e:	7c 61                	jl     807b81 <lwip_getsockopt+0x11a>
  807b20:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807b25:	7e 09                	jle    807b30 <lwip_getsockopt+0xc9>
  807b27:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807b2c:	74 15                	je     807b43 <lwip_getsockopt+0xdc>
  807b2e:	eb 51                	jmp    807b81 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  807b30:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807b34:	8b 00                	mov    (%rax),%eax
  807b36:	83 f8 03             	cmp    $0x3,%eax
  807b39:	77 06                	ja     807b41 <lwip_getsockopt+0xda>
        err = EINVAL;
  807b3b:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807b3f:	eb 46                	jmp    807b87 <lwip_getsockopt+0x120>
  807b41:	eb 44                	jmp    807b87 <lwip_getsockopt+0x120>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807b43:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807b47:	8b 00                	mov    (%rax),%eax
  807b49:	83 f8 03             	cmp    $0x3,%eax
  807b4c:	77 04                	ja     807b52 <lwip_getsockopt+0xeb>
        err = EINVAL;
  807b4e:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807b52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b56:	48 8b 00             	mov    (%rax),%rax
  807b59:	8b 00                	mov    (%rax),%eax
  807b5b:	83 f8 20             	cmp    $0x20,%eax
  807b5e:	75 19                	jne    807b79 <lwip_getsockopt+0x112>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807b60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b64:	48 8b 00             	mov    (%rax),%rax
  807b67:	48 8b 40 08          	mov    0x8(%rax),%rax
  807b6b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807b6f:	0f b6 c0             	movzbl %al,%eax
  807b72:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807b75:	85 c0                	test   %eax,%eax
  807b77:	74 06                	je     807b7f <lwip_getsockopt+0x118>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807b79:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807b7d:	eb 08                	jmp    807b87 <lwip_getsockopt+0x120>
  807b7f:	eb 06                	jmp    807b87 <lwip_getsockopt+0x120>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807b81:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807b85:	eb 69                	jmp    807bf0 <lwip_getsockopt+0x189>
  807b87:	eb 67                	jmp    807bf0 <lwip_getsockopt+0x189>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807b89:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807b8c:	83 e8 01             	sub    $0x1,%eax
  807b8f:	83 f8 01             	cmp    $0x1,%eax
  807b92:	77 13                	ja     807ba7 <lwip_getsockopt+0x140>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  807b94:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807b98:	8b 00                	mov    (%rax),%eax
  807b9a:	83 f8 03             	cmp    $0x3,%eax
  807b9d:	77 06                	ja     807ba5 <lwip_getsockopt+0x13e>
        err = EINVAL;
  807b9f:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807ba3:	eb 08                	jmp    807bad <lwip_getsockopt+0x146>
  807ba5:	eb 06                	jmp    807bad <lwip_getsockopt+0x146>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807ba7:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807bab:	eb 43                	jmp    807bf0 <lwip_getsockopt+0x189>
  807bad:	eb 41                	jmp    807bf0 <lwip_getsockopt+0x189>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  807baf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807bb3:	8b 00                	mov    (%rax),%eax
  807bb5:	83 f8 03             	cmp    $0x3,%eax
  807bb8:	77 06                	ja     807bc0 <lwip_getsockopt+0x159>
      err = EINVAL;
  807bba:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  807bbe:	eb 30                	jmp    807bf0 <lwip_getsockopt+0x189>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807bc0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bc4:	48 8b 00             	mov    (%rax),%rax
  807bc7:	8b 00                	mov    (%rax),%eax
  807bc9:	83 f8 10             	cmp    $0x10,%eax
  807bcc:	74 0a                	je     807bd8 <lwip_getsockopt+0x171>
      return 0;
  807bce:	b8 00 00 00 00       	mov    $0x0,%eax
  807bd3:	e9 e7 00 00 00       	jmpq   807cbf <lwip_getsockopt+0x258>

    switch (optname) {
  807bd8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807bdb:	83 e8 01             	sub    $0x1,%eax
  807bde:	83 f8 01             	cmp    $0x1,%eax
  807be1:	76 06                	jbe    807be9 <lwip_getsockopt+0x182>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807be3:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807be7:	eb 07                	jmp    807bf0 <lwip_getsockopt+0x189>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807be9:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807bea:	eb 04                	jmp    807bf0 <lwip_getsockopt+0x189>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  807bec:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  807bf0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807bf4:	74 28                	je     807c1e <lwip_getsockopt+0x1b7>
    sock_set_errno(sock, err);
  807bf6:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807bfa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bfe:	89 50 18             	mov    %edx,0x18(%rax)
  807c01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c05:	8b 50 18             	mov    0x18(%rax),%edx
  807c08:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807c0f:	00 00 00 
  807c12:	89 10                	mov    %edx,(%rax)
    return -1;
  807c14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c19:	e9 a1 00 00 00       	jmpq   807cbf <lwip_getsockopt+0x258>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807c1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c22:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807c26:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807c29:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807c2c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c2f:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807c32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807c36:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807c3a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c3e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807c42:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807c46:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807c49:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807c4d:	ba 01 00 00 00       	mov    $0x1,%edx
  807c52:	48 89 c6             	mov    %rax,%rsi
  807c55:	48 bf c1 7c 80 00 00 	movabs $0x807cc1,%rdi
  807c5c:	00 00 00 
  807c5f:	48 b8 22 8a 80 00 00 	movabs $0x808a22,%rax
  807c66:	00 00 00 
  807c69:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807c6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c6f:	48 8b 00             	mov    (%rax),%rax
  807c72:	8b 40 14             	mov    0x14(%rax),%eax
  807c75:	be 00 00 00 00       	mov    $0x0,%esi
  807c7a:	89 c7                	mov    %eax,%edi
  807c7c:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  807c83:	00 00 00 
  807c86:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807c88:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807c8c:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  807c8f:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807c93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c97:	89 50 18             	mov    %edx,0x18(%rax)
  807c9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c9e:	8b 50 18             	mov    0x18(%rax),%edx
  807ca1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807ca8:	00 00 00 
  807cab:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807cad:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807cb1:	74 07                	je     807cba <lwip_getsockopt+0x253>
  807cb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807cb8:	eb 05                	jmp    807cbf <lwip_getsockopt+0x258>
  807cba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807cbf:	c9                   	leaveq 
  807cc0:	c3                   	retq   

0000000000807cc1 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  807cc1:	55                   	push   %rbp
  807cc2:	48 89 e5             	mov    %rsp,%rbp
  807cc5:	48 83 ec 40          	sub    $0x40,%rsp
  807cc9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807ccd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807cd2:	75 2a                	jne    807cfe <lwip_getsockopt_internal+0x3d>
  807cd4:	48 ba c7 15 82 00 00 	movabs $0x8215c7,%rdx
  807cdb:	00 00 00 
  807cde:	be 38 05 00 00       	mov    $0x538,%esi
  807ce3:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  807cea:	00 00 00 
  807ced:	b8 00 00 00 00       	mov    $0x0,%eax
  807cf2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  807cf9:	00 00 00 
  807cfc:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807cfe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807d02:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807d06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d0a:	48 8b 00             	mov    (%rax),%rax
  807d0d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807d11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d15:	8b 40 08             	mov    0x8(%rax),%eax
  807d18:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807d1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d1f:	8b 40 0c             	mov    0xc(%rax),%eax
  807d22:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807d25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d29:	8b 40 10             	mov    0x10(%rax),%eax
  807d2c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807d2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d33:	48 8b 40 18          	mov    0x18(%rax),%rax
  807d37:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807d3b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807d3e:	83 f8 06             	cmp    $0x6,%eax
  807d41:	0f 84 b7 01 00 00    	je     807efe <lwip_getsockopt_internal+0x23d>
  807d47:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807d4c:	74 0d                	je     807d5b <lwip_getsockopt_internal+0x9a>
  807d4e:	85 c0                	test   %eax,%eax
  807d50:	0f 84 64 01 00 00    	je     807eba <lwip_getsockopt_internal+0x1f9>
  807d56:	e9 ec 01 00 00       	jmpq   807f47 <lwip_getsockopt_internal+0x286>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807d5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807d5e:	83 f8 20             	cmp    $0x20,%eax
  807d61:	74 36                	je     807d99 <lwip_getsockopt_internal+0xd8>
  807d63:	83 f8 20             	cmp    $0x20,%eax
  807d66:	7f 0f                	jg     807d77 <lwip_getsockopt_internal+0xb6>
  807d68:	83 f8 02             	cmp    $0x2,%eax
  807d6b:	74 2c                	je     807d99 <lwip_getsockopt_internal+0xd8>
  807d6d:	83 f8 08             	cmp    $0x8,%eax
  807d70:	74 27                	je     807d99 <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807d72:	e9 d0 01 00 00       	jmpq   807f47 <lwip_getsockopt_internal+0x286>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807d77:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807d7c:	74 3d                	je     807dbb <lwip_getsockopt_internal+0xfa>
  807d7e:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807d83:	0f 84 08 01 00 00    	je     807e91 <lwip_getsockopt_internal+0x1d0>
  807d89:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807d8e:	0f 84 80 00 00 00    	je     807e14 <lwip_getsockopt_internal+0x153>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807d94:	e9 ae 01 00 00       	jmpq   807f47 <lwip_getsockopt_internal+0x286>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807d99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d9d:	48 8b 00             	mov    (%rax),%rax
  807da0:	48 8b 40 08          	mov    0x8(%rax),%rax
  807da4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807da8:	0f b7 c0             	movzwl %ax,%eax
  807dab:	23 45 e4             	and    -0x1c(%rbp),%eax
  807dae:	89 c2                	mov    %eax,%edx
  807db0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807db4:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807db6:	e9 fa 00 00 00       	jmpq   807eb5 <lwip_getsockopt_internal+0x1f4>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807dbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dbf:	48 8b 00             	mov    (%rax),%rax
  807dc2:	8b 00                	mov    (%rax),%eax
  807dc4:	25 f0 00 00 00       	and    $0xf0,%eax
  807dc9:	83 f8 20             	cmp    $0x20,%eax
  807dcc:	74 24                	je     807df2 <lwip_getsockopt_internal+0x131>
  807dce:	83 f8 40             	cmp    $0x40,%eax
  807dd1:	74 07                	je     807dda <lwip_getsockopt_internal+0x119>
  807dd3:	83 f8 10             	cmp    $0x10,%eax
  807dd6:	74 0e                	je     807de6 <lwip_getsockopt_internal+0x125>
  807dd8:	eb 24                	jmp    807dfe <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807dda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807dde:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807de4:	eb 29                	jmp    807e0f <lwip_getsockopt_internal+0x14e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807de6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807dea:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807df0:	eb 1d                	jmp    807e0f <lwip_getsockopt_internal+0x14e>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807df2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807df6:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807dfc:	eb 11                	jmp    807e0f <lwip_getsockopt_internal+0x14e>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807dfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e02:	48 8b 00             	mov    (%rax),%rax
  807e05:	8b 00                	mov    (%rax),%eax
  807e07:	89 c2                	mov    %eax,%edx
  807e09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e0d:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807e0f:	e9 a1 00 00 00       	jmpq   807eb5 <lwip_getsockopt_internal+0x1f4>

    case SO_ERROR:
      if (sock->err == 0) {
  807e14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e18:	8b 40 18             	mov    0x18(%rax),%eax
  807e1b:	85 c0                	test   %eax,%eax
  807e1d:	75 58                	jne    807e77 <lwip_getsockopt_internal+0x1b6>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807e1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e23:	48 8b 00             	mov    (%rax),%rax
  807e26:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807e2a:	0f be c0             	movsbl %al,%eax
  807e2d:	f7 d8                	neg    %eax
  807e2f:	83 f8 0e             	cmp    $0xe,%eax
  807e32:	77 24                	ja     807e58 <lwip_getsockopt_internal+0x197>
  807e34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e38:	48 8b 00             	mov    (%rax),%rax
  807e3b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807e3f:	0f be c0             	movsbl %al,%eax
  807e42:	f7 d8                	neg    %eax
  807e44:	89 c2                	mov    %eax,%edx
  807e46:	48 b8 c0 14 82 00 00 	movabs $0x8214c0,%rax
  807e4d:	00 00 00 
  807e50:	48 63 d2             	movslq %edx,%rdx
  807e53:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807e56:	eb 05                	jmp    807e5d <lwip_getsockopt_internal+0x19c>
  807e58:	b8 05 00 00 00       	mov    $0x5,%eax
  807e5d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807e61:	89 42 18             	mov    %eax,0x18(%rdx)
  807e64:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e68:	8b 50 18             	mov    0x18(%rax),%edx
  807e6b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807e72:	00 00 00 
  807e75:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807e77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e7b:	8b 50 18             	mov    0x18(%rax),%edx
  807e7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e82:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807e84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e88:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807e8f:	eb 24                	jmp    807eb5 <lwip_getsockopt_internal+0x1f4>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807e91:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e95:	48 8b 00             	mov    (%rax),%rax
  807e98:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e9c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807ea0:	0f b6 c0             	movzbl %al,%eax
  807ea3:	83 e0 01             	and    $0x1,%eax
  807ea6:	85 c0                	test   %eax,%eax
  807ea8:	0f 95 c0             	setne  %al
  807eab:	0f b6 d0             	movzbl %al,%edx
  807eae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807eb2:	89 10                	mov    %edx,(%rax)
      break;
  807eb4:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807eb5:	e9 8d 00 00 00       	jmpq   807f47 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807eba:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807ebd:	83 f8 01             	cmp    $0x1,%eax
  807ec0:	74 21                	je     807ee3 <lwip_getsockopt_internal+0x222>
  807ec2:	83 f8 02             	cmp    $0x2,%eax
  807ec5:	74 02                	je     807ec9 <lwip_getsockopt_internal+0x208>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807ec7:	eb 7e                	jmp    807f47 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807ec9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ecd:	48 8b 00             	mov    (%rax),%rax
  807ed0:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ed4:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807ed8:	0f b6 d0             	movzbl %al,%edx
  807edb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807edf:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  807ee1:	eb 19                	jmp    807efc <lwip_getsockopt_internal+0x23b>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  807ee3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ee7:	48 8b 00             	mov    (%rax),%rax
  807eea:	48 8b 40 08          	mov    0x8(%rax),%rax
  807eee:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  807ef2:	0f b6 d0             	movzbl %al,%edx
  807ef5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ef9:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  807efb:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807efc:	eb 49                	jmp    807f47 <lwip_getsockopt_internal+0x286>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807efe:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807f01:	83 f8 01             	cmp    $0x1,%eax
  807f04:	74 07                	je     807f0d <lwip_getsockopt_internal+0x24c>
  807f06:	83 f8 02             	cmp    $0x2,%eax
  807f09:	74 21                	je     807f2c <lwip_getsockopt_internal+0x26b>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807f0b:	eb 39                	jmp    807f46 <lwip_getsockopt_internal+0x285>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807f0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f11:	48 8b 00             	mov    (%rax),%rax
  807f14:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f18:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807f1c:	0f b6 c0             	movzbl %al,%eax
  807f1f:	83 e0 40             	and    $0x40,%eax
  807f22:	89 c2                	mov    %eax,%edx
  807f24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f28:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  807f2a:	eb 1a                	jmp    807f46 <lwip_getsockopt_internal+0x285>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807f2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f30:	48 8b 00             	mov    (%rax),%rax
  807f33:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f37:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807f3d:	89 c2                	mov    %eax,%edx
  807f3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f43:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  807f45:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807f46:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807f47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f4b:	48 8b 00             	mov    (%rax),%rax
  807f4e:	8b 40 14             	mov    0x14(%rax),%eax
  807f51:	89 c7                	mov    %eax,%edi
  807f53:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  807f5a:	00 00 00 
  807f5d:	ff d0                	callq  *%rax
}
  807f5f:	c9                   	leaveq 
  807f60:	c3                   	retq   

0000000000807f61 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  807f61:	55                   	push   %rbp
  807f62:	48 89 e5             	mov    %rsp,%rbp
  807f65:	48 83 ec 60          	sub    $0x60,%rsp
  807f69:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807f6c:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807f6f:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807f72:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807f76:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807f7a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807f7d:	89 c7                	mov    %eax,%edi
  807f7f:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  807f86:	00 00 00 
  807f89:	ff d0                	callq  *%rax
  807f8b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  807f8f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807f96:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807f9b:	75 0a                	jne    807fa7 <lwip_setsockopt+0x46>
    return -1;
  807f9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807fa2:	e9 fd 01 00 00       	jmpq   8081a4 <lwip_setsockopt+0x243>

  if (NULL == optval) {
  807fa7:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807fac:	75 28                	jne    807fd6 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  807fae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fb2:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807fb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fbd:	8b 50 18             	mov    0x18(%rax),%edx
  807fc0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807fc7:	00 00 00 
  807fca:	89 10                	mov    %edx,(%rax)
    return -1;
  807fcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807fd1:	e9 ce 01 00 00       	jmpq   8081a4 <lwip_setsockopt+0x243>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807fd6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807fd9:	83 f8 06             	cmp    $0x6,%eax
  807fdc:	0f 84 ac 00 00 00    	je     80808e <lwip_setsockopt+0x12d>
  807fe2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807fe7:	74 09                	je     807ff2 <lwip_setsockopt+0x91>
  807fe9:	85 c0                	test   %eax,%eax
  807feb:	74 78                	je     808065 <lwip_setsockopt+0x104>
  807fed:	e9 dc 00 00 00       	jmpq   8080ce <lwip_setsockopt+0x16d>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807ff2:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807ff5:	83 f8 20             	cmp    $0x20,%eax
  807ff8:	74 0c                	je     808006 <lwip_setsockopt+0xa5>
  807ffa:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807fff:	74 18                	je     808019 <lwip_setsockopt+0xb8>
  808001:	83 f8 08             	cmp    $0x8,%eax
  808004:	75 54                	jne    80805a <lwip_setsockopt+0xf9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  808006:	8b 45 b0             	mov    -0x50(%rbp),%eax
  808009:	83 f8 03             	cmp    $0x3,%eax
  80800c:	77 09                	ja     808017 <lwip_setsockopt+0xb6>
        err = EINVAL;
  80800e:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  808015:	eb 4c                	jmp    808063 <lwip_setsockopt+0x102>
  808017:	eb 4a                	jmp    808063 <lwip_setsockopt+0x102>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  808019:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80801c:	83 f8 03             	cmp    $0x3,%eax
  80801f:	77 07                	ja     808028 <lwip_setsockopt+0xc7>
        err = EINVAL;
  808021:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  808028:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80802c:	48 8b 00             	mov    (%rax),%rax
  80802f:	8b 00                	mov    (%rax),%eax
  808031:	83 f8 20             	cmp    $0x20,%eax
  808034:	75 19                	jne    80804f <lwip_setsockopt+0xee>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  808036:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80803a:	48 8b 00             	mov    (%rax),%rax
  80803d:	48 8b 40 08          	mov    0x8(%rax),%rax
  808041:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  808045:	0f b6 c0             	movzbl %al,%eax
  808048:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80804b:	85 c0                	test   %eax,%eax
  80804d:	74 09                	je     808058 <lwip_setsockopt+0xf7>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  80804f:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  808056:	eb 0b                	jmp    808063 <lwip_setsockopt+0x102>
  808058:	eb 09                	jmp    808063 <lwip_setsockopt+0x102>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80805a:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808061:	eb 72                	jmp    8080d5 <lwip_setsockopt+0x174>
  808063:	eb 70                	jmp    8080d5 <lwip_setsockopt+0x174>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  808065:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808068:	83 e8 01             	sub    $0x1,%eax
  80806b:	83 f8 01             	cmp    $0x1,%eax
  80806e:	77 13                	ja     808083 <lwip_setsockopt+0x122>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  808070:	8b 45 b0             	mov    -0x50(%rbp),%eax
  808073:	83 f8 03             	cmp    $0x3,%eax
  808076:	77 09                	ja     808081 <lwip_setsockopt+0x120>
        err = EINVAL;
  808078:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  80807f:	eb 0b                	jmp    80808c <lwip_setsockopt+0x12b>
  808081:	eb 09                	jmp    80808c <lwip_setsockopt+0x12b>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  808083:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  80808a:	eb 49                	jmp    8080d5 <lwip_setsockopt+0x174>
  80808c:	eb 47                	jmp    8080d5 <lwip_setsockopt+0x174>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  80808e:	8b 45 b0             	mov    -0x50(%rbp),%eax
  808091:	83 f8 03             	cmp    $0x3,%eax
  808094:	77 09                	ja     80809f <lwip_setsockopt+0x13e>
      err = EINVAL;
  808096:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  80809d:	eb 36                	jmp    8080d5 <lwip_setsockopt+0x174>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80809f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080a3:	48 8b 00             	mov    (%rax),%rax
  8080a6:	8b 00                	mov    (%rax),%eax
  8080a8:	83 f8 10             	cmp    $0x10,%eax
  8080ab:	74 0a                	je     8080b7 <lwip_setsockopt+0x156>
      return 0;
  8080ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8080b2:	e9 ed 00 00 00       	jmpq   8081a4 <lwip_setsockopt+0x243>

    switch (optname) {
  8080b7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8080ba:	83 e8 01             	sub    $0x1,%eax
  8080bd:	83 f8 01             	cmp    $0x1,%eax
  8080c0:	76 09                	jbe    8080cb <lwip_setsockopt+0x16a>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8080c2:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8080c9:	eb 0a                	jmp    8080d5 <lwip_setsockopt+0x174>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  8080cb:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8080cc:	eb 07                	jmp    8080d5 <lwip_setsockopt+0x174>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8080ce:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  8080d5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8080d9:	74 27                	je     808102 <lwip_setsockopt+0x1a1>
    sock_set_errno(sock, err);
  8080db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8080e2:	89 50 18             	mov    %edx,0x18(%rax)
  8080e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080e9:	8b 50 18             	mov    0x18(%rax),%edx
  8080ec:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8080f3:	00 00 00 
  8080f6:	89 10                	mov    %edx,(%rax)
    return -1;
  8080f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080fd:	e9 a2 00 00 00       	jmpq   8081a4 <lwip_setsockopt+0x243>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  808102:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808106:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  80810a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80810d:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  808110:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808113:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  808116:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80811a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  80811e:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  808122:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  808126:	8b 45 fc             	mov    -0x4(%rbp),%eax
  808129:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80812c:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  808130:	ba 01 00 00 00       	mov    $0x1,%edx
  808135:	48 89 c6             	mov    %rax,%rsi
  808138:	48 bf a6 81 80 00 00 	movabs $0x8081a6,%rdi
  80813f:	00 00 00 
  808142:	48 b8 22 8a 80 00 00 	movabs $0x808a22,%rax
  808149:	00 00 00 
  80814c:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80814e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808152:	48 8b 00             	mov    (%rax),%rax
  808155:	8b 40 14             	mov    0x14(%rax),%eax
  808158:	be 00 00 00 00       	mov    $0x0,%esi
  80815d:	89 c7                	mov    %eax,%edi
  80815f:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  808166:	00 00 00 
  808169:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  80816b:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  80816f:	0f be c0             	movsbl %al,%eax
  808172:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  808175:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808179:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80817c:	89 50 18             	mov    %edx,0x18(%rax)
  80817f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808183:	8b 50 18             	mov    0x18(%rax),%edx
  808186:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80818d:	00 00 00 
  808190:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  808192:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  808196:	74 07                	je     80819f <lwip_setsockopt+0x23e>
  808198:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80819d:	eb 05                	jmp    8081a4 <lwip_setsockopt+0x243>
  80819f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8081a4:	c9                   	leaveq 
  8081a5:	c3                   	retq   

00000000008081a6 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  8081a6:	55                   	push   %rbp
  8081a7:	48 89 e5             	mov    %rsp,%rbp
  8081aa:	48 83 ec 40          	sub    $0x40,%rsp
  8081ae:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8081b2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8081b7:	75 2a                	jne    8081e3 <lwip_setsockopt_internal+0x3d>
  8081b9:	48 ba c7 15 82 00 00 	movabs $0x8215c7,%rdx
  8081c0:	00 00 00 
  8081c3:	be ae 06 00 00       	mov    $0x6ae,%esi
  8081c8:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8081cf:	00 00 00 
  8081d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8081d7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8081de:	00 00 00 
  8081e1:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  8081e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8081e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  8081eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081ef:	48 8b 00             	mov    (%rax),%rax
  8081f2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  8081f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081fa:	8b 40 08             	mov    0x8(%rax),%eax
  8081fd:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  808200:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808204:	8b 40 0c             	mov    0xc(%rax),%eax
  808207:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  80820a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80820e:	8b 40 10             	mov    0x10(%rax),%eax
  808211:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  808214:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808218:	48 8b 40 18          	mov    0x18(%rax),%rax
  80821c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  808220:	8b 45 e8             	mov    -0x18(%rbp),%eax
  808223:	83 f8 06             	cmp    $0x6,%eax
  808226:	0f 84 16 01 00 00    	je     808342 <lwip_setsockopt_internal+0x19c>
  80822c:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  808231:	74 0d                	je     808240 <lwip_setsockopt_internal+0x9a>
  808233:	85 c0                	test   %eax,%eax
  808235:	0f 84 c8 00 00 00    	je     808303 <lwip_setsockopt_internal+0x15d>
  80823b:	e9 78 01 00 00       	jmpq   8083b8 <lwip_setsockopt_internal+0x212>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808240:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808243:	83 f8 20             	cmp    $0x20,%eax
  808246:	74 11                	je     808259 <lwip_setsockopt_internal+0xb3>
  808248:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80824d:	74 62                	je     8082b1 <lwip_setsockopt_internal+0x10b>
  80824f:	83 f8 08             	cmp    $0x8,%eax
  808252:	74 05                	je     808259 <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  808254:	e9 5f 01 00 00       	jmpq   8083b8 <lwip_setsockopt_internal+0x212>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  808259:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80825d:	8b 00                	mov    (%rax),%eax
  80825f:	85 c0                	test   %eax,%eax
  808261:	74 27                	je     80828a <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  808263:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808267:	48 8b 00             	mov    (%rax),%rax
  80826a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80826e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808272:	48 8b 12             	mov    (%rdx),%rdx
  808275:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808279:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  80827d:	89 d1                	mov    %edx,%ecx
  80827f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  808282:	09 ca                	or     %ecx,%edx
  808284:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  808288:	eb 74                	jmp    8082fe <lwip_setsockopt_internal+0x158>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  80828a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80828e:	48 8b 00             	mov    (%rax),%rax
  808291:	48 8b 40 08          	mov    0x8(%rax),%rax
  808295:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808299:	48 8b 12             	mov    (%rdx),%rdx
  80829c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8082a0:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  8082a4:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8082a7:	f7 d1                	not    %ecx
  8082a9:	21 ca                	and    %ecx,%edx
  8082ab:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8082af:	eb 4d                	jmp    8082fe <lwip_setsockopt_internal+0x158>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8082b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8082b5:	8b 00                	mov    (%rax),%eax
  8082b7:	85 c0                	test   %eax,%eax
  8082b9:	74 22                	je     8082dd <lwip_setsockopt_internal+0x137>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8082bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8082bf:	48 8b 00             	mov    (%rax),%rax
  8082c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8082c6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8082ca:	48 8b 12             	mov    (%rdx),%rdx
  8082cd:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8082d1:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8082d5:	83 ca 01             	or     $0x1,%edx
  8082d8:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  8082db:	eb 20                	jmp    8082fd <lwip_setsockopt_internal+0x157>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8082dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8082e1:	48 8b 00             	mov    (%rax),%rax
  8082e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8082e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8082ec:	48 8b 12             	mov    (%rdx),%rdx
  8082ef:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8082f3:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8082f7:	83 e2 fe             	and    $0xfffffffe,%edx
  8082fa:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  8082fd:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  8082fe:	e9 b5 00 00 00       	jmpq   8083b8 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  808303:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808306:	83 f8 01             	cmp    $0x1,%eax
  808309:	74 20                	je     80832b <lwip_setsockopt_internal+0x185>
  80830b:	83 f8 02             	cmp    $0x2,%eax
  80830e:	74 05                	je     808315 <lwip_setsockopt_internal+0x16f>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808310:	e9 a3 00 00 00       	jmpq   8083b8 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  808315:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808319:	48 8b 00             	mov    (%rax),%rax
  80831c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808320:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808324:	8b 12                	mov    (%rdx),%edx
  808326:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  808329:	eb 15                	jmp    808340 <lwip_setsockopt_internal+0x19a>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  80832b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80832f:	48 8b 00             	mov    (%rax),%rax
  808332:	48 8b 40 08          	mov    0x8(%rax),%rax
  808336:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80833a:	8b 12                	mov    (%rdx),%edx
  80833c:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  80833f:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808340:	eb 76                	jmp    8083b8 <lwip_setsockopt_internal+0x212>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  808342:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808345:	83 f8 01             	cmp    $0x1,%eax
  808348:	74 07                	je     808351 <lwip_setsockopt_internal+0x1ab>
  80834a:	83 f8 02             	cmp    $0x2,%eax
  80834d:	74 50                	je     80839f <lwip_setsockopt_internal+0x1f9>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80834f:	eb 66                	jmp    8083b7 <lwip_setsockopt_internal+0x211>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
  808351:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808355:	8b 00                	mov    (%rax),%eax
  808357:	85 c0                	test   %eax,%eax
  808359:	74 22                	je     80837d <lwip_setsockopt_internal+0x1d7>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80835b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80835f:	48 8b 00             	mov    (%rax),%rax
  808362:	48 8b 40 08          	mov    0x8(%rax),%rax
  808366:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80836a:	48 8b 12             	mov    (%rdx),%rdx
  80836d:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808371:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808375:	83 ca 40             	or     $0x40,%edx
  808378:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80837b:	eb 3a                	jmp    8083b7 <lwip_setsockopt_internal+0x211>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80837d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808381:	48 8b 00             	mov    (%rax),%rax
  808384:	48 8b 40 08          	mov    0x8(%rax),%rax
  808388:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80838c:	48 8b 12             	mov    (%rdx),%rdx
  80838f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808393:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808397:	83 e2 bf             	and    $0xffffffbf,%edx
  80839a:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80839d:	eb 18                	jmp    8083b7 <lwip_setsockopt_internal+0x211>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  80839f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083a3:	48 8b 00             	mov    (%rax),%rax
  8083a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083aa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8083ae:	8b 12                	mov    (%rdx),%edx
  8083b0:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  8083b6:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  8083b7:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8083b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083bc:	48 8b 00             	mov    (%rax),%rax
  8083bf:	8b 40 14             	mov    0x14(%rax),%eax
  8083c2:	89 c7                	mov    %eax,%edi
  8083c4:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  8083cb:	00 00 00 
  8083ce:	ff d0                	callq  *%rax
}
  8083d0:	c9                   	leaveq 
  8083d1:	c3                   	retq   

00000000008083d2 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8083d2:	55                   	push   %rbp
  8083d3:	48 89 e5             	mov    %rsp,%rbp
  8083d6:	48 83 ec 28          	sub    $0x28,%rsp
  8083da:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8083dd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8083e1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8083e5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8083e8:	89 c7                	mov    %eax,%edi
  8083ea:	48 b8 47 5c 80 00 00 	movabs $0x805c47,%rax
  8083f1:	00 00 00 
  8083f4:	ff d0                	callq  *%rax
  8083f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  8083fa:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  808400:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808405:	75 0a                	jne    808411 <lwip_ioctl+0x3f>
    return -1;
  808407:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80840c:	e9 4d 01 00 00       	jmpq   80855e <lwip_ioctl+0x18c>

  switch (cmd) {
  808411:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  808415:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  80841b:	74 13                	je     808430 <lwip_ioctl+0x5e>
  80841d:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  808422:	48 39 d0             	cmp    %rdx,%rax
  808425:	0f 84 ae 00 00 00    	je     8084d9 <lwip_ioctl+0x107>
  80842b:	e9 0b 01 00 00       	jmpq   80853b <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  808430:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808435:	75 28                	jne    80845f <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  808437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80843b:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  808442:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808446:	8b 50 18             	mov    0x18(%rax),%edx
  808449:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808450:	00 00 00 
  808453:	89 10                	mov    %edx,(%rax)
      return -1;
  808455:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80845a:	e9 ff 00 00 00       	jmpq   80855e <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80845f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808463:	48 8b 00             	mov    (%rax),%rax
  808466:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  80846a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80846e:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  808471:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808475:	48 8b 40 08          	mov    0x8(%rax),%rax
  808479:	48 85 c0             	test   %rax,%rax
  80847c:	74 33                	je     8084b1 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  80847e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808482:	48 8b 40 08          	mov    0x8(%rax),%rax
  808486:	48 8b 00             	mov    (%rax),%rax
  808489:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80848d:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  808491:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808495:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808499:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  80849d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8084a1:	0f b7 10             	movzwl (%rax),%edx
  8084a4:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8084a8:	01 c2                	add    %eax,%edx
  8084aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8084ae:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8084b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084b5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8084bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084c0:	8b 50 18             	mov    0x18(%rax),%edx
  8084c3:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8084ca:	00 00 00 
  8084cd:	89 10                	mov    %edx,(%rax)
    return 0;
  8084cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8084d4:	e9 85 00 00 00       	jmpq   80855e <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8084d9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8084de:	74 21                	je     808501 <lwip_ioctl+0x12f>
  8084e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8084e4:	8b 00                	mov    (%rax),%eax
  8084e6:	85 c0                	test   %eax,%eax
  8084e8:	74 17                	je     808501 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  8084ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084ee:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8084f2:	80 cc 08             	or     $0x8,%ah
  8084f5:	89 c2                	mov    %eax,%edx
  8084f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084fb:	66 89 50 16          	mov    %dx,0x16(%rax)
  8084ff:	eb 15                	jmp    808516 <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  808501:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808505:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  808509:	80 e4 f7             	and    $0xf7,%ah
  80850c:	89 c2                	mov    %eax,%edx
  80850e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808512:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  808516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80851a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  808521:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808525:	8b 50 18             	mov    0x18(%rax),%edx
  808528:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80852f:	00 00 00 
  808532:	89 10                	mov    %edx,(%rax)
    return 0;
  808534:	b8 00 00 00 00       	mov    $0x0,%eax
  808539:	eb 23                	jmp    80855e <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80853b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80853f:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  808546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80854a:	8b 50 18             	mov    0x18(%rax),%edx
  80854d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808554:	00 00 00 
  808557:	89 10                	mov    %edx,(%rax)
    return -1;
  808559:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  80855e:	c9                   	leaveq 
  80855f:	c3                   	retq   

0000000000808560 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808560:	55                   	push   %rbp
  808561:	48 89 e5             	mov    %rsp,%rbp
  808564:	48 83 ec 10          	sub    $0x10,%rsp
  808568:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80856c:	48 b8 07 eb 80 00 00 	movabs $0x80eb07,%rax
  808573:	00 00 00 
  808576:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  808578:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80857f:	00 00 00 
  808582:	48 8b 00             	mov    (%rax),%rax
  808585:	48 85 c0             	test   %rax,%rax
  808588:	75 12                	jne    80859c <tcpip_tcp_timer+0x3c>
  80858a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808591:	00 00 00 
  808594:	48 8b 00             	mov    (%rax),%rax
  808597:	48 85 c0             	test   %rax,%rax
  80859a:	74 22                	je     8085be <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80859c:	ba 00 00 00 00       	mov    $0x0,%edx
  8085a1:	48 be 60 85 80 00 00 	movabs $0x808560,%rsi
  8085a8:	00 00 00 
  8085ab:	bf fa 00 00 00       	mov    $0xfa,%edi
  8085b0:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  8085b7:	00 00 00 
  8085ba:	ff d0                	callq  *%rax
  8085bc:	eb 10                	jmp    8085ce <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8085be:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8085c5:	00 00 00 
  8085c8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  8085ce:	c9                   	leaveq 
  8085cf:	c3                   	retq   

00000000008085d0 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8085d0:	55                   	push   %rbp
  8085d1:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8085d4:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8085db:	00 00 00 
  8085de:	8b 00                	mov    (%rax),%eax
  8085e0:	85 c0                	test   %eax,%eax
  8085e2:	75 54                	jne    808638 <tcp_timer_needed+0x68>
  8085e4:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8085eb:	00 00 00 
  8085ee:	48 8b 00             	mov    (%rax),%rax
  8085f1:	48 85 c0             	test   %rax,%rax
  8085f4:	75 12                	jne    808608 <tcp_timer_needed+0x38>
  8085f6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8085fd:	00 00 00 
  808600:	48 8b 00             	mov    (%rax),%rax
  808603:	48 85 c0             	test   %rax,%rax
  808606:	74 30                	je     808638 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  808608:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  80860f:	00 00 00 
  808612:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  808618:	ba 00 00 00 00       	mov    $0x0,%edx
  80861d:	48 be 60 85 80 00 00 	movabs $0x808560,%rsi
  808624:	00 00 00 
  808627:	bf fa 00 00 00       	mov    $0xfa,%edi
  80862c:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  808633:	00 00 00 
  808636:	ff d0                	callq  *%rax
  }
}
  808638:	5d                   	pop    %rbp
  808639:	c3                   	retq   

000000000080863a <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80863a:	55                   	push   %rbp
  80863b:	48 89 e5             	mov    %rsp,%rbp
  80863e:	48 83 ec 10          	sub    $0x10,%rsp
  808642:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  808646:	48 b8 25 15 81 00 00 	movabs $0x811525,%rax
  80864d:	00 00 00 
  808650:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808652:	ba 00 00 00 00       	mov    $0x0,%edx
  808657:	48 be 3a 86 80 00 00 	movabs $0x80863a,%rsi
  80865e:	00 00 00 
  808661:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808666:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  80866d:	00 00 00 
  808670:	ff d0                	callq  *%rax
}
  808672:	c9                   	leaveq 
  808673:	c3                   	retq   

0000000000808674 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808674:	55                   	push   %rbp
  808675:	48 89 e5             	mov    %rsp,%rbp
  808678:	48 83 ec 10          	sub    $0x10,%rsp
  80867c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  808680:	48 b8 6c 59 81 00 00 	movabs $0x81596c,%rax
  808687:	00 00 00 
  80868a:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80868c:	ba 00 00 00 00       	mov    $0x0,%edx
  808691:	48 be 74 86 80 00 00 	movabs $0x808674,%rsi
  808698:	00 00 00 
  80869b:	bf 88 13 00 00       	mov    $0x1388,%edi
  8086a0:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  8086a7:	00 00 00 
  8086aa:	ff d0                	callq  *%rax
}
  8086ac:	c9                   	leaveq 
  8086ad:	c3                   	retq   

00000000008086ae <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8086ae:	55                   	push   %rbp
  8086af:	48 89 e5             	mov    %rsp,%rbp
  8086b2:	48 83 ec 10          	sub    $0x10,%rsp
  8086b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8086ba:	48 b8 df 97 80 00 00 	movabs $0x8097df,%rax
  8086c1:	00 00 00 
  8086c4:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8086c6:	ba 00 00 00 00       	mov    $0x0,%edx
  8086cb:	48 be ae 86 80 00 00 	movabs $0x8086ae,%rsi
  8086d2:	00 00 00 
  8086d5:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8086da:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  8086e1:	00 00 00 
  8086e4:	ff d0                	callq  *%rax
}
  8086e6:	c9                   	leaveq 
  8086e7:	c3                   	retq   

00000000008086e8 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8086e8:	55                   	push   %rbp
  8086e9:	48 89 e5             	mov    %rsp,%rbp
  8086ec:	48 83 ec 10          	sub    $0x10,%rsp
  8086f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8086f4:	48 b8 75 98 80 00 00 	movabs $0x809875,%rax
  8086fb:	00 00 00 
  8086fe:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808700:	ba 00 00 00 00       	mov    $0x0,%edx
  808705:	48 be e8 86 80 00 00 	movabs $0x8086e8,%rsi
  80870c:	00 00 00 
  80870f:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808714:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  80871b:	00 00 00 
  80871e:	ff d0                	callq  *%rax
}
  808720:	c9                   	leaveq 
  808721:	c3                   	retq   

0000000000808722 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808722:	55                   	push   %rbp
  808723:	48 89 e5             	mov    %rsp,%rbp
  808726:	48 83 ec 20          	sub    $0x20,%rsp
  80872a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80872e:	ba 00 00 00 00       	mov    $0x0,%edx
  808733:	48 be 3a 86 80 00 00 	movabs $0x80863a,%rsi
  80873a:	00 00 00 
  80873d:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808742:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  808749:	00 00 00 
  80874c:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80874e:	ba 00 00 00 00       	mov    $0x0,%edx
  808753:	48 be 74 86 80 00 00 	movabs $0x808674,%rsi
  80875a:	00 00 00 
  80875d:	bf 88 13 00 00       	mov    $0x1388,%edi
  808762:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  808769:	00 00 00 
  80876c:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80876e:	ba 00 00 00 00       	mov    $0x0,%edx
  808773:	48 be ae 86 80 00 00 	movabs $0x8086ae,%rsi
  80877a:	00 00 00 
  80877d:	bf 60 ea 00 00       	mov    $0xea60,%edi
  808782:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  808789:	00 00 00 
  80878c:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80878e:	ba 00 00 00 00       	mov    $0x0,%edx
  808793:	48 be e8 86 80 00 00 	movabs $0x8086e8,%rsi
  80879a:	00 00 00 
  80879d:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8087a2:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  8087a9:	00 00 00 
  8087ac:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8087ae:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8087b5:	00 00 00 
  8087b8:	48 8b 00             	mov    (%rax),%rax
  8087bb:	48 85 c0             	test   %rax,%rax
  8087be:	74 1f                	je     8087df <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8087c0:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8087c7:	00 00 00 
  8087ca:	48 8b 00             	mov    (%rax),%rax
  8087cd:	48 ba b8 94 82 00 00 	movabs $0x8294b8,%rdx
  8087d4:	00 00 00 
  8087d7:	48 8b 12             	mov    (%rdx),%rdx
  8087da:	48 89 d7             	mov    %rdx,%rdi
  8087dd:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8087df:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8087e6:	00 00 00 
  8087e9:	8b 00                	mov    (%rax),%eax
  8087eb:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8087ef:	48 89 d6             	mov    %rdx,%rsi
  8087f2:	89 c7                	mov    %eax,%edi
  8087f4:	48 b8 91 e4 80 00 00 	movabs $0x80e491,%rax
  8087fb:	00 00 00 
  8087fe:	ff d0                	callq  *%rax
    switch (msg->type) {
  808800:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808804:	8b 00                	mov    (%rax),%eax
  808806:	83 f8 01             	cmp    $0x1,%eax
  808809:	74 3d                	je     808848 <tcpip_thread+0x126>
  80880b:	83 f8 01             	cmp    $0x1,%eax
  80880e:	72 17                	jb     808827 <tcpip_thread+0x105>
  808810:	83 f8 02             	cmp    $0x2,%eax
  808813:	0f 84 a8 00 00 00    	je     8088c1 <tcpip_thread+0x19f>
  808819:	83 f8 03             	cmp    $0x3,%eax
  80881c:	0f 84 ce 00 00 00    	je     8088f0 <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  808822:	e9 3a 01 00 00       	jmpq   808961 <tcpip_thread+0x23f>
    sys_mbox_fetch(mbox, (void *)&msg);
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  808827:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80882b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80882f:	48 8b 00             	mov    (%rax),%rax
  808832:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808836:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80883a:	48 83 c2 08          	add    $0x8,%rdx
  80883e:	48 89 d7             	mov    %rdx,%rdi
  808841:	ff d0                	callq  *%rax
      break;
  808843:	e9 19 01 00 00       	jmpq   808961 <tcpip_thread+0x23f>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  808848:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80884c:	48 8b 40 18          	mov    0x18(%rax),%rax
  808850:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808854:	0f b6 c0             	movzbl %al,%eax
  808857:	83 e0 20             	and    $0x20,%eax
  80885a:	85 c0                	test   %eax,%eax
  80885c:	74 24                	je     808882 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80885e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808862:	48 8b 50 18          	mov    0x18(%rax),%rdx
  808866:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80886a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80886e:	48 89 d6             	mov    %rdx,%rsi
  808871:	48 89 c7             	mov    %rax,%rdi
  808874:	48 b8 12 72 81 00 00 	movabs $0x817212,%rax
  80887b:	00 00 00 
  80887e:	ff d0                	callq  *%rax
  808880:	eb 22                	jmp    8088a4 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  808882:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808886:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80888a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80888e:	48 8b 40 10          	mov    0x10(%rax),%rax
  808892:	48 89 d6             	mov    %rdx,%rsi
  808895:	48 89 c7             	mov    %rax,%rdi
  808898:	48 b8 6f 0d 81 00 00 	movabs $0x810d6f,%rax
  80889f:	00 00 00 
  8088a2:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8088a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088a8:	48 89 c6             	mov    %rax,%rsi
  8088ab:	bf 09 00 00 00       	mov    $0x9,%edi
  8088b0:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  8088b7:	00 00 00 
  8088ba:	ff d0                	callq  *%rax
      break;
  8088bc:	e9 a0 00 00 00       	jmpq   808961 <tcpip_thread+0x23f>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8088c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088c5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8088c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8088cd:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8088d1:	48 89 d7             	mov    %rdx,%rdi
  8088d4:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8088d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088da:	48 89 c6             	mov    %rax,%rsi
  8088dd:	bf 08 00 00 00       	mov    $0x8,%edi
  8088e2:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  8088e9:	00 00 00 
  8088ec:	ff d0                	callq  *%rax
      break;
  8088ee:	eb 71                	jmp    808961 <tcpip_thread+0x23f>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8088f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088f4:	8b 40 10             	mov    0x10(%rax),%eax
  8088f7:	83 f8 ff             	cmp    $0xffffffff,%eax
  8088fa:	74 2a                	je     808926 <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8088fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808900:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808904:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808908:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80890c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808910:	8b 40 10             	mov    0x10(%rax),%eax
  808913:	48 89 ce             	mov    %rcx,%rsi
  808916:	89 c7                	mov    %eax,%edi
  808918:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  80891f:	00 00 00 
  808922:	ff d0                	callq  *%rax
  808924:	eb 22                	jmp    808948 <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  808926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80892a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80892e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808932:	48 8b 40 18          	mov    0x18(%rax),%rax
  808936:	48 89 d6             	mov    %rdx,%rsi
  808939:	48 89 c7             	mov    %rax,%rdi
  80893c:	48 b8 d7 e8 80 00 00 	movabs $0x80e8d7,%rax
  808943:	00 00 00 
  808946:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808948:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80894c:	48 89 c6             	mov    %rax,%rsi
  80894f:	bf 08 00 00 00       	mov    $0x8,%edi
  808954:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80895b:	00 00 00 
  80895e:	ff d0                	callq  *%rax
      break;
  808960:	90                   	nop

    default:
      break;
    }
  }
  808961:	e9 79 fe ff ff       	jmpq   8087df <tcpip_thread+0xbd>

0000000000808966 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  808966:	55                   	push   %rbp
  808967:	48 89 e5             	mov    %rsp,%rbp
  80896a:	48 83 ec 20          	sub    $0x20,%rsp
  80896e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808972:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808976:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80897d:	00 00 00 
  808980:	8b 00                	mov    (%rax),%eax
  808982:	83 f8 ff             	cmp    $0xffffffff,%eax
  808985:	0f 84 90 00 00 00    	je     808a1b <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80898b:	bf 09 00 00 00       	mov    $0x9,%edi
  808990:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  808997:	00 00 00 
  80899a:	ff d0                	callq  *%rax
  80899c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  8089a0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8089a5:	75 07                	jne    8089ae <tcpip_input+0x48>
      return ERR_MEM;
  8089a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8089ac:	eb 72                	jmp    808a20 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  8089ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089b2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  8089b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8089c0:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  8089c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089c8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8089cc:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8089d0:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8089d7:	00 00 00 
  8089da:	8b 00                	mov    (%rax),%eax
  8089dc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8089e0:	48 89 d6             	mov    %rdx,%rsi
  8089e3:	89 c7                	mov    %eax,%edi
  8089e5:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  8089ec:	00 00 00 
  8089ef:	ff d0                	callq  *%rax
  8089f1:	84 c0                	test   %al,%al
  8089f3:	74 1f                	je     808a14 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8089f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089f9:	48 89 c6             	mov    %rax,%rsi
  8089fc:	bf 09 00 00 00       	mov    $0x9,%edi
  808a01:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  808a08:	00 00 00 
  808a0b:	ff d0                	callq  *%rax
      return ERR_MEM;
  808a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808a12:	eb 0c                	jmp    808a20 <tcpip_input+0xba>
    }
    return ERR_OK;
  808a14:	b8 00 00 00 00       	mov    $0x0,%eax
  808a19:	eb 05                	jmp    808a20 <tcpip_input+0xba>
  }
  return ERR_VAL;
  808a1b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808a20:	c9                   	leaveq 
  808a21:	c3                   	retq   

0000000000808a22 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808a22:	55                   	push   %rbp
  808a23:	48 89 e5             	mov    %rsp,%rbp
  808a26:	48 83 ec 30          	sub    $0x30,%rsp
  808a2a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808a2e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808a32:	89 d0                	mov    %edx,%eax
  808a34:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808a37:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808a3e:	00 00 00 
  808a41:	8b 00                	mov    (%rax),%eax
  808a43:	83 f8 ff             	cmp    $0xffffffff,%eax
  808a46:	0f 84 bc 00 00 00    	je     808b08 <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808a4c:	bf 08 00 00 00       	mov    $0x8,%edi
  808a51:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  808a58:	00 00 00 
  808a5b:	ff d0                	callq  *%rax
  808a5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808a61:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808a66:	75 0a                	jne    808a72 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  808a68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808a6d:	e9 9b 00 00 00       	jmpq   808b0d <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808a72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a76:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  808a7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a80:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808a84:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  808a88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a8c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808a90:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  808a94:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  808a98:	74 23                	je     808abd <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  808a9a:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808aa1:	00 00 00 
  808aa4:	8b 00                	mov    (%rax),%eax
  808aa6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808aaa:	48 89 d6             	mov    %rdx,%rsi
  808aad:	89 c7                	mov    %eax,%edi
  808aaf:	48 b8 e3 79 81 00 00 	movabs $0x8179e3,%rax
  808ab6:	00 00 00 
  808ab9:	ff d0                	callq  *%rax
  808abb:	eb 44                	jmp    808b01 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808abd:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808ac4:	00 00 00 
  808ac7:	8b 00                	mov    (%rax),%eax
  808ac9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808acd:	48 89 d6             	mov    %rdx,%rsi
  808ad0:	89 c7                	mov    %eax,%edi
  808ad2:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  808ad9:	00 00 00 
  808adc:	ff d0                	callq  *%rax
  808ade:	84 c0                	test   %al,%al
  808ae0:	74 1f                	je     808b01 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808ae2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ae6:	48 89 c6             	mov    %rax,%rsi
  808ae9:	bf 08 00 00 00       	mov    $0x8,%edi
  808aee:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  808af5:	00 00 00 
  808af8:	ff d0                	callq  *%rax
        return ERR_MEM;
  808afa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808aff:	eb 0c                	jmp    808b0d <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808b01:	b8 00 00 00 00       	mov    $0x0,%eax
  808b06:	eb 05                	jmp    808b0d <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  808b08:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808b0d:	c9                   	leaveq 
  808b0e:	c3                   	retq   

0000000000808b0f <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808b0f:	55                   	push   %rbp
  808b10:	48 89 e5             	mov    %rsp,%rbp
  808b13:	48 83 ec 30          	sub    $0x30,%rsp
  808b17:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808b1a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808b1e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808b22:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b29:	00 00 00 
  808b2c:	8b 00                	mov    (%rax),%eax
  808b2e:	83 f8 ff             	cmp    $0xffffffff,%eax
  808b31:	74 77                	je     808baa <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808b33:	bf 08 00 00 00       	mov    $0x8,%edi
  808b38:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  808b3f:	00 00 00 
  808b42:	ff d0                	callq  *%rax
  808b44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808b48:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b4d:	75 07                	jne    808b56 <tcpip_timeout+0x47>
      return ERR_MEM;
  808b4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b54:	eb 59                	jmp    808baf <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808b56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b5a:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808b60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b64:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808b67:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808b6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b6e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808b72:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808b76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b7a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808b7e:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808b82:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b89:	00 00 00 
  808b8c:	8b 00                	mov    (%rax),%eax
  808b8e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b92:	48 89 d6             	mov    %rdx,%rsi
  808b95:	89 c7                	mov    %eax,%edi
  808b97:	48 b8 e3 79 81 00 00 	movabs $0x8179e3,%rax
  808b9e:	00 00 00 
  808ba1:	ff d0                	callq  *%rax
    return ERR_OK;
  808ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  808ba8:	eb 05                	jmp    808baf <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  808baa:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808baf:	c9                   	leaveq 
  808bb0:	c3                   	retq   

0000000000808bb1 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  808bb1:	55                   	push   %rbp
  808bb2:	48 89 e5             	mov    %rsp,%rbp
  808bb5:	48 83 ec 40          	sub    $0x40,%rsp
  808bb9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  808bbd:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808bc4:	00 00 00 
  808bc7:	8b 00                	mov    (%rax),%eax
  808bc9:	83 f8 ff             	cmp    $0xffffffff,%eax
  808bcc:	74 55                	je     808c23 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  808bce:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  808bd5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808bd9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  808bdd:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808be4:	00 00 00 
  808be7:	8b 00                	mov    (%rax),%eax
  808be9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  808bed:	48 89 d6             	mov    %rdx,%rsi
  808bf0:	89 c7                	mov    %eax,%edi
  808bf2:	48 b8 e3 79 81 00 00 	movabs $0x8179e3,%rax
  808bf9:	00 00 00 
  808bfc:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808bfe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808c02:	48 8b 40 08          	mov    0x8(%rax),%rax
  808c06:	8b 40 14             	mov    0x14(%rax),%eax
  808c09:	be 00 00 00 00       	mov    $0x0,%esi
  808c0e:	89 c7                	mov    %eax,%edi
  808c10:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  808c17:	00 00 00 
  808c1a:	ff d0                	callq  *%rax
    return ERR_OK;
  808c1c:	b8 00 00 00 00       	mov    $0x0,%eax
  808c21:	eb 05                	jmp    808c28 <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808c23:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808c28:	c9                   	leaveq 
  808c29:	c3                   	retq   

0000000000808c2a <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808c2a:	55                   	push   %rbp
  808c2b:	48 89 e5             	mov    %rsp,%rbp
  808c2e:	48 83 ec 10          	sub    $0x10,%rsp
  808c32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808c36:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808c3a:	48 b8 d5 92 80 00 00 	movabs $0x8092d5,%rax
  808c41:	00 00 00 
  808c44:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808c46:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808c4d:	00 00 00 
  808c50:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808c54:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808c57:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808c5e:	00 00 00 
  808c61:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808c65:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808c68:	bf 00 00 00 00       	mov    $0x0,%edi
  808c6d:	48 b8 b4 75 81 00 00 	movabs $0x8175b4,%rax
  808c74:	00 00 00 
  808c77:	ff d0                	callq  *%rax
  808c79:	48 ba 78 81 82 00 00 	movabs $0x828178,%rdx
  808c80:	00 00 00 
  808c83:	89 02                	mov    %eax,(%rdx)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  808c85:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808c8b:	b9 00 00 00 00       	mov    $0x0,%ecx
  808c90:	ba 00 00 00 00       	mov    $0x0,%edx
  808c95:	48 be 22 87 80 00 00 	movabs $0x808722,%rsi
  808c9c:	00 00 00 
  808c9f:	48 bf d3 15 82 00 00 	movabs $0x8215d3,%rdi
  808ca6:	00 00 00 
  808ca9:	48 b8 4d 85 81 00 00 	movabs $0x81854d,%rax
  808cb0:	00 00 00 
  808cb3:	ff d0                	callq  *%rax
}
  808cb5:	c9                   	leaveq 
  808cb6:	c3                   	retq   

0000000000808cb7 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  808cb7:	55                   	push   %rbp
  808cb8:	48 89 e5             	mov    %rsp,%rbp
  808cbb:	48 83 ec 20          	sub    $0x20,%rsp
  808cbf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  808cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808cc7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  808ccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ccf:	48 89 c7             	mov    %rax,%rdi
  808cd2:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  808cd9:	00 00 00 
  808cdc:	ff d0                	callq  *%rax
}
  808cde:	c9                   	leaveq 
  808cdf:	c3                   	retq   

0000000000808ce0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808ce0:	55                   	push   %rbp
  808ce1:	48 89 e5             	mov    %rsp,%rbp
  808ce4:	48 83 ec 10          	sub    $0x10,%rsp
  808ce8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808cec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cf0:	ba 00 00 00 00       	mov    $0x0,%edx
  808cf5:	48 89 c6             	mov    %rax,%rsi
  808cf8:	48 bf b7 8c 80 00 00 	movabs $0x808cb7,%rdi
  808cff:	00 00 00 
  808d02:	48 b8 22 8a 80 00 00 	movabs $0x808a22,%rax
  808d09:	00 00 00 
  808d0c:	ff d0                	callq  *%rax
}
  808d0e:	c9                   	leaveq 
  808d0f:	c3                   	retq   

0000000000808d10 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808d10:	55                   	push   %rbp
  808d11:	48 89 e5             	mov    %rsp,%rbp
  808d14:	48 83 ec 10          	sub    $0x10,%rsp
  808d18:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808d1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d20:	ba 00 00 00 00       	mov    $0x0,%edx
  808d25:	48 89 c6             	mov    %rax,%rsi
  808d28:	48 bf d9 c3 80 00 00 	movabs $0x80c3d9,%rdi
  808d2f:	00 00 00 
  808d32:	48 b8 22 8a 80 00 00 	movabs $0x808a22,%rax
  808d39:	00 00 00 
  808d3c:	ff d0                	callq  *%rax
}
  808d3e:	c9                   	leaveq 
  808d3f:	c3                   	retq   

0000000000808d40 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808d40:	55                   	push   %rbp
  808d41:	48 89 e5             	mov    %rsp,%rbp
  808d44:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808d48:	bf 06 00 00 00       	mov    $0x6,%edi
  808d4d:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  808d54:	00 00 00 
  808d57:	ff d0                	callq  *%rax
  808d59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808d5d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808d62:	74 29                	je     808d8d <netbuf_new+0x4d>
    buf->p = NULL;
  808d64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d68:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808d6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d73:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808d7a:	00 
    buf->addr = NULL;
  808d7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d7f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808d86:	00 
    return buf;
  808d87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d8b:	eb 05                	jmp    808d92 <netbuf_new+0x52>
  } else {
    return NULL;
  808d8d:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808d92:	c9                   	leaveq 
  808d93:	c3                   	retq   

0000000000808d94 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808d94:	55                   	push   %rbp
  808d95:	48 89 e5             	mov    %rsp,%rbp
  808d98:	48 83 ec 10          	sub    $0x10,%rsp
  808d9c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808da0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808da5:	74 55                	je     808dfc <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808da7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dab:	48 8b 00             	mov    (%rax),%rax
  808dae:	48 85 c0             	test   %rax,%rax
  808db1:	74 31                	je     808de4 <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808db3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808db7:	48 8b 00             	mov    (%rax),%rax
  808dba:	48 89 c7             	mov    %rax,%rdi
  808dbd:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  808dc4:	00 00 00 
  808dc7:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808dc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dcd:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808dd4:	00 
  808dd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dd9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808ddd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808de1:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808de4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808de8:	48 89 c6             	mov    %rax,%rsi
  808deb:	bf 06 00 00 00       	mov    $0x6,%edi
  808df0:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  808df7:	00 00 00 
  808dfa:	ff d0                	callq  *%rax
  }
}
  808dfc:	c9                   	leaveq 
  808dfd:	c3                   	retq   

0000000000808dfe <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808dfe:	55                   	push   %rbp
  808dff:	48 89 e5             	mov    %rsp,%rbp
  808e02:	48 83 ec 10          	sub    $0x10,%rsp
  808e06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808e0a:	89 f0                	mov    %esi,%eax
  808e0c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808e10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e15:	75 2a                	jne    808e41 <netbuf_alloc+0x43>
  808e17:	48 ba e0 15 82 00 00 	movabs $0x8215e0,%rdx
  808e1e:	00 00 00 
  808e21:	be 63 00 00 00       	mov    $0x63,%esi
  808e26:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  808e2d:	00 00 00 
  808e30:	b8 00 00 00 00       	mov    $0x0,%eax
  808e35:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  808e3c:	00 00 00 
  808e3f:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808e41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e45:	48 8b 00             	mov    (%rax),%rax
  808e48:	48 85 c0             	test   %rax,%rax
  808e4b:	74 16                	je     808e63 <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808e4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e51:	48 8b 00             	mov    (%rax),%rax
  808e54:	48 89 c7             	mov    %rax,%rdi
  808e57:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  808e5e:	00 00 00 
  808e61:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808e63:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808e67:	ba 00 00 00 00       	mov    $0x0,%edx
  808e6c:	89 c6                	mov    %eax,%esi
  808e6e:	bf 00 00 00 00       	mov    $0x0,%edi
  808e73:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  808e7a:	00 00 00 
  808e7d:	ff d0                	callq  *%rax
  808e7f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808e83:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808e86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e8a:	48 8b 00             	mov    (%rax),%rax
  808e8d:	48 85 c0             	test   %rax,%rax
  808e90:	75 07                	jne    808e99 <netbuf_alloc+0x9b>
     return NULL;
  808e92:	b8 00 00 00 00       	mov    $0x0,%eax
  808e97:	eb 55                	jmp    808eee <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808e99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e9d:	48 8b 00             	mov    (%rax),%rax
  808ea0:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808ea4:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808ea8:	73 2a                	jae    808ed4 <netbuf_alloc+0xd6>
  808eaa:	48 ba 10 16 82 00 00 	movabs $0x821610,%rdx
  808eb1:	00 00 00 
  808eb4:	be 6e 00 00 00       	mov    $0x6e,%esi
  808eb9:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  808ec0:	00 00 00 
  808ec3:	b8 00 00 00 00       	mov    $0x0,%eax
  808ec8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  808ecf:	00 00 00 
  808ed2:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  808ed4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ed8:	48 8b 10             	mov    (%rax),%rdx
  808edb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808edf:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ee7:	48 8b 00             	mov    (%rax),%rax
  808eea:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808eee:	c9                   	leaveq 
  808eef:	c3                   	retq   

0000000000808ef0 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808ef0:	55                   	push   %rbp
  808ef1:	48 89 e5             	mov    %rsp,%rbp
  808ef4:	48 83 ec 10          	sub    $0x10,%rsp
  808ef8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808efc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f01:	75 2a                	jne    808f2d <netbuf_free+0x3d>
  808f03:	48 ba 34 16 82 00 00 	movabs $0x821634,%rdx
  808f0a:	00 00 00 
  808f0d:	be 7b 00 00 00       	mov    $0x7b,%esi
  808f12:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  808f19:	00 00 00 
  808f1c:	b8 00 00 00 00       	mov    $0x0,%eax
  808f21:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  808f28:	00 00 00 
  808f2b:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808f2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f31:	48 8b 00             	mov    (%rax),%rax
  808f34:	48 85 c0             	test   %rax,%rax
  808f37:	74 16                	je     808f4f <netbuf_free+0x5f>
    pbuf_free(buf->p);
  808f39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f3d:	48 8b 00             	mov    (%rax),%rax
  808f40:	48 89 c7             	mov    %rax,%rdi
  808f43:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  808f4a:	00 00 00 
  808f4d:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  808f4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f53:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808f5a:	00 
  808f5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f5f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808f63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f67:	48 89 10             	mov    %rdx,(%rax)
}
  808f6a:	c9                   	leaveq 
  808f6b:	c3                   	retq   

0000000000808f6c <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  808f6c:	55                   	push   %rbp
  808f6d:	48 89 e5             	mov    %rsp,%rbp
  808f70:	48 83 ec 20          	sub    $0x20,%rsp
  808f74:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808f78:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808f7c:	89 d0                	mov    %edx,%eax
  808f7e:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  808f82:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f87:	75 2a                	jne    808fb3 <netbuf_ref+0x47>
  808f89:	48 ba 4d 16 82 00 00 	movabs $0x82164d,%rdx
  808f90:	00 00 00 
  808f93:	be 8e 00 00 00       	mov    $0x8e,%esi
  808f98:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  808f9f:	00 00 00 
  808fa2:	b8 00 00 00 00       	mov    $0x0,%eax
  808fa7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  808fae:	00 00 00 
  808fb1:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808fb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fb7:	48 8b 00             	mov    (%rax),%rax
  808fba:	48 85 c0             	test   %rax,%rax
  808fbd:	74 16                	je     808fd5 <netbuf_ref+0x69>
    pbuf_free(buf->p);
  808fbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fc3:	48 8b 00             	mov    (%rax),%rax
  808fc6:	48 89 c7             	mov    %rax,%rdi
  808fc9:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  808fd0:	00 00 00 
  808fd3:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  808fd5:	ba 02 00 00 00       	mov    $0x2,%edx
  808fda:	be 00 00 00 00       	mov    $0x0,%esi
  808fdf:	bf 00 00 00 00       	mov    $0x0,%edi
  808fe4:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  808feb:	00 00 00 
  808fee:	ff d0                	callq  *%rax
  808ff0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808ff4:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808ff7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ffb:	48 8b 00             	mov    (%rax),%rax
  808ffe:	48 85 c0             	test   %rax,%rax
  809001:	75 13                	jne    809016 <netbuf_ref+0xaa>
    buf->ptr = NULL;
  809003:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809007:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80900e:	00 
    return ERR_MEM;
  80900f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809014:	eb 41                	jmp    809057 <netbuf_ref+0xeb>
  }
  buf->p->payload = (void*)dataptr;
  809016:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80901a:	48 8b 00             	mov    (%rax),%rax
  80901d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  809021:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  809025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809029:	48 8b 10             	mov    (%rax),%rdx
  80902c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809030:	48 8b 00             	mov    (%rax),%rax
  809033:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  809037:	66 89 48 10          	mov    %cx,0x10(%rax)
  80903b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80903f:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  809043:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809047:	48 8b 10             	mov    (%rax),%rdx
  80904a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80904e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  809052:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809057:	c9                   	leaveq 
  809058:	c3                   	retq   

0000000000809059 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  809059:	55                   	push   %rbp
  80905a:	48 89 e5             	mov    %rsp,%rbp
  80905d:	48 83 ec 10          	sub    $0x10,%rsp
  809061:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809065:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  809069:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80906e:	75 2a                	jne    80909a <netbuf_chain+0x41>
  809070:	48 ba 65 16 82 00 00 	movabs $0x821665,%rdx
  809077:	00 00 00 
  80907a:	be a6 00 00 00       	mov    $0xa6,%esi
  80907f:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  809086:	00 00 00 
  809089:	b8 00 00 00 00       	mov    $0x0,%eax
  80908e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  809095:	00 00 00 
  809098:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80909a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80909f:	75 2a                	jne    8090cb <netbuf_chain+0x72>
  8090a1:	48 ba 7e 16 82 00 00 	movabs $0x82167e,%rdx
  8090a8:	00 00 00 
  8090ab:	be a7 00 00 00       	mov    $0xa7,%esi
  8090b0:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  8090b7:	00 00 00 
  8090ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8090bf:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8090c6:	00 00 00 
  8090c9:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  8090cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8090cf:	48 8b 10             	mov    (%rax),%rdx
  8090d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090d6:	48 8b 00             	mov    (%rax),%rax
  8090d9:	48 89 d6             	mov    %rdx,%rsi
  8090dc:	48 89 c7             	mov    %rax,%rdi
  8090df:	48 b8 49 df 80 00 00 	movabs $0x80df49,%rax
  8090e6:	00 00 00 
  8090e9:	ff d0                	callq  *%rax
  head->ptr = head->p;
  8090eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090ef:	48 8b 10             	mov    (%rax),%rdx
  8090f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090f6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  8090fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8090fe:	48 89 c6             	mov    %rax,%rsi
  809101:	bf 06 00 00 00       	mov    $0x6,%edi
  809106:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80910d:	00 00 00 
  809110:	ff d0                	callq  *%rax
}
  809112:	c9                   	leaveq 
  809113:	c3                   	retq   

0000000000809114 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  809114:	55                   	push   %rbp
  809115:	48 89 e5             	mov    %rsp,%rbp
  809118:	48 83 ec 20          	sub    $0x20,%rsp
  80911c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809120:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  809124:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  809128:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80912d:	75 2a                	jne    809159 <netbuf_data+0x45>
  80912f:	48 ba 99 16 82 00 00 	movabs $0x821699,%rdx
  809136:	00 00 00 
  809139:	be b9 00 00 00       	mov    $0xb9,%esi
  80913e:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  809145:	00 00 00 
  809148:	b8 00 00 00 00       	mov    $0x0,%eax
  80914d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  809154:	00 00 00 
  809157:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  809159:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80915e:	75 2a                	jne    80918a <netbuf_data+0x76>
  809160:	48 ba b2 16 82 00 00 	movabs $0x8216b2,%rdx
  809167:	00 00 00 
  80916a:	be ba 00 00 00       	mov    $0xba,%esi
  80916f:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  809176:	00 00 00 
  809179:	b8 00 00 00 00       	mov    $0x0,%eax
  80917e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  809185:	00 00 00 
  809188:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80918a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80918f:	75 2a                	jne    8091bb <netbuf_data+0xa7>
  809191:	48 ba cf 16 82 00 00 	movabs $0x8216cf,%rdx
  809198:	00 00 00 
  80919b:	be bb 00 00 00       	mov    $0xbb,%esi
  8091a0:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  8091a7:	00 00 00 
  8091aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8091af:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8091b6:	00 00 00 
  8091b9:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  8091bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8091c3:	48 85 c0             	test   %rax,%rax
  8091c6:	75 07                	jne    8091cf <netbuf_data+0xbb>
    return ERR_BUF;
  8091c8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8091cd:	eb 2b                	jmp    8091fa <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  8091cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8091d7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8091db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8091df:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  8091e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8091ea:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8091ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8091f2:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  8091f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8091fa:	c9                   	leaveq 
  8091fb:	c3                   	retq   

00000000008091fc <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8091fc:	55                   	push   %rbp
  8091fd:	48 89 e5             	mov    %rsp,%rbp
  809200:	48 83 ec 10          	sub    $0x10,%rsp
  809204:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  809208:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80920d:	75 2a                	jne    809239 <netbuf_next+0x3d>
  80920f:	48 ba 34 16 82 00 00 	movabs $0x821634,%rdx
  809216:	00 00 00 
  809219:	be d2 00 00 00       	mov    $0xd2,%esi
  80921e:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  809225:	00 00 00 
  809228:	b8 00 00 00 00       	mov    $0x0,%eax
  80922d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  809234:	00 00 00 
  809237:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  809239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80923d:	48 8b 40 08          	mov    0x8(%rax),%rax
  809241:	48 8b 00             	mov    (%rax),%rax
  809244:	48 85 c0             	test   %rax,%rax
  809247:	75 07                	jne    809250 <netbuf_next+0x54>
    return -1;
  809249:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80924e:	eb 2f                	jmp    80927f <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  809250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809254:	48 8b 40 08          	mov    0x8(%rax),%rax
  809258:	48 8b 10             	mov    (%rax),%rdx
  80925b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80925f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  809263:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809267:	48 8b 40 08          	mov    0x8(%rax),%rax
  80926b:	48 8b 00             	mov    (%rax),%rax
  80926e:	48 85 c0             	test   %rax,%rax
  809271:	75 07                	jne    80927a <netbuf_next+0x7e>
    return 1;
  809273:	b8 01 00 00 00       	mov    $0x1,%eax
  809278:	eb 05                	jmp    80927f <netbuf_next+0x83>
  }
  return 0;
  80927a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80927f:	c9                   	leaveq 
  809280:	c3                   	retq   

0000000000809281 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  809281:	55                   	push   %rbp
  809282:	48 89 e5             	mov    %rsp,%rbp
  809285:	48 83 ec 10          	sub    $0x10,%rsp
  809289:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80928d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809292:	75 2a                	jne    8092be <netbuf_first+0x3d>
  809294:	48 ba 34 16 82 00 00 	movabs $0x821634,%rdx
  80929b:	00 00 00 
  80929e:	be e7 00 00 00       	mov    $0xe7,%esi
  8092a3:	48 bf fa 15 82 00 00 	movabs $0x8215fa,%rdi
  8092aa:	00 00 00 
  8092ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8092b2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8092b9:	00 00 00 
  8092bc:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  8092be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092c2:	48 8b 10             	mov    (%rax),%rdx
  8092c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092c9:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  8092cd:	c9                   	leaveq 
  8092ce:	c3                   	retq   

00000000008092cf <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8092cf:	55                   	push   %rbp
  8092d0:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8092d3:	5d                   	pop    %rbp
  8092d4:	c3                   	retq   

00000000008092d5 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8092d5:	55                   	push   %rbp
  8092d6:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  8092d9:	48 b8 cf 92 80 00 00 	movabs $0x8092cf,%rax
  8092e0:	00 00 00 
  8092e3:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  8092e5:	48 b8 24 73 81 00 00 	movabs $0x817324,%rax
  8092ec:	00 00 00 
  8092ef:	ff d0                	callq  *%rax
  mem_init();
  8092f1:	48 b8 ef c2 80 00 00 	movabs $0x80c2ef,%rax
  8092f8:	00 00 00 
  8092fb:	ff d0                	callq  *%rax
  memp_init();
  8092fd:	48 b8 52 cc 80 00 00 	movabs $0x80cc52,%rax
  809304:	00 00 00 
  809307:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  809309:	48 b8 07 5c 80 00 00 	movabs $0x805c07,%rax
  809310:	00 00 00 
  809313:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  809315:	5d                   	pop    %rbp
  809316:	c3                   	retq   

0000000000809317 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  809317:	55                   	push   %rbp
  809318:	48 89 e5             	mov    %rsp,%rbp
  80931b:	48 83 ec 20          	sub    $0x20,%rsp
  80931f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809327:	48 8b 40 38          	mov    0x38(%rax),%rax
  80932b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  80932f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809333:	48 89 c7             	mov    %rax,%rdi
  809336:	48 b8 eb d2 80 00 00 	movabs $0x80d2eb,%rax
  80933d:	00 00 00 
  809340:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  809342:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809346:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80934d:	00 00 00 
  809350:	48 89 c7             	mov    %rax,%rdi
  809353:	48 b8 03 d1 80 00 00 	movabs $0x80d103,%rax
  80935a:	00 00 00 
  80935d:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80935f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809363:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80936a:	00 00 00 
  80936d:	48 89 c7             	mov    %rax,%rdi
  809370:	48 b8 09 d2 80 00 00 	movabs $0x80d209,%rax
  809377:	00 00 00 
  80937a:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80937c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809380:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  809387:	00 00 00 
  80938a:	48 89 c7             	mov    %rax,%rdi
  80938d:	48 b8 36 d2 80 00 00 	movabs $0x80d236,%rax
  809394:	00 00 00 
  809397:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  809399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80939d:	be 0c 00 00 00       	mov    $0xc,%esi
  8093a2:	48 89 c7             	mov    %rax,%rdi
  8093a5:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  8093ac:	00 00 00 
  8093af:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8093b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8093b5:	48 89 c7             	mov    %rax,%rdi
  8093b8:	48 b8 c5 a4 80 00 00 	movabs $0x80a4c5,%rax
  8093bf:	00 00 00 
  8093c2:	ff d0                	callq  *%rax
}
  8093c4:	c9                   	leaveq 
  8093c5:	c3                   	retq   

00000000008093c6 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8093c6:	55                   	push   %rbp
  8093c7:	48 89 e5             	mov    %rsp,%rbp
  8093ca:	48 83 ec 20          	sub    $0x20,%rsp
  8093ce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8093d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8093d6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8093da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8093de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093e2:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  8093e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8093ea:	ba 00 00 00 00       	mov    $0x0,%edx
  8093ef:	48 89 ce             	mov    %rcx,%rsi
  8093f2:	48 89 c7             	mov    %rax,%rdi
  8093f5:	48 b8 c6 6a 81 00 00 	movabs $0x816ac6,%rax
  8093fc:	00 00 00 
  8093ff:	ff d0                	callq  *%rax
  809401:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  809404:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809408:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80940c:	8d 50 01             	lea    0x1(%rax),%edx
  80940f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809413:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  809416:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80941c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809420:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809426:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80942b:	89 c8                	mov    %ecx,%eax
  80942d:	f7 ea                	imul   %edx
  80942f:	c1 fa 05             	sar    $0x5,%edx
  809432:	89 c8                	mov    %ecx,%eax
  809434:	c1 f8 1f             	sar    $0x1f,%eax
  809437:	29 c2                	sub    %eax,%edx
  809439:	89 d0                	mov    %edx,%eax
  80943b:	89 c2                	mov    %eax,%edx
  80943d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809441:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  809445:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809449:	be 08 00 00 00       	mov    $0x8,%esi
  80944e:	48 89 c7             	mov    %rax,%rdi
  809451:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  809458:	00 00 00 
  80945b:	ff d0                	callq  *%rax
}
  80945d:	c9                   	leaveq 
  80945e:	c3                   	retq   

000000000080945f <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  80945f:	55                   	push   %rbp
  809460:	48 89 e5             	mov    %rsp,%rbp
  809463:	48 83 ec 20          	sub    $0x20,%rsp
  809467:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80946b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80946f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809473:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  809477:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80947b:	be 36 00 00 00       	mov    $0x36,%esi
  809480:	48 89 c7             	mov    %rax,%rdi
  809483:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  80948a:	00 00 00 
  80948d:	ff d0                	callq  *%rax
  80948f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  809493:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  809498:	74 69                	je     809503 <dhcp_handle_offer+0xa4>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80949a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80949e:	48 83 c0 02          	add    $0x2,%rax
  8094a2:	48 89 c7             	mov    %rax,%rdi
  8094a5:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  8094ac:	00 00 00 
  8094af:	ff d0                	callq  *%rax
  8094b1:	89 c7                	mov    %eax,%edi
  8094b3:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  8094ba:	00 00 00 
  8094bd:	ff d0                	callq  *%rax
  8094bf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8094c3:	89 42 48             	mov    %eax,0x48(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8094c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094ca:	48 8b 40 18          	mov    0x18(%rax),%rax
  8094ce:	48 83 c0 10          	add    $0x10,%rax
  8094d2:	48 85 c0             	test   %rax,%rax
  8094d5:	74 0d                	je     8094e4 <dhcp_handle_offer+0x85>
  8094d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094db:	48 8b 40 18          	mov    0x18(%rax),%rax
  8094df:	8b 40 10             	mov    0x10(%rax),%eax
  8094e2:	eb 05                	jmp    8094e9 <dhcp_handle_offer+0x8a>
  8094e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8094e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8094ed:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8094f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094f4:	48 89 c7             	mov    %rax,%rdi
  8094f7:	48 b8 05 95 80 00 00 	movabs $0x809505,%rax
  8094fe:	00 00 00 
  809501:	ff d0                	callq  *%rax
  }
}
  809503:	c9                   	leaveq 
  809504:	c3                   	retq   

0000000000809505 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  809505:	55                   	push   %rbp
  809506:	48 89 e5             	mov    %rsp,%rbp
  809509:	48 83 ec 20          	sub    $0x20,%rsp
  80950d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809511:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809515:	48 8b 40 38          	mov    0x38(%rax),%rax
  809519:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80951d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809521:	48 89 c7             	mov    %rax,%rdi
  809524:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80952b:	00 00 00 
  80952e:	ff d0                	callq  *%rax
  809530:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809533:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809537:	0f 85 3a 02 00 00    	jne    809777 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80953d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809541:	ba 01 00 00 00       	mov    $0x1,%edx
  809546:	be 35 00 00 00       	mov    $0x35,%esi
  80954b:	48 89 c7             	mov    %rax,%rdi
  80954e:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  809555:	00 00 00 
  809558:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80955a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80955e:	be 03 00 00 00       	mov    $0x3,%esi
  809563:	48 89 c7             	mov    %rax,%rdi
  809566:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80956d:	00 00 00 
  809570:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809572:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809576:	ba 02 00 00 00       	mov    $0x2,%edx
  80957b:	be 39 00 00 00       	mov    $0x39,%esi
  809580:	48 89 c7             	mov    %rax,%rdi
  809583:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80958a:	00 00 00 
  80958d:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80958f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809593:	be 40 02 00 00       	mov    $0x240,%esi
  809598:	48 89 c7             	mov    %rax,%rdi
  80959b:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  8095a2:	00 00 00 
  8095a5:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8095a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095ab:	ba 04 00 00 00       	mov    $0x4,%edx
  8095b0:	be 32 00 00 00       	mov    $0x32,%esi
  8095b5:	48 89 c7             	mov    %rax,%rdi
  8095b8:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  8095bf:	00 00 00 
  8095c2:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8095c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095c8:	8b 40 4c             	mov    0x4c(%rax),%eax
  8095cb:	89 c7                	mov    %eax,%edi
  8095cd:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8095d4:	00 00 00 
  8095d7:	ff d0                	callq  *%rax
  8095d9:	89 c2                	mov    %eax,%edx
  8095db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095df:	89 d6                	mov    %edx,%esi
  8095e1:	48 89 c7             	mov    %rax,%rdi
  8095e4:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  8095eb:	00 00 00 
  8095ee:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8095f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095f4:	ba 04 00 00 00       	mov    $0x4,%edx
  8095f9:	be 36 00 00 00       	mov    $0x36,%esi
  8095fe:	48 89 c7             	mov    %rax,%rdi
  809601:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  809608:	00 00 00 
  80960b:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80960d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809611:	8b 40 48             	mov    0x48(%rax),%eax
  809614:	89 c7                	mov    %eax,%edi
  809616:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  80961d:	00 00 00 
  809620:	ff d0                	callq  *%rax
  809622:	89 c2                	mov    %eax,%edx
  809624:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809628:	89 d6                	mov    %edx,%esi
  80962a:	48 89 c7             	mov    %rax,%rdi
  80962d:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  809634:	00 00 00 
  809637:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80963d:	ba 04 00 00 00       	mov    $0x4,%edx
  809642:	be 37 00 00 00       	mov    $0x37,%esi
  809647:	48 89 c7             	mov    %rax,%rdi
  80964a:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  809651:	00 00 00 
  809654:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809656:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80965a:	be 01 00 00 00       	mov    $0x1,%esi
  80965f:	48 89 c7             	mov    %rax,%rdi
  809662:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  809669:	00 00 00 
  80966c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80966e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809672:	be 03 00 00 00       	mov    $0x3,%esi
  809677:	48 89 c7             	mov    %rax,%rdi
  80967a:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  809681:	00 00 00 
  809684:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  809686:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80968a:	be 1c 00 00 00       	mov    $0x1c,%esi
  80968f:	48 89 c7             	mov    %rax,%rdi
  809692:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  809699:	00 00 00 
  80969c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80969e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096a2:	be 06 00 00 00       	mov    $0x6,%esi
  8096a7:	48 89 c7             	mov    %rax,%rdi
  8096aa:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  8096b1:	00 00 00 
  8096b4:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8096b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096ba:	48 89 c7             	mov    %rax,%rdi
  8096bd:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  8096c4:	00 00 00 
  8096c7:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8096c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096cd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8096d1:	66 05 f0 00          	add    $0xf0,%ax
  8096d5:	0f b7 d0             	movzwl %ax,%edx
  8096d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096dc:	48 8b 40 30          	mov    0x30(%rax),%rax
  8096e0:	89 d6                	mov    %edx,%esi
  8096e2:	48 89 c7             	mov    %rax,%rdi
  8096e5:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  8096ec:	00 00 00 
  8096ef:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8096f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096f5:	48 8b 70 30          	mov    0x30(%rax),%rsi
  8096f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  809701:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809705:	49 89 d0             	mov    %rdx,%r8
  809708:	b9 43 00 00 00       	mov    $0x43,%ecx
  80970d:	48 ba ec 24 82 00 00 	movabs $0x8224ec,%rdx
  809714:	00 00 00 
  809717:	48 89 c7             	mov    %rax,%rdi
  80971a:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  809721:	00 00 00 
  809724:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80972a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80972e:	ba 43 00 00 00       	mov    $0x43,%edx
  809733:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80973a:	00 00 00 
  80973d:	48 89 c7             	mov    %rax,%rdi
  809740:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  809747:	00 00 00 
  80974a:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80974c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809750:	48 89 c7             	mov    %rax,%rdi
  809753:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80975a:	00 00 00 
  80975d:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80975f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809763:	be 01 00 00 00       	mov    $0x1,%esi
  809768:	48 89 c7             	mov    %rax,%rdi
  80976b:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  809772:	00 00 00 
  809775:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80977b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80977f:	8d 50 01             	lea    0x1(%rax),%edx
  809782:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809786:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  809789:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80978d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809791:	3c 03                	cmp    $0x3,%al
  809793:	77 12                	ja     8097a7 <dhcp_select+0x2a2>
  809795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809799:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80979d:	0f b6 c0             	movzbl %al,%eax
  8097a0:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  8097a5:	eb 05                	jmp    8097ac <dhcp_select+0x2a7>
  8097a7:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8097ac:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8097b0:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8097b4:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8097ba:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8097bf:	89 c8                	mov    %ecx,%eax
  8097c1:	f7 ea                	imul   %edx
  8097c3:	c1 fa 05             	sar    $0x5,%edx
  8097c6:	89 c8                	mov    %ecx,%eax
  8097c8:	c1 f8 1f             	sar    $0x1f,%eax
  8097cb:	29 c2                	sub    %eax,%edx
  8097cd:	89 d0                	mov    %edx,%eax
  8097cf:	89 c2                	mov    %eax,%edx
  8097d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097d5:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8097d9:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8097dd:	c9                   	leaveq 
  8097de:	c3                   	retq   

00000000008097df <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8097df:	55                   	push   %rbp
  8097e0:	48 89 e5             	mov    %rsp,%rbp
  8097e3:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8097e7:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8097ee:	00 00 00 
  8097f1:	48 8b 00             	mov    (%rax),%rax
  8097f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8097f8:	eb 72                	jmp    80986c <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8097fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097fe:	48 8b 40 38          	mov    0x38(%rax),%rax
  809802:	48 85 c0             	test   %rax,%rax
  809805:	74 5a                	je     809861 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  809807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80980b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80980f:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809813:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809816:	66 89 48 46          	mov    %cx,0x46(%rax)
  80981a:	66 83 fa 01          	cmp    $0x1,%dx
  80981e:	75 15                	jne    809835 <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809820:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809824:	48 89 c7             	mov    %rax,%rdi
  809827:	48 b8 b6 9a 80 00 00 	movabs $0x809ab6,%rax
  80982e:	00 00 00 
  809831:	ff d0                	callq  *%rax
  809833:	eb 2c                	jmp    809861 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809839:	48 8b 40 38          	mov    0x38(%rax),%rax
  80983d:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809841:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809844:	66 89 48 44          	mov    %cx,0x44(%rax)
  809848:	66 83 fa 01          	cmp    $0x1,%dx
  80984c:	75 13                	jne    809861 <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  80984e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809852:	48 89 c7             	mov    %rax,%rdi
  809855:	48 b8 68 9a 80 00 00 	movabs $0x809a68,%rax
  80985c:	00 00 00 
  80985f:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  809861:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809865:	48 8b 00             	mov    (%rax),%rax
  809868:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80986c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809871:	75 87                	jne    8097fa <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  809873:	c9                   	leaveq 
  809874:	c3                   	retq   

0000000000809875 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  809875:	55                   	push   %rbp
  809876:	48 89 e5             	mov    %rsp,%rbp
  809879:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  80987d:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  809884:	00 00 00 
  809887:	48 8b 00             	mov    (%rax),%rax
  80988a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  80988e:	eb 77                	jmp    809907 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  809890:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809894:	48 8b 40 38          	mov    0x38(%rax),%rax
  809898:	48 85 c0             	test   %rax,%rax
  80989b:	74 5f                	je     8098fc <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  80989d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098a1:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098a5:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8098a9:	66 83 f8 01          	cmp    $0x1,%ax
  8098ad:	76 15                	jbe    8098c4 <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  8098af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098b3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098b7:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8098bb:	83 ea 01             	sub    $0x1,%edx
  8098be:	66 89 50 42          	mov    %dx,0x42(%rax)
  8098c2:	eb 38                	jmp    8098fc <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8098c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098c8:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098cc:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8098d0:	66 83 f8 01          	cmp    $0x1,%ax
  8098d4:	75 26                	jne    8098fc <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  8098d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098da:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098de:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8098e2:	83 ea 01             	sub    $0x1,%edx
  8098e5:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  8098e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ed:	48 89 c7             	mov    %rax,%rdi
  8098f0:	48 b8 10 99 80 00 00 	movabs $0x809910,%rax
  8098f7:	00 00 00 
  8098fa:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8098fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809900:	48 8b 00             	mov    (%rax),%rax
  809903:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  809907:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80990c:	75 82                	jne    809890 <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  80990e:	c9                   	leaveq 
  80990f:	c3                   	retq   

0000000000809910 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  809910:	55                   	push   %rbp
  809911:	48 89 e5             	mov    %rsp,%rbp
  809914:	48 83 ec 20          	sub    $0x20,%rsp
  809918:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80991c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809920:	48 8b 40 38          	mov    0x38(%rax),%rax
  809924:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80992c:	0f b6 00             	movzbl (%rax),%eax
  80992f:	3c 0c                	cmp    $0xc,%al
  809931:	74 0b                	je     80993e <dhcp_timeout+0x2e>
  809933:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809937:	0f b6 00             	movzbl (%rax),%eax
  80993a:	3c 06                	cmp    $0x6,%al
  80993c:	75 18                	jne    809956 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  80993e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809942:	48 89 c7             	mov    %rax,%rdi
  809945:	48 b8 c5 a4 80 00 00 	movabs $0x80a4c5,%rax
  80994c:	00 00 00 
  80994f:	ff d0                	callq  *%rax
  809951:	e9 10 01 00 00       	jmpq   809a66 <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809956:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80995a:	0f b6 00             	movzbl (%rax),%eax
  80995d:	3c 01                	cmp    $0x1,%al
  80995f:	75 4f                	jne    8099b0 <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  809961:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809965:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809969:	3c 05                	cmp    $0x5,%al
  80996b:	77 18                	ja     809985 <dhcp_timeout+0x75>
      dhcp_select(netif);
  80996d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809971:	48 89 c7             	mov    %rax,%rdi
  809974:	48 b8 05 95 80 00 00 	movabs $0x809505,%rax
  80997b:	00 00 00 
  80997e:	ff d0                	callq  *%rax
  809980:	e9 e1 00 00 00       	jmpq   809a66 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  809985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809989:	48 89 c7             	mov    %rax,%rdi
  80998c:	48 b8 44 ad 80 00 00 	movabs $0x80ad44,%rax
  809993:	00 00 00 
  809996:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809998:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80999c:	48 89 c7             	mov    %rax,%rdi
  80999f:	48 b8 c5 a4 80 00 00 	movabs $0x80a4c5,%rax
  8099a6:	00 00 00 
  8099a9:	ff d0                	callq  *%rax
  8099ab:	e9 b6 00 00 00       	jmpq   809a66 <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8099b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099b4:	0f b6 00             	movzbl (%rax),%eax
  8099b7:	3c 08                	cmp    $0x8,%al
  8099b9:	75 39                	jne    8099f4 <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8099bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099bf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8099c3:	3c 01                	cmp    $0x1,%al
  8099c5:	77 18                	ja     8099df <dhcp_timeout+0xcf>
      dhcp_check(netif);
  8099c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8099cb:	48 89 c7             	mov    %rax,%rdi
  8099ce:	48 b8 c6 93 80 00 00 	movabs $0x8093c6,%rax
  8099d5:	00 00 00 
  8099d8:	ff d0                	callq  *%rax
  8099da:	e9 87 00 00 00       	jmpq   809a66 <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8099df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8099e3:	48 89 c7             	mov    %rax,%rdi
  8099e6:	48 b8 27 a7 80 00 00 	movabs $0x80a727,%rax
  8099ed:	00 00 00 
  8099f0:	ff d0                	callq  *%rax
  8099f2:	eb 72                	jmp    809a66 <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8099f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099f8:	0f b6 00             	movzbl (%rax),%eax
  8099fb:	3c 05                	cmp    $0x5,%al
  8099fd:	75 15                	jne    809a14 <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8099ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a03:	48 89 c7             	mov    %rax,%rdi
  809a06:	48 b8 af a9 80 00 00 	movabs $0x80a9af,%rax
  809a0d:	00 00 00 
  809a10:	ff d0                	callq  *%rax
  809a12:	eb 52                	jmp    809a66 <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  809a14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a18:	0f b6 00             	movzbl (%rax),%eax
  809a1b:	3c 04                	cmp    $0x4,%al
  809a1d:	75 47                	jne    809a66 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  809a1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a23:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809a27:	3c 08                	cmp    $0x8,%al
  809a29:	77 15                	ja     809a40 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a2f:	48 89 c7             	mov    %rax,%rdi
  809a32:	48 b8 79 ab 80 00 00 	movabs $0x80ab79,%rax
  809a39:	00 00 00 
  809a3c:	ff d0                	callq  *%rax
  809a3e:	eb 26                	jmp    809a66 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  809a40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a44:	48 89 c7             	mov    %rax,%rdi
  809a47:	48 b8 44 ad 80 00 00 	movabs $0x80ad44,%rax
  809a4e:	00 00 00 
  809a51:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809a53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a57:	48 89 c7             	mov    %rax,%rdi
  809a5a:	48 b8 c5 a4 80 00 00 	movabs $0x80a4c5,%rax
  809a61:	00 00 00 
  809a64:	ff d0                	callq  *%rax
    }
  }
}
  809a66:	c9                   	leaveq 
  809a67:	c3                   	retq   

0000000000809a68 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809a68:	55                   	push   %rbp
  809a69:	48 89 e5             	mov    %rsp,%rbp
  809a6c:	48 83 ec 20          	sub    $0x20,%rsp
  809a70:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809a74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a78:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809a80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a84:	0f b6 00             	movzbl (%rax),%eax
  809a87:	3c 01                	cmp    $0x1,%al
  809a89:	74 16                	je     809aa1 <dhcp_t1_timeout+0x39>
  809a8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a8f:	0f b6 00             	movzbl (%rax),%eax
  809a92:	3c 0a                	cmp    $0xa,%al
  809a94:	74 0b                	je     809aa1 <dhcp_t1_timeout+0x39>
  809a96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a9a:	0f b6 00             	movzbl (%rax),%eax
  809a9d:	3c 05                	cmp    $0x5,%al
  809a9f:	75 13                	jne    809ab4 <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  809aa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809aa5:	48 89 c7             	mov    %rax,%rdi
  809aa8:	48 b8 af a9 80 00 00 	movabs $0x80a9af,%rax
  809aaf:	00 00 00 
  809ab2:	ff d0                	callq  *%rax
  }
}
  809ab4:	c9                   	leaveq 
  809ab5:	c3                   	retq   

0000000000809ab6 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  809ab6:	55                   	push   %rbp
  809ab7:	48 89 e5             	mov    %rsp,%rbp
  809aba:	48 83 ec 20          	sub    $0x20,%rsp
  809abe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809ac2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ac6:	48 8b 40 38          	mov    0x38(%rax),%rax
  809aca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809ace:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ad2:	0f b6 00             	movzbl (%rax),%eax
  809ad5:	3c 01                	cmp    $0x1,%al
  809ad7:	74 16                	je     809aef <dhcp_t2_timeout+0x39>
  809ad9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809add:	0f b6 00             	movzbl (%rax),%eax
  809ae0:	3c 0a                	cmp    $0xa,%al
  809ae2:	74 0b                	je     809aef <dhcp_t2_timeout+0x39>
  809ae4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ae8:	0f b6 00             	movzbl (%rax),%eax
  809aeb:	3c 05                	cmp    $0x5,%al
  809aed:	75 13                	jne    809b02 <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  809aef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809af3:	48 89 c7             	mov    %rax,%rdi
  809af6:	48 b8 79 ab 80 00 00 	movabs $0x80ab79,%rax
  809afd:	00 00 00 
  809b00:	ff d0                	callq  *%rax
  }
}
  809b02:	c9                   	leaveq 
  809b03:	c3                   	retq   

0000000000809b04 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  809b04:	55                   	push   %rbp
  809b05:	48 89 e5             	mov    %rsp,%rbp
  809b08:	53                   	push   %rbx
  809b09:	48 83 ec 38          	sub    $0x38,%rsp
  809b0d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809b11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809b15:	48 8b 40 38          	mov    0x38(%rax),%rax
  809b19:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809b1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b21:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809b28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b2c:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  809b33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b37:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809b3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b42:	be 33 00 00 00       	mov    $0x33,%esi
  809b47:	48 89 c7             	mov    %rax,%rdi
  809b4a:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809b51:	00 00 00 
  809b54:	ff d0                	callq  *%rax
  809b56:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809b5a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809b5f:	74 1e                	je     809b7f <dhcp_handle_ack+0x7b>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  809b61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809b65:	48 83 c0 02          	add    $0x2,%rax
  809b69:	48 89 c7             	mov    %rax,%rdi
  809b6c:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809b73:	00 00 00 
  809b76:	ff d0                	callq  *%rax
  809b78:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809b7c:	89 42 68             	mov    %eax,0x68(%rdx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  809b7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b83:	be 3a 00 00 00       	mov    $0x3a,%esi
  809b88:	48 89 c7             	mov    %rax,%rdi
  809b8b:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809b92:	00 00 00 
  809b95:	ff d0                	callq  *%rax
  809b97:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809b9b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809ba0:	74 20                	je     809bc2 <dhcp_handle_ack+0xbe>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  809ba2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ba6:	48 83 c0 02          	add    $0x2,%rax
  809baa:	48 89 c7             	mov    %rax,%rdi
  809bad:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809bb4:	00 00 00 
  809bb7:	ff d0                	callq  *%rax
  809bb9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809bbd:	89 42 6c             	mov    %eax,0x6c(%rdx)
  809bc0:	eb 12                	jmp    809bd4 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  809bc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809bc6:	8b 40 68             	mov    0x68(%rax),%eax
  809bc9:	d1 e8                	shr    %eax
  809bcb:	89 c2                	mov    %eax,%edx
  809bcd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809bd1:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  809bd4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809bd8:	be 3b 00 00 00       	mov    $0x3b,%esi
  809bdd:	48 89 c7             	mov    %rax,%rdi
  809be0:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809be7:	00 00 00 
  809bea:	ff d0                	callq  *%rax
  809bec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809bf0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809bf5:	74 20                	je     809c17 <dhcp_handle_ack+0x113>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809bf7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809bfb:	48 83 c0 02          	add    $0x2,%rax
  809bff:	48 89 c7             	mov    %rax,%rdi
  809c02:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809c09:	00 00 00 
  809c0c:	ff d0                	callq  *%rax
  809c0e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809c12:	89 42 70             	mov    %eax,0x70(%rdx)
  809c15:	eb 0e                	jmp    809c25 <dhcp_handle_ack+0x121>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809c17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c1b:	8b 50 68             	mov    0x68(%rax),%edx
  809c1e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c22:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809c25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c29:	48 8b 40 18          	mov    0x18(%rax),%rax
  809c2d:	48 83 c0 10          	add    $0x10,%rax
  809c31:	48 85 c0             	test   %rax,%rax
  809c34:	74 0d                	je     809c43 <dhcp_handle_ack+0x13f>
  809c36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c3a:	48 8b 40 18          	mov    0x18(%rax),%rax
  809c3e:	8b 40 10             	mov    0x10(%rax),%eax
  809c41:	eb 05                	jmp    809c48 <dhcp_handle_ack+0x144>
  809c43:	b8 00 00 00 00       	mov    $0x0,%eax
  809c48:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809c4c:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  809c4f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c53:	be 01 00 00 00       	mov    $0x1,%esi
  809c58:	48 89 c7             	mov    %rax,%rdi
  809c5b:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809c62:	00 00 00 
  809c65:	ff d0                	callq  *%rax
  809c67:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809c6b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809c70:	74 2c                	je     809c9e <dhcp_handle_ack+0x19a>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809c72:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809c76:	48 83 c0 02          	add    $0x2,%rax
  809c7a:	48 89 c7             	mov    %rax,%rdi
  809c7d:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809c84:	00 00 00 
  809c87:	ff d0                	callq  *%rax
  809c89:	89 c7                	mov    %eax,%edi
  809c8b:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  809c92:	00 00 00 
  809c95:	ff d0                	callq  *%rax
  809c97:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809c9b:	89 42 50             	mov    %eax,0x50(%rdx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  809c9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ca2:	be 03 00 00 00       	mov    $0x3,%esi
  809ca7:	48 89 c7             	mov    %rax,%rdi
  809caa:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809cb1:	00 00 00 
  809cb4:	ff d0                	callq  *%rax
  809cb6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809cba:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809cbf:	74 2c                	je     809ced <dhcp_handle_ack+0x1e9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809cc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809cc5:	48 83 c0 02          	add    $0x2,%rax
  809cc9:	48 89 c7             	mov    %rax,%rdi
  809ccc:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809cd3:	00 00 00 
  809cd6:	ff d0                	callq  *%rax
  809cd8:	89 c7                	mov    %eax,%edi
  809cda:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  809ce1:	00 00 00 
  809ce4:	ff d0                	callq  *%rax
  809ce6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809cea:	89 42 54             	mov    %eax,0x54(%rdx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809ced:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cf1:	be 1c 00 00 00       	mov    $0x1c,%esi
  809cf6:	48 89 c7             	mov    %rax,%rdi
  809cf9:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809d00:	00 00 00 
  809d03:	ff d0                	callq  *%rax
  809d05:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809d09:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d0e:	74 2c                	je     809d3c <dhcp_handle_ack+0x238>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809d10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d14:	48 83 c0 02          	add    $0x2,%rax
  809d18:	48 89 c7             	mov    %rax,%rdi
  809d1b:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809d22:	00 00 00 
  809d25:	ff d0                	callq  *%rax
  809d27:	89 c7                	mov    %eax,%edi
  809d29:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  809d30:	00 00 00 
  809d33:	ff d0                	callq  *%rax
  809d35:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809d39:	89 42 58             	mov    %eax,0x58(%rdx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809d3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d40:	be 06 00 00 00       	mov    $0x6,%esi
  809d45:	48 89 c7             	mov    %rax,%rdi
  809d48:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  809d4f:	00 00 00 
  809d52:	ff d0                	callq  *%rax
  809d54:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809d58:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d5d:	0f 84 9d 00 00 00    	je     809e00 <dhcp_handle_ack+0x2fc>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809d63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d67:	48 83 c0 01          	add    $0x1,%rax
  809d6b:	48 89 c7             	mov    %rax,%rdi
  809d6e:	48 b8 37 c0 80 00 00 	movabs $0x80c037,%rax
  809d75:	00 00 00 
  809d78:	ff d0                	callq  *%rax
  809d7a:	c0 e8 02             	shr    $0x2,%al
  809d7d:	0f b6 d0             	movzbl %al,%edx
  809d80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d84:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809d87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d8b:	8b 40 5c             	mov    0x5c(%rax),%eax
  809d8e:	83 f8 02             	cmp    $0x2,%eax
  809d91:	76 0b                	jbe    809d9e <dhcp_handle_ack+0x29a>
      dhcp->dns_count = DHCP_MAX_DNS;
  809d93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d97:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809d9e:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809da2:	eb 4d                	jmp    809df1 <dhcp_handle_ack+0x2ed>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809da4:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809da8:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809dac:	c1 e0 02             	shl    $0x2,%eax
  809daf:	83 c0 02             	add    $0x2,%eax
  809db2:	48 63 d0             	movslq %eax,%rdx
  809db5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809db9:	48 01 d0             	add    %rdx,%rax
  809dbc:	48 89 c7             	mov    %rax,%rdi
  809dbf:	48 b8 4c c0 80 00 00 	movabs $0x80c04c,%rax
  809dc6:	00 00 00 
  809dc9:	ff d0                	callq  *%rax
  809dcb:	89 c7                	mov    %eax,%edi
  809dcd:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  809dd4:	00 00 00 
  809dd7:	ff d0                	callq  *%rax
  809dd9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809ddd:	48 63 cb             	movslq %ebx,%rcx
  809de0:	48 83 c1 18          	add    $0x18,%rcx
  809de4:	89 04 8a             	mov    %eax,(%rdx,%rcx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809de7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809deb:	83 c0 01             	add    $0x1,%eax
  809dee:	88 45 ef             	mov    %al,-0x11(%rbp)
  809df1:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809df5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809df9:	8b 40 5c             	mov    0x5c(%rax),%eax
  809dfc:	39 c2                	cmp    %eax,%edx
  809dfe:	72 a4                	jb     809da4 <dhcp_handle_ack+0x2a0>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809e00:	48 83 c4 38          	add    $0x38,%rsp
  809e04:	5b                   	pop    %rbx
  809e05:	5d                   	pop    %rbp
  809e06:	c3                   	retq   

0000000000809e07 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809e07:	55                   	push   %rbp
  809e08:	48 89 e5             	mov    %rsp,%rbp
  809e0b:	48 83 ec 20          	sub    $0x20,%rsp
  809e0f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809e13:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809e17:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809e1c:	75 2a                	jne    809e48 <dhcp_start+0x41>
  809e1e:	48 ba e8 16 82 00 00 	movabs $0x8216e8,%rdx
  809e25:	00 00 00 
  809e28:	be 38 02 00 00       	mov    $0x238,%esi
  809e2d:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  809e34:	00 00 00 
  809e37:	b8 00 00 00 00       	mov    $0x0,%eax
  809e3c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  809e43:	00 00 00 
  809e46:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809e48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e4c:	48 8b 40 38          	mov    0x38(%rax),%rax
  809e50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e58:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809e5c:	83 e0 f7             	and    $0xfffffff7,%eax
  809e5f:	89 c2                	mov    %eax,%edx
  809e61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e65:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809e68:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809e6d:	75 32                	jne    809ea1 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809e6f:	bf 78 00 00 00       	mov    $0x78,%edi
  809e74:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  809e7b:	00 00 00 
  809e7e:	ff d0                	callq  *%rax
  809e80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809e84:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809e89:	75 0a                	jne    809e95 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809e8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e90:	e9 3a 01 00 00       	jmpq   809fcf <dhcp_start+0x1c8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809e95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e99:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809e9d:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  809ea1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ea5:	ba 78 00 00 00       	mov    $0x78,%edx
  809eaa:	be 00 00 00 00       	mov    $0x0,%esi
  809eaf:	48 89 c7             	mov    %rax,%rdi
  809eb2:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  809eb9:	00 00 00 
  809ebc:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  809ebe:	48 b8 25 58 81 00 00 	movabs $0x815825,%rax
  809ec5:	00 00 00 
  809ec8:	ff d0                	callq  *%rax
  809eca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809ece:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809ed2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ed6:	48 8b 40 08          	mov    0x8(%rax),%rax
  809eda:	48 85 c0             	test   %rax,%rax
  809edd:	75 31                	jne    809f10 <dhcp_start+0x109>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809edf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ee3:	48 89 c7             	mov    %rax,%rdi
  809ee6:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  809eed:	00 00 00 
  809ef0:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  809ef2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809ef9:	00 
  809efa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809efe:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809f02:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809f06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f0b:	e9 bf 00 00 00       	jmpq   809fcf <dhcp_start+0x1c8>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809f10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f14:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f18:	ba 44 00 00 00       	mov    $0x44,%edx
  809f1d:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  809f24:	00 00 00 
  809f27:	48 89 c7             	mov    %rax,%rdi
  809f2a:	48 b8 c9 54 81 00 00 	movabs $0x8154c9,%rax
  809f31:	00 00 00 
  809f34:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809f36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f3a:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f3e:	ba 43 00 00 00       	mov    $0x43,%edx
  809f43:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  809f4a:	00 00 00 
  809f4d:	48 89 c7             	mov    %rax,%rdi
  809f50:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  809f57:	00 00 00 
  809f5a:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  809f5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f60:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809f68:	48 be 52 b6 80 00 00 	movabs $0x80b652,%rsi
  809f6f:	00 00 00 
  809f72:	48 89 c7             	mov    %rax,%rdi
  809f75:	48 b8 4d 57 81 00 00 	movabs $0x81574d,%rax
  809f7c:	00 00 00 
  809f7f:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  809f81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f85:	48 89 c7             	mov    %rax,%rdi
  809f88:	48 b8 c5 a4 80 00 00 	movabs $0x80a4c5,%rax
  809f8f:	00 00 00 
  809f92:	ff d0                	callq  *%rax
  809f94:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  809f97:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809f9b:	74 1a                	je     809fb7 <dhcp_start+0x1b0>
    /* free resources allocated above */
    dhcp_stop(netif);
  809f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fa1:	48 89 c7             	mov    %rax,%rdi
  809fa4:	48 b8 b2 af 80 00 00 	movabs $0x80afb2,%rax
  809fab:	00 00 00 
  809fae:	ff d0                	callq  *%rax
    return ERR_MEM;
  809fb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809fb5:	eb 18                	jmp    809fcf <dhcp_start+0x1c8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  809fb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fbb:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809fbf:	83 c8 08             	or     $0x8,%eax
  809fc2:	89 c2                	mov    %eax,%edx
  809fc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fc8:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  809fcb:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809fcf:	c9                   	leaveq 
  809fd0:	c3                   	retq   

0000000000809fd1 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  809fd1:	55                   	push   %rbp
  809fd2:	48 89 e5             	mov    %rsp,%rbp
  809fd5:	48 83 ec 30          	sub    $0x30,%rsp
  809fd9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  809fdd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809fe1:	48 8b 40 38          	mov    0x38(%rax),%rax
  809fe5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809fe9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  809fed:	bf 78 00 00 00       	mov    $0x78,%edi
  809ff2:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  809ff9:	00 00 00 
  809ffc:	ff d0                	callq  *%rax
  809ffe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  80a002:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a007:	75 05                	jne    80a00e <dhcp_inform+0x3d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  80a009:	e9 37 02 00 00       	jmpq   80a245 <dhcp_inform+0x274>
  }
  netif->dhcp = dhcp;
  80a00e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a012:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a016:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  80a01a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a01e:	ba 78 00 00 00       	mov    $0x78,%edx
  80a023:	be 00 00 00 00       	mov    $0x0,%esi
  80a028:	48 89 c7             	mov    %rax,%rdi
  80a02b:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  80a032:	00 00 00 
  80a035:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80a037:	48 b8 25 58 81 00 00 	movabs $0x815825,%rax
  80a03e:	00 00 00 
  80a041:	ff d0                	callq  *%rax
  80a043:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a047:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  80a04b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a04f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a053:	48 85 c0             	test   %rax,%rax
  80a056:	75 18                	jne    80a070 <dhcp_inform+0x9f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80a058:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a05c:	48 89 c7             	mov    %rax,%rdi
  80a05f:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80a066:	00 00 00 
  80a069:	ff d0                	callq  *%rax
    return;
  80a06b:	e9 d5 01 00 00       	jmpq   80a245 <dhcp_inform+0x274>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a070:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a074:	48 89 c7             	mov    %rax,%rdi
  80a077:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80a07e:	00 00 00 
  80a081:	ff d0                	callq  *%rax
  80a083:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a086:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a08a:	0f 85 5f 01 00 00    	jne    80a1ef <dhcp_inform+0x21e>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a090:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a094:	ba 01 00 00 00       	mov    $0x1,%edx
  80a099:	be 35 00 00 00       	mov    $0x35,%esi
  80a09e:	48 89 c7             	mov    %rax,%rdi
  80a0a1:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a0a8:	00 00 00 
  80a0ab:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80a0ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0b1:	be 08 00 00 00       	mov    $0x8,%esi
  80a0b6:	48 89 c7             	mov    %rax,%rdi
  80a0b9:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a0c0:	00 00 00 
  80a0c3:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a0c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0c9:	ba 02 00 00 00       	mov    $0x2,%edx
  80a0ce:	be 39 00 00 00       	mov    $0x39,%esi
  80a0d3:	48 89 c7             	mov    %rax,%rdi
  80a0d6:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a0dd:	00 00 00 
  80a0e0:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80a0e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0e6:	be 40 02 00 00       	mov    $0x240,%esi
  80a0eb:	48 89 c7             	mov    %rax,%rdi
  80a0ee:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  80a0f5:	00 00 00 
  80a0f8:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a0fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0fe:	48 89 c7             	mov    %rax,%rdi
  80a101:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80a108:	00 00 00 
  80a10b:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a10d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a111:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a115:	66 05 f0 00          	add    $0xf0,%ax
  80a119:	0f b7 d0             	movzwl %ax,%edx
  80a11c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a120:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a124:	89 d6                	mov    %edx,%esi
  80a126:	48 89 c7             	mov    %rax,%rdi
  80a129:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80a130:	00 00 00 
  80a133:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a135:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a139:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a13d:	ba 44 00 00 00       	mov    $0x44,%edx
  80a142:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80a149:	00 00 00 
  80a14c:	48 89 c7             	mov    %rax,%rdi
  80a14f:	48 b8 c9 54 81 00 00 	movabs $0x8154c9,%rax
  80a156:	00 00 00 
  80a159:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80a15b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a15f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a163:	ba 43 00 00 00       	mov    $0x43,%edx
  80a168:	48 be ec 24 82 00 00 	movabs $0x8224ec,%rsi
  80a16f:	00 00 00 
  80a172:	48 89 c7             	mov    %rax,%rdi
  80a175:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80a17c:	00 00 00 
  80a17f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a181:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a185:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a189:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a18d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a191:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80a195:	49 89 d0             	mov    %rdx,%r8
  80a198:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a19d:	48 ba ec 24 82 00 00 	movabs $0x8224ec,%rdx
  80a1a4:	00 00 00 
  80a1a7:	48 89 c7             	mov    %rax,%rdi
  80a1aa:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80a1b1:	00 00 00 
  80a1b4:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a1b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1ba:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1be:	ba 43 00 00 00       	mov    $0x43,%edx
  80a1c3:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80a1ca:	00 00 00 
  80a1cd:	48 89 c7             	mov    %rax,%rdi
  80a1d0:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80a1d7:	00 00 00 
  80a1da:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a1dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a1e0:	48 89 c7             	mov    %rax,%rdi
  80a1e3:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80a1ea:	00 00 00 
  80a1ed:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  80a1ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a1f4:	74 4f                	je     80a245 <dhcp_inform+0x274>
    if (dhcp->pcb != NULL) {
  80a1f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1fe:	48 85 c0             	test   %rax,%rax
  80a201:	74 17                	je     80a21a <dhcp_inform+0x249>
      udp_remove(dhcp->pcb);
  80a203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a207:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a20b:	48 89 c7             	mov    %rax,%rdi
  80a20e:	48 b8 7b 57 81 00 00 	movabs $0x81577b,%rax
  80a215:	00 00 00 
  80a218:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  80a21a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a21e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a225:	00 
    mem_free((void *)dhcp);
  80a226:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a22a:	48 89 c7             	mov    %rax,%rdi
  80a22d:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80a234:	00 00 00 
  80a237:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  80a239:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a23d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a241:	48 89 50 38          	mov    %rdx,0x38(%rax)
  }
}
  80a245:	c9                   	leaveq 
  80a246:	c3                   	retq   

000000000080a247 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80a247:	55                   	push   %rbp
  80a248:	48 89 e5             	mov    %rsp,%rbp
  80a24b:	48 83 ec 10          	sub    $0x10,%rsp
  80a24f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a253:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a257:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a25c:	75 2a                	jne    80a288 <dhcp_arp_reply+0x41>
  80a25e:	48 ba e8 16 82 00 00 	movabs $0x8216e8,%rdx
  80a265:	00 00 00 
  80a268:	be b5 02 00 00       	mov    $0x2b5,%esi
  80a26d:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80a274:	00 00 00 
  80a277:	b8 00 00 00 00       	mov    $0x0,%eax
  80a27c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80a283:	00 00 00 
  80a286:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80a288:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a28c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a290:	48 85 c0             	test   %rax,%rax
  80a293:	74 37                	je     80a2cc <dhcp_arp_reply+0x85>
  80a295:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a299:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a29d:	0f b6 00             	movzbl (%rax),%eax
  80a2a0:	3c 08                	cmp    $0x8,%al
  80a2a2:	75 28                	jne    80a2cc <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80a2a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a2a8:	8b 10                	mov    (%rax),%edx
  80a2aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2ae:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a2b2:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a2b5:	39 c2                	cmp    %eax,%edx
  80a2b7:	75 13                	jne    80a2cc <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  80a2b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2bd:	48 89 c7             	mov    %rax,%rdi
  80a2c0:	48 b8 ce a2 80 00 00 	movabs $0x80a2ce,%rax
  80a2c7:	00 00 00 
  80a2ca:	ff d0                	callq  *%rax
    }
  }
}
  80a2cc:	c9                   	leaveq 
  80a2cd:	c3                   	retq   

000000000080a2ce <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80a2ce:	55                   	push   %rbp
  80a2cf:	48 89 e5             	mov    %rsp,%rbp
  80a2d2:	48 83 ec 20          	sub    $0x20,%rsp
  80a2d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a2da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2de:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a2e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a2e6:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80a2ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2ee:	be 0c 00 00 00       	mov    $0xc,%esi
  80a2f3:	48 89 c7             	mov    %rax,%rdi
  80a2f6:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80a2fd:	00 00 00 
  80a300:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a302:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a306:	48 89 c7             	mov    %rax,%rdi
  80a309:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80a310:	00 00 00 
  80a313:	ff d0                	callq  *%rax
  80a315:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a318:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a31c:	0f 85 5c 01 00 00    	jne    80a47e <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a322:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a326:	ba 01 00 00 00       	mov    $0x1,%edx
  80a32b:	be 35 00 00 00       	mov    $0x35,%esi
  80a330:	48 89 c7             	mov    %rax,%rdi
  80a333:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a33a:	00 00 00 
  80a33d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a33f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a343:	be 04 00 00 00       	mov    $0x4,%esi
  80a348:	48 89 c7             	mov    %rax,%rdi
  80a34b:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a352:	00 00 00 
  80a355:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a35b:	ba 02 00 00 00       	mov    $0x2,%edx
  80a360:	be 39 00 00 00       	mov    $0x39,%esi
  80a365:	48 89 c7             	mov    %rax,%rdi
  80a368:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a36f:	00 00 00 
  80a372:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a374:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a378:	be 40 02 00 00       	mov    $0x240,%esi
  80a37d:	48 89 c7             	mov    %rax,%rdi
  80a380:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  80a387:	00 00 00 
  80a38a:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a38c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a390:	ba 04 00 00 00       	mov    $0x4,%edx
  80a395:	be 32 00 00 00       	mov    $0x32,%esi
  80a39a:	48 89 c7             	mov    %rax,%rdi
  80a39d:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a3a4:	00 00 00 
  80a3a7:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a3a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3ad:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a3b0:	89 c7                	mov    %eax,%edi
  80a3b2:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  80a3b9:	00 00 00 
  80a3bc:	ff d0                	callq  *%rax
  80a3be:	89 c2                	mov    %eax,%edx
  80a3c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3c4:	89 d6                	mov    %edx,%esi
  80a3c6:	48 89 c7             	mov    %rax,%rdi
  80a3c9:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a3d0:	00 00 00 
  80a3d3:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a3d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3d9:	48 89 c7             	mov    %rax,%rdi
  80a3dc:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80a3e3:	00 00 00 
  80a3e6:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a3e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3ec:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a3f0:	66 05 f0 00          	add    $0xf0,%ax
  80a3f4:	0f b7 d0             	movzwl %ax,%edx
  80a3f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3fb:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a3ff:	89 d6                	mov    %edx,%esi
  80a401:	48 89 c7             	mov    %rax,%rdi
  80a404:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80a40b:	00 00 00 
  80a40e:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a410:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a414:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a418:	ba 43 00 00 00       	mov    $0x43,%edx
  80a41d:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80a424:	00 00 00 
  80a427:	48 89 c7             	mov    %rax,%rdi
  80a42a:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80a431:	00 00 00 
  80a434:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a436:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a43a:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a43e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a442:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a446:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a44a:	49 89 d0             	mov    %rdx,%r8
  80a44d:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a452:	48 ba ec 24 82 00 00 	movabs $0x8224ec,%rdx
  80a459:	00 00 00 
  80a45c:	48 89 c7             	mov    %rax,%rdi
  80a45f:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80a466:	00 00 00 
  80a469:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a46b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a46f:	48 89 c7             	mov    %rax,%rdi
  80a472:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80a479:	00 00 00 
  80a47c:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a47e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a482:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a486:	8d 50 01             	lea    0x1(%rax),%edx
  80a489:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a48d:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a490:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a496:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a49a:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a4a0:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a4a5:	89 c8                	mov    %ecx,%eax
  80a4a7:	f7 ea                	imul   %edx
  80a4a9:	c1 fa 05             	sar    $0x5,%edx
  80a4ac:	89 c8                	mov    %ecx,%eax
  80a4ae:	c1 f8 1f             	sar    $0x1f,%eax
  80a4b1:	29 c2                	sub    %eax,%edx
  80a4b3:	89 d0                	mov    %edx,%eax
  80a4b5:	89 c2                	mov    %eax,%edx
  80a4b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4bb:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a4bf:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a4c3:	c9                   	leaveq 
  80a4c4:	c3                   	retq   

000000000080a4c5 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a4c5:	55                   	push   %rbp
  80a4c6:	48 89 e5             	mov    %rsp,%rbp
  80a4c9:	48 83 ec 20          	sub    $0x20,%rsp
  80a4cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a4d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a4d5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a4d9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a4dd:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a4e1:	48 b8 e8 24 82 00 00 	movabs $0x8224e8,%rax
  80a4e8:	00 00 00 
  80a4eb:	8b 10                	mov    (%rax),%edx
  80a4ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4f1:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a4f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a4f8:	48 89 c7             	mov    %rax,%rdi
  80a4fb:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80a502:	00 00 00 
  80a505:	ff d0                	callq  *%rax
  80a507:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a50a:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a50e:	0f 85 a8 01 00 00    	jne    80a6bc <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a514:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a518:	ba 01 00 00 00       	mov    $0x1,%edx
  80a51d:	be 35 00 00 00       	mov    $0x35,%esi
  80a522:	48 89 c7             	mov    %rax,%rdi
  80a525:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a52c:	00 00 00 
  80a52f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a535:	be 01 00 00 00       	mov    $0x1,%esi
  80a53a:	48 89 c7             	mov    %rax,%rdi
  80a53d:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a544:	00 00 00 
  80a547:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a549:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a54d:	ba 02 00 00 00       	mov    $0x2,%edx
  80a552:	be 39 00 00 00       	mov    $0x39,%esi
  80a557:	48 89 c7             	mov    %rax,%rdi
  80a55a:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a561:	00 00 00 
  80a564:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a566:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a56a:	be 40 02 00 00       	mov    $0x240,%esi
  80a56f:	48 89 c7             	mov    %rax,%rdi
  80a572:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  80a579:	00 00 00 
  80a57c:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a57e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a582:	ba 04 00 00 00       	mov    $0x4,%edx
  80a587:	be 37 00 00 00       	mov    $0x37,%esi
  80a58c:	48 89 c7             	mov    %rax,%rdi
  80a58f:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80a596:	00 00 00 
  80a599:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a59b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a59f:	be 01 00 00 00       	mov    $0x1,%esi
  80a5a4:	48 89 c7             	mov    %rax,%rdi
  80a5a7:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a5ae:	00 00 00 
  80a5b1:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a5b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5b7:	be 03 00 00 00       	mov    $0x3,%esi
  80a5bc:	48 89 c7             	mov    %rax,%rdi
  80a5bf:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a5c6:	00 00 00 
  80a5c9:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a5cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5cf:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a5d4:	48 89 c7             	mov    %rax,%rdi
  80a5d7:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a5de:	00 00 00 
  80a5e1:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a5e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5e7:	be 06 00 00 00       	mov    $0x6,%esi
  80a5ec:	48 89 c7             	mov    %rax,%rdi
  80a5ef:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80a5f6:	00 00 00 
  80a5f9:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a5fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5ff:	48 89 c7             	mov    %rax,%rdi
  80a602:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80a609:	00 00 00 
  80a60c:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a612:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a616:	66 05 f0 00          	add    $0xf0,%ax
  80a61a:	0f b7 d0             	movzwl %ax,%edx
  80a61d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a621:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a625:	89 d6                	mov    %edx,%esi
  80a627:	48 89 c7             	mov    %rax,%rdi
  80a62a:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80a631:	00 00 00 
  80a634:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a636:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a63a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a63e:	ba 43 00 00 00       	mov    $0x43,%edx
  80a643:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80a64a:	00 00 00 
  80a64d:	48 89 c7             	mov    %rax,%rdi
  80a650:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80a657:	00 00 00 
  80a65a:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a65c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a660:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a664:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a668:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a66c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a670:	49 89 d0             	mov    %rdx,%r8
  80a673:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a678:	48 ba ec 24 82 00 00 	movabs $0x8224ec,%rdx
  80a67f:	00 00 00 
  80a682:	48 89 c7             	mov    %rax,%rdi
  80a685:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80a68c:	00 00 00 
  80a68f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a691:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a695:	48 89 c7             	mov    %rax,%rdi
  80a698:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80a69f:	00 00 00 
  80a6a2:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a6a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6a8:	be 06 00 00 00       	mov    $0x6,%esi
  80a6ad:	48 89 c7             	mov    %rax,%rdi
  80a6b0:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80a6b7:	00 00 00 
  80a6ba:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a6bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6c0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a6c4:	8d 50 01             	lea    0x1(%rax),%edx
  80a6c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6cb:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a6ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6d2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a6d6:	3c 03                	cmp    $0x3,%al
  80a6d8:	77 15                	ja     80a6ef <dhcp_discover+0x22a>
  80a6da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6de:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a6e2:	0f b6 c0             	movzbl %al,%eax
  80a6e5:	83 c0 01             	add    $0x1,%eax
  80a6e8:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a6ed:	eb 05                	jmp    80a6f4 <dhcp_discover+0x22f>
  80a6ef:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a6f4:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a6f8:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a6fc:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a702:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a707:	89 c8                	mov    %ecx,%eax
  80a709:	f7 ea                	imul   %edx
  80a70b:	c1 fa 05             	sar    $0x5,%edx
  80a70e:	89 c8                	mov    %ecx,%eax
  80a710:	c1 f8 1f             	sar    $0x1f,%eax
  80a713:	29 c2                	sub    %eax,%edx
  80a715:	89 d0                	mov    %edx,%eax
  80a717:	89 c2                	mov    %eax,%edx
  80a719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a71d:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a721:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a725:	c9                   	leaveq 
  80a726:	c3                   	retq   

000000000080a727 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a727:	55                   	push   %rbp
  80a728:	48 89 e5             	mov    %rsp,%rbp
  80a72b:	53                   	push   %rbx
  80a72c:	48 83 ec 48          	sub    $0x48,%rsp
  80a730:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a734:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80a739:	75 2a                	jne    80a765 <dhcp_bind+0x3e>
  80a73b:	48 ba 0b 17 82 00 00 	movabs $0x82170b,%rdx
  80a742:	00 00 00 
  80a745:	be 3d 03 00 00       	mov    $0x33d,%esi
  80a74a:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80a751:	00 00 00 
  80a754:	b8 00 00 00 00       	mov    $0x0,%eax
  80a759:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80a760:	00 00 00 
  80a763:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a765:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a769:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a76d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a771:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80a776:	75 2a                	jne    80a7a2 <dhcp_bind+0x7b>
  80a778:	48 ba 24 17 82 00 00 	movabs $0x821724,%rdx
  80a77f:	00 00 00 
  80a782:	be 3f 03 00 00       	mov    $0x33f,%esi
  80a787:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80a78e:	00 00 00 
  80a791:	b8 00 00 00 00       	mov    $0x0,%eax
  80a796:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80a79d:	00 00 00 
  80a7a0:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a7a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7a6:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a7a9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a7ac:	74 4d                	je     80a7fb <dhcp_bind+0xd4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a7ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7b2:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a7b5:	83 c0 1e             	add    $0x1e,%eax
  80a7b8:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a7bd:	f7 e2                	mul    %edx
  80a7bf:	89 d0                	mov    %edx,%eax
  80a7c1:	c1 e8 05             	shr    $0x5,%eax
  80a7c4:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a7c7:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a7ce:	76 07                	jbe    80a7d7 <dhcp_bind+0xb0>
      timeout = 0xffff;
  80a7d0:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a7d7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a7da:	89 c2                	mov    %eax,%edx
  80a7dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7e0:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a7e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7e8:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a7ec:	66 85 c0             	test   %ax,%ax
  80a7ef:	75 0a                	jne    80a7fb <dhcp_bind+0xd4>
      dhcp->t1_timeout = 1;
  80a7f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7f5:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a7fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a7ff:	8b 40 70             	mov    0x70(%rax),%eax
  80a802:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a805:	74 4d                	je     80a854 <dhcp_bind+0x12d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a807:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a80b:	8b 40 70             	mov    0x70(%rax),%eax
  80a80e:	83 c0 1e             	add    $0x1e,%eax
  80a811:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a816:	f7 e2                	mul    %edx
  80a818:	89 d0                	mov    %edx,%eax
  80a81a:	c1 e8 05             	shr    $0x5,%eax
  80a81d:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a820:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a827:	76 07                	jbe    80a830 <dhcp_bind+0x109>
      timeout = 0xffff;
  80a829:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a830:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a833:	89 c2                	mov    %eax,%edx
  80a835:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a839:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a83d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a841:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a845:	66 85 c0             	test   %ax,%ax
  80a848:	75 0a                	jne    80a854 <dhcp_bind+0x12d>
      dhcp->t2_timeout = 1;
  80a84a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a84e:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a854:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a858:	48 83 c0 50          	add    $0x50,%rax
  80a85c:	48 85 c0             	test   %rax,%rax
  80a85f:	74 09                	je     80a86a <dhcp_bind+0x143>
  80a861:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a865:	8b 40 50             	mov    0x50(%rax),%eax
  80a868:	eb 05                	jmp    80a86f <dhcp_bind+0x148>
  80a86a:	b8 00 00 00 00       	mov    $0x0,%eax
  80a86f:	89 45 d0             	mov    %eax,-0x30(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a872:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a875:	85 c0                	test   %eax,%eax
  80a877:	75 65                	jne    80a8de <dhcp_bind+0x1b7>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a879:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a87c:	89 c7                	mov    %eax,%edi
  80a87e:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  80a885:	00 00 00 
  80a888:	ff d0                	callq  *%rax
  80a88a:	c1 e8 18             	shr    $0x18,%eax
  80a88d:	88 45 df             	mov    %al,-0x21(%rbp)
    if (first_octet <= 127) {
  80a890:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80a894:	84 c0                	test   %al,%al
  80a896:	78 16                	js     80a8ae <dhcp_bind+0x187>
      sn_mask.addr = htonl(0xff000000);
  80a898:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a89d:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80a8a4:	00 00 00 
  80a8a7:	ff d0                	callq  *%rax
  80a8a9:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a8ac:	eb 30                	jmp    80a8de <dhcp_bind+0x1b7>
    } else if (first_octet >= 192) {
  80a8ae:	80 7d df bf          	cmpb   $0xbf,-0x21(%rbp)
  80a8b2:	76 16                	jbe    80a8ca <dhcp_bind+0x1a3>
      sn_mask.addr = htonl(0xffffff00);
  80a8b4:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a8b9:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80a8c0:	00 00 00 
  80a8c3:	ff d0                	callq  *%rax
  80a8c5:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a8c8:	eb 14                	jmp    80a8de <dhcp_bind+0x1b7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a8ca:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a8cf:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80a8d6:	00 00 00 
  80a8d9:	ff d0                	callq  *%rax
  80a8db:	89 45 d0             	mov    %eax,-0x30(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a8de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a8e2:	48 83 c0 54          	add    $0x54,%rax
  80a8e6:	48 85 c0             	test   %rax,%rax
  80a8e9:	74 09                	je     80a8f4 <dhcp_bind+0x1cd>
  80a8eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a8ef:	8b 40 54             	mov    0x54(%rax),%eax
  80a8f2:	eb 05                	jmp    80a8f9 <dhcp_bind+0x1d2>
  80a8f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80a8f9:	89 45 c0             	mov    %eax,-0x40(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80a8fc:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80a8ff:	85 c0                	test   %eax,%eax
  80a901:	75 28                	jne    80a92b <dhcp_bind+0x204>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80a903:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a907:	8b 50 4c             	mov    0x4c(%rax),%edx
  80a90a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a90d:	21 d0                	and    %edx,%eax
  80a90f:	89 45 c0             	mov    %eax,-0x40(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80a912:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  80a915:	bf 01 00 00 00       	mov    $0x1,%edi
  80a91a:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80a921:	00 00 00 
  80a924:	ff d0                	callq  *%rax
  80a926:	09 d8                	or     %ebx,%eax
  80a928:	89 45 c0             	mov    %eax,-0x40(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80a92b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a92f:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80a933:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a937:	48 89 d6             	mov    %rdx,%rsi
  80a93a:	48 89 c7             	mov    %rax,%rdi
  80a93d:	48 b8 03 d1 80 00 00 	movabs $0x80d103,%rax
  80a944:	00 00 00 
  80a947:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80a949:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80a94d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a951:	48 89 d6             	mov    %rdx,%rsi
  80a954:	48 89 c7             	mov    %rax,%rdi
  80a957:	48 b8 36 d2 80 00 00 	movabs $0x80d236,%rax
  80a95e:	00 00 00 
  80a961:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80a963:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80a967:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a96b:	48 89 d6             	mov    %rdx,%rsi
  80a96e:	48 89 c7             	mov    %rax,%rdi
  80a971:	48 b8 09 d2 80 00 00 	movabs $0x80d209,%rax
  80a978:	00 00 00 
  80a97b:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80a97d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a981:	48 89 c7             	mov    %rax,%rdi
  80a984:	48 b8 82 d2 80 00 00 	movabs $0x80d282,%rax
  80a98b:	00 00 00 
  80a98e:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80a990:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a994:	be 0a 00 00 00       	mov    $0xa,%esi
  80a999:	48 89 c7             	mov    %rax,%rdi
  80a99c:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80a9a3:	00 00 00 
  80a9a6:	ff d0                	callq  *%rax
}
  80a9a8:	48 83 c4 48          	add    $0x48,%rsp
  80a9ac:	5b                   	pop    %rbx
  80a9ad:	5d                   	pop    %rbp
  80a9ae:	c3                   	retq   

000000000080a9af <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80a9af:	55                   	push   %rbp
  80a9b0:	48 89 e5             	mov    %rsp,%rbp
  80a9b3:	48 83 ec 20          	sub    $0x20,%rsp
  80a9b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a9bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9bf:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a9c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80a9c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9cb:	be 05 00 00 00       	mov    $0x5,%esi
  80a9d0:	48 89 c7             	mov    %rax,%rdi
  80a9d3:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80a9da:	00 00 00 
  80a9dd:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a9df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9e3:	48 89 c7             	mov    %rax,%rdi
  80a9e6:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80a9ed:	00 00 00 
  80a9f0:	ff d0                	callq  *%rax
  80a9f2:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a9f5:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a9f9:	0f 85 12 01 00 00    	jne    80ab11 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a9ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa03:	ba 01 00 00 00       	mov    $0x1,%edx
  80aa08:	be 35 00 00 00       	mov    $0x35,%esi
  80aa0d:	48 89 c7             	mov    %rax,%rdi
  80aa10:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80aa17:	00 00 00 
  80aa1a:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80aa1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa20:	be 03 00 00 00       	mov    $0x3,%esi
  80aa25:	48 89 c7             	mov    %rax,%rdi
  80aa28:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80aa2f:	00 00 00 
  80aa32:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80aa34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa38:	ba 02 00 00 00       	mov    $0x2,%edx
  80aa3d:	be 39 00 00 00       	mov    $0x39,%esi
  80aa42:	48 89 c7             	mov    %rax,%rdi
  80aa45:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80aa4c:	00 00 00 
  80aa4f:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80aa51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa55:	be 40 02 00 00       	mov    $0x240,%esi
  80aa5a:	48 89 c7             	mov    %rax,%rdi
  80aa5d:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  80aa64:	00 00 00 
  80aa67:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80aa69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa6d:	48 89 c7             	mov    %rax,%rdi
  80aa70:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80aa77:	00 00 00 
  80aa7a:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80aa7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa80:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aa84:	66 05 f0 00          	add    $0xf0,%ax
  80aa88:	0f b7 d0             	movzwl %ax,%edx
  80aa8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa8f:	48 8b 40 30          	mov    0x30(%rax),%rax
  80aa93:	89 d6                	mov    %edx,%esi
  80aa95:	48 89 c7             	mov    %rax,%rdi
  80aa98:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80aa9f:	00 00 00 
  80aaa2:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80aaa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaa8:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80aaac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aab0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aab4:	ba 43 00 00 00       	mov    $0x43,%edx
  80aab9:	48 89 ce             	mov    %rcx,%rsi
  80aabc:	48 89 c7             	mov    %rax,%rdi
  80aabf:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80aac6:	00 00 00 
  80aac9:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80aacb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aacf:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80aad3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aad7:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80aadb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aadf:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aae3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80aae7:	49 89 c8             	mov    %rcx,%r8
  80aaea:	b9 43 00 00 00       	mov    $0x43,%ecx
  80aaef:	48 89 c7             	mov    %rax,%rdi
  80aaf2:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80aaf9:	00 00 00 
  80aafc:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80aafe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab02:	48 89 c7             	mov    %rax,%rdi
  80ab05:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80ab0c:	00 00 00 
  80ab0f:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ab11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab15:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ab19:	8d 50 01             	lea    0x1(%rax),%edx
  80ab1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab20:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80ab23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab27:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ab2b:	3c 09                	cmp    $0x9,%al
  80ab2d:	77 12                	ja     80ab41 <dhcp_renew+0x192>
  80ab2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab33:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ab37:	0f b6 c0             	movzbl %al,%eax
  80ab3a:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80ab3f:	eb 05                	jmp    80ab46 <dhcp_renew+0x197>
  80ab41:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80ab46:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ab4a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ab4e:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ab54:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ab59:	89 c8                	mov    %ecx,%eax
  80ab5b:	f7 ea                	imul   %edx
  80ab5d:	c1 fa 05             	sar    $0x5,%edx
  80ab60:	89 c8                	mov    %ecx,%eax
  80ab62:	c1 f8 1f             	sar    $0x1f,%eax
  80ab65:	29 c2                	sub    %eax,%edx
  80ab67:	89 d0                	mov    %edx,%eax
  80ab69:	89 c2                	mov    %eax,%edx
  80ab6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab6f:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ab73:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ab77:	c9                   	leaveq 
  80ab78:	c3                   	retq   

000000000080ab79 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80ab79:	55                   	push   %rbp
  80ab7a:	48 89 e5             	mov    %rsp,%rbp
  80ab7d:	48 83 ec 20          	sub    $0x20,%rsp
  80ab81:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ab85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab89:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ab8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80ab91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab95:	be 04 00 00 00       	mov    $0x4,%esi
  80ab9a:	48 89 c7             	mov    %rax,%rdi
  80ab9d:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80aba4:	00 00 00 
  80aba7:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80aba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abad:	48 89 c7             	mov    %rax,%rdi
  80abb0:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80abb7:	00 00 00 
  80abba:	ff d0                	callq  *%rax
  80abbc:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80abbf:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80abc3:	0f 85 13 01 00 00    	jne    80acdc <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80abc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abcd:	ba 01 00 00 00       	mov    $0x1,%edx
  80abd2:	be 35 00 00 00       	mov    $0x35,%esi
  80abd7:	48 89 c7             	mov    %rax,%rdi
  80abda:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80abe1:	00 00 00 
  80abe4:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80abe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abea:	be 03 00 00 00       	mov    $0x3,%esi
  80abef:	48 89 c7             	mov    %rax,%rdi
  80abf2:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80abf9:	00 00 00 
  80abfc:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80abfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac02:	ba 02 00 00 00       	mov    $0x2,%edx
  80ac07:	be 39 00 00 00       	mov    $0x39,%esi
  80ac0c:	48 89 c7             	mov    %rax,%rdi
  80ac0f:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80ac16:	00 00 00 
  80ac19:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80ac1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac1f:	be 40 02 00 00       	mov    $0x240,%esi
  80ac24:	48 89 c7             	mov    %rax,%rdi
  80ac27:	48 b8 06 b2 80 00 00 	movabs $0x80b206,%rax
  80ac2e:	00 00 00 
  80ac31:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80ac33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac37:	48 89 c7             	mov    %rax,%rdi
  80ac3a:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80ac41:	00 00 00 
  80ac44:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ac46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac4a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ac4e:	66 05 f0 00          	add    $0xf0,%ax
  80ac52:	0f b7 d0             	movzwl %ax,%edx
  80ac55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac59:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ac5d:	89 d6                	mov    %edx,%esi
  80ac5f:	48 89 c7             	mov    %rax,%rdi
  80ac62:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80ac69:	00 00 00 
  80ac6c:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80ac6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac72:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ac76:	ba 43 00 00 00       	mov    $0x43,%edx
  80ac7b:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80ac82:	00 00 00 
  80ac85:	48 89 c7             	mov    %rax,%rdi
  80ac88:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80ac8f:	00 00 00 
  80ac92:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80ac94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac98:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80ac9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aca0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aca4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80aca8:	49 89 d0             	mov    %rdx,%r8
  80acab:	b9 43 00 00 00       	mov    $0x43,%ecx
  80acb0:	48 ba ec 24 82 00 00 	movabs $0x8224ec,%rdx
  80acb7:	00 00 00 
  80acba:	48 89 c7             	mov    %rax,%rdi
  80acbd:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80acc4:	00 00 00 
  80acc7:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80acc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80accd:	48 89 c7             	mov    %rax,%rdi
  80acd0:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80acd7:	00 00 00 
  80acda:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80acdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ace0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ace4:	8d 50 01             	lea    0x1(%rax),%edx
  80ace7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aceb:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80acee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acf2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80acf6:	3c 09                	cmp    $0x9,%al
  80acf8:	77 12                	ja     80ad0c <dhcp_rebind+0x193>
  80acfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acfe:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ad02:	0f b6 c0             	movzbl %al,%eax
  80ad05:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80ad0a:	eb 05                	jmp    80ad11 <dhcp_rebind+0x198>
  80ad0c:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ad11:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ad15:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ad19:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ad1f:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ad24:	89 c8                	mov    %ecx,%eax
  80ad26:	f7 ea                	imul   %edx
  80ad28:	c1 fa 05             	sar    $0x5,%edx
  80ad2b:	89 c8                	mov    %ecx,%eax
  80ad2d:	c1 f8 1f             	sar    $0x1f,%eax
  80ad30:	29 c2                	sub    %eax,%edx
  80ad32:	89 d0                	mov    %edx,%eax
  80ad34:	89 c2                	mov    %eax,%edx
  80ad36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad3a:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ad3e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ad42:	c9                   	leaveq 
  80ad43:	c3                   	retq   

000000000080ad44 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80ad44:	55                   	push   %rbp
  80ad45:	48 89 e5             	mov    %rsp,%rbp
  80ad48:	48 83 ec 20          	sub    $0x20,%rsp
  80ad4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ad50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad54:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ad58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80ad5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad60:	be 0d 00 00 00       	mov    $0xd,%esi
  80ad65:	48 89 c7             	mov    %rax,%rdi
  80ad68:	48 b8 ae b0 80 00 00 	movabs $0x80b0ae,%rax
  80ad6f:	00 00 00 
  80ad72:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80ad74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad78:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80ad7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad83:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80ad8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad8e:	8b 50 50             	mov    0x50(%rax),%edx
  80ad91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad95:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80ad98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad9c:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80ada3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ada7:	8b 50 58             	mov    0x58(%rax),%edx
  80adaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adae:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80adb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adb5:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80adbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adc0:	8b 50 70             	mov    0x70(%rax),%edx
  80adc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adc7:	89 50 6c             	mov    %edx,0x6c(%rax)
  80adca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adce:	8b 50 6c             	mov    0x6c(%rax),%edx
  80add1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80add5:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80add8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80addc:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ade3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ade7:	48 89 c7             	mov    %rax,%rdi
  80adea:	48 b8 a2 b8 80 00 00 	movabs $0x80b8a2,%rax
  80adf1:	00 00 00 
  80adf4:	ff d0                	callq  *%rax
  80adf6:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80adf9:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80adfd:	0f 85 dd 00 00 00    	jne    80aee0 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80ae03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae07:	ba 01 00 00 00       	mov    $0x1,%edx
  80ae0c:	be 35 00 00 00       	mov    $0x35,%esi
  80ae11:	48 89 c7             	mov    %rax,%rdi
  80ae14:	48 b8 df b0 80 00 00 	movabs $0x80b0df,%rax
  80ae1b:	00 00 00 
  80ae1e:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80ae20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae24:	be 07 00 00 00       	mov    $0x7,%esi
  80ae29:	48 89 c7             	mov    %rax,%rdi
  80ae2c:	48 b8 90 b1 80 00 00 	movabs $0x80b190,%rax
  80ae33:	00 00 00 
  80ae36:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80ae38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae3c:	48 89 c7             	mov    %rax,%rdi
  80ae3f:	48 b8 1d bd 80 00 00 	movabs $0x80bd1d,%rax
  80ae46:	00 00 00 
  80ae49:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ae4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae4f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae53:	66 05 f0 00          	add    $0xf0,%ax
  80ae57:	0f b7 d0             	movzwl %ax,%edx
  80ae5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae5e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ae62:	89 d6                	mov    %edx,%esi
  80ae64:	48 89 c7             	mov    %rax,%rdi
  80ae67:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  80ae6e:	00 00 00 
  80ae71:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80ae73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae77:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80ae7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ae83:	ba 43 00 00 00       	mov    $0x43,%edx
  80ae88:	48 89 ce             	mov    %rcx,%rsi
  80ae8b:	48 89 c7             	mov    %rax,%rdi
  80ae8e:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  80ae95:	00 00 00 
  80ae98:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80ae9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae9e:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80aea2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aea6:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80aeaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeae:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aeb2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80aeb6:	49 89 c8             	mov    %rcx,%r8
  80aeb9:	b9 43 00 00 00       	mov    $0x43,%ecx
  80aebe:	48 89 c7             	mov    %rax,%rdi
  80aec1:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  80aec8:	00 00 00 
  80aecb:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80aecd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aed1:	48 89 c7             	mov    %rax,%rdi
  80aed4:	48 b8 f7 bb 80 00 00 	movabs $0x80bbf7,%rax
  80aedb:	00 00 00 
  80aede:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80aee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aee8:	8d 50 01             	lea    0x1(%rax),%edx
  80aeeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeef:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80aef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aef6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aefa:	3c 09                	cmp    $0x9,%al
  80aefc:	77 12                	ja     80af10 <dhcp_release+0x1cc>
  80aefe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af02:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80af06:	0f b6 c0             	movzbl %al,%eax
  80af09:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80af0e:	eb 05                	jmp    80af15 <dhcp_release+0x1d1>
  80af10:	b8 10 27 00 00       	mov    $0x2710,%eax
  80af15:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80af19:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80af1d:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80af23:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80af28:	89 c8                	mov    %ecx,%eax
  80af2a:	f7 ea                	imul   %edx
  80af2c:	c1 fa 05             	sar    $0x5,%edx
  80af2f:	89 c8                	mov    %ecx,%eax
  80af31:	c1 f8 1f             	sar    $0x1f,%eax
  80af34:	29 c2                	sub    %eax,%edx
  80af36:	89 d0                	mov    %edx,%eax
  80af38:	89 c2                	mov    %eax,%edx
  80af3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af3e:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80af42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af46:	48 89 c7             	mov    %rax,%rdi
  80af49:	48 b8 eb d2 80 00 00 	movabs $0x80d2eb,%rax
  80af50:	00 00 00 
  80af53:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80af55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af59:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80af60:	00 00 00 
  80af63:	48 89 c7             	mov    %rax,%rdi
  80af66:	48 b8 03 d1 80 00 00 	movabs $0x80d103,%rax
  80af6d:	00 00 00 
  80af70:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80af72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af76:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80af7d:	00 00 00 
  80af80:	48 89 c7             	mov    %rax,%rdi
  80af83:	48 b8 09 d2 80 00 00 	movabs $0x80d209,%rax
  80af8a:	00 00 00 
  80af8d:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80af8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af93:	48 be e8 24 82 00 00 	movabs $0x8224e8,%rsi
  80af9a:	00 00 00 
  80af9d:	48 89 c7             	mov    %rax,%rdi
  80afa0:	48 b8 36 d2 80 00 00 	movabs $0x80d236,%rax
  80afa7:	00 00 00 
  80afaa:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80afac:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80afb0:	c9                   	leaveq 
  80afb1:	c3                   	retq   

000000000080afb2 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80afb2:	55                   	push   %rbp
  80afb3:	48 89 e5             	mov    %rsp,%rbp
  80afb6:	48 83 ec 20          	sub    $0x20,%rsp
  80afba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80afbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afc2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80afc6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80afca:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80afcf:	75 2a                	jne    80affb <dhcp_stop+0x49>
  80afd1:	48 ba 3c 17 82 00 00 	movabs $0x82173c,%rdx
  80afd8:	00 00 00 
  80afdb:	be 2c 04 00 00       	mov    $0x42c,%esi
  80afe0:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80afe7:	00 00 00 
  80afea:	b8 00 00 00 00       	mov    $0x0,%eax
  80afef:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80aff6:	00 00 00 
  80aff9:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80affb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afff:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80b003:	83 e0 f7             	and    $0xfffffff7,%eax
  80b006:	89 c2                	mov    %eax,%edx
  80b008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b00c:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80b00f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b014:	0f 84 92 00 00 00    	je     80b0ac <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80b01a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b01e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b022:	48 85 c0             	test   %rax,%rax
  80b025:	74 23                	je     80b04a <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80b027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b02b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b02f:	48 89 c7             	mov    %rax,%rdi
  80b032:	48 b8 7b 57 81 00 00 	movabs $0x81577b,%rax
  80b039:	00 00 00 
  80b03c:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80b03e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b042:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80b049:	00 
    }
    if (dhcp->p != NULL) {
  80b04a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b04e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b052:	48 85 c0             	test   %rax,%rax
  80b055:	74 23                	je     80b07a <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80b057:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b05b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b05f:	48 89 c7             	mov    %rax,%rdi
  80b062:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80b069:	00 00 00 
  80b06c:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80b06e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b072:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b079:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80b07a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b07e:	48 89 c7             	mov    %rax,%rdi
  80b081:	48 b8 da b5 80 00 00 	movabs $0x80b5da,%rax
  80b088:	00 00 00 
  80b08b:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80b08d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b091:	48 89 c7             	mov    %rax,%rdi
  80b094:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80b09b:	00 00 00 
  80b09e:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80b0a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0a4:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b0ab:	00 
  }
}
  80b0ac:	c9                   	leaveq 
  80b0ad:	c3                   	retq   

000000000080b0ae <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80b0ae:	55                   	push   %rbp
  80b0af:	48 89 e5             	mov    %rsp,%rbp
  80b0b2:	48 83 ec 0c          	sub    $0xc,%rsp
  80b0b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b0ba:	89 f0                	mov    %esi,%eax
  80b0bc:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80b0bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0c3:	0f b6 00             	movzbl (%rax),%eax
  80b0c6:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80b0c9:	74 12                	je     80b0dd <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80b0cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0cf:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80b0d3:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80b0d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0d9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80b0dd:	c9                   	leaveq 
  80b0de:	c3                   	retq   

000000000080b0df <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80b0df:	55                   	push   %rbp
  80b0e0:	48 89 e5             	mov    %rsp,%rbp
  80b0e3:	48 83 ec 10          	sub    $0x10,%rsp
  80b0e7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b0eb:	89 f1                	mov    %esi,%ecx
  80b0ed:	89 d0                	mov    %edx,%eax
  80b0ef:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80b0f2:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80b0f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0f9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b0fd:	0f b7 d0             	movzwl %ax,%edx
  80b100:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80b104:	01 d0                	add    %edx,%eax
  80b106:	83 c0 02             	add    $0x2,%eax
  80b109:	83 f8 44             	cmp    $0x44,%eax
  80b10c:	76 2a                	jbe    80b138 <dhcp_option+0x59>
  80b10e:	48 ba 58 17 82 00 00 	movabs $0x821758,%rdx
  80b115:	00 00 00 
  80b118:	be 5a 04 00 00       	mov    $0x45a,%esi
  80b11d:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b124:	00 00 00 
  80b127:	b8 00 00 00 00       	mov    $0x0,%eax
  80b12c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b133:	00 00 00 
  80b136:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80b138:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b13c:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b140:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b144:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b148:	8d 70 01             	lea    0x1(%rax),%esi
  80b14b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b14f:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b153:	0f b7 c0             	movzwl %ax,%eax
  80b156:	48 98                	cltq   
  80b158:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b15c:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80b163:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b167:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b16b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b16f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b173:	8d 70 01             	lea    0x1(%rax),%esi
  80b176:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b17a:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b17e:	0f b7 c0             	movzwl %ax,%eax
  80b181:	48 98                	cltq   
  80b183:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80b187:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b18e:	c9                   	leaveq 
  80b18f:	c3                   	retq   

000000000080b190 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80b190:	55                   	push   %rbp
  80b191:	48 89 e5             	mov    %rsp,%rbp
  80b194:	48 83 ec 10          	sub    $0x10,%rsp
  80b198:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b19c:	89 f0                	mov    %esi,%eax
  80b19e:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b1a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1a5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b1a9:	66 83 f8 43          	cmp    $0x43,%ax
  80b1ad:	76 2a                	jbe    80b1d9 <dhcp_option_byte+0x49>
  80b1af:	48 ba a0 17 82 00 00 	movabs $0x8217a0,%rdx
  80b1b6:	00 00 00 
  80b1b9:	be 65 04 00 00       	mov    $0x465,%esi
  80b1be:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b1c5:	00 00 00 
  80b1c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80b1cd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b1d4:	00 00 00 
  80b1d7:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80b1d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1dd:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b1e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1e5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b1e9:	8d 70 01             	lea    0x1(%rax),%esi
  80b1ec:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b1f0:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b1f4:	0f b7 c0             	movzwl %ax,%eax
  80b1f7:	48 98                	cltq   
  80b1f9:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b1fd:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b204:	c9                   	leaveq 
  80b205:	c3                   	retq   

000000000080b206 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80b206:	55                   	push   %rbp
  80b207:	48 89 e5             	mov    %rsp,%rbp
  80b20a:	48 83 ec 10          	sub    $0x10,%rsp
  80b20e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b212:	89 f0                	mov    %esi,%eax
  80b214:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80b218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b21c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b220:	0f b7 c0             	movzwl %ax,%eax
  80b223:	83 c0 02             	add    $0x2,%eax
  80b226:	83 f8 44             	cmp    $0x44,%eax
  80b229:	76 2a                	jbe    80b255 <dhcp_option_short+0x4f>
  80b22b:	48 ba e0 17 82 00 00 	movabs $0x8217e0,%rdx
  80b232:	00 00 00 
  80b235:	be 6c 04 00 00       	mov    $0x46c,%esi
  80b23a:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b241:	00 00 00 
  80b244:	b8 00 00 00 00       	mov    $0x0,%eax
  80b249:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b250:	00 00 00 
  80b253:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80b255:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b259:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b25d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b261:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b265:	8d 70 01             	lea    0x1(%rax),%esi
  80b268:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b26c:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b270:	0f b7 c0             	movzwl %ax,%eax
  80b273:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b277:	66 c1 e9 08          	shr    $0x8,%cx
  80b27b:	48 98                	cltq   
  80b27d:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80b284:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b288:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b28c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b290:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b294:	8d 70 01             	lea    0x1(%rax),%esi
  80b297:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b29b:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b29f:	0f b7 c0             	movzwl %ax,%eax
  80b2a2:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b2a6:	48 98                	cltq   
  80b2a8:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b2af:	c9                   	leaveq 
  80b2b0:	c3                   	retq   

000000000080b2b1 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80b2b1:	55                   	push   %rbp
  80b2b2:	48 89 e5             	mov    %rsp,%rbp
  80b2b5:	48 83 ec 10          	sub    $0x10,%rsp
  80b2b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b2bd:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80b2c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2c4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2c8:	0f b7 c0             	movzwl %ax,%eax
  80b2cb:	83 c0 04             	add    $0x4,%eax
  80b2ce:	83 f8 44             	cmp    $0x44,%eax
  80b2d1:	76 2a                	jbe    80b2fd <dhcp_option_long+0x4c>
  80b2d3:	48 ba 28 18 82 00 00 	movabs $0x821828,%rdx
  80b2da:	00 00 00 
  80b2dd:	be 74 04 00 00       	mov    $0x474,%esi
  80b2e2:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b2e9:	00 00 00 
  80b2ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2f1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b2f8:	00 00 00 
  80b2fb:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b2fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b301:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b309:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b30d:	8d 70 01             	lea    0x1(%rax),%esi
  80b310:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b314:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b318:	0f b7 c0             	movzwl %ax,%eax
  80b31b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b31e:	c1 e9 18             	shr    $0x18,%ecx
  80b321:	48 98                	cltq   
  80b323:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b32a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b32e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b332:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b336:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b33a:	8d 70 01             	lea    0x1(%rax),%esi
  80b33d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b341:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b345:	0f b7 c0             	movzwl %ax,%eax
  80b348:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b34b:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80b351:	48 c1 e9 10          	shr    $0x10,%rcx
  80b355:	48 98                	cltq   
  80b357:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b35e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b362:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b366:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b36a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b36e:	8d 70 01             	lea    0x1(%rax),%esi
  80b371:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b375:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b379:	0f b7 c0             	movzwl %ax,%eax
  80b37c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b37f:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80b385:	48 c1 e9 08          	shr    $0x8,%rcx
  80b389:	48 98                	cltq   
  80b38b:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b392:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b396:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b39a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b39e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3a2:	8d 70 01             	lea    0x1(%rax),%esi
  80b3a5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b3a9:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b3ad:	0f b7 c0             	movzwl %ax,%eax
  80b3b0:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b3b3:	48 98                	cltq   
  80b3b5:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b3bc:	c9                   	leaveq 
  80b3bd:	c3                   	retq   

000000000080b3be <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b3be:	55                   	push   %rbp
  80b3bf:	48 89 e5             	mov    %rsp,%rbp
  80b3c2:	48 83 ec 20          	sub    $0x20,%rsp
  80b3c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b3ca:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b3cf:	75 2a                	jne    80b3fb <dhcp_unfold_reply+0x3d>
  80b3d1:	48 ba 68 18 82 00 00 	movabs $0x821868,%rdx
  80b3d8:	00 00 00 
  80b3db:	be 89 04 00 00       	mov    $0x489,%esi
  80b3e0:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b3e7:	00 00 00 
  80b3ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3ef:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b3f6:	00 00 00 
  80b3f9:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b3fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b3ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b403:	48 85 c0             	test   %rax,%rax
  80b406:	75 2a                	jne    80b432 <dhcp_unfold_reply+0x74>
  80b408:	48 ba 75 18 82 00 00 	movabs $0x821875,%rdx
  80b40f:	00 00 00 
  80b412:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b417:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b41e:	00 00 00 
  80b421:	b8 00 00 00 00       	mov    $0x0,%eax
  80b426:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b42d:	00 00 00 
  80b430:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b436:	48 89 c7             	mov    %rax,%rdi
  80b439:	48 b8 da b5 80 00 00 	movabs $0x80b5da,%rax
  80b440:	00 00 00 
  80b443:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b445:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b449:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b44d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b451:	66 3d f0 00          	cmp    $0xf0,%ax
  80b455:	76 52                	jbe    80b4a9 <dhcp_unfold_reply+0xeb>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b45b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b45f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b463:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b469:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b46d:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b471:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b475:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b479:	0f b7 c0             	movzwl %ax,%eax
  80b47c:	89 c7                	mov    %eax,%edi
  80b47e:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  80b485:	00 00 00 
  80b488:	ff d0                	callq  *%rax
  80b48a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b48e:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (dhcp->options_in == NULL) {
  80b492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b496:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b49a:	48 85 c0             	test   %rax,%rax
  80b49d:	75 0a                	jne    80b4a9 <dhcp_unfold_reply+0xeb>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b49f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b4a4:	e9 2f 01 00 00       	jmpq   80b5d8 <dhcp_unfold_reply+0x21a>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b4a9:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b4ae:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  80b4b5:	00 00 00 
  80b4b8:	ff d0                	callq  *%rax
  80b4ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b4be:	48 89 42 18          	mov    %rax,0x18(%rdx)
  if (dhcp->msg_in == NULL) {
  80b4c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4c6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b4ca:	48 85 c0             	test   %rax,%rax
  80b4cd:	75 2d                	jne    80b4fc <dhcp_unfold_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b4cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4d3:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b4d7:	48 89 c7             	mov    %rax,%rdi
  80b4da:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80b4e1:	00 00 00 
  80b4e4:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b4e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4ea:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b4f1:	00 
    return ERR_MEM;
  80b4f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b4f7:	e9 dc 00 00 00       	jmpq   80b5d8 <dhcp_unfold_reply+0x21a>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b4fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b500:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b504:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b508:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b50c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b511:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b516:	48 89 c7             	mov    %rax,%rdi
  80b519:	48 b8 2d e3 80 00 00 	movabs $0x80e32d,%rax
  80b520:	00 00 00 
  80b523:	ff d0                	callq  *%rax
  80b525:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b529:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b52f:	74 2a                	je     80b55b <dhcp_unfold_reply+0x19d>
  80b531:	48 ba 88 18 82 00 00 	movabs $0x821888,%rdx
  80b538:	00 00 00 
  80b53b:	be a0 04 00 00       	mov    $0x4a0,%esi
  80b540:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b547:	00 00 00 
  80b54a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b54f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b556:	00 00 00 
  80b559:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b55b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b55f:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b563:	48 85 c0             	test   %rax,%rax
  80b566:	74 6b                	je     80b5d3 <dhcp_unfold_reply+0x215>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b568:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b56c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b570:	0f b7 d0             	movzwl %ax,%edx
  80b573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b577:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b57b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b57f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b583:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b588:	48 89 c7             	mov    %rax,%rdi
  80b58b:	48 b8 2d e3 80 00 00 	movabs $0x80e32d,%rax
  80b592:	00 00 00 
  80b595:	ff d0                	callq  *%rax
  80b597:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b59b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b59f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b5a3:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b5a7:	74 2a                	je     80b5d3 <dhcp_unfold_reply+0x215>
  80b5a9:	48 ba ba 18 82 00 00 	movabs $0x8218ba,%rdx
  80b5b0:	00 00 00 
  80b5b3:	be a7 04 00 00       	mov    $0x4a7,%esi
  80b5b8:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b5bf:	00 00 00 
  80b5c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80b5c7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b5ce:	00 00 00 
  80b5d1:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b5d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b5d8:	c9                   	leaveq 
  80b5d9:	c3                   	retq   

000000000080b5da <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b5da:	55                   	push   %rbp
  80b5db:	48 89 e5             	mov    %rsp,%rbp
  80b5de:	48 83 ec 10          	sub    $0x10,%rsp
  80b5e2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b5e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b5ea:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b5ee:	48 85 c0             	test   %rax,%rax
  80b5f1:	74 23                	je     80b616 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b5f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b5f7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b5fb:	48 89 c7             	mov    %rax,%rdi
  80b5fe:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80b605:	00 00 00 
  80b608:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b60a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b60e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b615:	00 
  }
  if (dhcp->options_in) {
  80b616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b61a:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b61e:	48 85 c0             	test   %rax,%rax
  80b621:	74 2d                	je     80b650 <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b623:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b627:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b62b:	48 89 c7             	mov    %rax,%rdi
  80b62e:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80b635:	00 00 00 
  80b638:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b63a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b63e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b645:	00 
    dhcp->options_in_len = 0;
  80b646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b64a:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b650:	c9                   	leaveq 
  80b651:	c3                   	retq   

000000000080b652 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b652:	55                   	push   %rbp
  80b653:	48 89 e5             	mov    %rsp,%rbp
  80b656:	48 83 ec 60          	sub    $0x60,%rsp
  80b65a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b65e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b662:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b666:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b66a:	44 89 c0             	mov    %r8d,%eax
  80b66d:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b671:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b675:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b679:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b67d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b681:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b685:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b689:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b68d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b691:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b695:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b699:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b69d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b6a1:	0f b6 00             	movzbl (%rax),%eax
  80b6a4:	3c 02                	cmp    $0x2,%al
  80b6a6:	74 05                	je     80b6ad <dhcp_recv+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b6a8:	e9 d4 01 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b6ad:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b6b1:	eb 31                	jmp    80b6e4 <dhcp_recv+0x92>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b6b3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b6b7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b6bb:	48 98                	cltq   
  80b6bd:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b6c2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b6c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b6ca:	48 98                	cltq   
  80b6cc:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b6d1:	38 c1                	cmp    %al,%cl
  80b6d3:	74 05                	je     80b6da <dhcp_recv+0x88>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b6d5:	e9 a7 01 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b6da:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b6de:	83 c0 01             	add    $0x1,%eax
  80b6e1:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b6e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b6e8:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b6ec:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b6ef:	77 c2                	ja     80b6b3 <dhcp_recv+0x61>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b6f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b6f5:	8b 40 04             	mov    0x4(%rax),%eax
  80b6f8:	89 c7                	mov    %eax,%edi
  80b6fa:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  80b701:	00 00 00 
  80b704:	ff d0                	callq  *%rax
  80b706:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b70a:	8b 52 04             	mov    0x4(%rdx),%edx
  80b70d:	39 d0                	cmp    %edx,%eax
  80b70f:	74 05                	je     80b716 <dhcp_recv+0xc4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b711:	e9 6b 01 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b71a:	48 89 c7             	mov    %rax,%rdi
  80b71d:	48 b8 be b3 80 00 00 	movabs $0x80b3be,%rax
  80b724:	00 00 00 
  80b727:	ff d0                	callq  *%rax
  80b729:	84 c0                	test   %al,%al
  80b72b:	74 05                	je     80b732 <dhcp_recv+0xe0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b72d:	e9 4f 01 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b732:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b736:	be 35 00 00 00       	mov    $0x35,%esi
  80b73b:	48 89 c7             	mov    %rax,%rdi
  80b73e:	48 b8 75 be 80 00 00 	movabs $0x80be75,%rax
  80b745:	00 00 00 
  80b748:	ff d0                	callq  *%rax
  80b74a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b74e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b753:	75 05                	jne    80b75a <dhcp_recv+0x108>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b755:	e9 27 01 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b75a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b75e:	48 83 c0 02          	add    $0x2,%rax
  80b762:	48 89 c7             	mov    %rax,%rdi
  80b765:	48 b8 37 c0 80 00 00 	movabs $0x80c037,%rax
  80b76c:	00 00 00 
  80b76f:	ff d0                	callq  *%rax
  80b771:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b774:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b778:	0f 85 84 00 00 00    	jne    80b802 <dhcp_recv+0x1b0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b77e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b782:	0f b6 00             	movzbl (%rax),%eax
  80b785:	3c 01                	cmp    $0x1,%al
  80b787:	75 35                	jne    80b7be <dhcp_recv+0x16c>
      dhcp_handle_ack(netif);
  80b789:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b78d:	48 89 c7             	mov    %rax,%rdi
  80b790:	48 b8 04 9b 80 00 00 	movabs $0x809b04,%rax
  80b797:	00 00 00 
  80b79a:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b79c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7a0:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b7a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7aa:	48 89 c7             	mov    %rax,%rdi
  80b7ad:	48 b8 c6 93 80 00 00 	movabs $0x8093c6,%rax
  80b7b4:	00 00 00 
  80b7b7:	ff d0                	callq  *%rax
  80b7b9:	e9 c3 00 00 00       	jmpq   80b881 <dhcp_recv+0x22f>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b7be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7c2:	0f b6 00             	movzbl (%rax),%eax
  80b7c5:	3c 03                	cmp    $0x3,%al
  80b7c7:	74 1a                	je     80b7e3 <dhcp_recv+0x191>
  80b7c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7cd:	0f b6 00             	movzbl (%rax),%eax
  80b7d0:	3c 04                	cmp    $0x4,%al
  80b7d2:	74 0f                	je     80b7e3 <dhcp_recv+0x191>
  80b7d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7d8:	0f b6 00             	movzbl (%rax),%eax
  80b7db:	3c 05                	cmp    $0x5,%al
  80b7dd:	0f 85 9e 00 00 00    	jne    80b881 <dhcp_recv+0x22f>
      dhcp->request_timeout = 0;
  80b7e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7e7:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b7ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7f1:	48 89 c7             	mov    %rax,%rdi
  80b7f4:	48 b8 27 a7 80 00 00 	movabs $0x80a727,%rax
  80b7fb:	00 00 00 
  80b7fe:	ff d0                	callq  *%rax
  80b800:	eb 7f                	jmp    80b881 <dhcp_recv+0x22f>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b802:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b806:	75 4b                	jne    80b853 <dhcp_recv+0x201>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b808:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b80c:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b80f:	3c 03                	cmp    $0x3,%al
  80b811:	74 21                	je     80b834 <dhcp_recv+0x1e2>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b813:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b817:	0f b6 00             	movzbl (%rax),%eax
  80b81a:	3c 01                	cmp    $0x1,%al
  80b81c:	74 16                	je     80b834 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b81e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b822:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b825:	3c 04                	cmp    $0x4,%al
  80b827:	74 0b                	je     80b834 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b829:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b82d:	0f b6 00             	movzbl (%rax),%eax
  80b830:	3c 05                	cmp    $0x5,%al
  80b832:	75 1f                	jne    80b853 <dhcp_recv+0x201>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b834:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b838:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b83e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b842:	48 89 c7             	mov    %rax,%rdi
  80b845:	48 b8 17 93 80 00 00 	movabs $0x809317,%rax
  80b84c:	00 00 00 
  80b84f:	ff d0                	callq  *%rax
  80b851:	eb 2e                	jmp    80b881 <dhcp_recv+0x22f>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b853:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b857:	75 28                	jne    80b881 <dhcp_recv+0x22f>
  80b859:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b85d:	0f b6 00             	movzbl (%rax),%eax
  80b860:	3c 06                	cmp    $0x6,%al
  80b862:	75 1d                	jne    80b881 <dhcp_recv+0x22f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b864:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b868:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b86e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b872:	48 89 c7             	mov    %rax,%rdi
  80b875:	48 b8 5f 94 80 00 00 	movabs $0x80945f,%rax
  80b87c:	00 00 00 
  80b87f:	ff d0                	callq  *%rax
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b881:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b885:	48 89 c7             	mov    %rax,%rdi
  80b888:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80b88f:	00 00 00 
  80b892:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b894:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b898:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b89f:	00 
}
  80b8a0:	c9                   	leaveq 
  80b8a1:	c3                   	retq   

000000000080b8a2 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b8a2:	55                   	push   %rbp
  80b8a3:	48 89 e5             	mov    %rsp,%rbp
  80b8a6:	53                   	push   %rbx
  80b8a7:	48 83 ec 28          	sub    $0x28,%rsp
  80b8ab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b8af:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b8b4:	75 2a                	jne    80b8e0 <dhcp_create_request+0x3e>
  80b8b6:	48 ba d8 18 82 00 00 	movabs $0x8218d8,%rdx
  80b8bd:	00 00 00 
  80b8c0:	be 2d 05 00 00       	mov    $0x52d,%esi
  80b8c5:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b8cc:	00 00 00 
  80b8cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8d4:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b8db:	00 00 00 
  80b8de:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b8e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b8e4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b8e8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80b8ec:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80b8f1:	75 2a                	jne    80b91d <dhcp_create_request+0x7b>
  80b8f3:	48 ba 00 19 82 00 00 	movabs $0x821900,%rdx
  80b8fa:	00 00 00 
  80b8fd:	be 2f 05 00 00       	mov    $0x52f,%esi
  80b902:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b909:	00 00 00 
  80b90c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b911:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b918:	00 00 00 
  80b91b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80b91d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b921:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b925:	48 85 c0             	test   %rax,%rax
  80b928:	74 2a                	je     80b954 <dhcp_create_request+0xb2>
  80b92a:	48 ba 28 19 82 00 00 	movabs $0x821928,%rdx
  80b931:	00 00 00 
  80b934:	be 30 05 00 00       	mov    $0x530,%esi
  80b939:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b940:	00 00 00 
  80b943:	b8 00 00 00 00       	mov    $0x0,%eax
  80b948:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b94f:	00 00 00 
  80b952:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80b954:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b958:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b95c:	48 85 c0             	test   %rax,%rax
  80b95f:	74 2a                	je     80b98b <dhcp_create_request+0xe9>
  80b961:	48 ba 58 19 82 00 00 	movabs $0x821958,%rdx
  80b968:	00 00 00 
  80b96b:	be 31 05 00 00       	mov    $0x531,%esi
  80b970:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b977:	00 00 00 
  80b97a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b97f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b986:	00 00 00 
  80b989:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80b98b:	ba 00 00 00 00       	mov    $0x0,%edx
  80b990:	be 34 01 00 00       	mov    $0x134,%esi
  80b995:	bf 00 00 00 00       	mov    $0x0,%edi
  80b99a:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  80b9a1:	00 00 00 
  80b9a4:	ff d0                	callq  *%rax
  80b9a6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b9aa:	48 89 42 30          	mov    %rax,0x30(%rdx)
  if (dhcp->p_out == NULL) {
  80b9ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b9b2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b9b6:	48 85 c0             	test   %rax,%rax
  80b9b9:	75 0a                	jne    80b9c5 <dhcp_create_request+0x123>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80b9bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b9c0:	e9 2b 02 00 00       	jmpq   80bbf0 <dhcp_create_request+0x34e>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80b9c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b9c9:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b9cd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80b9d1:	66 3d 33 01          	cmp    $0x133,%ax
  80b9d5:	77 2a                	ja     80ba01 <dhcp_create_request+0x15f>
  80b9d7:	48 ba 88 19 82 00 00 	movabs $0x821988,%rdx
  80b9de:	00 00 00 
  80b9e1:	be 38 05 00 00       	mov    $0x538,%esi
  80b9e6:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80b9ed:	00 00 00 
  80b9f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9f5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80b9fc:	00 00 00 
  80b9ff:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80ba01:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80ba08:	00 00 00 
  80ba0b:	8b 00                	mov    (%rax),%eax
  80ba0d:	8d 48 01             	lea    0x1(%rax),%ecx
  80ba10:	48 ba 7c 81 82 00 00 	movabs $0x82817c,%rdx
  80ba17:	00 00 00 
  80ba1a:	89 0a                	mov    %ecx,(%rdx)
  80ba1c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ba20:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80ba23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba27:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba2b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80ba2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba33:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80ba37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba3b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba3f:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80ba42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba46:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba4a:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80ba4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba52:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba56:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80ba5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba5e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba62:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80ba66:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba6a:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80ba6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba72:	8b 40 04             	mov    0x4(%rax),%eax
  80ba75:	89 c7                	mov    %eax,%edi
  80ba77:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80ba7e:	00 00 00 
  80ba81:	ff d0                	callq  *%rax
  80ba83:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80ba86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba8a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba8e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80ba94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba98:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba9c:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80baa2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80baa6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80baaa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80baae:	8b 52 08             	mov    0x8(%rdx),%edx
  80bab1:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80bab4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bab8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80babc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80bac3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bac7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bacb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80bad2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bad6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bada:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bae1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bae7:	eb 45                	jmp    80bb2e <dhcp_create_request+0x28c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80bae9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80baed:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80baf1:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80baf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80baf9:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80bafd:	0f b6 c0             	movzbl %al,%eax
  80bb00:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bb04:	76 11                	jbe    80bb17 <dhcp_create_request+0x275>
  80bb06:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb0a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bb0e:	48 98                	cltq   
  80bb10:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80bb15:	eb 05                	jmp    80bb1c <dhcp_create_request+0x27a>
  80bb17:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb1c:	48 63 d6             	movslq %esi,%rdx
  80bb1f:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bb23:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb27:	83 c0 01             	add    $0x1,%eax
  80bb2a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bb2e:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80bb33:	76 b4                	jbe    80bae9 <dhcp_create_request+0x247>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bb35:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bb3b:	eb 1e                	jmp    80bb5b <dhcp_create_request+0x2b9>
    dhcp->msg_out->sname[i] = 0;
  80bb3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb41:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bb45:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb49:	48 98                	cltq   
  80bb4b:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bb50:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb54:	83 c0 01             	add    $0x1,%eax
  80bb57:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bb5b:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80bb60:	76 db                	jbe    80bb3d <dhcp_create_request+0x29b>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bb62:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bb68:	eb 1e                	jmp    80bb88 <dhcp_create_request+0x2e6>
    dhcp->msg_out->file[i] = 0;
  80bb6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb6e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bb72:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb76:	48 98                	cltq   
  80bb78:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bb7d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb81:	83 c0 01             	add    $0x1,%eax
  80bb84:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bb88:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80bb8d:	76 db                	jbe    80bb6a <dhcp_create_request+0x2c8>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80bb8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb93:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bb97:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80bb9c:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80bba3:	00 00 00 
  80bba6:	ff d0                	callq  *%rax
  80bba8:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80bbae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbb2:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bbb8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bbbe:	eb 24                	jmp    80bbe4 <dhcp_create_request+0x342>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80bbc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbc4:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bbc8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bbcc:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80bbd0:	48 98                	cltq   
  80bbd2:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bbd9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bbdd:	83 c0 01             	add    $0x1,%eax
  80bbe0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bbe4:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80bbe9:	76 d5                	jbe    80bbc0 <dhcp_create_request+0x31e>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80bbeb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bbf0:	48 83 c4 28          	add    $0x28,%rsp
  80bbf4:	5b                   	pop    %rbx
  80bbf5:	5d                   	pop    %rbp
  80bbf6:	c3                   	retq   

000000000080bbf7 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80bbf7:	55                   	push   %rbp
  80bbf8:	48 89 e5             	mov    %rsp,%rbp
  80bbfb:	48 83 ec 20          	sub    $0x20,%rsp
  80bbff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80bc03:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80bc08:	75 2a                	jne    80bc34 <dhcp_delete_request+0x3d>
  80bc0a:	48 ba d0 19 82 00 00 	movabs $0x8219d0,%rdx
  80bc11:	00 00 00 
  80bc14:	be 69 05 00 00       	mov    $0x569,%esi
  80bc19:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bc20:	00 00 00 
  80bc23:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc28:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bc2f:	00 00 00 
  80bc32:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80bc34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bc38:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc3c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80bc40:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bc45:	75 2a                	jne    80bc71 <dhcp_delete_request+0x7a>
  80bc47:	48 ba f8 19 82 00 00 	movabs $0x8219f8,%rdx
  80bc4e:	00 00 00 
  80bc51:	be 6b 05 00 00       	mov    $0x56b,%esi
  80bc56:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bc5d:	00 00 00 
  80bc60:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc65:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bc6c:	00 00 00 
  80bc6f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80bc71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc75:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bc79:	48 85 c0             	test   %rax,%rax
  80bc7c:	75 2a                	jne    80bca8 <dhcp_delete_request+0xb1>
  80bc7e:	48 ba 20 1a 82 00 00 	movabs $0x821a20,%rdx
  80bc85:	00 00 00 
  80bc88:	be 6c 05 00 00       	mov    $0x56c,%esi
  80bc8d:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bc94:	00 00 00 
  80bc97:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc9c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bca3:	00 00 00 
  80bca6:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80bca8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bcac:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bcb0:	48 85 c0             	test   %rax,%rax
  80bcb3:	75 2a                	jne    80bcdf <dhcp_delete_request+0xe8>
  80bcb5:	48 ba 50 1a 82 00 00 	movabs $0x821a50,%rdx
  80bcbc:	00 00 00 
  80bcbf:	be 6d 05 00 00       	mov    $0x56d,%esi
  80bcc4:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bccb:	00 00 00 
  80bcce:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcd3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bcda:	00 00 00 
  80bcdd:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80bcdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bce3:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bce7:	48 85 c0             	test   %rax,%rax
  80bcea:	74 17                	je     80bd03 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80bcec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bcf0:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bcf4:	48 89 c7             	mov    %rax,%rdi
  80bcf7:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80bcfe:	00 00 00 
  80bd01:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80bd03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd07:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80bd0e:	00 
  dhcp->msg_out = NULL;
  80bd0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd13:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80bd1a:	00 
}
  80bd1b:	c9                   	leaveq 
  80bd1c:	c3                   	retq   

000000000080bd1d <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80bd1d:	55                   	push   %rbp
  80bd1e:	48 89 e5             	mov    %rsp,%rbp
  80bd21:	48 83 ec 10          	sub    $0x10,%rsp
  80bd25:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80bd29:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bd2e:	75 2a                	jne    80bd5a <dhcp_option_trailer+0x3d>
  80bd30:	48 ba 80 1a 82 00 00 	movabs $0x821a80,%rdx
  80bd37:	00 00 00 
  80bd3a:	be 80 05 00 00       	mov    $0x580,%esi
  80bd3f:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bd46:	00 00 00 
  80bd49:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd4e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bd55:	00 00 00 
  80bd58:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80bd5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd5e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bd62:	48 85 c0             	test   %rax,%rax
  80bd65:	75 2a                	jne    80bd91 <dhcp_option_trailer+0x74>
  80bd67:	48 ba a8 1a 82 00 00 	movabs $0x821aa8,%rdx
  80bd6e:	00 00 00 
  80bd71:	be 81 05 00 00       	mov    $0x581,%esi
  80bd76:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bd7d:	00 00 00 
  80bd80:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd85:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bd8c:	00 00 00 
  80bd8f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bd91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd95:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bd99:	66 83 f8 43          	cmp    $0x43,%ax
  80bd9d:	76 2a                	jbe    80bdc9 <dhcp_option_trailer+0xac>
  80bd9f:	48 ba d8 1a 82 00 00 	movabs $0x821ad8,%rdx
  80bda6:	00 00 00 
  80bda9:	be 82 05 00 00       	mov    $0x582,%esi
  80bdae:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80bdb5:	00 00 00 
  80bdb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdbd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80bdc4:	00 00 00 
  80bdc7:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80bdc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdcd:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bdd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdd5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bdd9:	8d 70 01             	lea    0x1(%rax),%esi
  80bddc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bde0:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bde4:	0f b7 c0             	movzwl %ax,%eax
  80bde7:	48 98                	cltq   
  80bde9:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80bdf0:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bdf1:	eb 60                	jmp    80be53 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bdf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdf7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bdfb:	66 83 f8 43          	cmp    $0x43,%ax
  80bdff:	76 2a                	jbe    80be2b <dhcp_option_trailer+0x10e>
  80be01:	48 ba d8 1a 82 00 00 	movabs $0x821ad8,%rdx
  80be08:	00 00 00 
  80be0b:	be 87 05 00 00       	mov    $0x587,%esi
  80be10:	48 bf f6 16 82 00 00 	movabs $0x8216f6,%rdi
  80be17:	00 00 00 
  80be1a:	b8 00 00 00 00       	mov    $0x0,%eax
  80be1f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80be26:	00 00 00 
  80be29:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80be2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be2f:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80be33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be37:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80be3b:	8d 70 01             	lea    0x1(%rax),%esi
  80be3e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80be42:	66 89 71 40          	mov    %si,0x40(%rcx)
  80be46:	0f b7 c0             	movzwl %ax,%eax
  80be49:	48 98                	cltq   
  80be4b:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80be52:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80be53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be57:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80be5b:	66 83 f8 43          	cmp    $0x43,%ax
  80be5f:	76 92                	jbe    80bdf3 <dhcp_option_trailer+0xd6>
  80be61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be65:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80be69:	0f b7 c0             	movzwl %ax,%eax
  80be6c:	83 e0 03             	and    $0x3,%eax
  80be6f:	85 c0                	test   %eax,%eax
  80be71:	75 80                	jne    80bdf3 <dhcp_option_trailer+0xd6>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80be73:	c9                   	leaveq 
  80be74:	c3                   	retq   

000000000080be75 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80be75:	55                   	push   %rbp
  80be76:	48 89 e5             	mov    %rsp,%rbp
  80be79:	48 83 ec 2c          	sub    $0x2c,%rsp
  80be7d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80be81:	89 f0                	mov    %esi,%eax
  80be83:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80be86:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80be8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80be8e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80be92:	48 85 c0             	test   %rax,%rax
  80be95:	0f 84 95 01 00 00    	je     80c030 <dhcp_get_option_ptr+0x1bb>
  80be9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80be9f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bea3:	66 85 c0             	test   %ax,%ax
  80bea6:	0f 84 84 01 00 00    	je     80c030 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80beac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80beb0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80beb4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80beb8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bebe:	e9 80 00 00 00       	jmpq   80bf43 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80bec3:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bec7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80becb:	48 01 d0             	add    %rdx,%rax
  80bece:	0f b6 00             	movzbl (%rax),%eax
  80bed1:	3c 34                	cmp    $0x34,%al
  80bed3:	75 22                	jne    80bef7 <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80bed5:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80beda:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bede:	8d 50 01             	lea    0x1(%rax),%edx
  80bee1:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80bee5:	0f b7 d0             	movzwl %ax,%edx
  80bee8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80beec:	48 01 d0             	add    %rdx,%rax
  80beef:	0f b6 00             	movzbl (%rax),%eax
  80bef2:	88 45 ff             	mov    %al,-0x1(%rbp)
  80bef5:	eb 4c                	jmp    80bf43 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80bef7:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80befb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80beff:	48 01 d0             	add    %rdx,%rax
  80bf02:	0f b6 00             	movzbl (%rax),%eax
  80bf05:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bf08:	75 10                	jne    80bf1a <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80bf0a:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bf0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf12:	48 01 d0             	add    %rdx,%rax
  80bf15:	e9 1b 01 00 00       	jmpq   80c035 <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80bf1a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bf1e:	83 c0 01             	add    $0x1,%eax
  80bf21:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80bf25:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bf29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf2d:	48 01 d0             	add    %rdx,%rax
  80bf30:	0f b6 00             	movzbl (%rax),%eax
  80bf33:	0f b6 d0             	movzbl %al,%edx
  80bf36:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bf3a:	01 d0                	add    %edx,%eax
  80bf3c:	83 c0 01             	add    $0x1,%eax
  80bf3f:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bf43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bf47:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bf4b:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bf4f:	76 16                	jbe    80bf67 <dhcp_get_option_ptr+0xf2>
  80bf51:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bf55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bf59:	48 01 d0             	add    %rdx,%rax
  80bf5c:	0f b6 00             	movzbl (%rax),%eax
  80bf5f:	3c ff                	cmp    $0xff,%al
  80bf61:	0f 85 5c ff ff ff    	jne    80bec3 <dhcp_get_option_ptr+0x4e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80bf67:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80bf6b:	0f 84 bf 00 00 00    	je     80c030 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80bf71:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80bf75:	75 18                	jne    80bf8f <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80bf77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bf7b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bf7f:	48 83 c0 6c          	add    $0x6c,%rax
  80bf83:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80bf87:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80bf8d:	eb 34                	jmp    80bfc3 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80bf8f:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80bf93:	75 18                	jne    80bfad <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bf95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bf99:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bf9d:	48 83 c0 2c          	add    $0x2c,%rax
  80bfa1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80bfa5:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80bfab:	eb 16                	jmp    80bfc3 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bfad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfb1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bfb5:	48 83 c0 2c          	add    $0x2c,%rax
  80bfb9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80bfbd:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80bfc3:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80bfc9:	eb 49                	jmp    80c014 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80bfcb:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bfcf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bfd3:	48 01 d0             	add    %rdx,%rax
  80bfd6:	0f b6 00             	movzbl (%rax),%eax
  80bfd9:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bfdc:	75 0d                	jne    80bfeb <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80bfde:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bfe2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bfe6:	48 01 d0             	add    %rdx,%rax
  80bfe9:	eb 4a                	jmp    80c035 <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80bfeb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bfef:	83 c0 01             	add    $0x1,%eax
  80bff2:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80bff6:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bffa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bffe:	48 01 d0             	add    %rdx,%rax
  80c001:	0f b6 00             	movzbl (%rax),%eax
  80c004:	0f b6 d0             	movzbl %al,%edx
  80c007:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c00b:	01 d0                	add    %edx,%eax
  80c00d:	83 c0 01             	add    $0x1,%eax
  80c010:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c014:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c018:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80c01c:	73 12                	jae    80c030 <dhcp_get_option_ptr+0x1bb>
  80c01e:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c022:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c026:	48 01 d0             	add    %rdx,%rax
  80c029:	0f b6 00             	movzbl (%rax),%eax
  80c02c:	3c ff                	cmp    $0xff,%al
  80c02e:	75 9b                	jne    80bfcb <dhcp_get_option_ptr+0x156>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80c030:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c035:	c9                   	leaveq 
  80c036:	c3                   	retq   

000000000080c037 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80c037:	55                   	push   %rbp
  80c038:	48 89 e5             	mov    %rsp,%rbp
  80c03b:	48 83 ec 08          	sub    $0x8,%rsp
  80c03f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80c043:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c047:	0f b6 00             	movzbl (%rax),%eax
}
  80c04a:	c9                   	leaveq 
  80c04b:	c3                   	retq   

000000000080c04c <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80c04c:	55                   	push   %rbp
  80c04d:	48 89 e5             	mov    %rsp,%rbp
  80c050:	48 83 ec 18          	sub    $0x18,%rsp
  80c054:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80c058:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c05c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c060:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c064:	0f b6 00             	movzbl (%rax),%eax
  80c067:	0f b6 c0             	movzbl %al,%eax
  80c06a:	c1 e0 18             	shl    $0x18,%eax
  80c06d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80c070:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c074:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c078:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c07c:	0f b6 00             	movzbl (%rax),%eax
  80c07f:	0f b6 c0             	movzbl %al,%eax
  80c082:	c1 e0 10             	shl    $0x10,%eax
  80c085:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80c088:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c08c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c090:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c094:	0f b6 00             	movzbl (%rax),%eax
  80c097:	0f b6 c0             	movzbl %al,%eax
  80c09a:	c1 e0 08             	shl    $0x8,%eax
  80c09d:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80c0a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c0a4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c0a8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c0ac:	0f b6 00             	movzbl (%rax),%eax
  80c0af:	0f b6 c0             	movzbl %al,%eax
  80c0b2:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80c0b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80c0b8:	c9                   	leaveq 
  80c0b9:	c3                   	retq   

000000000080c0ba <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80c0ba:	55                   	push   %rbp
  80c0bb:	48 89 e5             	mov    %rsp,%rbp
  80c0be:	48 83 ec 20          	sub    $0x20,%rsp
  80c0c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80c0c6:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c0cd:	00 00 00 
  80c0d0:	48 8b 00             	mov    (%rax),%rax
  80c0d3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c0d7:	73 2a                	jae    80c103 <plug_holes+0x49>
  80c0d9:	48 ba 18 1b 82 00 00 	movabs $0x821b18,%rdx
  80c0e0:	00 00 00 
  80c0e3:	be e3 00 00 00       	mov    $0xe3,%esi
  80c0e8:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c0ef:	00 00 00 
  80c0f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c0f7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c0fe:	00 00 00 
  80c101:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80c103:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c10a:	00 00 00 
  80c10d:	48 8b 00             	mov    (%rax),%rax
  80c110:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c114:	72 2a                	jb     80c140 <plug_holes+0x86>
  80c116:	48 ba 43 1b 82 00 00 	movabs $0x821b43,%rdx
  80c11d:	00 00 00 
  80c120:	be e4 00 00 00       	mov    $0xe4,%esi
  80c125:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c12c:	00 00 00 
  80c12f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c134:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c13b:	00 00 00 
  80c13e:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80c140:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c144:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c148:	84 c0                	test   %al,%al
  80c14a:	74 2a                	je     80c176 <plug_holes+0xbc>
  80c14c:	48 ba 5d 1b 82 00 00 	movabs $0x821b5d,%rdx
  80c153:	00 00 00 
  80c156:	be e5 00 00 00       	mov    $0xe5,%esi
  80c15b:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c162:	00 00 00 
  80c165:	b8 00 00 00 00       	mov    $0x0,%eax
  80c16a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c171:	00 00 00 
  80c174:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80c176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c17a:	8b 00                	mov    (%rax),%eax
  80c17c:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c181:	76 2a                	jbe    80c1ad <plug_holes+0xf3>
  80c183:	48 ba 78 1b 82 00 00 	movabs $0x821b78,%rdx
  80c18a:	00 00 00 
  80c18d:	be e8 00 00 00       	mov    $0xe8,%esi
  80c192:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c199:	00 00 00 
  80c19c:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1a1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c1a8:	00 00 00 
  80c1ab:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80c1ad:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c1b4:	00 00 00 
  80c1b7:	48 8b 10             	mov    (%rax),%rdx
  80c1ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1be:	8b 00                	mov    (%rax),%eax
  80c1c0:	89 c0                	mov    %eax,%eax
  80c1c2:	48 01 d0             	add    %rdx,%rax
  80c1c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80c1c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1cd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c1d1:	0f 84 81 00 00 00    	je     80c258 <plug_holes+0x19e>
  80c1d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c1db:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c1df:	84 c0                	test   %al,%al
  80c1e1:	75 75                	jne    80c258 <plug_holes+0x19e>
  80c1e3:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c1ea:	00 00 00 
  80c1ed:	48 8b 00             	mov    (%rax),%rax
  80c1f0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c1f4:	74 62                	je     80c258 <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80c1f6:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c1fd:	00 00 00 
  80c200:	48 8b 00             	mov    (%rax),%rax
  80c203:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c207:	75 11                	jne    80c21a <plug_holes+0x160>
      lfree = mem;
  80c209:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c210:	00 00 00 
  80c213:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c217:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80c21a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c21e:	8b 10                	mov    (%rax),%edx
  80c220:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c224:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80c226:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c22d:	00 00 00 
  80c230:	48 8b 10             	mov    (%rax),%rdx
  80c233:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c237:	8b 00                	mov    (%rax),%eax
  80c239:	89 c0                	mov    %eax,%eax
  80c23b:	48 01 c2             	add    %rax,%rdx
  80c23e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80c242:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c249:	00 00 00 
  80c24c:	48 8b 00             	mov    (%rax),%rax
  80c24f:	48 29 c1             	sub    %rax,%rcx
  80c252:	48 89 c8             	mov    %rcx,%rax
  80c255:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80c258:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c25f:	00 00 00 
  80c262:	48 8b 10             	mov    (%rax),%rdx
  80c265:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c269:	8b 40 04             	mov    0x4(%rax),%eax
  80c26c:	89 c0                	mov    %eax,%eax
  80c26e:	48 01 d0             	add    %rdx,%rax
  80c271:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80c275:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c279:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c27d:	74 6e                	je     80c2ed <plug_holes+0x233>
  80c27f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c283:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c287:	84 c0                	test   %al,%al
  80c289:	75 62                	jne    80c2ed <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80c28b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c292:	00 00 00 
  80c295:	48 8b 00             	mov    (%rax),%rax
  80c298:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c29c:	75 11                	jne    80c2af <plug_holes+0x1f5>
      lfree = pmem;
  80c29e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c2a5:	00 00 00 
  80c2a8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c2ac:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80c2af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2b3:	8b 10                	mov    (%rax),%edx
  80c2b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c2b9:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80c2bb:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2c2:	00 00 00 
  80c2c5:	48 8b 10             	mov    (%rax),%rdx
  80c2c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2cc:	8b 00                	mov    (%rax),%eax
  80c2ce:	89 c0                	mov    %eax,%eax
  80c2d0:	48 01 c2             	add    %rax,%rdx
  80c2d3:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80c2d7:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2de:	00 00 00 
  80c2e1:	48 8b 00             	mov    (%rax),%rax
  80c2e4:	48 29 c1             	sub    %rax,%rcx
  80c2e7:	48 89 c8             	mov    %rcx,%rax
  80c2ea:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80c2ed:	c9                   	leaveq 
  80c2ee:	c3                   	retq   

000000000080c2ef <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80c2ef:	55                   	push   %rbp
  80c2f0:	48 89 e5             	mov    %rsp,%rbp
  80c2f3:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80c2f7:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80c2fe:	00 00 00 
  80c301:	48 83 c0 03          	add    $0x3,%rax
  80c305:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c309:	48 89 c2             	mov    %rax,%rdx
  80c30c:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c313:	00 00 00 
  80c316:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c319:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c320:	00 00 00 
  80c323:	48 8b 00             	mov    (%rax),%rax
  80c326:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c32a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c32e:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c334:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c338:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c33f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c343:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c347:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c34e:	00 00 00 
  80c351:	48 8b 00             	mov    (%rax),%rax
  80c354:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c35b:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c362:	00 00 00 
  80c365:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c368:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c36f:	00 00 00 
  80c372:	48 8b 00             	mov    (%rax),%rax
  80c375:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c379:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c380:	00 00 00 
  80c383:	48 8b 00             	mov    (%rax),%rax
  80c386:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c38c:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c393:	00 00 00 
  80c396:	48 8b 00             	mov    (%rax),%rax
  80c399:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c3a0:	bf 01 00 00 00       	mov    $0x1,%edi
  80c3a5:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  80c3ac:	00 00 00 
  80c3af:	ff d0                	callq  *%rax
  80c3b1:	48 ba 18 95 a4 00 00 	movabs $0xa49518,%rdx
  80c3b8:	00 00 00 
  80c3bb:	89 02                	mov    %eax,(%rdx)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c3bd:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3c4:	00 00 00 
  80c3c7:	48 8b 10             	mov    (%rax),%rdx
  80c3ca:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3d1:	00 00 00 
  80c3d4:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c3d7:	c9                   	leaveq 
  80c3d8:	c3                   	retq   

000000000080c3d9 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c3d9:	55                   	push   %rbp
  80c3da:	48 89 e5             	mov    %rsp,%rbp
  80c3dd:	48 83 ec 20          	sub    $0x20,%rsp
  80c3e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c3e5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c3ea:	75 05                	jne    80c3f1 <mem_free+0x18>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c3ec:	e9 6b 01 00 00       	jmpq   80c55c <mem_free+0x183>
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c3f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3f5:	83 e0 03             	and    $0x3,%eax
  80c3f8:	48 85 c0             	test   %rax,%rax
  80c3fb:	74 2a                	je     80c427 <mem_free+0x4e>
  80c3fd:	48 ba a8 1b 82 00 00 	movabs $0x821ba8,%rdx
  80c404:	00 00 00 
  80c407:	be 30 01 00 00       	mov    $0x130,%esi
  80c40c:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c413:	00 00 00 
  80c416:	b8 00 00 00 00       	mov    $0x0,%eax
  80c41b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c422:	00 00 00 
  80c425:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c427:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c42e:	00 00 00 
  80c431:	48 8b 00             	mov    (%rax),%rax
  80c434:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c438:	72 13                	jb     80c44d <mem_free+0x74>
  80c43a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c441:	00 00 00 
  80c444:	48 8b 00             	mov    (%rax),%rax
  80c447:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c44b:	72 2a                	jb     80c477 <mem_free+0x9e>
  80c44d:	48 ba c9 1b 82 00 00 	movabs $0x821bc9,%rdx
  80c454:	00 00 00 
  80c457:	be 33 01 00 00       	mov    $0x133,%esi
  80c45c:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c463:	00 00 00 
  80c466:	b8 00 00 00 00       	mov    $0x0,%eax
  80c46b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c472:	00 00 00 
  80c475:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c477:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c47e:	00 00 00 
  80c481:	48 8b 00             	mov    (%rax),%rax
  80c484:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c488:	72 13                	jb     80c49d <mem_free+0xc4>
  80c48a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c491:	00 00 00 
  80c494:	48 8b 00             	mov    (%rax),%rax
  80c497:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c49b:	72 05                	jb     80c4a2 <mem_free+0xc9>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c49d:	e9 ba 00 00 00       	jmpq   80c55c <mem_free+0x183>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c4a2:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c4a9:	00 00 00 
  80c4ac:	8b 00                	mov    (%rax),%eax
  80c4ae:	be 00 00 00 00       	mov    $0x0,%esi
  80c4b3:	89 c7                	mov    %eax,%edi
  80c4b5:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  80c4bc:	00 00 00 
  80c4bf:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c4c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c4c5:	48 83 e8 0c          	sub    $0xc,%rax
  80c4c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c4cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4d1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c4d5:	84 c0                	test   %al,%al
  80c4d7:	75 2a                	jne    80c503 <mem_free+0x12a>
  80c4d9:	48 ba e0 1b 82 00 00 	movabs $0x821be0,%rdx
  80c4e0:	00 00 00 
  80c4e3:	be 43 01 00 00       	mov    $0x143,%esi
  80c4e8:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c4ef:	00 00 00 
  80c4f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c4f7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c4fe:	00 00 00 
  80c501:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c503:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c507:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c50b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c512:	00 00 00 
  80c515:	48 8b 00             	mov    (%rax),%rax
  80c518:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c51c:	73 11                	jae    80c52f <mem_free+0x156>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c51e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c525:	00 00 00 
  80c528:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c52c:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c52f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c533:	48 89 c7             	mov    %rax,%rdi
  80c536:	48 b8 ba c0 80 00 00 	movabs $0x80c0ba,%rax
  80c53d:	00 00 00 
  80c540:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c542:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c549:	00 00 00 
  80c54c:	8b 00                	mov    (%rax),%eax
  80c54e:	89 c7                	mov    %eax,%edi
  80c550:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80c557:	00 00 00 
  80c55a:	ff d0                	callq  *%rax
}
  80c55c:	c9                   	leaveq 
  80c55d:	c3                   	retq   

000000000080c55e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c55e:	55                   	push   %rbp
  80c55f:	48 89 e5             	mov    %rsp,%rbp
  80c562:	48 83 ec 30          	sub    $0x30,%rsp
  80c566:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c56a:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c56d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c570:	83 c0 03             	add    $0x3,%eax
  80c573:	83 e0 fc             	and    $0xfffffffc,%eax
  80c576:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c579:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c57d:	77 07                	ja     80c586 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c57f:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c586:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c58d:	76 0a                	jbe    80c599 <mem_realloc+0x3b>
    return NULL;
  80c58f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c594:	e9 da 02 00 00       	jmpq   80c873 <mem_realloc+0x315>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c599:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c5a0:	00 00 00 
  80c5a3:	48 8b 00             	mov    (%rax),%rax
  80c5a6:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c5aa:	72 13                	jb     80c5bf <mem_realloc+0x61>
  80c5ac:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c5b3:	00 00 00 
  80c5b6:	48 8b 00             	mov    (%rax),%rax
  80c5b9:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c5bd:	72 2a                	jb     80c5e9 <mem_realloc+0x8b>
  80c5bf:	48 ba f4 1b 82 00 00 	movabs $0x821bf4,%rdx
  80c5c6:	00 00 00 
  80c5c9:	be 79 01 00 00       	mov    $0x179,%esi
  80c5ce:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c5d5:	00 00 00 
  80c5d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5dd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c5e4:	00 00 00 
  80c5e7:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c5e9:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c5f0:	00 00 00 
  80c5f3:	48 8b 00             	mov    (%rax),%rax
  80c5f6:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c5fa:	72 13                	jb     80c60f <mem_realloc+0xb1>
  80c5fc:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c603:	00 00 00 
  80c606:	48 8b 00             	mov    (%rax),%rax
  80c609:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c60d:	72 09                	jb     80c618 <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c60f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c613:	e9 5b 02 00 00       	jmpq   80c873 <mem_realloc+0x315>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c618:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c61c:	48 83 e8 0c          	sub    $0xc,%rax
  80c620:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c624:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c628:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c62f:	00 00 00 
  80c632:	48 8b 00             	mov    (%rax),%rax
  80c635:	48 29 c2             	sub    %rax,%rdx
  80c638:	48 89 d0             	mov    %rdx,%rax
  80c63b:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c63e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c642:	8b 00                	mov    (%rax),%eax
  80c644:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c647:	83 e8 0c             	sub    $0xc,%eax
  80c64a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c64d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c650:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c653:	76 2a                	jbe    80c67f <mem_realloc+0x121>
  80c655:	48 ba 10 1c 82 00 00 	movabs $0x821c10,%rdx
  80c65c:	00 00 00 
  80c65f:	be 8a 01 00 00       	mov    $0x18a,%esi
  80c664:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80c66b:	00 00 00 
  80c66e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c673:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80c67a:	00 00 00 
  80c67d:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c67f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c682:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c685:	76 0a                	jbe    80c691 <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80c687:	b8 00 00 00 00       	mov    $0x0,%eax
  80c68c:	e9 e2 01 00 00       	jmpq   80c873 <mem_realloc+0x315>
  }
  if (newsize == size) {
  80c691:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c694:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c697:	75 09                	jne    80c6a2 <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80c699:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c69d:	e9 d1 01 00 00       	jmpq   80c873 <mem_realloc+0x315>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c6a2:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c6a9:	00 00 00 
  80c6ac:	8b 00                	mov    (%rax),%eax
  80c6ae:	be 00 00 00 00       	mov    $0x0,%esi
  80c6b3:	89 c7                	mov    %eax,%edi
  80c6b5:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  80c6bc:	00 00 00 
  80c6bf:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c6c1:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6c8:	00 00 00 
  80c6cb:	48 8b 10             	mov    (%rax),%rdx
  80c6ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c6d2:	8b 00                	mov    (%rax),%eax
  80c6d4:	89 c0                	mov    %eax,%eax
  80c6d6:	48 01 d0             	add    %rdx,%rax
  80c6d9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c6dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c6e1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c6e5:	84 c0                	test   %al,%al
  80c6e7:	0f 85 ba 00 00 00    	jne    80c7a7 <mem_realloc+0x249>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c6ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c6f1:	8b 00                	mov    (%rax),%eax
  80c6f3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c6f6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c6f9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c6fc:	01 d0                	add    %edx,%eax
  80c6fe:	83 c0 0c             	add    $0xc,%eax
  80c701:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c704:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c70b:	00 00 00 
  80c70e:	48 8b 00             	mov    (%rax),%rax
  80c711:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c715:	75 20                	jne    80c737 <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80c717:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c71e:	00 00 00 
  80c721:	48 8b 10             	mov    (%rax),%rdx
  80c724:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c727:	48 01 c2             	add    %rax,%rdx
  80c72a:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c731:	00 00 00 
  80c734:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c737:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c73e:	00 00 00 
  80c741:	48 8b 10             	mov    (%rax),%rdx
  80c744:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c747:	48 01 d0             	add    %rdx,%rax
  80c74a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c74e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c752:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c756:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c75a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c75d:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c75f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c763:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c766:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c769:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c76d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c770:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c776:	8b 00                	mov    (%rax),%eax
  80c778:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c77d:	74 23                	je     80c7a2 <mem_realloc+0x244>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c77f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c786:	00 00 00 
  80c789:	48 8b 10             	mov    (%rax),%rdx
  80c78c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c790:	8b 00                	mov    (%rax),%eax
  80c792:	89 c0                	mov    %eax,%eax
  80c794:	48 01 c2             	add    %rax,%rdx
  80c797:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c79a:	89 42 04             	mov    %eax,0x4(%rdx)
  80c79d:	e9 b3 00 00 00       	jmpq   80c855 <mem_realloc+0x2f7>
  80c7a2:	e9 ae 00 00 00       	jmpq   80c855 <mem_realloc+0x2f7>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c7a7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7aa:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c7ae:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c7b1:	48 39 c2             	cmp    %rax,%rdx
  80c7b4:	0f 87 9b 00 00 00    	ja     80c855 <mem_realloc+0x2f7>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c7ba:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7bd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c7c0:	01 d0                	add    %edx,%eax
  80c7c2:	83 c0 0c             	add    $0xc,%eax
  80c7c5:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c7c8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c7cf:	00 00 00 
  80c7d2:	48 8b 10             	mov    (%rax),%rdx
  80c7d5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c7d8:	48 01 d0             	add    %rdx,%rax
  80c7db:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c7df:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c7e6:	00 00 00 
  80c7e9:	48 8b 00             	mov    (%rax),%rax
  80c7ec:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c7f0:	73 11                	jae    80c803 <mem_realloc+0x2a5>
      lfree = mem2;
  80c7f2:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c7f9:	00 00 00 
  80c7fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c800:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c803:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c807:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c80b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c80f:	8b 10                	mov    (%rax),%edx
  80c811:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c815:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c817:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c81b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c81e:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c825:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c828:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c82a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c82e:	8b 00                	mov    (%rax),%eax
  80c830:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c835:	74 1e                	je     80c855 <mem_realloc+0x2f7>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c837:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c83e:	00 00 00 
  80c841:	48 8b 10             	mov    (%rax),%rdx
  80c844:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c848:	8b 00                	mov    (%rax),%eax
  80c84a:	89 c0                	mov    %eax,%eax
  80c84c:	48 01 c2             	add    %rax,%rdx
  80c84f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c852:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c855:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c85c:	00 00 00 
  80c85f:	8b 00                	mov    (%rax),%eax
  80c861:	89 c7                	mov    %eax,%edi
  80c863:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80c86a:	00 00 00 
  80c86d:	ff d0                	callq  *%rax
  return rmem;
  80c86f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c873:	c9                   	leaveq 
  80c874:	c3                   	retq   

000000000080c875 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c875:	55                   	push   %rbp
  80c876:	48 89 e5             	mov    %rsp,%rbp
  80c879:	48 83 ec 30          	sub    $0x30,%rsp
  80c87d:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c880:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c884:	75 0a                	jne    80c890 <mem_malloc+0x1b>
    return NULL;
  80c886:	b8 00 00 00 00       	mov    $0x0,%eax
  80c88b:	e9 6b 03 00 00       	jmpq   80cbfb <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c890:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c893:	83 c0 03             	add    $0x3,%eax
  80c896:	83 e0 fc             	and    $0xfffffffc,%eax
  80c899:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c89c:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c8a0:	77 07                	ja     80c8a9 <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c8a2:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c8a9:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c8b0:	76 0a                	jbe    80c8bc <mem_malloc+0x47>
    return NULL;
  80c8b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8b7:	e9 3f 03 00 00       	jmpq   80cbfb <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c8bc:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c8c3:	00 00 00 
  80c8c6:	8b 00                	mov    (%rax),%eax
  80c8c8:	be 00 00 00 00       	mov    $0x0,%esi
  80c8cd:	89 c7                	mov    %eax,%edi
  80c8cf:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  80c8d6:	00 00 00 
  80c8d9:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c8db:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c8e2:	00 00 00 
  80c8e5:	48 8b 00             	mov    (%rax),%rax
  80c8e8:	48 89 c2             	mov    %rax,%rdx
  80c8eb:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8f2:	00 00 00 
  80c8f5:	48 8b 00             	mov    (%rax),%rax
  80c8f8:	48 29 c2             	sub    %rax,%rdx
  80c8fb:	48 89 d0             	mov    %rdx,%rax
  80c8fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80c901:	e9 c5 02 00 00       	jmpq   80cbcb <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80c906:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c90d:	00 00 00 
  80c910:	48 8b 10             	mov    (%rax),%rdx
  80c913:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c916:	48 01 d0             	add    %rdx,%rax
  80c919:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c91d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c921:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c925:	84 c0                	test   %al,%al
  80c927:	0f 85 86 02 00 00    	jne    80cbb3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80c92d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c931:	8b 00                	mov    (%rax),%eax
  80c933:	89 c2                	mov    %eax,%edx
  80c935:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c938:	48 29 c2             	sub    %rax,%rdx
  80c93b:	48 89 d0             	mov    %rdx,%rax
  80c93e:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c942:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c945:	48 39 c2             	cmp    %rax,%rdx
  80c948:	0f 82 65 02 00 00    	jb     80cbb3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80c94e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c952:	8b 00                	mov    (%rax),%eax
  80c954:	89 c2                	mov    %eax,%edx
  80c956:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c959:	48 29 c2             	sub    %rax,%rdx
  80c95c:	48 89 d0             	mov    %rdx,%rax
  80c95f:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c963:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c966:	48 83 c0 18          	add    $0x18,%rax
  80c96a:	48 39 c2             	cmp    %rax,%rdx
  80c96d:	0f 82 81 00 00 00    	jb     80c9f4 <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80c973:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c976:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c979:	01 d0                	add    %edx,%eax
  80c97b:	83 c0 0c             	add    $0xc,%eax
  80c97e:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80c981:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c988:	00 00 00 
  80c98b:	48 8b 10             	mov    (%rax),%rdx
  80c98e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c991:	48 01 d0             	add    %rdx,%rax
  80c994:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80c998:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c99c:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80c9a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c9a4:	8b 10                	mov    (%rax),%edx
  80c9a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c9aa:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80c9ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c9b0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c9b3:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80c9b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c9ba:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c9bd:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80c9bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c9c3:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80c9c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c9cb:	8b 00                	mov    (%rax),%eax
  80c9cd:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c9d2:	74 28                	je     80c9fc <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c9d4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c9db:	00 00 00 
  80c9de:	48 8b 10             	mov    (%rax),%rdx
  80c9e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c9e5:	8b 00                	mov    (%rax),%eax
  80c9e7:	89 c0                	mov    %eax,%eax
  80c9e9:	48 01 c2             	add    %rax,%rdx
  80c9ec:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c9ef:	89 42 04             	mov    %eax,0x4(%rdx)
  80c9f2:	eb 08                	jmp    80c9fc <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80c9f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c9f8:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80c9fc:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca03:	00 00 00 
  80ca06:	48 8b 00             	mov    (%rax),%rax
  80ca09:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80ca0d:	0f 85 c2 00 00 00    	jne    80cad5 <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80ca13:	eb 2e                	jmp    80ca43 <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80ca15:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca1c:	00 00 00 
  80ca1f:	48 8b 10             	mov    (%rax),%rdx
  80ca22:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca29:	00 00 00 
  80ca2c:	48 8b 00             	mov    (%rax),%rax
  80ca2f:	8b 00                	mov    (%rax),%eax
  80ca31:	89 c0                	mov    %eax,%eax
  80ca33:	48 01 c2             	add    %rax,%rdx
  80ca36:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca3d:	00 00 00 
  80ca40:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80ca43:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca4a:	00 00 00 
  80ca4d:	48 8b 00             	mov    (%rax),%rax
  80ca50:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80ca54:	84 c0                	test   %al,%al
  80ca56:	74 1f                	je     80ca77 <mem_malloc+0x202>
  80ca58:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca5f:	00 00 00 
  80ca62:	48 8b 10             	mov    (%rax),%rdx
  80ca65:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80ca6c:	00 00 00 
  80ca6f:	48 8b 00             	mov    (%rax),%rax
  80ca72:	48 39 c2             	cmp    %rax,%rdx
  80ca75:	75 9e                	jne    80ca15 <mem_malloc+0x1a0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80ca77:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca7e:	00 00 00 
  80ca81:	48 8b 10             	mov    (%rax),%rdx
  80ca84:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80ca8b:	00 00 00 
  80ca8e:	48 8b 00             	mov    (%rax),%rax
  80ca91:	48 39 c2             	cmp    %rax,%rdx
  80ca94:	74 3f                	je     80cad5 <mem_malloc+0x260>
  80ca96:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca9d:	00 00 00 
  80caa0:	48 8b 00             	mov    (%rax),%rax
  80caa3:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80caa7:	84 c0                	test   %al,%al
  80caa9:	74 2a                	je     80cad5 <mem_malloc+0x260>
  80caab:	48 ba 33 1c 82 00 00 	movabs $0x821c33,%rdx
  80cab2:	00 00 00 
  80cab5:	be 46 02 00 00       	mov    $0x246,%esi
  80caba:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80cac1:	00 00 00 
  80cac4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cac9:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cad0:	00 00 00 
  80cad3:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80cad5:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cadc:	00 00 00 
  80cadf:	8b 00                	mov    (%rax),%eax
  80cae1:	89 c7                	mov    %eax,%edi
  80cae3:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80caea:	00 00 00 
  80caed:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80caef:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80caf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80caf6:	48 01 d0             	add    %rdx,%rax
  80caf9:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80cafd:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cb04:	00 00 00 
  80cb07:	48 8b 00             	mov    (%rax),%rax
  80cb0a:	48 39 c2             	cmp    %rax,%rdx
  80cb0d:	76 2a                	jbe    80cb39 <mem_malloc+0x2c4>
  80cb0f:	48 ba 50 1c 82 00 00 	movabs $0x821c50,%rdx
  80cb16:	00 00 00 
  80cb19:	be 4b 02 00 00       	mov    $0x24b,%esi
  80cb1e:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80cb25:	00 00 00 
  80cb28:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb2d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cb34:	00 00 00 
  80cb37:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80cb39:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb3d:	48 83 c0 0c          	add    $0xc,%rax
  80cb41:	83 e0 03             	and    $0x3,%eax
  80cb44:	48 85 c0             	test   %rax,%rax
  80cb47:	74 2a                	je     80cb73 <mem_malloc+0x2fe>
  80cb49:	48 ba 80 1c 82 00 00 	movabs $0x821c80,%rdx
  80cb50:	00 00 00 
  80cb53:	be 4d 02 00 00       	mov    $0x24d,%esi
  80cb58:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80cb5f:	00 00 00 
  80cb62:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb67:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cb6e:	00 00 00 
  80cb71:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80cb73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb77:	83 e0 03             	and    $0x3,%eax
  80cb7a:	48 85 c0             	test   %rax,%rax
  80cb7d:	74 2a                	je     80cba9 <mem_malloc+0x334>
  80cb7f:	48 ba b0 1c 82 00 00 	movabs $0x821cb0,%rdx
  80cb86:	00 00 00 
  80cb89:	be 4f 02 00 00       	mov    $0x24f,%esi
  80cb8e:	48 bf 2f 1b 82 00 00 	movabs $0x821b2f,%rdi
  80cb95:	00 00 00 
  80cb98:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb9d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cba4:	00 00 00 
  80cba7:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80cba9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cbad:	48 83 c0 0c          	add    $0xc,%rax
  80cbb1:	eb 48                	jmp    80cbfb <mem_malloc+0x386>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80cbb3:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cbba:	00 00 00 
  80cbbd:	48 8b 10             	mov    (%rax),%rdx
  80cbc0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cbc3:	48 01 d0             	add    %rdx,%rax
  80cbc6:	8b 00                	mov    (%rax),%eax
  80cbc8:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80cbcb:	b8 00 00 22 00       	mov    $0x220000,%eax
  80cbd0:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80cbd3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80cbd6:	0f 87 2a fd ff ff    	ja     80c906 <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80cbdc:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cbe3:	00 00 00 
  80cbe6:	8b 00                	mov    (%rax),%eax
  80cbe8:	89 c7                	mov    %eax,%edi
  80cbea:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80cbf1:	00 00 00 
  80cbf4:	ff d0                	callq  *%rax
  return NULL;
  80cbf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cbfb:	c9                   	leaveq 
  80cbfc:	c3                   	retq   

000000000080cbfd <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80cbfd:	55                   	push   %rbp
  80cbfe:	48 89 e5             	mov    %rsp,%rbp
  80cc01:	48 83 ec 20          	sub    $0x20,%rsp
  80cc05:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cc08:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80cc0b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cc0e:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cc12:	89 c7                	mov    %eax,%edi
  80cc14:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  80cc1b:	00 00 00 
  80cc1e:	ff d0                	callq  *%rax
  80cc20:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80cc24:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cc29:	74 21                	je     80cc4c <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80cc2b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cc2e:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cc32:	89 c2                	mov    %eax,%edx
  80cc34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc38:	be 00 00 00 00       	mov    $0x0,%esi
  80cc3d:	48 89 c7             	mov    %rax,%rdi
  80cc40:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  80cc47:	00 00 00 
  80cc4a:	ff d0                	callq  *%rax
  }
  return p;
  80cc4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cc50:	c9                   	leaveq 
  80cc51:	c3                   	retq   

000000000080cc52 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80cc52:	55                   	push   %rbp
  80cc53:	48 89 e5             	mov    %rsp,%rbp
  80cc56:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80cc5a:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cc60:	eb 05                	jmp    80cc67 <memp_init+0x15>
  80cc62:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cc67:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cc6c:	76 f4                	jbe    80cc62 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80cc6e:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80cc75:	00 00 00 
  80cc78:	48 83 c0 03          	add    $0x3,%rax
  80cc7c:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80cc80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cc84:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cc8a:	e9 97 00 00 00       	jmpq   80cd26 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80cc8f:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cc93:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cc9a:	00 00 00 
  80cc9d:	48 63 d2             	movslq %edx,%rdx
  80cca0:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80cca7:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80cca8:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80ccae:	eb 56                	jmp    80cd06 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80ccb0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ccb4:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ccbb:	00 00 00 
  80ccbe:	48 63 d2             	movslq %edx,%rdx
  80ccc1:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80ccc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccc9:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80cccc:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ccd0:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ccd7:	00 00 00 
  80ccda:	48 63 d2             	movslq %edx,%rdx
  80ccdd:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cce1:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80cce5:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cce9:	48 b8 e0 1c 82 00 00 	movabs $0x821ce0,%rax
  80ccf0:	00 00 00 
  80ccf3:	48 63 d2             	movslq %edx,%rdx
  80ccf6:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ccfa:	0f b7 c0             	movzwl %ax,%eax
  80ccfd:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80cd01:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80cd06:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cd0a:	48 b8 00 1d 82 00 00 	movabs $0x821d00,%rax
  80cd11:	00 00 00 
  80cd14:	48 63 d2             	movslq %edx,%rdx
  80cd17:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80cd1b:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80cd1f:	77 8f                	ja     80ccb0 <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cd21:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cd26:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cd2b:	0f 86 5e ff ff ff    	jbe    80cc8f <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80cd31:	c9                   	leaveq 
  80cd32:	c3                   	retq   

000000000080cd33 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80cd33:	55                   	push   %rbp
  80cd34:	48 89 e5             	mov    %rsp,%rbp
  80cd37:	48 83 ec 20          	sub    $0x20,%rsp
  80cd3b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80cd3e:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80cd42:	76 2a                	jbe    80cd6e <memp_malloc+0x3b>
  80cd44:	48 ba af 1d 82 00 00 	movabs $0x821daf,%rdx
  80cd4b:	00 00 00 
  80cd4e:	be 2d 01 00 00       	mov    $0x12d,%esi
  80cd53:	48 bf cc 1d 82 00 00 	movabs $0x821dcc,%rdi
  80cd5a:	00 00 00 
  80cd5d:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd62:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cd69:	00 00 00 
  80cd6c:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80cd6e:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cd75:	00 00 00 
  80cd78:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cd7b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80cd7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80cd83:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cd88:	74 4e                	je     80cdd8 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80cd8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd8e:	48 8b 08             	mov    (%rax),%rcx
  80cd91:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cd98:	00 00 00 
  80cd9b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cd9e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cda2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cda6:	83 e0 03             	and    $0x3,%eax
  80cda9:	48 85 c0             	test   %rax,%rax
  80cdac:	74 2a                	je     80cdd8 <memp_malloc+0xa5>
  80cdae:	48 ba e8 1d 82 00 00 	movabs $0x821de8,%rdx
  80cdb5:	00 00 00 
  80cdb8:	be 3f 01 00 00       	mov    $0x13f,%esi
  80cdbd:	48 bf cc 1d 82 00 00 	movabs $0x821dcc,%rdi
  80cdc4:	00 00 00 
  80cdc7:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdcc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80cdd3:	00 00 00 
  80cdd6:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cdd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cddc:	c9                   	leaveq 
  80cddd:	c3                   	retq   

000000000080cdde <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80cdde:	55                   	push   %rbp
  80cddf:	48 89 e5             	mov    %rsp,%rbp
  80cde2:	48 83 ec 20          	sub    $0x20,%rsp
  80cde6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cde9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cded:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cdf2:	75 02                	jne    80cdf6 <memp_free+0x18>
    return;
  80cdf4:	eb 6b                	jmp    80ce61 <memp_free+0x83>
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cdf6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cdfa:	83 e0 03             	and    $0x3,%eax
  80cdfd:	48 85 c0             	test   %rax,%rax
  80ce00:	74 2a                	je     80ce2c <memp_free+0x4e>
  80ce02:	48 ba 10 1e 82 00 00 	movabs $0x821e10,%rdx
  80ce09:	00 00 00 
  80ce0c:	be 5b 01 00 00       	mov    $0x15b,%esi
  80ce11:	48 bf cc 1d 82 00 00 	movabs $0x821dcc,%rdi
  80ce18:	00 00 00 
  80ce1b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce20:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80ce27:	00 00 00 
  80ce2a:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80ce2c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ce30:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80ce34:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce3b:	00 00 00 
  80ce3e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ce41:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80ce45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce49:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80ce4c:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce53:	00 00 00 
  80ce56:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ce59:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80ce5d:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80ce61:	c9                   	leaveq 
  80ce62:	c3                   	retq   

000000000080ce63 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80ce63:	55                   	push   %rbp
  80ce64:	48 89 e5             	mov    %rsp,%rbp
  80ce67:	48 83 ec 30          	sub    $0x30,%rsp
  80ce6b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ce6f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80ce73:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80ce77:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80ce7b:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80ce7f:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80ce83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce87:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80ce8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce92:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80ce99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce9d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80cea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cea8:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80ceac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceb0:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80ceb7:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80ceb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cebc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cec0:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80cec4:	48 b8 4b b0 b4 00 00 	movabs $0xb4b04b,%rax
  80cecb:	00 00 00 
  80cece:	0f b6 00             	movzbl (%rax),%eax
  80ced1:	8d 48 01             	lea    0x1(%rax),%ecx
  80ced4:	48 ba 4b b0 b4 00 00 	movabs $0xb4b04b,%rdx
  80cedb:	00 00 00 
  80cede:	88 0a                	mov    %cl,(%rdx)
  80cee0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cee4:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80cee7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceeb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80ceef:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80cef3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80cef7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cefb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80ceff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf03:	48 89 c7             	mov    %rax,%rdi
  80cf06:	48 b8 55 cf 80 00 00 	movabs $0x80cf55,%rax
  80cf0d:	00 00 00 
  80cf10:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80cf12:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cf16:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cf1a:	48 89 d7             	mov    %rdx,%rdi
  80cf1d:	ff d0                	callq  *%rax
  80cf1f:	84 c0                	test   %al,%al
  80cf21:	74 07                	je     80cf2a <netif_add+0xc7>
    return NULL;
  80cf23:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf28:	eb 29                	jmp    80cf53 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80cf2a:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cf31:	00 00 00 
  80cf34:	48 8b 10             	mov    (%rax),%rdx
  80cf37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf3b:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80cf3e:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cf45:	00 00 00 
  80cf48:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cf4c:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80cf4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cf53:	c9                   	leaveq 
  80cf54:	c3                   	retq   

000000000080cf55 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80cf55:	55                   	push   %rbp
  80cf56:	48 89 e5             	mov    %rsp,%rbp
  80cf59:	48 83 ec 20          	sub    $0x20,%rsp
  80cf5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cf61:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cf65:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cf69:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80cf6d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80cf71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf75:	48 89 d6             	mov    %rdx,%rsi
  80cf78:	48 89 c7             	mov    %rax,%rdi
  80cf7b:	48 b8 03 d1 80 00 00 	movabs $0x80d103,%rax
  80cf82:	00 00 00 
  80cf85:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80cf87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cf8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf8f:	48 89 d6             	mov    %rdx,%rsi
  80cf92:	48 89 c7             	mov    %rax,%rdi
  80cf95:	48 b8 36 d2 80 00 00 	movabs $0x80d236,%rax
  80cf9c:	00 00 00 
  80cf9f:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80cfa1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80cfa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfa9:	48 89 d6             	mov    %rdx,%rsi
  80cfac:	48 89 c7             	mov    %rax,%rdi
  80cfaf:	48 b8 09 d2 80 00 00 	movabs $0x80d209,%rax
  80cfb6:	00 00 00 
  80cfb9:	ff d0                	callq  *%rax
}
  80cfbb:	c9                   	leaveq 
  80cfbc:	c3                   	retq   

000000000080cfbd <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80cfbd:	55                   	push   %rbp
  80cfbe:	48 89 e5             	mov    %rsp,%rbp
  80cfc1:	48 83 ec 20          	sub    $0x20,%rsp
  80cfc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80cfc9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cfce:	75 05                	jne    80cfd5 <netif_remove+0x18>
  80cfd0:	e9 98 00 00 00       	jmpq   80d06d <netif_remove+0xb0>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80cfd5:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cfdc:	00 00 00 
  80cfdf:	48 8b 00             	mov    (%rax),%rax
  80cfe2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cfe6:	75 16                	jne    80cffe <netif_remove+0x41>
    netif_list = netif->next;
  80cfe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cfec:	48 8b 10             	mov    (%rax),%rdx
  80cfef:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cff6:	00 00 00 
  80cff9:	48 89 10             	mov    %rdx,(%rax)
  80cffc:	eb 4b                	jmp    80d049 <netif_remove+0x8c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cffe:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d005:	00 00 00 
  80d008:	48 8b 00             	mov    (%rax),%rax
  80d00b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d00f:	eb 28                	jmp    80d039 <netif_remove+0x7c>
      if (tmpNetif->next == netif) {
  80d011:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d015:	48 8b 00             	mov    (%rax),%rax
  80d018:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d01c:	75 10                	jne    80d02e <netif_remove+0x71>
        tmpNetif->next = netif->next;
  80d01e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d022:	48 8b 10             	mov    (%rax),%rdx
  80d025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d029:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80d02c:	eb 12                	jmp    80d040 <netif_remove+0x83>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d02e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d032:	48 8b 00             	mov    (%rax),%rax
  80d035:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d039:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d03e:	75 d1                	jne    80d011 <netif_remove+0x54>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80d040:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d045:	75 02                	jne    80d049 <netif_remove+0x8c>
      return; /*  we didn't find any netif today */
  80d047:	eb 24                	jmp    80d06d <netif_remove+0xb0>
  }
  /* this netif is default? */
  if (netif_default == netif)
  80d049:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d050:	00 00 00 
  80d053:	48 8b 00             	mov    (%rax),%rax
  80d056:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d05a:	75 11                	jne    80d06d <netif_remove+0xb0>
    /* reset default netif */
    netif_set_default(NULL);
  80d05c:	bf 00 00 00 00       	mov    $0x0,%edi
  80d061:	48 b8 63 d2 80 00 00 	movabs $0x80d263,%rax
  80d068:	00 00 00 
  80d06b:	ff d0                	callq  *%rax
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80d06d:	c9                   	leaveq 
  80d06e:	c3                   	retq   

000000000080d06f <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80d06f:	55                   	push   %rbp
  80d070:	48 89 e5             	mov    %rsp,%rbp
  80d073:	48 83 ec 18          	sub    $0x18,%rsp
  80d077:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80d07b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d080:	75 07                	jne    80d089 <netif_find+0x1a>
    return NULL;
  80d082:	b8 00 00 00 00       	mov    $0x0,%eax
  80d087:	eb 78                	jmp    80d101 <netif_find+0x92>
  }

  num = name[2] - '0';
  80d089:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d08d:	48 83 c0 02          	add    $0x2,%rax
  80d091:	0f b6 00             	movzbl (%rax),%eax
  80d094:	83 e8 30             	sub    $0x30,%eax
  80d097:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d09a:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d0a1:	00 00 00 
  80d0a4:	48 8b 00             	mov    (%rax),%rax
  80d0a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d0ab:	eb 48                	jmp    80d0f5 <netif_find+0x86>
    if (num == netif->num &&
  80d0ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0b1:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80d0b5:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80d0b8:	75 30                	jne    80d0ea <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80d0ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0be:	0f b6 10             	movzbl (%rax),%edx
  80d0c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0c5:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80d0c9:	38 c2                	cmp    %al,%dl
  80d0cb:	75 1d                	jne    80d0ea <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80d0cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d0d1:	48 83 c0 01          	add    $0x1,%rax
  80d0d5:	0f b6 10             	movzbl (%rax),%edx
  80d0d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0dc:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80d0e0:	38 c2                	cmp    %al,%dl
  80d0e2:	75 06                	jne    80d0ea <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80d0e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0e8:	eb 17                	jmp    80d101 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d0ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0ee:	48 8b 00             	mov    (%rax),%rax
  80d0f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d0f5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d0fa:	75 b1                	jne    80d0ad <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80d0fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d101:	c9                   	leaveq 
  80d102:	c3                   	retq   

000000000080d103 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80d103:	55                   	push   %rbp
  80d104:	48 89 e5             	mov    %rsp,%rbp
  80d107:	48 83 ec 30          	sub    $0x30,%rsp
  80d10b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80d10f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80d113:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d117:	8b 10                	mov    (%rax),%edx
  80d119:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d11d:	8b 40 08             	mov    0x8(%rax),%eax
  80d120:	39 c2                	cmp    %eax,%edx
  80d122:	0f 84 c4 00 00 00    	je     80d1ec <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80d128:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80d12f:	00 00 00 
  80d132:	48 8b 00             	mov    (%rax),%rax
  80d135:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80d139:	eb 46                	jmp    80d181 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80d13b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d13f:	8b 10                	mov    (%rax),%edx
  80d141:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d145:	8b 40 08             	mov    0x8(%rax),%eax
  80d148:	39 c2                	cmp    %eax,%edx
  80d14a:	75 29                	jne    80d175 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80d14c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d150:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d154:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80d158:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d15c:	48 89 c7             	mov    %rax,%rdi
  80d15f:	48 b8 de ed 80 00 00 	movabs $0x80edde,%rax
  80d166:	00 00 00 
  80d169:	ff d0                	callq  *%rax
        pcb = next;
  80d16b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d16f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d173:	eb 0c                	jmp    80d181 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80d175:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d179:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d17d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80d181:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d186:	75 b3                	jne    80d13b <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d188:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80d18f:	00 00 00 
  80d192:	48 8b 00             	mov    (%rax),%rax
  80d195:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d199:	eb 4a                	jmp    80d1e5 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d19b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d19f:	48 85 c0             	test   %rax,%rax
  80d1a2:	74 35                	je     80d1d9 <netif_set_ipaddr+0xd6>
  80d1a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d1a8:	8b 00                	mov    (%rax),%eax
  80d1aa:	85 c0                	test   %eax,%eax
  80d1ac:	74 2b                	je     80d1d9 <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80d1ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d1b2:	8b 10                	mov    (%rax),%edx
  80d1b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d1b8:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d1bb:	39 c2                	cmp    %eax,%edx
  80d1bd:	75 1a                	jne    80d1d9 <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80d1bf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d1c4:	74 08                	je     80d1ce <netif_set_ipaddr+0xcb>
  80d1c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d1ca:	8b 00                	mov    (%rax),%eax
  80d1cc:	eb 05                	jmp    80d1d3 <netif_set_ipaddr+0xd0>
  80d1ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1d3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d1d7:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d1d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d1dd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d1e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d1e5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d1ea:	75 af                	jne    80d19b <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80d1ec:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d1f1:	74 08                	je     80d1fb <netif_set_ipaddr+0xf8>
  80d1f3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d1f7:	8b 00                	mov    (%rax),%eax
  80d1f9:	eb 05                	jmp    80d200 <netif_set_ipaddr+0xfd>
  80d1fb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d200:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80d204:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80d207:	c9                   	leaveq 
  80d208:	c3                   	retq   

000000000080d209 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80d209:	55                   	push   %rbp
  80d20a:	48 89 e5             	mov    %rsp,%rbp
  80d20d:	48 83 ec 10          	sub    $0x10,%rsp
  80d211:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d215:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80d219:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d21e:	74 08                	je     80d228 <netif_set_gw+0x1f>
  80d220:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d224:	8b 00                	mov    (%rax),%eax
  80d226:	eb 05                	jmp    80d22d <netif_set_gw+0x24>
  80d228:	b8 00 00 00 00       	mov    $0x0,%eax
  80d22d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d231:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80d234:	c9                   	leaveq 
  80d235:	c3                   	retq   

000000000080d236 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80d236:	55                   	push   %rbp
  80d237:	48 89 e5             	mov    %rsp,%rbp
  80d23a:	48 83 ec 10          	sub    $0x10,%rsp
  80d23e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d242:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80d246:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d24b:	74 08                	je     80d255 <netif_set_netmask+0x1f>
  80d24d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d251:	8b 00                	mov    (%rax),%eax
  80d253:	eb 05                	jmp    80d25a <netif_set_netmask+0x24>
  80d255:	b8 00 00 00 00       	mov    $0x0,%eax
  80d25a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d25e:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80d261:	c9                   	leaveq 
  80d262:	c3                   	retq   

000000000080d263 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80d263:	55                   	push   %rbp
  80d264:	48 89 e5             	mov    %rsp,%rbp
  80d267:	48 83 ec 08          	sub    $0x8,%rsp
  80d26b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80d26f:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d276:	00 00 00 
  80d279:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d27d:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80d280:	c9                   	leaveq 
  80d281:	c3                   	retq   

000000000080d282 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80d282:	55                   	push   %rbp
  80d283:	48 89 e5             	mov    %rsp,%rbp
  80d286:	48 83 ec 10          	sub    $0x10,%rsp
  80d28a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80d28e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d292:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d296:	0f b6 c0             	movzbl %al,%eax
  80d299:	83 e0 01             	and    $0x1,%eax
  80d29c:	85 c0                	test   %eax,%eax
  80d29e:	75 49                	jne    80d2e9 <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80d2a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2a4:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d2a8:	83 c8 01             	or     $0x1,%eax
  80d2ab:	89 c2                	mov    %eax,%edx
  80d2ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2b1:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80d2b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2b8:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d2bc:	0f b6 c0             	movzbl %al,%eax
  80d2bf:	83 e0 20             	and    $0x20,%eax
  80d2c2:	85 c0                	test   %eax,%eax
  80d2c4:	74 23                	je     80d2e9 <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80d2c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2ca:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80d2ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2d2:	ba 00 00 00 00       	mov    $0x0,%edx
  80d2d7:	48 89 ce             	mov    %rcx,%rsi
  80d2da:	48 89 c7             	mov    %rax,%rdi
  80d2dd:	48 b8 c6 6a 81 00 00 	movabs $0x816ac6,%rax
  80d2e4:	00 00 00 
  80d2e7:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80d2e9:	c9                   	leaveq 
  80d2ea:	c3                   	retq   

000000000080d2eb <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80d2eb:	55                   	push   %rbp
  80d2ec:	48 89 e5             	mov    %rsp,%rbp
  80d2ef:	48 83 ec 08          	sub    $0x8,%rsp
  80d2f3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d2f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2fb:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d2ff:	0f b6 c0             	movzbl %al,%eax
  80d302:	83 e0 01             	and    $0x1,%eax
  80d305:	85 c0                	test   %eax,%eax
  80d307:	74 14                	je     80d31d <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d30d:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d311:	83 e0 fe             	and    $0xfffffffe,%eax
  80d314:	89 c2                	mov    %eax,%edx
  80d316:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d31a:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d31d:	c9                   	leaveq 
  80d31e:	c3                   	retq   

000000000080d31f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d31f:	55                   	push   %rbp
  80d320:	48 89 e5             	mov    %rsp,%rbp
  80d323:	48 83 ec 08          	sub    $0x8,%rsp
  80d327:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d32b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d32f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d333:	0f b6 c0             	movzbl %al,%eax
  80d336:	83 e0 01             	and    $0x1,%eax
  80d339:	85 c0                	test   %eax,%eax
  80d33b:	0f 95 c0             	setne  %al
}
  80d33e:	c9                   	leaveq 
  80d33f:	c3                   	retq   

000000000080d340 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d340:	55                   	push   %rbp
  80d341:	48 89 e5             	mov    %rsp,%rbp
  80d344:	48 83 ec 30          	sub    $0x30,%rsp
  80d348:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d34b:	89 f0                	mov    %esi,%eax
  80d34d:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d350:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d354:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d35a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d35d:	83 f8 01             	cmp    $0x1,%eax
  80d360:	74 16                	je     80d378 <pbuf_alloc+0x38>
  80d362:	83 f8 01             	cmp    $0x1,%eax
  80d365:	72 0c                	jb     80d373 <pbuf_alloc+0x33>
  80d367:	83 f8 02             	cmp    $0x2,%eax
  80d36a:	74 11                	je     80d37d <pbuf_alloc+0x3d>
  80d36c:	83 f8 03             	cmp    $0x3,%eax
  80d36f:	74 3d                	je     80d3ae <pbuf_alloc+0x6e>
  80d371:	eb 11                	jmp    80d384 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d373:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d378:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d37d:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d382:	eb 2b                	jmp    80d3af <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d384:	48 ba 30 1e 82 00 00 	movabs $0x821e30,%rdx
  80d38b:	00 00 00 
  80d38e:	be 8a 00 00 00       	mov    $0x8a,%esi
  80d393:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d39a:	00 00 00 
  80d39d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3a2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d3a9:	00 00 00 
  80d3ac:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d3ae:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d3af:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d3b2:	83 f8 02             	cmp    $0x2,%eax
  80d3b5:	77 0e                	ja     80d3c5 <pbuf_alloc+0x85>
  80d3b7:	83 f8 01             	cmp    $0x1,%eax
  80d3ba:	0f 83 ac 03 00 00    	jae    80d76c <pbuf_alloc+0x42c>
  80d3c0:	e9 d8 02 00 00       	jmpq   80d69d <pbuf_alloc+0x35d>
  80d3c5:	83 f8 03             	cmp    $0x3,%eax
  80d3c8:	0f 85 05 04 00 00    	jne    80d7d3 <pbuf_alloc+0x493>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d3ce:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d3d3:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  80d3da:	00 00 00 
  80d3dd:	ff d0                	callq  *%rax
  80d3df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d3e3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d3e8:	75 0a                	jne    80d3f4 <pbuf_alloc+0xb4>
      return NULL;
  80d3ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3ef:	e9 1f 04 00 00       	jmpq   80d813 <pbuf_alloc+0x4d3>
    }
    p->type = type;
  80d3f4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d3f7:	89 c2                	mov    %eax,%edx
  80d3f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3fd:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d400:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d404:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d40b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d40f:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d417:	48 01 d0             	add    %rdx,%rax
  80d41a:	48 83 c0 03          	add    $0x3,%rax
  80d41e:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d422:	48 89 c2             	mov    %rax,%rdx
  80d425:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d429:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d42d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d431:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d435:	83 e0 03             	and    $0x3,%eax
  80d438:	48 85 c0             	test   %rax,%rax
  80d43b:	74 2a                	je     80d467 <pbuf_alloc+0x127>
  80d43d:	48 ba 60 1e 82 00 00 	movabs $0x821e60,%rdx
  80d444:	00 00 00 
  80d447:	be 9c 00 00 00       	mov    $0x9c,%esi
  80d44c:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d453:	00 00 00 
  80d456:	b8 00 00 00 00       	mov    $0x0,%eax
  80d45b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d462:	00 00 00 
  80d465:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d46b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d46f:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d473:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d477:	83 c0 03             	add    $0x3,%eax
  80d47a:	83 e0 fc             	and    $0xfffffffc,%eax
  80d47d:	89 c2                	mov    %eax,%edx
  80d47f:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d484:	29 d0                	sub    %edx,%eax
  80d486:	89 c2                	mov    %eax,%edx
  80d488:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d48c:	39 c2                	cmp    %eax,%edx
  80d48e:	0f 4e c2             	cmovle %edx,%eax
  80d491:	89 c2                	mov    %eax,%edx
  80d493:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d497:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d49b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d49f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d4a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4a7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d4ab:	0f b7 c0             	movzwl %ax,%eax
  80d4ae:	48 01 c2             	add    %rax,%rdx
  80d4b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4b5:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d4bb:	48 39 c2             	cmp    %rax,%rdx
  80d4be:	76 2a                	jbe    80d4ea <pbuf_alloc+0x1aa>
  80d4c0:	48 ba 90 1e 82 00 00 	movabs $0x821e90,%rdx
  80d4c7:	00 00 00 
  80d4ca:	be a3 00 00 00       	mov    $0xa3,%esi
  80d4cf:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d4d6:	00 00 00 
  80d4d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4de:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d4e5:	00 00 00 
  80d4e8:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d4ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4ee:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d4f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d4fc:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d500:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d504:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d508:	0f b7 c0             	movzwl %ax,%eax
  80d50b:	29 c2                	sub    %eax,%edx
  80d50d:	89 d0                	mov    %edx,%eax
  80d50f:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d512:	e9 77 01 00 00       	jmpq   80d68e <pbuf_alloc+0x34e>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d517:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d51c:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  80d523:	00 00 00 
  80d526:	ff d0                	callq  *%rax
  80d528:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d52c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d531:	75 1d                	jne    80d550 <pbuf_alloc+0x210>
        /* free chain so far allocated */
        pbuf_free(p);
  80d533:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d537:	48 89 c7             	mov    %rax,%rdi
  80d53a:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80d541:	00 00 00 
  80d544:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d546:	b8 00 00 00 00       	mov    $0x0,%eax
  80d54b:	e9 c3 02 00 00       	jmpq   80d813 <pbuf_alloc+0x4d3>
      }
      q->type = type;
  80d550:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d553:	89 c2                	mov    %eax,%edx
  80d555:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d559:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d55c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d560:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d564:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d568:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d56f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d573:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d577:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d57a:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d581:	7e 2a                	jle    80d5ad <pbuf_alloc+0x26d>
  80d583:	48 ba c1 1e 82 00 00 	movabs $0x821ec1,%rdx
  80d58a:	00 00 00 
  80d58d:	be bc 00 00 00       	mov    $0xbc,%esi
  80d592:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d599:	00 00 00 
  80d59c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5a1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d5a8:	00 00 00 
  80d5ab:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d5ad:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d5b0:	89 c2                	mov    %eax,%edx
  80d5b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d5b6:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d5ba:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d5bd:	66 3d cf 07          	cmp    $0x7cf,%ax
  80d5c1:	77 05                	ja     80d5c8 <pbuf_alloc+0x288>
  80d5c3:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d5c6:	eb 05                	jmp    80d5cd <pbuf_alloc+0x28d>
  80d5c8:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d5cd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d5d1:	66 89 42 12          	mov    %ax,0x12(%rdx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d5d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d5d9:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d5dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d5e1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d5e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d5e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d5ed:	83 e0 03             	and    $0x3,%eax
  80d5f0:	48 85 c0             	test   %rax,%rax
  80d5f3:	74 2a                	je     80d61f <pbuf_alloc+0x2df>
  80d5f5:	48 ba d8 1e 82 00 00 	movabs $0x821ed8,%rdx
  80d5fc:	00 00 00 
  80d5ff:	be c2 00 00 00       	mov    $0xc2,%esi
  80d604:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d60b:	00 00 00 
  80d60e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d613:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d61a:	00 00 00 
  80d61d:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d61f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d623:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d627:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d62b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d62f:	0f b7 c0             	movzwl %ax,%eax
  80d632:	48 01 c2             	add    %rax,%rdx
  80d635:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d639:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d63f:	48 39 c2             	cmp    %rax,%rdx
  80d642:	76 2a                	jbe    80d66e <pbuf_alloc+0x32e>
  80d644:	48 ba 90 1e 82 00 00 	movabs $0x821e90,%rdx
  80d64b:	00 00 00 
  80d64e:	be c5 00 00 00       	mov    $0xc5,%esi
  80d653:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d65a:	00 00 00 
  80d65d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d662:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d669:	00 00 00 
  80d66c:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d66e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d672:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d678:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d67c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d680:	0f b7 c0             	movzwl %ax,%eax
  80d683:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d686:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d68a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d68e:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d692:	0f 8f 7f fe ff ff    	jg     80d517 <pbuf_alloc+0x1d7>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d698:	e9 60 01 00 00       	jmpq   80d7fd <pbuf_alloc+0x4bd>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d69d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d6a1:	83 c0 1b             	add    $0x1b,%eax
  80d6a4:	83 e0 fc             	and    $0xfffffffc,%eax
  80d6a7:	89 c2                	mov    %eax,%edx
  80d6a9:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d6ad:	83 c0 03             	add    $0x3,%eax
  80d6b0:	83 e0 fc             	and    $0xfffffffc,%eax
  80d6b3:	01 d0                	add    %edx,%eax
  80d6b5:	89 c7                	mov    %eax,%edi
  80d6b7:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  80d6be:	00 00 00 
  80d6c1:	ff d0                	callq  *%rax
  80d6c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d6c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d6cc:	75 0a                	jne    80d6d8 <pbuf_alloc+0x398>
      return NULL;
  80d6ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80d6d3:	e9 3b 01 00 00       	jmpq   80d813 <pbuf_alloc+0x4d3>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d6d8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d6dc:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d6e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6e4:	48 01 d0             	add    %rdx,%rax
  80d6e7:	48 83 c0 03          	add    $0x3,%rax
  80d6eb:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d6ef:	48 89 c2             	mov    %rax,%rdx
  80d6f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6f6:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d6fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6fe:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d702:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d706:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d70a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d70e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d712:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d716:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d71a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d721:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d724:	89 c2                	mov    %eax,%edx
  80d726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d72a:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d72d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d731:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d735:	83 e0 03             	and    $0x3,%eax
  80d738:	48 85 c0             	test   %rax,%rax
  80d73b:	74 2a                	je     80d767 <pbuf_alloc+0x427>
  80d73d:	48 ba 08 1f 82 00 00 	movabs $0x821f08,%rdx
  80d744:	00 00 00 
  80d747:	be dd 00 00 00       	mov    $0xdd,%esi
  80d74c:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d753:	00 00 00 
  80d756:	b8 00 00 00 00       	mov    $0x0,%eax
  80d75b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d762:	00 00 00 
  80d765:	ff d1                	callq  *%rcx
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d767:	e9 91 00 00 00       	jmpq   80d7fd <pbuf_alloc+0x4bd>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d76c:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d771:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  80d778:	00 00 00 
  80d77b:	ff d0                	callq  *%rax
  80d77d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d781:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d786:	75 0a                	jne    80d792 <pbuf_alloc+0x452>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d788:	b8 00 00 00 00       	mov    $0x0,%eax
  80d78d:	e9 81 00 00 00       	jmpq   80d813 <pbuf_alloc+0x4d3>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d792:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d796:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d79d:	00 
    p->len = p->tot_len = length;
  80d79e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7a2:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d7a6:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d7aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7ae:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d7b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7b6:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d7ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7be:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d7c5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d7c8:	89 c2                	mov    %eax,%edx
  80d7ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7ce:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d7d1:	eb 2a                	jmp    80d7fd <pbuf_alloc+0x4bd>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d7d3:	48 ba 33 1f 82 00 00 	movabs $0x821f33,%rdx
  80d7da:	00 00 00 
  80d7dd:	be f1 00 00 00       	mov    $0xf1,%esi
  80d7e2:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d7e9:	00 00 00 
  80d7ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7f1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d7f8:	00 00 00 
  80d7fb:	ff d1                	callq  *%rcx
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d7fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d801:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d80b:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d813:	c9                   	leaveq 
  80d814:	c3                   	retq   

000000000080d815 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d815:	55                   	push   %rbp
  80d816:	48 89 e5             	mov    %rsp,%rbp
  80d819:	48 83 ec 20          	sub    $0x20,%rsp
  80d81d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d821:	89 f0                	mov    %esi,%eax
  80d823:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d827:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d82c:	75 2a                	jne    80d858 <pbuf_realloc+0x43>
  80d82e:	48 ba 4e 1f 82 00 00 	movabs $0x821f4e,%rdx
  80d835:	00 00 00 
  80d838:	be 13 01 00 00       	mov    $0x113,%esi
  80d83d:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d844:	00 00 00 
  80d847:	b8 00 00 00 00       	mov    $0x0,%eax
  80d84c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d853:	00 00 00 
  80d856:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d85c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d860:	3c 03                	cmp    $0x3,%al
  80d862:	74 4e                	je     80d8b2 <pbuf_realloc+0x9d>
  80d864:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d868:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d86c:	3c 01                	cmp    $0x1,%al
  80d86e:	74 42                	je     80d8b2 <pbuf_realloc+0x9d>
  80d870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d874:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d878:	84 c0                	test   %al,%al
  80d87a:	74 36                	je     80d8b2 <pbuf_realloc+0x9d>
  80d87c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d880:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d884:	3c 02                	cmp    $0x2,%al
  80d886:	74 2a                	je     80d8b2 <pbuf_realloc+0x9d>
  80d888:	48 ba 66 1f 82 00 00 	movabs $0x821f66,%rdx
  80d88f:	00 00 00 
  80d892:	be 17 01 00 00       	mov    $0x117,%esi
  80d897:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d89e:	00 00 00 
  80d8a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8a6:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d8ad:	00 00 00 
  80d8b0:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d8b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8b6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d8ba:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d8be:	77 05                	ja     80d8c5 <pbuf_realloc+0xb0>
    /* enlarging not yet supported */
    return;
  80d8c0:	e9 97 01 00 00       	jmpq   80da5c <pbuf_realloc+0x247>
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d8c5:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d8c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8cd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d8d1:	0f b7 c0             	movzwl %ax,%eax
  80d8d4:	29 c2                	sub    %eax,%edx
  80d8d6:	89 d0                	mov    %edx,%eax
  80d8d8:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80d8db:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d8df:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80d8e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d8eb:	e9 90 00 00 00       	jmpq   80d980 <pbuf_realloc+0x16b>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80d8f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8f4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d8f8:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80d8fc:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80d903:	7e 2a                	jle    80d92f <pbuf_realloc+0x11a>
  80d905:	48 ba 81 1f 82 00 00 	movabs $0x821f81,%rdx
  80d90c:	00 00 00 
  80d90f:	be 2b 01 00 00       	mov    $0x12b,%esi
  80d914:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d91b:	00 00 00 
  80d91e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d923:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d92a:	00 00 00 
  80d92d:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80d92f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d933:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d937:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80d93a:	01 c2                	add    %eax,%edx
  80d93c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d940:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80d944:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d948:	48 8b 00             	mov    (%rax),%rax
  80d94b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80d94f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d954:	75 2a                	jne    80d980 <pbuf_realloc+0x16b>
  80d956:	48 ba 92 1f 82 00 00 	movabs $0x821f92,%rdx
  80d95d:	00 00 00 
  80d960:	be 2f 01 00 00       	mov    $0x12f,%esi
  80d965:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d96c:	00 00 00 
  80d96f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d974:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80d97b:	00 00 00 
  80d97e:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d980:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d984:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d988:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d98c:	0f 82 5e ff ff ff    	jb     80d8f0 <pbuf_realloc+0xdb>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80d992:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d996:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d99a:	84 c0                	test   %al,%al
  80d99c:	75 75                	jne    80da13 <pbuf_realloc+0x1fe>
  80d99e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9a2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d9a6:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d9aa:	74 67                	je     80da13 <pbuf_realloc+0x1fe>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80d9ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9b0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d9b4:	48 89 c2             	mov    %rax,%rdx
  80d9b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9bb:	48 29 c2             	sub    %rax,%rdx
  80d9be:	48 89 d0             	mov    %rdx,%rax
  80d9c1:	89 c2                	mov    %eax,%edx
  80d9c3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80d9c7:	01 c2                	add    %eax,%edx
  80d9c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9cd:	89 d6                	mov    %edx,%esi
  80d9cf:	48 89 c7             	mov    %rax,%rdi
  80d9d2:	48 b8 5e c5 80 00 00 	movabs $0x80c55e,%rax
  80d9d9:	00 00 00 
  80d9dc:	ff d0                	callq  *%rax
  80d9de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80d9e2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d9e7:	75 2a                	jne    80da13 <pbuf_realloc+0x1fe>
  80d9e9:	48 ba aa 1f 82 00 00 	movabs $0x821faa,%rdx
  80d9f0:	00 00 00 
  80d9f3:	be 39 01 00 00       	mov    $0x139,%esi
  80d9f8:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80d9ff:	00 00 00 
  80da02:	b8 00 00 00 00       	mov    $0x0,%eax
  80da07:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80da0e:	00 00 00 
  80da11:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80da13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da17:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80da1b:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80da1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da23:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80da27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da2b:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80da2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da33:	48 8b 00             	mov    (%rax),%rax
  80da36:	48 85 c0             	test   %rax,%rax
  80da39:	74 16                	je     80da51 <pbuf_realloc+0x23c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80da3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da3f:	48 8b 00             	mov    (%rax),%rax
  80da42:	48 89 c7             	mov    %rax,%rdi
  80da45:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80da4c:	00 00 00 
  80da4f:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80da51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da55:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

}
  80da5c:	c9                   	leaveq 
  80da5d:	c3                   	retq   

000000000080da5e <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80da5e:	55                   	push   %rbp
  80da5f:	48 89 e5             	mov    %rsp,%rbp
  80da62:	48 83 ec 20          	sub    $0x20,%rsp
  80da66:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80da6a:	89 f0                	mov    %esi,%eax
  80da6c:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80da70:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80da75:	75 2a                	jne    80daa1 <pbuf_header+0x43>
  80da77:	48 ba c5 1f 82 00 00 	movabs $0x821fc5,%rdx
  80da7e:	00 00 00 
  80da81:	be 64 01 00 00       	mov    $0x164,%esi
  80da86:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80da8d:	00 00 00 
  80da90:	b8 00 00 00 00       	mov    $0x0,%eax
  80da95:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80da9c:	00 00 00 
  80da9f:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80daa1:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80daa6:	74 07                	je     80daaf <pbuf_header+0x51>
  80daa8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80daad:	75 0a                	jne    80dab9 <pbuf_header+0x5b>
    return 0;
  80daaf:	b8 00 00 00 00       	mov    $0x0,%eax
  80dab4:	e9 64 01 00 00       	jmpq   80dc1d <pbuf_header+0x1bf>
 
  if (header_size_increment < 0){
  80dab9:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dabe:	79 42                	jns    80db02 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80dac0:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dac4:	f7 d8                	neg    %eax
  80dac6:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80daca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dace:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dad2:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dad6:	73 32                	jae    80db0a <pbuf_header+0xac>
  80dad8:	48 ba cf 1f 82 00 00 	movabs $0x821fcf,%rdx
  80dadf:	00 00 00 
  80dae2:	be 6b 01 00 00       	mov    $0x16b,%esi
  80dae7:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80daee:	00 00 00 
  80daf1:	b8 00 00 00 00       	mov    $0x0,%eax
  80daf6:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dafd:	00 00 00 
  80db00:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80db02:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80db06:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80db0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db0e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80db12:	0f b6 c0             	movzbl %al,%eax
  80db15:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80db19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db1d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80db21:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80db25:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80db2a:	74 07                	je     80db33 <pbuf_header+0xd5>
  80db2c:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80db31:	75 48                	jne    80db7b <pbuf_header+0x11d>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80db33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db37:	48 8b 40 08          	mov    0x8(%rax),%rax
  80db3b:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80db40:	48 f7 da             	neg    %rdx
  80db43:	48 01 c2             	add    %rax,%rdx
  80db46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db4a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80db4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db52:	48 8b 40 08          	mov    0x8(%rax),%rax
  80db56:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80db5a:	48 83 c2 18          	add    $0x18,%rdx
  80db5e:	48 39 d0             	cmp    %rdx,%rax
  80db61:	73 16                	jae    80db79 <pbuf_header+0x11b>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80db63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db67:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80db6b:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80db6f:	b8 01 00 00 00       	mov    $0x1,%eax
  80db74:	e9 a4 00 00 00       	jmpq   80dc1d <pbuf_header+0x1bf>
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80db79:	eb 71                	jmp    80dbec <pbuf_header+0x18e>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80db7b:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80db80:	74 07                	je     80db89 <pbuf_header+0x12b>
  80db82:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80db87:	75 39                	jne    80dbc2 <pbuf_header+0x164>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80db89:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80db8e:	79 2b                	jns    80dbbb <pbuf_header+0x15d>
  80db90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db94:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80db98:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80db9c:	72 1d                	jb     80dbbb <pbuf_header+0x15d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80db9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dba2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dba6:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dbab:	48 f7 da             	neg    %rdx
  80dbae:	48 01 c2             	add    %rax,%rdx
  80dbb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbb5:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dbb9:	eb 31                	jmp    80dbec <pbuf_header+0x18e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80dbbb:	b8 01 00 00 00       	mov    $0x1,%eax
  80dbc0:	eb 5b                	jmp    80dc1d <pbuf_header+0x1bf>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80dbc2:	48 ba ed 1f 82 00 00 	movabs $0x821fed,%rdx
  80dbc9:	00 00 00 
  80dbcc:	be 9a 01 00 00       	mov    $0x19a,%esi
  80dbd1:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80dbd8:	00 00 00 
  80dbdb:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbe0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dbe7:	00 00 00 
  80dbea:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80dbec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbf0:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dbf4:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dbf8:	01 c2                	add    %eax,%edx
  80dbfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbfe:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80dc02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc06:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dc0a:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dc0e:	01 c2                	add    %eax,%edx
  80dc10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc14:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80dc18:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dc1d:	c9                   	leaveq 
  80dc1e:	c3                   	retq   

000000000080dc1f <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80dc1f:	55                   	push   %rbp
  80dc20:	48 89 e5             	mov    %rsp,%rbp
  80dc23:	48 83 ec 30          	sub    $0x30,%rsp
  80dc27:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80dc2b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dc30:	75 3b                	jne    80dc6d <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80dc32:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dc37:	75 2a                	jne    80dc63 <pbuf_free+0x44>
  80dc39:	48 ba c5 1f 82 00 00 	movabs $0x821fc5,%rdx
  80dc40:	00 00 00 
  80dc43:	be d0 01 00 00       	mov    $0x1d0,%esi
  80dc48:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80dc4f:	00 00 00 
  80dc52:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc57:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dc5e:	00 00 00 
  80dc61:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80dc63:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc68:	e9 65 01 00 00       	jmpq   80ddd2 <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80dc6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc71:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc75:	84 c0                	test   %al,%al
  80dc77:	74 4e                	je     80dcc7 <pbuf_free+0xa8>
  80dc79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc7d:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc81:	3c 01                	cmp    $0x1,%al
  80dc83:	74 42                	je     80dcc7 <pbuf_free+0xa8>
  80dc85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc89:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc8d:	3c 02                	cmp    $0x2,%al
  80dc8f:	74 36                	je     80dcc7 <pbuf_free+0xa8>
  80dc91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc95:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc99:	3c 03                	cmp    $0x3,%al
  80dc9b:	74 2a                	je     80dcc7 <pbuf_free+0xa8>
  80dc9d:	48 ba fb 1f 82 00 00 	movabs $0x821ffb,%rdx
  80dca4:	00 00 00 
  80dca7:	be db 01 00 00       	mov    $0x1db,%esi
  80dcac:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80dcb3:	00 00 00 
  80dcb6:	b8 00 00 00 00       	mov    $0x0,%eax
  80dcbb:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dcc2:	00 00 00 
  80dcc5:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80dcc7:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80dccb:	e9 f3 00 00 00       	jmpq   80ddc3 <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80dcd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dcd4:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dcd8:	66 85 c0             	test   %ax,%ax
  80dcdb:	75 2a                	jne    80dd07 <pbuf_free+0xe8>
  80dcdd:	48 ba 10 20 82 00 00 	movabs $0x822010,%rdx
  80dce4:	00 00 00 
  80dce7:	be e8 01 00 00       	mov    $0x1e8,%esi
  80dcec:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80dcf3:	00 00 00 
  80dcf6:	b8 00 00 00 00       	mov    $0x0,%eax
  80dcfb:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dd02:	00 00 00 
  80dd05:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80dd07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd0b:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dd0f:	8d 50 ff             	lea    -0x1(%rax),%edx
  80dd12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd16:	66 89 50 16          	mov    %dx,0x16(%rax)
  80dd1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd1e:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dd22:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80dd26:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80dd2b:	0f 85 8a 00 00 00    	jne    80ddbb <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80dd31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd35:	48 8b 00             	mov    (%rax),%rax
  80dd38:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80dd3c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd40:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dd44:	0f b6 c0             	movzbl %al,%eax
  80dd47:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80dd4b:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80dd50:	75 1a                	jne    80dd6c <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80dd52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd56:	48 89 c6             	mov    %rax,%rsi
  80dd59:	bf 0d 00 00 00       	mov    $0xd,%edi
  80dd5e:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80dd65:	00 00 00 
  80dd68:	ff d0                	callq  *%rax
  80dd6a:	eb 3b                	jmp    80dda7 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80dd6c:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80dd71:	74 07                	je     80dd7a <pbuf_free+0x15b>
  80dd73:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80dd78:	75 1a                	jne    80dd94 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80dd7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd7e:	48 89 c6             	mov    %rax,%rsi
  80dd81:	bf 0c 00 00 00       	mov    $0xc,%edi
  80dd86:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80dd8d:	00 00 00 
  80dd90:	ff d0                	callq  *%rax
  80dd92:	eb 13                	jmp    80dda7 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80dd94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd98:	48 89 c7             	mov    %rax,%rdi
  80dd9b:	48 b8 d9 c3 80 00 00 	movabs $0x80c3d9,%rax
  80dda2:	00 00 00 
  80dda5:	ff d0                	callq  *%rax
      }
      count++;
  80dda7:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80ddab:	83 c0 01             	add    $0x1,%eax
  80ddae:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80ddb1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ddb5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80ddb9:	eb 08                	jmp    80ddc3 <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80ddbb:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80ddc2:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80ddc3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80ddc8:	0f 85 02 ff ff ff    	jne    80dcd0 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80ddce:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80ddd2:	c9                   	leaveq 
  80ddd3:	c3                   	retq   

000000000080ddd4 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80ddd4:	55                   	push   %rbp
  80ddd5:	48 89 e5             	mov    %rsp,%rbp
  80ddd8:	48 83 ec 18          	sub    $0x18,%rsp
  80dddc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80dde0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80dde4:	eb 0f                	jmp    80ddf5 <pbuf_clen+0x21>
    ++len;
  80dde6:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80ddea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddee:	48 8b 00             	mov    (%rax),%rax
  80ddf1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80ddf5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ddfa:	75 ea                	jne    80dde6 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80ddfc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80de00:	c9                   	leaveq 
  80de01:	c3                   	retq   

000000000080de02 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80de02:	55                   	push   %rbp
  80de03:	48 89 e5             	mov    %rsp,%rbp
  80de06:	48 83 ec 08          	sub    $0x8,%rsp
  80de0a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80de0e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80de13:	74 13                	je     80de28 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80de15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80de19:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de1d:	8d 50 01             	lea    0x1(%rax),%edx
  80de20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80de24:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80de28:	c9                   	leaveq 
  80de29:	c3                   	retq   

000000000080de2a <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80de2a:	55                   	push   %rbp
  80de2b:	48 89 e5             	mov    %rsp,%rbp
  80de2e:	48 83 ec 20          	sub    $0x20,%rsp
  80de32:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80de36:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80de3a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80de3f:	74 07                	je     80de48 <pbuf_cat+0x1e>
  80de41:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80de46:	75 2a                	jne    80de72 <pbuf_cat+0x48>
  80de48:	48 ba 28 20 82 00 00 	movabs $0x822028,%rdx
  80de4f:	00 00 00 
  80de52:	be 42 02 00 00       	mov    $0x242,%esi
  80de57:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80de5e:	00 00 00 
  80de61:	b8 00 00 00 00       	mov    $0x0,%eax
  80de66:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80de6d:	00 00 00 
  80de70:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80de72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80de7a:	eb 25                	jmp    80dea1 <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80de7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80de80:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80de84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80de88:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80de8c:	01 c2                	add    %eax,%edx
  80de8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80de92:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80de96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80de9a:	48 8b 00             	mov    (%rax),%rax
  80de9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dea1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dea5:	48 8b 00             	mov    (%rax),%rax
  80dea8:	48 85 c0             	test   %rax,%rax
  80deab:	75 cf                	jne    80de7c <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80dead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80deb1:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80deb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80deb9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80debd:	66 39 c2             	cmp    %ax,%dx
  80dec0:	74 2a                	je     80deec <pbuf_cat+0xc2>
  80dec2:	48 ba 60 20 82 00 00 	movabs $0x822060,%rdx
  80dec9:	00 00 00 
  80decc:	be 4a 02 00 00       	mov    $0x24a,%esi
  80ded1:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80ded8:	00 00 00 
  80dedb:	b8 00 00 00 00       	mov    $0x0,%eax
  80dee0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dee7:	00 00 00 
  80deea:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80deec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80def0:	48 8b 00             	mov    (%rax),%rax
  80def3:	48 85 c0             	test   %rax,%rax
  80def6:	74 2a                	je     80df22 <pbuf_cat+0xf8>
  80def8:	48 ba 8d 20 82 00 00 	movabs $0x82208d,%rdx
  80deff:	00 00 00 
  80df02:	be 4b 02 00 00       	mov    $0x24b,%esi
  80df07:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80df0e:	00 00 00 
  80df11:	b8 00 00 00 00       	mov    $0x0,%eax
  80df16:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80df1d:	00 00 00 
  80df20:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80df22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df26:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80df2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80df2e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80df32:	01 c2                	add    %eax,%edx
  80df34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df38:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80df3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df40:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80df44:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80df47:	c9                   	leaveq 
  80df48:	c3                   	retq   

000000000080df49 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80df49:	55                   	push   %rbp
  80df4a:	48 89 e5             	mov    %rsp,%rbp
  80df4d:	48 83 ec 10          	sub    $0x10,%rsp
  80df51:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80df55:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80df59:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80df5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df61:	48 89 d6             	mov    %rdx,%rsi
  80df64:	48 89 c7             	mov    %rax,%rdi
  80df67:	48 b8 2a de 80 00 00 	movabs $0x80de2a,%rax
  80df6e:	00 00 00 
  80df71:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80df73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80df77:	48 89 c7             	mov    %rax,%rdi
  80df7a:	48 b8 02 de 80 00 00 	movabs $0x80de02,%rax
  80df81:	00 00 00 
  80df84:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80df86:	c9                   	leaveq 
  80df87:	c3                   	retq   

000000000080df88 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80df88:	55                   	push   %rbp
  80df89:	48 89 e5             	mov    %rsp,%rbp
  80df8c:	48 83 ec 20          	sub    $0x20,%rsp
  80df90:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80df94:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80df98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df9c:	48 8b 00             	mov    (%rax),%rax
  80df9f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80dfa3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80dfa8:	0f 84 9e 00 00 00    	je     80e04c <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80dfae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dfb2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dfb6:	0f b7 d0             	movzwl %ax,%edx
  80dfb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dfbd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dfc1:	0f b7 c8             	movzwl %ax,%ecx
  80dfc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dfc8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dfcc:	0f b7 c0             	movzwl %ax,%eax
  80dfcf:	29 c1                	sub    %eax,%ecx
  80dfd1:	89 c8                	mov    %ecx,%eax
  80dfd3:	39 c2                	cmp    %eax,%edx
  80dfd5:	74 2a                	je     80e001 <pbuf_dechain+0x79>
  80dfd7:	48 ba a0 20 82 00 00 	movabs $0x8220a0,%rdx
  80dfde:	00 00 00 
  80dfe1:	be 80 02 00 00       	mov    $0x280,%esi
  80dfe6:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80dfed:	00 00 00 
  80dff0:	b8 00 00 00 00       	mov    $0x0,%eax
  80dff5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80dffc:	00 00 00 
  80dfff:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80e001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e005:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e009:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e00d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e011:	29 c2                	sub    %eax,%edx
  80e013:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e017:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80e01b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e01f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80e026:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e02a:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e02e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e032:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80e036:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e03a:	48 89 c7             	mov    %rax,%rdi
  80e03d:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  80e044:	00 00 00 
  80e047:	ff d0                	callq  *%rax
  80e049:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80e04c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e050:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e054:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e058:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e05c:	66 39 c2             	cmp    %ax,%dx
  80e05f:	74 2a                	je     80e08b <pbuf_dechain+0x103>
  80e061:	48 ba c2 20 82 00 00 	movabs $0x8220c2,%rdx
  80e068:	00 00 00 
  80e06b:	be 91 02 00 00       	mov    $0x291,%esi
  80e070:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e077:	00 00 00 
  80e07a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e07f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e086:	00 00 00 
  80e089:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80e08b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e08f:	75 06                	jne    80e097 <pbuf_dechain+0x10f>
  80e091:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e095:	eb 05                	jmp    80e09c <pbuf_dechain+0x114>
  80e097:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e09c:	c9                   	leaveq 
  80e09d:	c3                   	retq   

000000000080e09e <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80e09e:	55                   	push   %rbp
  80e09f:	48 89 e5             	mov    %rsp,%rbp
  80e0a2:	48 83 ec 20          	sub    $0x20,%rsp
  80e0a6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e0aa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80e0ae:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80e0b4:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80e0ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e0bf:	74 1c                	je     80e0dd <pbuf_copy+0x3f>
  80e0c1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e0c6:	74 15                	je     80e0dd <pbuf_copy+0x3f>
  80e0c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0cc:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e0d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e0d4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0d8:	66 39 c2             	cmp    %ax,%dx
  80e0db:	73 2a                	jae    80e107 <pbuf_copy+0x69>
  80e0dd:	48 ba d8 20 82 00 00 	movabs $0x8220d8,%rdx
  80e0e4:	00 00 00 
  80e0e7:	be b1 02 00 00       	mov    $0x2b1,%esi
  80e0ec:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e0f3:	00 00 00 
  80e0f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0fb:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e102:	00 00 00 
  80e105:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80e107:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e10c:	75 2a                	jne    80e138 <pbuf_copy+0x9a>
  80e10e:	48 ba 08 21 82 00 00 	movabs $0x822108,%rdx
  80e115:	00 00 00 
  80e118:	be b6 02 00 00       	mov    $0x2b6,%esi
  80e11d:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e124:	00 00 00 
  80e127:	b8 00 00 00 00       	mov    $0x0,%eax
  80e12c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e133:	00 00 00 
  80e136:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80e138:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e13c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e140:	0f b7 d0             	movzwl %ax,%edx
  80e143:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80e147:	89 d1                	mov    %edx,%ecx
  80e149:	29 c1                	sub    %eax,%ecx
  80e14b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e14f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e153:	0f b7 d0             	movzwl %ax,%edx
  80e156:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80e15a:	29 c2                	sub    %eax,%edx
  80e15c:	89 d0                	mov    %edx,%eax
  80e15e:	39 c1                	cmp    %eax,%ecx
  80e160:	7c 12                	jl     80e174 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80e162:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e166:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e16a:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80e16e:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80e172:	eb 10                	jmp    80e184 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80e174:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e178:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e17c:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80e180:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80e184:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e188:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e18c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e190:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80e194:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e198:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e19c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e1a0:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80e1a4:	48 01 d1             	add    %rdx,%rcx
  80e1a7:	48 89 c2             	mov    %rax,%rdx
  80e1aa:	48 89 cf             	mov    %rcx,%rdi
  80e1ad:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  80e1b4:	00 00 00 
  80e1b7:	ff d0                	callq  *%rax
    offset_to += len;
  80e1b9:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e1bd:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80e1c1:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e1c5:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80e1c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1cd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e1d1:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e1d5:	73 2a                	jae    80e201 <pbuf_copy+0x163>
  80e1d7:	48 ba 15 21 82 00 00 	movabs $0x822115,%rdx
  80e1de:	00 00 00 
  80e1e1:	be c2 02 00 00       	mov    $0x2c2,%esi
  80e1e6:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e1ed:	00 00 00 
  80e1f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1f5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e1fc:	00 00 00 
  80e1ff:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80e201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e205:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e209:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e20d:	75 11                	jne    80e220 <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80e20f:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80e215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e219:	48 8b 00             	mov    (%rax),%rax
  80e21c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80e220:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e224:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e228:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e22c:	73 2a                	jae    80e258 <pbuf_copy+0x1ba>
  80e22e:	48 ba 2c 21 82 00 00 	movabs $0x82212c,%rdx
  80e235:	00 00 00 
  80e238:	be c8 02 00 00       	mov    $0x2c8,%esi
  80e23d:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e244:	00 00 00 
  80e247:	b8 00 00 00 00       	mov    $0x0,%eax
  80e24c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e253:	00 00 00 
  80e256:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80e258:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e25c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e260:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e264:	77 11                	ja     80e277 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80e266:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80e26c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e270:	48 8b 00             	mov    (%rax),%rax
  80e273:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80e277:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e27c:	74 4b                	je     80e2c9 <pbuf_copy+0x22b>
  80e27e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e282:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e286:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e28a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e28e:	66 39 c2             	cmp    %ax,%dx
  80e291:	75 36                	jne    80e2c9 <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e293:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e297:	48 8b 00             	mov    (%rax),%rax
  80e29a:	48 85 c0             	test   %rax,%rax
  80e29d:	74 2a                	je     80e2c9 <pbuf_copy+0x22b>
  80e29f:	48 ba 48 21 82 00 00 	movabs $0x822148,%rdx
  80e2a6:	00 00 00 
  80e2a9:	be d2 02 00 00       	mov    $0x2d2,%esi
  80e2ae:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e2b5:	00 00 00 
  80e2b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e2bd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e2c4:	00 00 00 
  80e2c7:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80e2c9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e2ce:	74 4b                	je     80e31b <pbuf_copy+0x27d>
  80e2d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2d4:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e2d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2dc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e2e0:	66 39 c2             	cmp    %ax,%dx
  80e2e3:	75 36                	jne    80e31b <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e2e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2e9:	48 8b 00             	mov    (%rax),%rax
  80e2ec:	48 85 c0             	test   %rax,%rax
  80e2ef:	74 2a                	je     80e31b <pbuf_copy+0x27d>
  80e2f1:	48 ba 48 21 82 00 00 	movabs $0x822148,%rdx
  80e2f8:	00 00 00 
  80e2fb:	be d7 02 00 00       	mov    $0x2d7,%esi
  80e300:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e307:	00 00 00 
  80e30a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e30f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e316:	00 00 00 
  80e319:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e31b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e320:	0f 85 e1 fd ff ff    	jne    80e107 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e326:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e32b:	c9                   	leaveq 
  80e32c:	c3                   	retq   

000000000080e32d <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e32d:	55                   	push   %rbp
  80e32e:	48 89 e5             	mov    %rsp,%rbp
  80e331:	48 83 ec 30          	sub    $0x30,%rsp
  80e335:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e339:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e33d:	89 c8                	mov    %ecx,%eax
  80e33f:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e343:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e347:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e34d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e352:	75 2a                	jne    80e37e <pbuf_copy_partial+0x51>
  80e354:	48 ba 78 21 82 00 00 	movabs $0x822178,%rdx
  80e35b:	00 00 00 
  80e35e:	be ef 02 00 00       	mov    $0x2ef,%esi
  80e363:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e36a:	00 00 00 
  80e36d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e372:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e379:	00 00 00 
  80e37c:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e37e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e383:	75 2a                	jne    80e3af <pbuf_copy_partial+0x82>
  80e385:	48 ba a0 21 82 00 00 	movabs $0x8221a0,%rdx
  80e38c:	00 00 00 
  80e38f:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e394:	48 bf 4b 1e 82 00 00 	movabs $0x821e4b,%rdi
  80e39b:	00 00 00 
  80e39e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3a3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e3aa:	00 00 00 
  80e3ad:	ff d1                	callq  *%rcx

  left = 0;
  80e3af:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e3b5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e3ba:	74 07                	je     80e3c3 <pbuf_copy_partial+0x96>
  80e3bc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e3c1:	75 0a                	jne    80e3cd <pbuf_copy_partial+0xa0>
    return 0;
  80e3c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3c8:	e9 c2 00 00 00       	jmpq   80e48f <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e3cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3d1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e3d5:	e9 9f 00 00 00       	jmpq   80e479 <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80e3da:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e3df:	74 1c                	je     80e3fd <pbuf_copy_partial+0xd0>
  80e3e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e3e5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e3e9:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e3ed:	77 0e                	ja     80e3fd <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e3ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e3f3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e3f7:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e3fb:	eb 71                	jmp    80e46e <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e3fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e401:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e405:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e409:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e40d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e411:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e415:	76 08                	jbe    80e41f <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e417:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e41b:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e41f:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e423:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e427:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e42b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80e42f:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e433:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80e437:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e43b:	48 01 d1             	add    %rdx,%rcx
  80e43e:	48 89 c2             	mov    %rax,%rdx
  80e441:	48 89 cf             	mov    %rcx,%rdi
  80e444:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  80e44b:	00 00 00 
  80e44e:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e450:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e454:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e458:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e45c:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e460:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e464:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e468:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e46e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e472:	48 8b 00             	mov    (%rax),%rax
  80e475:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e479:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e47e:	74 0b                	je     80e48b <pbuf_copy_partial+0x15e>
  80e480:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e485:	0f 85 4f ff ff ff    	jne    80e3da <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e48b:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e48f:	c9                   	leaveq 
  80e490:	c3                   	retq   

000000000080e491 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e491:	55                   	push   %rbp
  80e492:	48 89 e5             	mov    %rsp,%rbp
  80e495:	48 83 ec 40          	sub    $0x40,%rsp
  80e499:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e49c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e4a0:	48 b8 37 87 81 00 00 	movabs $0x818737,%rax
  80e4a7:	00 00 00 
  80e4aa:	ff d0                	callq  *%rax
  80e4ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e4b0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e4b5:	74 0c                	je     80e4c3 <sys_mbox_fetch+0x32>
  80e4b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4bb:	48 8b 00             	mov    (%rax),%rax
  80e4be:	48 85 c0             	test   %rax,%rax
  80e4c1:	75 25                	jne    80e4e8 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e4c3:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e4c7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e4ca:	ba 00 00 00 00       	mov    $0x0,%edx
  80e4cf:	48 89 ce             	mov    %rcx,%rsi
  80e4d2:	89 c7                	mov    %eax,%edi
  80e4d4:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  80e4db:	00 00 00 
  80e4de:	ff d0                	callq  *%rax
  80e4e0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e4e3:	e9 e1 00 00 00       	jmpq   80e5c9 <sys_mbox_fetch+0x138>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e4e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4ec:	48 8b 00             	mov    (%rax),%rax
  80e4ef:	8b 40 08             	mov    0x8(%rax),%eax
  80e4f2:	85 c0                	test   %eax,%eax
  80e4f4:	74 27                	je     80e51d <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e4f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4fa:	48 8b 00             	mov    (%rax),%rax
  80e4fd:	8b 50 08             	mov    0x8(%rax),%edx
  80e500:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e504:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e507:	48 89 ce             	mov    %rcx,%rsi
  80e50a:	89 c7                	mov    %eax,%edi
  80e50c:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  80e513:	00 00 00 
  80e516:	ff d0                	callq  *%rax
  80e518:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e51b:	eb 07                	jmp    80e524 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e51d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e524:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e528:	75 69                	jne    80e593 <sys_mbox_fetch+0x102>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e52a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e52e:	48 8b 00             	mov    (%rax),%rax
  80e531:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e535:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e539:	48 8b 10             	mov    (%rax),%rdx
  80e53c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e540:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e543:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e547:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e54b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e54f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e553:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e557:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e55b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e55f:	48 89 c6             	mov    %rax,%rsi
  80e562:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e567:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80e56e:	00 00 00 
  80e571:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e577:	48 85 c0             	test   %rax,%rax
  80e57a:	74 12                	je     80e58e <sys_mbox_fetch+0xfd>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e57c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e580:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e584:	48 89 d7             	mov    %rdx,%rdi
  80e587:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e589:	e9 12 ff ff ff       	jmpq   80e4a0 <sys_mbox_fetch+0xf>
  80e58e:	e9 0d ff ff ff       	jmpq   80e4a0 <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e593:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e597:	48 8b 00             	mov    (%rax),%rax
  80e59a:	8b 40 08             	mov    0x8(%rax),%eax
  80e59d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e5a0:	76 19                	jbe    80e5bb <sys_mbox_fetch+0x12a>
        timeouts->next->time -= time_needed;
  80e5a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e5a6:	48 8b 00             	mov    (%rax),%rax
  80e5a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e5ad:	48 8b 12             	mov    (%rdx),%rdx
  80e5b0:	8b 52 08             	mov    0x8(%rdx),%edx
  80e5b3:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e5b6:	89 50 08             	mov    %edx,0x8(%rax)
  80e5b9:	eb 0e                	jmp    80e5c9 <sys_mbox_fetch+0x138>
      } else {
        timeouts->next->time = 0;
  80e5bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e5bf:	48 8b 00             	mov    (%rax),%rax
  80e5c2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e5c9:	c9                   	leaveq 
  80e5ca:	c3                   	retq   

000000000080e5cb <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e5cb:	55                   	push   %rbp
  80e5cc:	48 89 e5             	mov    %rsp,%rbp
  80e5cf:	48 83 ec 40          	sub    $0x40,%rsp
  80e5d3:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e5d6:	48 b8 37 87 81 00 00 	movabs $0x818737,%rax
  80e5dd:	00 00 00 
  80e5e0:	ff d0                	callq  *%rax
  80e5e2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e5e6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e5eb:	74 0c                	je     80e5f9 <sys_sem_wait+0x2e>
  80e5ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e5f1:	48 8b 00             	mov    (%rax),%rax
  80e5f4:	48 85 c0             	test   %rax,%rax
  80e5f7:	75 1b                	jne    80e614 <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80e5f9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e5fc:	be 00 00 00 00       	mov    $0x0,%esi
  80e601:	89 c7                	mov    %eax,%edi
  80e603:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  80e60a:	00 00 00 
  80e60d:	ff d0                	callq  *%rax
  80e60f:	e9 dc 00 00 00       	jmpq   80e6f0 <sys_sem_wait+0x125>
  } else {
    if (timeouts->next->time > 0) {
  80e614:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e618:	48 8b 00             	mov    (%rax),%rax
  80e61b:	8b 40 08             	mov    0x8(%rax),%eax
  80e61e:	85 c0                	test   %eax,%eax
  80e620:	74 22                	je     80e644 <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e622:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e626:	48 8b 00             	mov    (%rax),%rax
  80e629:	8b 50 08             	mov    0x8(%rax),%edx
  80e62c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e62f:	89 d6                	mov    %edx,%esi
  80e631:	89 c7                	mov    %eax,%edi
  80e633:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  80e63a:	00 00 00 
  80e63d:	ff d0                	callq  *%rax
  80e63f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e642:	eb 07                	jmp    80e64b <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e644:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e64b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e64f:	75 69                	jne    80e6ba <sys_sem_wait+0xef>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e651:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e655:	48 8b 00             	mov    (%rax),%rax
  80e658:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e65c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e660:	48 8b 10             	mov    (%rax),%rdx
  80e663:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e667:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e66a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e66e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e672:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e67a:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e67e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e682:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e686:	48 89 c6             	mov    %rax,%rsi
  80e689:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e68e:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80e695:	00 00 00 
  80e698:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e69a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e69e:	48 85 c0             	test   %rax,%rax
  80e6a1:	74 12                	je     80e6b5 <sys_sem_wait+0xea>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e6a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e6a7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e6ab:	48 89 d7             	mov    %rdx,%rdi
  80e6ae:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e6b0:	e9 21 ff ff ff       	jmpq   80e5d6 <sys_sem_wait+0xb>
  80e6b5:	e9 1c ff ff ff       	jmpq   80e5d6 <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e6ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6be:	48 8b 00             	mov    (%rax),%rax
  80e6c1:	8b 40 08             	mov    0x8(%rax),%eax
  80e6c4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e6c7:	76 19                	jbe    80e6e2 <sys_sem_wait+0x117>
        timeouts->next->time -= time_needed;
  80e6c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6cd:	48 8b 00             	mov    (%rax),%rax
  80e6d0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6d4:	48 8b 12             	mov    (%rdx),%rdx
  80e6d7:	8b 52 08             	mov    0x8(%rdx),%edx
  80e6da:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e6dd:	89 50 08             	mov    %edx,0x8(%rax)
  80e6e0:	eb 0e                	jmp    80e6f0 <sys_sem_wait+0x125>
      } else {
        timeouts->next->time = 0;
  80e6e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6e6:	48 8b 00             	mov    (%rax),%rax
  80e6e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e6f0:	c9                   	leaveq 
  80e6f1:	c3                   	retq   

000000000080e6f2 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e6f2:	55                   	push   %rbp
  80e6f3:	48 89 e5             	mov    %rsp,%rbp
  80e6f6:	48 83 ec 40          	sub    $0x40,%rsp
  80e6fa:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80e6fd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80e701:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e705:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e70a:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  80e711:	00 00 00 
  80e714:	ff d0                	callq  *%rax
  80e716:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80e71a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e71f:	75 36                	jne    80e757 <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e721:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e726:	75 2a                	jne    80e752 <sys_timeout+0x60>
  80e728:	48 ba c8 21 82 00 00 	movabs $0x8221c8,%rdx
  80e72f:	00 00 00 
  80e732:	be c3 00 00 00       	mov    $0xc3,%esi
  80e737:	48 bf e5 21 82 00 00 	movabs $0x8221e5,%rdi
  80e73e:	00 00 00 
  80e741:	b8 00 00 00 00       	mov    $0x0,%eax
  80e746:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e74d:	00 00 00 
  80e750:	ff d1                	callq  *%rcx
    return;
  80e752:	e9 7e 01 00 00       	jmpq   80e8d5 <sys_timeout+0x1e3>
  }
  timeout->next = NULL;
  80e757:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e75b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e762:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80e766:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e76a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e76e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e772:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80e776:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e77a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e77e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80e781:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e784:	48 b8 37 87 81 00 00 	movabs $0x818737,%rax
  80e78b:	00 00 00 
  80e78e:	ff d0                	callq  *%rax
  80e790:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e794:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e799:	75 36                	jne    80e7d1 <sys_timeout+0xdf>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e79b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e7a0:	75 2a                	jne    80e7cc <sys_timeout+0xda>
  80e7a2:	48 ba f9 21 82 00 00 	movabs $0x8221f9,%rdx
  80e7a9:	00 00 00 
  80e7ac:	be d1 00 00 00       	mov    $0xd1,%esi
  80e7b1:	48 bf e5 21 82 00 00 	movabs $0x8221e5,%rdi
  80e7b8:	00 00 00 
  80e7bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80e7c0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e7c7:	00 00 00 
  80e7ca:	ff d1                	callq  *%rcx
    return;
  80e7cc:	e9 04 01 00 00       	jmpq   80e8d5 <sys_timeout+0x1e3>
  }

  if (timeouts->next == NULL) {
  80e7d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7d5:	48 8b 00             	mov    (%rax),%rax
  80e7d8:	48 85 c0             	test   %rax,%rax
  80e7db:	75 10                	jne    80e7ed <sys_timeout+0xfb>
    timeouts->next = timeout;
  80e7dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7e1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e7e5:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e7e8:	e9 e8 00 00 00       	jmpq   80e8d5 <sys_timeout+0x1e3>
  }

  if (timeouts->next->time > msecs) {
  80e7ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7f1:	48 8b 00             	mov    (%rax),%rax
  80e7f4:	8b 40 08             	mov    0x8(%rax),%eax
  80e7f7:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80e7fa:	76 35                	jbe    80e831 <sys_timeout+0x13f>
    timeouts->next->time -= msecs;
  80e7fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e800:	48 8b 00             	mov    (%rax),%rax
  80e803:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e807:	48 8b 12             	mov    (%rdx),%rdx
  80e80a:	8b 52 08             	mov    0x8(%rdx),%edx
  80e80d:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80e810:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e813:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e817:	48 8b 10             	mov    (%rax),%rdx
  80e81a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e81e:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e821:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e825:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e829:	48 89 10             	mov    %rdx,(%rax)
  80e82c:	e9 a4 00 00 00       	jmpq   80e8d5 <sys_timeout+0x1e3>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e831:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e835:	48 8b 00             	mov    (%rax),%rax
  80e838:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e83c:	e9 89 00 00 00       	jmpq   80e8ca <sys_timeout+0x1d8>
      timeout->time -= t->time;
  80e841:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e845:	8b 50 08             	mov    0x8(%rax),%edx
  80e848:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e84c:	8b 40 08             	mov    0x8(%rax),%eax
  80e84f:	29 c2                	sub    %eax,%edx
  80e851:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e855:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e858:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e85c:	48 8b 00             	mov    (%rax),%rax
  80e85f:	48 85 c0             	test   %rax,%rax
  80e862:	74 15                	je     80e879 <sys_timeout+0x187>
  80e864:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e868:	48 8b 00             	mov    (%rax),%rax
  80e86b:	8b 50 08             	mov    0x8(%rax),%edx
  80e86e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e872:	8b 40 08             	mov    0x8(%rax),%eax
  80e875:	39 c2                	cmp    %eax,%edx
  80e877:	76 46                	jbe    80e8bf <sys_timeout+0x1cd>
        if (t->next != NULL) {
  80e879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e87d:	48 8b 00             	mov    (%rax),%rax
  80e880:	48 85 c0             	test   %rax,%rax
  80e883:	74 1f                	je     80e8a4 <sys_timeout+0x1b2>
          t->next->time -= timeout->time;
  80e885:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e889:	48 8b 00             	mov    (%rax),%rax
  80e88c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e890:	48 8b 12             	mov    (%rdx),%rdx
  80e893:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e896:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e89a:	8b 52 08             	mov    0x8(%rdx),%edx
  80e89d:	29 d1                	sub    %edx,%ecx
  80e89f:	89 ca                	mov    %ecx,%edx
  80e8a1:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e8a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e8a8:	48 8b 10             	mov    (%rax),%rdx
  80e8ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e8af:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e8b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e8b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e8ba:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e8bd:	eb 16                	jmp    80e8d5 <sys_timeout+0x1e3>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e8bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e8c3:	48 8b 00             	mov    (%rax),%rax
  80e8c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e8ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e8cf:	0f 85 6c ff ff ff    	jne    80e841 <sys_timeout+0x14f>
        t->next = timeout;
        break;
      }
    }
  }
}
  80e8d5:	c9                   	leaveq 
  80e8d6:	c3                   	retq   

000000000080e8d7 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80e8d7:	55                   	push   %rbp
  80e8d8:	48 89 e5             	mov    %rsp,%rbp
  80e8db:	48 83 ec 30          	sub    $0x30,%rsp
  80e8df:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80e8e3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80e8e7:	48 b8 37 87 81 00 00 	movabs $0x818737,%rax
  80e8ee:	00 00 00 
  80e8f1:	ff d0                	callq  *%rax
  80e8f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80e8f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e8fc:	75 36                	jne    80e934 <sys_untimeout+0x5d>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80e8fe:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e903:	75 2a                	jne    80e92f <sys_untimeout+0x58>
  80e905:	48 ba 18 22 82 00 00 	movabs $0x822218,%rdx
  80e90c:	00 00 00 
  80e90f:	be 00 01 00 00       	mov    $0x100,%esi
  80e914:	48 bf e5 21 82 00 00 	movabs $0x8221e5,%rdi
  80e91b:	00 00 00 
  80e91e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e923:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80e92a:	00 00 00 
  80e92d:	ff d1                	callq  *%rcx
    return;
  80e92f:	e9 cc 00 00 00       	jmpq   80ea00 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
  80e934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e938:	48 8b 00             	mov    (%rax),%rax
  80e93b:	48 85 c0             	test   %rax,%rax
  80e93e:	75 05                	jne    80e945 <sys_untimeout+0x6e>
    return;
  80e940:	e9 bb 00 00 00       	jmpq   80ea00 <sys_untimeout+0x129>
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e945:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e949:	48 8b 00             	mov    (%rax),%rax
  80e94c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e950:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80e957:	00 
  80e958:	e9 97 00 00 00       	jmpq   80e9f4 <sys_untimeout+0x11d>
    if ((t->h == h) && (t->arg == arg)) {
  80e95d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e961:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e965:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80e969:	75 76                	jne    80e9e1 <sys_untimeout+0x10a>
  80e96b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e96f:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e973:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80e977:	75 68                	jne    80e9e1 <sys_untimeout+0x10a>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80e979:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e97e:	75 10                	jne    80e990 <sys_untimeout+0xb9>
        timeouts->next = t->next;
  80e980:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e984:	48 8b 10             	mov    (%rax),%rdx
  80e987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e98b:	48 89 10             	mov    %rdx,(%rax)
  80e98e:	eb 0e                	jmp    80e99e <sys_untimeout+0xc7>
      else
        prev_t->next = t->next;
  80e990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e994:	48 8b 10             	mov    (%rax),%rdx
  80e997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e99b:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80e99e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9a2:	48 8b 00             	mov    (%rax),%rax
  80e9a5:	48 85 c0             	test   %rax,%rax
  80e9a8:	74 1d                	je     80e9c7 <sys_untimeout+0xf0>
        t->next->time += t->time;
  80e9aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9ae:	48 8b 00             	mov    (%rax),%rax
  80e9b1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9b5:	48 8b 12             	mov    (%rdx),%rdx
  80e9b8:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e9bb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9bf:	8b 52 08             	mov    0x8(%rdx),%edx
  80e9c2:	01 ca                	add    %ecx,%edx
  80e9c4:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80e9c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9cb:	48 89 c6             	mov    %rax,%rsi
  80e9ce:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e9d3:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80e9da:	00 00 00 
  80e9dd:	ff d0                	callq  *%rax
      return;
  80e9df:	eb 1f                	jmp    80ea00 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e9e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e9e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9ed:	48 8b 00             	mov    (%rax),%rax
  80e9f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e9f4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e9f9:	0f 85 5e ff ff ff    	jne    80e95d <sys_untimeout+0x86>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80e9ff:	90                   	nop
}
  80ea00:	c9                   	leaveq 
  80ea01:	c3                   	retq   

000000000080ea02 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80ea02:	55                   	push   %rbp
  80ea03:	48 89 e5             	mov    %rsp,%rbp
  80ea06:	48 83 ec 20          	sub    $0x20,%rsp
  80ea0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80ea0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80ea16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea1a:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80ea1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea23:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ea27:	8b 00                	mov    (%rax),%eax
  80ea29:	89 c7                	mov    %eax,%edi
  80ea2b:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  80ea32:	00 00 00 
  80ea35:	ff d0                	callq  *%rax
}
  80ea37:	c9                   	leaveq 
  80ea38:	c3                   	retq   

000000000080ea39 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80ea39:	55                   	push   %rbp
  80ea3a:	48 89 e5             	mov    %rsp,%rbp
  80ea3d:	48 83 ec 20          	sub    $0x20,%rsp
  80ea41:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80ea44:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80ea47:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80ea4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80ea4f:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80ea55:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80ea59:	74 1f                	je     80ea7a <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80ea5b:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80ea5f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80ea62:	48 be 02 ea 80 00 00 	movabs $0x80ea02,%rsi
  80ea69:	00 00 00 
  80ea6c:	89 c7                	mov    %eax,%edi
  80ea6e:	48 b8 f2 e6 80 00 00 	movabs $0x80e6f2,%rax
  80ea75:	00 00 00 
  80ea78:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80ea7a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80ea7d:	89 c7                	mov    %eax,%edi
  80ea7f:	48 b8 cb e5 80 00 00 	movabs $0x80e5cb,%rax
  80ea86:	00 00 00 
  80ea89:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80ea8b:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80ea8f:	66 85 c0             	test   %ax,%ax
  80ea92:	74 07                	je     80ea9b <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80ea94:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea99:	eb 22                	jmp    80eabd <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80ea9b:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80ea9f:	48 89 c6             	mov    %rax,%rsi
  80eaa2:	48 bf 02 ea 80 00 00 	movabs $0x80ea02,%rdi
  80eaa9:	00 00 00 
  80eaac:	48 b8 d7 e8 80 00 00 	movabs $0x80e8d7,%rax
  80eab3:	00 00 00 
  80eab6:	ff d0                	callq  *%rax
    return 1;
  80eab8:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80eabd:	c9                   	leaveq 
  80eabe:	c3                   	retq   

000000000080eabf <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80eabf:	55                   	push   %rbp
  80eac0:	48 89 e5             	mov    %rsp,%rbp
  80eac3:	48 83 ec 20          	sub    $0x20,%rsp
  80eac7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80eaca:	bf 00 00 00 00       	mov    $0x0,%edi
  80eacf:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  80ead6:	00 00 00 
  80ead9:	ff d0                	callq  *%rax
  80eadb:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80eade:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80eae1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80eae4:	89 d6                	mov    %edx,%esi
  80eae6:	89 c7                	mov    %eax,%edi
  80eae8:	48 b8 39 ea 80 00 00 	movabs $0x80ea39,%rax
  80eaef:	00 00 00 
  80eaf2:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80eaf4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80eaf7:	89 c7                	mov    %eax,%edi
  80eaf9:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  80eb00:	00 00 00 
  80eb03:	ff d0                	callq  *%rax
}
  80eb05:	c9                   	leaveq 
  80eb06:	c3                   	retq   

000000000080eb07 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80eb07:	55                   	push   %rbp
  80eb08:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80eb0b:	48 b8 fa 01 81 00 00 	movabs $0x8101fa,%rax
  80eb12:	00 00 00 
  80eb15:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80eb17:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80eb1e:	00 00 00 
  80eb21:	0f b6 00             	movzbl (%rax),%eax
  80eb24:	8d 50 01             	lea    0x1(%rax),%edx
  80eb27:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80eb2e:	00 00 00 
  80eb31:	88 10                	mov    %dl,(%rax)
  80eb33:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80eb3a:	00 00 00 
  80eb3d:	0f b6 00             	movzbl (%rax),%eax
  80eb40:	0f b6 c0             	movzbl %al,%eax
  80eb43:	83 e0 01             	and    $0x1,%eax
  80eb46:	85 c0                	test   %eax,%eax
  80eb48:	74 0c                	je     80eb56 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80eb4a:	48 b8 be f9 80 00 00 	movabs $0x80f9be,%rax
  80eb51:	00 00 00 
  80eb54:	ff d0                	callq  *%rax
  }
}
  80eb56:	5d                   	pop    %rbp
  80eb57:	c3                   	retq   

000000000080eb58 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80eb58:	55                   	push   %rbp
  80eb59:	48 89 e5             	mov    %rsp,%rbp
  80eb5c:	48 83 ec 20          	sub    $0x20,%rsp
  80eb60:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80eb64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb68:	8b 40 18             	mov    0x18(%rax),%eax
  80eb6b:	83 f8 07             	cmp    $0x7,%eax
  80eb6e:	0f 87 37 02 00 00    	ja     80edab <tcp_close+0x253>
  80eb74:	89 c0                	mov    %eax,%eax
  80eb76:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80eb7d:	00 
  80eb7e:	48 b8 50 22 82 00 00 	movabs $0x822250,%rax
  80eb85:	00 00 00 
  80eb88:	48 01 d0             	add    %rdx,%rax
  80eb8b:	48 8b 00             	mov    (%rax),%rax
  80eb8e:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80eb90:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80eb94:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eb9b:	00 00 00 
  80eb9e:	48 8b 00             	mov    (%rax),%rax
  80eba1:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80eba5:	75 23                	jne    80ebca <tcp_close+0x72>
  80eba7:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ebae:	00 00 00 
  80ebb1:	48 8b 00             	mov    (%rax),%rax
  80ebb4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ebb8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ebbf:	00 00 00 
  80ebc2:	48 89 10             	mov    %rdx,(%rax)
  80ebc5:	e9 94 00 00 00       	jmpq   80ec5e <tcp_close+0x106>
  80ebca:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ebd1:	00 00 00 
  80ebd4:	48 8b 10             	mov    (%rax),%rdx
  80ebd7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ebde:	00 00 00 
  80ebe1:	48 89 10             	mov    %rdx,(%rax)
  80ebe4:	eb 66                	jmp    80ec4c <tcp_close+0xf4>
  80ebe6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ebed:	00 00 00 
  80ebf0:	48 8b 00             	mov    (%rax),%rax
  80ebf3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ebf7:	48 85 c0             	test   %rax,%rax
  80ebfa:	74 32                	je     80ec2e <tcp_close+0xd6>
  80ebfc:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ec03:	00 00 00 
  80ec06:	48 8b 00             	mov    (%rax),%rax
  80ec09:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ec0d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ec11:	75 1b                	jne    80ec2e <tcp_close+0xd6>
  80ec13:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ec1a:	00 00 00 
  80ec1d:	48 8b 00             	mov    (%rax),%rax
  80ec20:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ec24:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ec28:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ec2c:	eb 30                	jmp    80ec5e <tcp_close+0x106>
  80ec2e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ec35:	00 00 00 
  80ec38:	48 8b 00             	mov    (%rax),%rax
  80ec3b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ec3f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ec46:	00 00 00 
  80ec49:	48 89 10             	mov    %rdx,(%rax)
  80ec4c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ec53:	00 00 00 
  80ec56:	48 8b 00             	mov    (%rax),%rax
  80ec59:	48 85 c0             	test   %rax,%rax
  80ec5c:	75 88                	jne    80ebe6 <tcp_close+0x8e>
  80ec5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec62:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ec69:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80ec6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec6e:	48 89 c6             	mov    %rax,%rsi
  80ec71:	bf 02 00 00 00       	mov    $0x2,%edi
  80ec76:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ec7d:	00 00 00 
  80ec80:	ff d0                	callq  *%rax
    pcb = NULL;
  80ec82:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ec89:	00 
    break;
  80ec8a:	e9 29 01 00 00       	jmpq   80edb8 <tcp_close+0x260>
  case LISTEN:
    err = ERR_OK;
  80ec8f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80ec93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec97:	48 89 c6             	mov    %rax,%rsi
  80ec9a:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80eca1:	00 00 00 
  80eca4:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  80ecab:	00 00 00 
  80ecae:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80ecb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecb4:	48 89 c6             	mov    %rax,%rsi
  80ecb7:	bf 03 00 00 00       	mov    $0x3,%edi
  80ecbc:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ecc3:	00 00 00 
  80ecc6:	ff d0                	callq  *%rax
    pcb = NULL;
  80ecc8:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eccf:	00 
    break;
  80ecd0:	e9 e3 00 00 00       	jmpq   80edb8 <tcp_close+0x260>
  case SYN_SENT:
    err = ERR_OK;
  80ecd5:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ecd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecdd:	48 89 c6             	mov    %rax,%rsi
  80ece0:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ece7:	00 00 00 
  80ecea:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  80ecf1:	00 00 00 
  80ecf4:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ecf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecfa:	48 89 c6             	mov    %rax,%rsi
  80ecfd:	bf 02 00 00 00       	mov    $0x2,%edi
  80ed02:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ed09:	00 00 00 
  80ed0c:	ff d0                	callq  *%rax
    pcb = NULL;
  80ed0e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ed15:	00 
    snmp_inc_tcpattemptfails();
    break;
  80ed16:	e9 9d 00 00 00       	jmpq   80edb8 <tcp_close+0x260>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ed1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed1f:	be 01 00 00 00       	mov    $0x1,%esi
  80ed24:	48 89 c7             	mov    %rax,%rdi
  80ed27:	48 b8 89 2f 81 00 00 	movabs $0x812f89,%rax
  80ed2e:	00 00 00 
  80ed31:	ff d0                	callq  *%rax
  80ed33:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ed36:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ed3a:	75 0d                	jne    80ed49 <tcp_close+0x1f1>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80ed3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed40:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ed47:	eb 6f                	jmp    80edb8 <tcp_close+0x260>
  80ed49:	eb 6d                	jmp    80edb8 <tcp_close+0x260>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ed4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed4f:	be 01 00 00 00       	mov    $0x1,%esi
  80ed54:	48 89 c7             	mov    %rax,%rdi
  80ed57:	48 b8 89 2f 81 00 00 	movabs $0x812f89,%rax
  80ed5e:	00 00 00 
  80ed61:	ff d0                	callq  *%rax
  80ed63:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ed66:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ed6a:	75 0d                	jne    80ed79 <tcp_close+0x221>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80ed6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed70:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ed77:	eb 3f                	jmp    80edb8 <tcp_close+0x260>
  80ed79:	eb 3d                	jmp    80edb8 <tcp_close+0x260>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ed7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed7f:	be 01 00 00 00       	mov    $0x1,%esi
  80ed84:	48 89 c7             	mov    %rax,%rdi
  80ed87:	48 b8 89 2f 81 00 00 	movabs $0x812f89,%rax
  80ed8e:	00 00 00 
  80ed91:	ff d0                	callq  *%rax
  80ed93:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ed96:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ed9a:	75 0d                	jne    80eda9 <tcp_close+0x251>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80ed9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eda0:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80eda7:	eb 0f                	jmp    80edb8 <tcp_close+0x260>
  80eda9:	eb 0d                	jmp    80edb8 <tcp_close+0x260>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80edab:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80edaf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80edb6:	00 
    break;
  80edb7:	90                   	nop
  }

  if (pcb != NULL && err == ERR_OK) {
  80edb8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80edbd:	74 19                	je     80edd8 <tcp_close+0x280>
  80edbf:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80edc3:	75 13                	jne    80edd8 <tcp_close+0x280>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80edc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edc9:	48 89 c7             	mov    %rax,%rdi
  80edcc:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  80edd3:	00 00 00 
  80edd6:	ff d0                	callq  *%rax
  }
  return err;
  80edd8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80eddc:	c9                   	leaveq 
  80eddd:	c3                   	retq   

000000000080edde <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80edde:	55                   	push   %rbp
  80eddf:	48 89 e5             	mov    %rsp,%rbp
  80ede2:	48 83 ec 50          	sub    $0x50,%rsp
  80ede6:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80edea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80edee:	8b 40 18             	mov    0x18(%rax),%eax
  80edf1:	83 f8 0a             	cmp    $0xa,%eax
  80edf4:	75 3a                	jne    80ee30 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80edf6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80edfa:	48 89 c6             	mov    %rax,%rsi
  80edfd:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80ee04:	00 00 00 
  80ee07:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  80ee0e:	00 00 00 
  80ee11:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ee13:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee17:	48 89 c6             	mov    %rax,%rsi
  80ee1a:	bf 02 00 00 00       	mov    $0x2,%edi
  80ee1f:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ee26:	00 00 00 
  80ee29:	ff d0                	callq  *%rax
  80ee2b:	e9 75 01 00 00       	jmpq   80efa5 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80ee30:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee34:	8b 40 60             	mov    0x60(%rax),%eax
  80ee37:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80ee3a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee3e:	8b 40 30             	mov    0x30(%rax),%eax
  80ee41:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80ee44:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee48:	48 85 c0             	test   %rax,%rax
  80ee4b:	74 08                	je     80ee55 <tcp_abort+0x77>
  80ee4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee51:	8b 00                	mov    (%rax),%eax
  80ee53:	eb 05                	jmp    80ee5a <tcp_abort+0x7c>
  80ee55:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee5a:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80ee5d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee61:	48 83 c0 04          	add    $0x4,%rax
  80ee65:	48 85 c0             	test   %rax,%rax
  80ee68:	74 09                	je     80ee73 <tcp_abort+0x95>
  80ee6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee6e:	8b 40 04             	mov    0x4(%rax),%eax
  80ee71:	eb 05                	jmp    80ee78 <tcp_abort+0x9a>
  80ee73:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee78:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80ee7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee7f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ee83:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80ee87:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee8b:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80ee8f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80ee93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ee97:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80ee9e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80eea2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eea6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80eeaa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80eeae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eeb2:	48 89 c6             	mov    %rax,%rsi
  80eeb5:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80eebc:	00 00 00 
  80eebf:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  80eec6:	00 00 00 
  80eec9:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80eecb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eecf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80eed6:	48 85 c0             	test   %rax,%rax
  80eed9:	74 1a                	je     80eef5 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80eedb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eedf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80eee6:	48 89 c7             	mov    %rax,%rdi
  80eee9:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  80eef0:	00 00 00 
  80eef3:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80eef5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eef9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ef00:	48 85 c0             	test   %rax,%rax
  80ef03:	74 1a                	je     80ef1f <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80ef05:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef09:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ef10:	48 89 c7             	mov    %rax,%rdi
  80ef13:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  80ef1a:	00 00 00 
  80ef1d:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80ef1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef23:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ef2a:	48 85 c0             	test   %rax,%rax
  80ef2d:	74 1a                	je     80ef49 <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80ef2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef33:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ef3a:	48 89 c7             	mov    %rax,%rdi
  80ef3d:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  80ef44:	00 00 00 
  80ef47:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80ef49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef4d:	48 89 c6             	mov    %rax,%rsi
  80ef50:	bf 02 00 00 00       	mov    $0x2,%edi
  80ef55:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ef5c:	00 00 00 
  80ef5f:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80ef61:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ef66:	74 12                	je     80ef7a <tcp_abort+0x19c>
  80ef68:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ef6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef70:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80ef75:	48 89 d7             	mov    %rdx,%rdi
  80ef78:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80ef7a:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80ef7f:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80ef83:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80ef87:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80ef8b:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80ef8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ef91:	45 89 c1             	mov    %r8d,%r9d
  80ef94:	41 89 f8             	mov    %edi,%r8d
  80ef97:	89 c7                	mov    %eax,%edi
  80ef99:	48 b8 27 44 81 00 00 	movabs $0x814427,%rax
  80efa0:	00 00 00 
  80efa3:	ff d0                	callq  *%rax
  }
}
  80efa5:	c9                   	leaveq 
  80efa6:	c3                   	retq   

000000000080efa7 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80efa7:	55                   	push   %rbp
  80efa8:	48 89 e5             	mov    %rsp,%rbp
  80efab:	48 83 ec 30          	sub    $0x30,%rsp
  80efaf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80efb3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80efb7:	89 d0                	mov    %edx,%eax
  80efb9:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80efbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efc1:	8b 40 18             	mov    0x18(%rax),%eax
  80efc4:	85 c0                	test   %eax,%eax
  80efc6:	74 2a                	je     80eff2 <tcp_bind+0x4b>
  80efc8:	48 ba 90 22 82 00 00 	movabs $0x822290,%rdx
  80efcf:	00 00 00 
  80efd2:	be 05 01 00 00       	mov    $0x105,%esi
  80efd7:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80efde:	00 00 00 
  80efe1:	b8 00 00 00 00       	mov    $0x0,%eax
  80efe6:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80efed:	00 00 00 
  80eff0:	ff d1                	callq  *%rcx

  if (port == 0) {
  80eff2:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80eff7:	75 10                	jne    80f009 <tcp_bind+0x62>
    port = tcp_new_port();
  80eff9:	48 b8 c0 f5 80 00 00 	movabs $0x80f5c0,%rax
  80f000:	00 00 00 
  80f003:	ff d0                	callq  *%rax
  80f005:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f009:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f010:	00 00 00 
  80f013:	48 8b 00             	mov    (%rax),%rax
  80f016:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f01a:	eb 58                	jmp    80f074 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f01c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f020:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f024:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f028:	75 3e                	jne    80f068 <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f02a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f02e:	48 85 c0             	test   %rax,%rax
  80f031:	74 2b                	je     80f05e <tcp_bind+0xb7>
  80f033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f037:	8b 00                	mov    (%rax),%eax
  80f039:	85 c0                	test   %eax,%eax
  80f03b:	74 21                	je     80f05e <tcp_bind+0xb7>
  80f03d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f042:	74 1a                	je     80f05e <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80f044:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f048:	8b 00                	mov    (%rax),%eax
  80f04a:	85 c0                	test   %eax,%eax
  80f04c:	74 10                	je     80f05e <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f04e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f052:	8b 10                	mov    (%rax),%edx
  80f054:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f058:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f05a:	39 c2                	cmp    %eax,%edx
  80f05c:	75 0a                	jne    80f068 <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f05e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f063:	e9 a2 01 00 00       	jmpq   80f20a <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f06c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f070:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f074:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f079:	75 a1                	jne    80f01c <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f07b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f082:	00 00 00 
  80f085:	48 8b 00             	mov    (%rax),%rax
  80f088:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f08c:	eb 58                	jmp    80f0e6 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f08e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f092:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f096:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f09a:	75 3e                	jne    80f0da <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f09c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0a0:	48 85 c0             	test   %rax,%rax
  80f0a3:	74 2b                	je     80f0d0 <tcp_bind+0x129>
  80f0a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0a9:	8b 00                	mov    (%rax),%eax
  80f0ab:	85 c0                	test   %eax,%eax
  80f0ad:	74 21                	je     80f0d0 <tcp_bind+0x129>
  80f0af:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f0b4:	74 1a                	je     80f0d0 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80f0b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f0ba:	8b 00                	mov    (%rax),%eax
  80f0bc:	85 c0                	test   %eax,%eax
  80f0be:	74 10                	je     80f0d0 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f0c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0c4:	8b 10                	mov    (%rax),%edx
  80f0c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f0ca:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f0cc:	39 c2                	cmp    %eax,%edx
  80f0ce:	75 0a                	jne    80f0da <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f0d0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f0d5:	e9 30 01 00 00       	jmpq   80f20a <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f0da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0de:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f0e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f0e6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f0eb:	75 a1                	jne    80f08e <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f0ed:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f0f4:	00 00 00 
  80f0f7:	48 8b 00             	mov    (%rax),%rax
  80f0fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f0fe:	eb 58                	jmp    80f158 <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80f100:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f104:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f108:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f10c:	75 3e                	jne    80f14c <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f10e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f112:	48 85 c0             	test   %rax,%rax
  80f115:	74 2b                	je     80f142 <tcp_bind+0x19b>
  80f117:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f11b:	8b 00                	mov    (%rax),%eax
  80f11d:	85 c0                	test   %eax,%eax
  80f11f:	74 21                	je     80f142 <tcp_bind+0x19b>
  80f121:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f126:	74 1a                	je     80f142 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80f128:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f12c:	8b 00                	mov    (%rax),%eax
  80f12e:	85 c0                	test   %eax,%eax
  80f130:	74 10                	je     80f142 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f132:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f136:	8b 10                	mov    (%rax),%edx
  80f138:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f13c:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f13e:	39 c2                	cmp    %eax,%edx
  80f140:	75 0a                	jne    80f14c <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f142:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f147:	e9 be 00 00 00       	jmpq   80f20a <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f14c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f150:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f154:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f158:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f15d:	75 a1                	jne    80f100 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f15f:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f166:	00 00 00 
  80f169:	48 8b 00             	mov    (%rax),%rax
  80f16c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f170:	eb 31                	jmp    80f1a3 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80f172:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f176:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f17a:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f17e:	75 17                	jne    80f197 <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f184:	8b 10                	mov    (%rax),%edx
  80f186:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f18a:	8b 00                	mov    (%rax),%eax
  80f18c:	39 c2                	cmp    %eax,%edx
  80f18e:	75 07                	jne    80f197 <tcp_bind+0x1f0>
        return ERR_USE;
  80f190:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f195:	eb 73                	jmp    80f20a <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f197:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f19b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f19f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1a3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f1a8:	75 c8                	jne    80f172 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80f1aa:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f1af:	74 16                	je     80f1c7 <tcp_bind+0x220>
  80f1b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f1b5:	8b 00                	mov    (%rax),%eax
  80f1b7:	85 c0                	test   %eax,%eax
  80f1b9:	74 0c                	je     80f1c7 <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80f1bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f1bf:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f1c3:	8b 12                	mov    (%rdx),%edx
  80f1c5:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80f1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f1cb:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f1cf:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80f1d3:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f1da:	00 00 00 
  80f1dd:	48 8b 10             	mov    (%rax),%rdx
  80f1e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f1e4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f1e8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f1ef:	00 00 00 
  80f1f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f1f6:	48 89 10             	mov    %rdx,(%rax)
  80f1f9:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  80f200:	00 00 00 
  80f203:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80f205:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f20a:	c9                   	leaveq 
  80f20b:	c3                   	retq   

000000000080f20c <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80f20c:	55                   	push   %rbp
  80f20d:	48 89 e5             	mov    %rsp,%rbp
  80f210:	48 83 ec 14          	sub    $0x14,%rsp
  80f214:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f218:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f21c:	89 d0                	mov    %edx,%eax
  80f21e:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80f221:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80f226:	c9                   	leaveq 
  80f227:	c3                   	retq   

000000000080f228 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80f228:	55                   	push   %rbp
  80f229:	48 89 e5             	mov    %rsp,%rbp
  80f22c:	53                   	push   %rbx
  80f22d:	48 83 ec 28          	sub    $0x28,%rsp
  80f231:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80f235:	89 f0                	mov    %esi,%eax
  80f237:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80f23a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f23e:	8b 40 18             	mov    0x18(%rax),%eax
  80f241:	85 c0                	test   %eax,%eax
  80f243:	74 2a                	je     80f26f <tcp_listen_with_backlog+0x47>
  80f245:	48 ba d0 22 82 00 00 	movabs $0x8222d0,%rdx
  80f24c:	00 00 00 
  80f24f:	be 60 01 00 00       	mov    $0x160,%esi
  80f254:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80f25b:	00 00 00 
  80f25e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f263:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80f26a:	00 00 00 
  80f26d:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80f26f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f273:	8b 40 18             	mov    0x18(%rax),%eax
  80f276:	83 f8 01             	cmp    $0x1,%eax
  80f279:	75 09                	jne    80f284 <tcp_listen_with_backlog+0x5c>
    return pcb;
  80f27b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f27f:	e9 e6 01 00 00       	jmpq   80f46a <tcp_listen_with_backlog+0x242>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80f284:	bf 03 00 00 00       	mov    $0x3,%edi
  80f289:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  80f290:	00 00 00 
  80f293:	ff d0                	callq  *%rax
  80f295:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (lpcb == NULL) {
  80f299:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f29e:	75 0a                	jne    80f2aa <tcp_listen_with_backlog+0x82>
    return NULL;
  80f2a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2a5:	e9 c0 01 00 00       	jmpq   80f46a <tcp_listen_with_backlog+0x242>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80f2aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f2ae:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80f2b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2b6:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80f2ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f2be:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f2c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2c6:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80f2ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2ce:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f2d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f2d9:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f2dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2e1:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f2e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2e9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f2ed:	83 c8 02             	or     $0x2,%eax
  80f2f0:	89 c2                	mov    %eax,%edx
  80f2f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2f6:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f2fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f2fe:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f302:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f306:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f309:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f30d:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f315:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f318:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f31c:	48 85 c0             	test   %rax,%rax
  80f31f:	74 08                	je     80f329 <tcp_listen_with_backlog+0x101>
  80f321:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f325:	8b 00                	mov    (%rax),%eax
  80f327:	eb 05                	jmp    80f32e <tcp_listen_with_backlog+0x106>
  80f329:	b8 00 00 00 00       	mov    $0x0,%eax
  80f32e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f332:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f334:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f33b:	00 00 00 
  80f33e:	48 8b 00             	mov    (%rax),%rax
  80f341:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f345:	75 23                	jne    80f36a <tcp_listen_with_backlog+0x142>
  80f347:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f34e:	00 00 00 
  80f351:	48 8b 00             	mov    (%rax),%rax
  80f354:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f358:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f35f:	00 00 00 
  80f362:	48 89 10             	mov    %rdx,(%rax)
  80f365:	e9 94 00 00 00       	jmpq   80f3fe <tcp_listen_with_backlog+0x1d6>
  80f36a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f371:	00 00 00 
  80f374:	48 8b 10             	mov    (%rax),%rdx
  80f377:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f37e:	00 00 00 
  80f381:	48 89 10             	mov    %rdx,(%rax)
  80f384:	eb 66                	jmp    80f3ec <tcp_listen_with_backlog+0x1c4>
  80f386:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f38d:	00 00 00 
  80f390:	48 8b 00             	mov    (%rax),%rax
  80f393:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f397:	48 85 c0             	test   %rax,%rax
  80f39a:	74 32                	je     80f3ce <tcp_listen_with_backlog+0x1a6>
  80f39c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3a3:	00 00 00 
  80f3a6:	48 8b 00             	mov    (%rax),%rax
  80f3a9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f3ad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f3b1:	75 1b                	jne    80f3ce <tcp_listen_with_backlog+0x1a6>
  80f3b3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3ba:	00 00 00 
  80f3bd:	48 8b 00             	mov    (%rax),%rax
  80f3c0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80f3c4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f3c8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f3cc:	eb 30                	jmp    80f3fe <tcp_listen_with_backlog+0x1d6>
  80f3ce:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3d5:	00 00 00 
  80f3d8:	48 8b 00             	mov    (%rax),%rax
  80f3db:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f3df:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3e6:	00 00 00 
  80f3e9:	48 89 10             	mov    %rdx,(%rax)
  80f3ec:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3f3:	00 00 00 
  80f3f6:	48 8b 00             	mov    (%rax),%rax
  80f3f9:	48 85 c0             	test   %rax,%rax
  80f3fc:	75 88                	jne    80f386 <tcp_listen_with_backlog+0x15e>
  80f3fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f402:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f409:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f40a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f40e:	48 89 c6             	mov    %rax,%rsi
  80f411:	bf 02 00 00 00       	mov    $0x2,%edi
  80f416:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80f41d:	00 00 00 
  80f420:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f426:	48 bb 0c f2 80 00 00 	movabs $0x80f20c,%rbx
  80f42d:	00 00 00 
  80f430:	48 89 58 30          	mov    %rbx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f434:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f43b:	00 00 00 
  80f43e:	48 8b 10             	mov    (%rax),%rdx
  80f441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f445:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f449:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f450:	00 00 00 
  80f453:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f457:	48 89 10             	mov    %rdx,(%rax)
  80f45a:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  80f461:	00 00 00 
  80f464:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f466:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80f46a:	48 83 c4 28          	add    $0x28,%rsp
  80f46e:	5b                   	pop    %rbx
  80f46f:	5d                   	pop    %rbp
  80f470:	c3                   	retq   

000000000080f471 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f471:	55                   	push   %rbp
  80f472:	48 89 e5             	mov    %rsp,%rbp
  80f475:	48 83 ec 10          	sub    $0x10,%rsp
  80f479:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f47d:	89 f0                	mov    %esi,%eax
  80f47f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f483:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f487:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f48b:	0f b7 d0             	movzwl %ax,%edx
  80f48e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f492:	01 d0                	add    %edx,%eax
  80f494:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f499:	76 16                	jbe    80f4b1 <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f49b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f49f:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f4a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4a9:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f4af:	eb 3b                	jmp    80f4ec <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f4b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4b5:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f4b9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f4bd:	01 c2                	add    %eax,%edx
  80f4bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4c3:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f4c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4cb:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f4cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4d3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f4d7:	66 39 c2             	cmp    %ax,%dx
  80f4da:	72 10                	jb     80f4ec <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f4dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4e0:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f4e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4e8:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f4ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4f0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f4f4:	0f b6 c0             	movzbl %al,%eax
  80f4f7:	83 e0 01             	and    $0x1,%eax
  80f4fa:	85 c0                	test   %eax,%eax
  80f4fc:	75 77                	jne    80f575 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f4fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f502:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f506:	0f b6 c0             	movzbl %al,%eax
  80f509:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f50c:	85 c0                	test   %eax,%eax
  80f50e:	75 65                	jne    80f575 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f510:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f514:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f518:	0f b6 c0             	movzbl %al,%eax
  80f51b:	83 e0 01             	and    $0x1,%eax
  80f51e:	85 c0                	test   %eax,%eax
  80f520:	74 3d                	je     80f55f <tcp_recved+0xee>
  80f522:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f526:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f52a:	83 e0 fe             	and    $0xfffffffe,%eax
  80f52d:	89 c2                	mov    %eax,%edx
  80f52f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f533:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f536:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f53a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f53e:	83 c8 02             	or     $0x2,%eax
  80f541:	89 c2                	mov    %eax,%edx
  80f543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f547:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f54a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f54e:	48 89 c7             	mov    %rax,%rdi
  80f551:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  80f558:	00 00 00 
  80f55b:	ff d0                	callq  *%rax
  80f55d:	eb 5f                	jmp    80f5be <tcp_recved+0x14d>
  80f55f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f563:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f567:	83 c8 01             	or     $0x1,%eax
  80f56a:	89 c2                	mov    %eax,%edx
  80f56c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f570:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f573:	eb 49                	jmp    80f5be <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f575:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f579:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f57d:	0f b6 c0             	movzbl %al,%eax
  80f580:	83 e0 01             	and    $0x1,%eax
  80f583:	85 c0                	test   %eax,%eax
  80f585:	74 37                	je     80f5be <tcp_recved+0x14d>
  80f587:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f58b:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f58f:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f593:	76 29                	jbe    80f5be <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f595:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f599:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f59d:	83 c8 02             	or     $0x2,%eax
  80f5a0:	89 c2                	mov    %eax,%edx
  80f5a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5a6:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f5a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5ad:	48 89 c7             	mov    %rax,%rdi
  80f5b0:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  80f5b7:	00 00 00 
  80f5ba:	ff d0                	callq  *%rax
  80f5bc:	eb 00                	jmp    80f5be <tcp_recved+0x14d>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f5be:	c9                   	leaveq 
  80f5bf:	c3                   	retq   

000000000080f5c0 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f5c0:	55                   	push   %rbp
  80f5c1:	48 89 e5             	mov    %rsp,%rbp
  80f5c4:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f5c8:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f5cf:	00 00 00 
  80f5d2:	0f b7 00             	movzwl (%rax),%eax
  80f5d5:	8d 50 01             	lea    0x1(%rax),%edx
  80f5d8:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f5df:	00 00 00 
  80f5e2:	66 89 10             	mov    %dx,(%rax)
  80f5e5:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f5ec:	00 00 00 
  80f5ef:	0f b7 00             	movzwl (%rax),%eax
  80f5f2:	66 85 c0             	test   %ax,%ax
  80f5f5:	79 0f                	jns    80f606 <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f5f7:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f5fe:	00 00 00 
  80f601:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f606:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f60d:	00 00 00 
  80f610:	48 8b 00             	mov    (%rax),%rax
  80f613:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f617:	eb 28                	jmp    80f641 <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80f619:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f61d:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f621:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f628:	00 00 00 
  80f62b:	0f b7 00             	movzwl (%rax),%eax
  80f62e:	66 39 c2             	cmp    %ax,%dx
  80f631:	75 02                	jne    80f635 <tcp_new_port+0x75>
      goto again;
  80f633:	eb 93                	jmp    80f5c8 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f635:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f639:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f63d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f641:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f646:	75 d1                	jne    80f619 <tcp_new_port+0x59>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f648:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f64f:	00 00 00 
  80f652:	48 8b 00             	mov    (%rax),%rax
  80f655:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f659:	eb 2b                	jmp    80f686 <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80f65b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f65f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f663:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f66a:	00 00 00 
  80f66d:	0f b7 00             	movzwl (%rax),%eax
  80f670:	66 39 c2             	cmp    %ax,%dx
  80f673:	75 05                	jne    80f67a <tcp_new_port+0xba>
      goto again;
  80f675:	e9 4e ff ff ff       	jmpq   80f5c8 <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f67a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f67e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f682:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f686:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f68b:	75 ce                	jne    80f65b <tcp_new_port+0x9b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f68d:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f694:	00 00 00 
  80f697:	48 8b 00             	mov    (%rax),%rax
  80f69a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f69e:	eb 2b                	jmp    80f6cb <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80f6a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6a4:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f6a8:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f6af:	00 00 00 
  80f6b2:	0f b7 00             	movzwl (%rax),%eax
  80f6b5:	66 39 c2             	cmp    %ax,%dx
  80f6b8:	75 05                	jne    80f6bf <tcp_new_port+0xff>
      goto again;
  80f6ba:	e9 09 ff ff ff       	jmpq   80f5c8 <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f6bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6c3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f6c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f6cb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f6d0:	75 ce                	jne    80f6a0 <tcp_new_port+0xe0>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f6d2:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f6d9:	00 00 00 
  80f6dc:	0f b7 00             	movzwl (%rax),%eax
}
  80f6df:	c9                   	leaveq 
  80f6e0:	c3                   	retq   

000000000080f6e1 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f6e1:	55                   	push   %rbp
  80f6e2:	48 89 e5             	mov    %rsp,%rbp
  80f6e5:	48 83 ec 40          	sub    $0x40,%rsp
  80f6e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f6ed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f6f1:	89 d0                	mov    %edx,%eax
  80f6f3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f6f7:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f6fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f6ff:	8b 40 18             	mov    0x18(%rax),%eax
  80f702:	85 c0                	test   %eax,%eax
  80f704:	74 2a                	je     80f730 <tcp_connect+0x4f>
  80f706:	48 ba f8 22 82 00 00 	movabs $0x8222f8,%rdx
  80f70d:	00 00 00 
  80f710:	be ec 01 00 00       	mov    $0x1ec,%esi
  80f715:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80f71c:	00 00 00 
  80f71f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f724:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80f72b:	00 00 00 
  80f72e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f730:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f735:	74 28                	je     80f75f <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f737:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f73b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f73f:	8b 12                	mov    (%rdx),%edx
  80f741:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f744:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f748:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f74c:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f750:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f754:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f758:	66 85 c0             	test   %ax,%ax
  80f75b:	75 20                	jne    80f77d <tcp_connect+0x9c>
  80f75d:	eb 0a                	jmp    80f769 <tcp_connect+0x88>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f75f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f764:	e9 53 02 00 00       	jmpq   80f9bc <tcp_connect+0x2db>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f769:	48 b8 c0 f5 80 00 00 	movabs $0x80f5c0,%rax
  80f770:	00 00 00 
  80f773:	ff d0                	callq  *%rax
  80f775:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f779:	66 89 42 28          	mov    %ax,0x28(%rdx)
  }
  iss = tcp_next_iss();
  80f77d:	48 b8 85 0b 81 00 00 	movabs $0x810b85,%rax
  80f784:	00 00 00 
  80f787:	ff d0                	callq  *%rax
  80f789:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f78c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f790:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f79b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f79e:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f7a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f7a4:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f7a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7ab:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f7ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f7b1:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f7b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7b8:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f7bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7bf:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f7c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7c9:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f7cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7d3:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f7d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7dd:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f7e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f7e7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f7eb:	0f b7 c0             	movzwl %ax,%eax
  80f7ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f7f2:	48 89 d6             	mov    %rdx,%rsi
  80f7f5:	89 c7                	mov    %eax,%edi
  80f7f7:	48 b8 bd 0b 81 00 00 	movabs $0x810bbd,%rax
  80f7fe:	00 00 00 
  80f801:	ff d0                	callq  *%rax
  80f803:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f807:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f80b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f80f:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f815:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f819:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f81d:	89 d0                	mov    %edx,%eax
  80f81f:	c1 e0 02             	shl    $0x2,%eax
  80f822:	01 d0                	add    %edx,%eax
  80f824:	01 c0                	add    %eax,%eax
  80f826:	89 c2                	mov    %eax,%edx
  80f828:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f82c:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f834:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f83b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f83f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f843:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f84a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f851:	00 00 00 
  80f854:	48 8b 00             	mov    (%rax),%rax
  80f857:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f85b:	75 23                	jne    80f880 <tcp_connect+0x19f>
  80f85d:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f864:	00 00 00 
  80f867:	48 8b 00             	mov    (%rax),%rax
  80f86a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f86e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f875:	00 00 00 
  80f878:	48 89 10             	mov    %rdx,(%rax)
  80f87b:	e9 94 00 00 00       	jmpq   80f914 <tcp_connect+0x233>
  80f880:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f887:	00 00 00 
  80f88a:	48 8b 10             	mov    (%rax),%rdx
  80f88d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f894:	00 00 00 
  80f897:	48 89 10             	mov    %rdx,(%rax)
  80f89a:	eb 66                	jmp    80f902 <tcp_connect+0x221>
  80f89c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f8a3:	00 00 00 
  80f8a6:	48 8b 00             	mov    (%rax),%rax
  80f8a9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f8ad:	48 85 c0             	test   %rax,%rax
  80f8b0:	74 32                	je     80f8e4 <tcp_connect+0x203>
  80f8b2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f8b9:	00 00 00 
  80f8bc:	48 8b 00             	mov    (%rax),%rax
  80f8bf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f8c3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f8c7:	75 1b                	jne    80f8e4 <tcp_connect+0x203>
  80f8c9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f8d0:	00 00 00 
  80f8d3:	48 8b 00             	mov    (%rax),%rax
  80f8d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f8da:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f8de:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f8e2:	eb 30                	jmp    80f914 <tcp_connect+0x233>
  80f8e4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f8eb:	00 00 00 
  80f8ee:	48 8b 00             	mov    (%rax),%rax
  80f8f1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f8f5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f8fc:	00 00 00 
  80f8ff:	48 89 10             	mov    %rdx,(%rax)
  80f902:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f909:	00 00 00 
  80f90c:	48 8b 00             	mov    (%rax),%rax
  80f90f:	48 85 c0             	test   %rax,%rax
  80f912:	75 88                	jne    80f89c <tcp_connect+0x1bb>
  80f914:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f918:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f91f:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80f920:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f927:	00 00 00 
  80f92a:	48 8b 10             	mov    (%rax),%rdx
  80f92d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f931:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f935:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f93c:	00 00 00 
  80f93f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f943:	48 89 10             	mov    %rdx,(%rax)
  80f946:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  80f94d:	00 00 00 
  80f950:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80f952:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80f957:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  80f95e:	00 00 00 
  80f961:	ff d0                	callq  *%rax
  80f963:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80f966:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80f96a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f96e:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  80f975:	49 89 d1             	mov    %rdx,%r9
  80f978:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80f97e:	b9 02 00 00 00       	mov    $0x2,%ecx
  80f983:	ba 00 00 00 00       	mov    $0x0,%edx
  80f988:	be 00 00 00 00       	mov    $0x0,%esi
  80f98d:	48 89 c7             	mov    %rax,%rdi
  80f990:	48 b8 66 30 81 00 00 	movabs $0x813066,%rax
  80f997:	00 00 00 
  80f99a:	ff d0                	callq  *%rax
  80f99c:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80f99f:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80f9a3:	75 13                	jne    80f9b8 <tcp_connect+0x2d7>
    tcp_output(pcb);
  80f9a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9a9:	48 89 c7             	mov    %rax,%rdi
  80f9ac:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  80f9b3:	00 00 00 
  80f9b6:	ff d0                	callq  *%rax
  }
  return ret;
  80f9b8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80f9bc:	c9                   	leaveq 
  80f9bd:	c3                   	retq   

000000000080f9be <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80f9be:	55                   	push   %rbp
  80f9bf:	48 89 e5             	mov    %rsp,%rbp
  80f9c2:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80f9c6:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80f9ca:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f9d1:	00 00 00 
  80f9d4:	8b 00                	mov    (%rax),%eax
  80f9d6:	8d 50 01             	lea    0x1(%rax),%edx
  80f9d9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f9e0:	00 00 00 
  80f9e3:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80f9e5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f9ec:	00 
  pcb = tcp_active_pcbs;
  80f9ed:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f9f4:	00 00 00 
  80f9f7:	48 8b 00             	mov    (%rax),%rax
  80f9fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80f9fe:	e9 5e 06 00 00       	jmpq   810061 <tcp_slowtmr+0x6a3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80fa03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa07:	8b 40 18             	mov    0x18(%rax),%eax
  80fa0a:	85 c0                	test   %eax,%eax
  80fa0c:	75 2a                	jne    80fa38 <tcp_slowtmr+0x7a>
  80fa0e:	48 ba 30 23 82 00 00 	movabs $0x822330,%rdx
  80fa15:	00 00 00 
  80fa18:	be 36 02 00 00       	mov    $0x236,%esi
  80fa1d:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80fa24:	00 00 00 
  80fa27:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa2c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80fa33:	00 00 00 
  80fa36:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80fa38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa3c:	8b 40 18             	mov    0x18(%rax),%eax
  80fa3f:	83 f8 01             	cmp    $0x1,%eax
  80fa42:	75 2a                	jne    80fa6e <tcp_slowtmr+0xb0>
  80fa44:	48 ba 60 23 82 00 00 	movabs $0x822360,%rdx
  80fa4b:	00 00 00 
  80fa4e:	be 37 02 00 00       	mov    $0x237,%esi
  80fa53:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80fa5a:	00 00 00 
  80fa5d:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa62:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80fa69:	00 00 00 
  80fa6c:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80fa6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa72:	8b 40 18             	mov    0x18(%rax),%eax
  80fa75:	83 f8 0a             	cmp    $0xa,%eax
  80fa78:	75 2a                	jne    80faa4 <tcp_slowtmr+0xe6>
  80fa7a:	48 ba 90 23 82 00 00 	movabs $0x822390,%rdx
  80fa81:	00 00 00 
  80fa84:	be 38 02 00 00       	mov    $0x238,%esi
  80fa89:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80fa90:	00 00 00 
  80fa93:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa98:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80fa9f:	00 00 00 
  80faa2:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80faa4:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80faa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faac:	8b 40 18             	mov    0x18(%rax),%eax
  80faaf:	83 f8 02             	cmp    $0x2,%eax
  80fab2:	75 15                	jne    80fac9 <tcp_slowtmr+0x10b>
  80fab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fab8:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fabc:	3c 06                	cmp    $0x6,%al
  80fabe:	75 09                	jne    80fac9 <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80fac0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80fac4:	e9 e4 01 00 00       	jmpq   80fcad <tcp_slowtmr+0x2ef>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80fac9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80facd:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fad1:	3c 0c                	cmp    $0xc,%al
  80fad3:	75 09                	jne    80fade <tcp_slowtmr+0x120>
      ++pcb_remove;
  80fad5:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80fad9:	e9 cf 01 00 00       	jmpq   80fcad <tcp_slowtmr+0x2ef>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80fade:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fae2:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fae9:	84 c0                	test   %al,%al
  80faeb:	0f 84 9a 00 00 00    	je     80fb8b <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80faf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faf5:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80fafb:	8d 50 01             	lea    0x1(%rax),%edx
  80fafe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb02:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80fb08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb0c:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80fb12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb16:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fb1d:	0f b6 c0             	movzbl %al,%eax
  80fb20:	83 e8 01             	sub    $0x1,%eax
  80fb23:	48 ba 45 22 82 00 00 	movabs $0x822245,%rdx
  80fb2a:	00 00 00 
  80fb2d:	48 98                	cltq   
  80fb2f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fb33:	0f b6 c0             	movzbl %al,%eax
  80fb36:	39 c1                	cmp    %eax,%ecx
  80fb38:	0f 82 6f 01 00 00    	jb     80fcad <tcp_slowtmr+0x2ef>
          pcb->persist_cnt = 0;
  80fb3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb42:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80fb49:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80fb4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb50:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fb57:	3c 06                	cmp    $0x6,%al
  80fb59:	77 18                	ja     80fb73 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80fb5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb5f:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fb66:	8d 50 01             	lea    0x1(%rax),%edx
  80fb69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb6d:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80fb73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb77:	48 89 c7             	mov    %rax,%rdi
  80fb7a:	48 b8 f9 49 81 00 00 	movabs $0x8149f9,%rax
  80fb81:	00 00 00 
  80fb84:	ff d0                	callq  *%rax
  80fb86:	e9 22 01 00 00       	jmpq   80fcad <tcp_slowtmr+0x2ef>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80fb8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb8f:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fb93:	66 85 c0             	test   %ax,%ax
  80fb96:	78 13                	js     80fbab <tcp_slowtmr+0x1ed>
          ++pcb->rtime;
  80fb98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb9c:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fba0:	8d 50 01             	lea    0x1(%rax),%edx
  80fba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fba7:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80fbab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbaf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80fbb6:	48 85 c0             	test   %rax,%rax
  80fbb9:	0f 84 ee 00 00 00    	je     80fcad <tcp_slowtmr+0x2ef>
  80fbbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbc3:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80fbc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbcb:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fbcf:	66 39 c2             	cmp    %ax,%dx
  80fbd2:	0f 8c d5 00 00 00    	jl     80fcad <tcp_slowtmr+0x2ef>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80fbd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbdc:	8b 40 18             	mov    0x18(%rax),%eax
  80fbdf:	83 f8 02             	cmp    $0x2,%eax
  80fbe2:	74 49                	je     80fc2d <tcp_slowtmr+0x26f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80fbe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbe8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80fbec:	66 c1 f8 03          	sar    $0x3,%ax
  80fbf0:	0f bf d0             	movswl %ax,%edx
  80fbf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbf7:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80fbfb:	98                   	cwtl   
  80fbfc:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80fbff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc03:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fc07:	0f b6 c0             	movzbl %al,%eax
  80fc0a:	48 ba 38 22 82 00 00 	movabs $0x822238,%rdx
  80fc11:	00 00 00 
  80fc14:	48 98                	cltq   
  80fc16:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fc1a:	0f b6 c0             	movzbl %al,%eax
  80fc1d:	89 c1                	mov    %eax,%ecx
  80fc1f:	d3 e6                	shl    %cl,%esi
  80fc21:	89 f0                	mov    %esi,%eax
  80fc23:	89 c2                	mov    %eax,%edx
  80fc25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc29:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80fc2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc31:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80fc37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc3b:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80fc3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc43:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80fc47:	66 39 c2             	cmp    %ax,%dx
  80fc4a:	0f 46 c2             	cmovbe %edx,%eax
  80fc4d:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80fc51:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80fc55:	66 d1 e8             	shr    %ax
  80fc58:	89 c2                	mov    %eax,%edx
  80fc5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc5e:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80fc62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc66:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80fc6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc6e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fc72:	66 39 c2             	cmp    %ax,%dx
  80fc75:	73 13                	jae    80fc8a <tcp_slowtmr+0x2cc>
            pcb->ssthresh = pcb->mss * 2;
  80fc77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc7b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fc7f:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80fc82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc86:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80fc8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc8e:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80fc92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc96:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80fc9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc9e:	48 89 c7             	mov    %rax,%rdi
  80fca1:	48 b8 31 46 81 00 00 	movabs $0x814631,%rax
  80fca8:	00 00 00 
  80fcab:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80fcad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcb1:	8b 40 18             	mov    0x18(%rax),%eax
  80fcb4:	83 f8 06             	cmp    $0x6,%eax
  80fcb7:	75 20                	jne    80fcd9 <tcp_slowtmr+0x31b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fcb9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fcc0:	00 00 00 
  80fcc3:	8b 10                	mov    (%rax),%edx
  80fcc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcc9:	8b 40 38             	mov    0x38(%rax),%eax
  80fccc:	29 c2                	sub    %eax,%edx
  80fcce:	89 d0                	mov    %edx,%eax
  80fcd0:	83 f8 28             	cmp    $0x28,%eax
  80fcd3:	76 04                	jbe    80fcd9 <tcp_slowtmr+0x31b>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fcd5:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fcd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcdd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fce1:	0f b7 c0             	movzwl %ax,%eax
  80fce4:	83 e0 08             	and    $0x8,%eax
  80fce7:	85 c0                	test   %eax,%eax
  80fce9:	0f 84 01 01 00 00    	je     80fdf0 <tcp_slowtmr+0x432>
       ((pcb->state == ESTABLISHED) || 
  80fcef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcf3:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fcf6:	83 f8 04             	cmp    $0x4,%eax
  80fcf9:	74 10                	je     80fd0b <tcp_slowtmr+0x34d>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80fcfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcff:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80fd02:	83 f8 07             	cmp    $0x7,%eax
  80fd05:	0f 85 e5 00 00 00    	jne    80fdf0 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fd0b:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fd12:	00 00 00 
  80fd15:	8b 10                	mov    (%rax),%edx
  80fd17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd1b:	8b 40 38             	mov    0x38(%rax),%eax
  80fd1e:	29 c2                	sub    %eax,%edx
  80fd20:	89 d0                	mov    %edx,%eax
  80fd22:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fd24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd28:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fd2e:	89 c0                	mov    %eax,%eax
  80fd30:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fd36:	48 c1 e8 02          	shr    $0x2,%rax
  80fd3a:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fd41:	9b c4 20 
  80fd44:	48 f7 e2             	mul    %rdx
  80fd47:	48 89 d0             	mov    %rdx,%rax
  80fd4a:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fd4e:	48 39 c1             	cmp    %rax,%rcx
  80fd51:	76 18                	jbe    80fd6b <tcp_slowtmr+0x3ad>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80fd53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd57:	48 89 c7             	mov    %rax,%rdi
  80fd5a:	48 b8 de ed 80 00 00 	movabs $0x80edde,%rax
  80fd61:	00 00 00 
  80fd64:	ff d0                	callq  *%rax
  80fd66:	e9 85 00 00 00       	jmpq   80fdf0 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fd6b:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fd72:	00 00 00 
  80fd75:	8b 10                	mov    (%rax),%edx
  80fd77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd7b:	8b 40 38             	mov    0x38(%rax),%eax
  80fd7e:	29 c2                	sub    %eax,%edx
  80fd80:	89 d0                	mov    %edx,%eax
  80fd82:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80fd84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd88:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fd8e:	89 c2                	mov    %eax,%edx
  80fd90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd94:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fd9b:	0f b6 c0             	movzbl %al,%eax
  80fd9e:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80fda5:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80fda8:	48 c1 e8 02          	shr    $0x2,%rax
  80fdac:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fdb3:	9b c4 20 
  80fdb6:	48 f7 e2             	mul    %rdx
  80fdb9:	48 89 d0             	mov    %rdx,%rax
  80fdbc:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fdc0:	48 39 c1             	cmp    %rax,%rcx
  80fdc3:	76 2b                	jbe    80fdf0 <tcp_slowtmr+0x432>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80fdc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdc9:	48 89 c7             	mov    %rax,%rdi
  80fdcc:	48 b8 d4 47 81 00 00 	movabs $0x8147d4,%rax
  80fdd3:	00 00 00 
  80fdd6:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80fdd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fddc:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fde3:	8d 50 01             	lea    0x1(%rax),%edx
  80fde6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdea:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fdf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdf4:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fdfb:	48 85 c0             	test   %rax,%rax
  80fdfe:	74 57                	je     80fe57 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80fe00:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe07:	00 00 00 
  80fe0a:	8b 10                	mov    (%rax),%edx
  80fe0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe10:	8b 40 38             	mov    0x38(%rax),%eax
  80fe13:	89 d1                	mov    %edx,%ecx
  80fe15:	29 c1                	sub    %eax,%ecx
  80fe17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe1b:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fe1f:	0f bf d0             	movswl %ax,%edx
  80fe22:	89 d0                	mov    %edx,%eax
  80fe24:	01 c0                	add    %eax,%eax
  80fe26:	01 d0                	add    %edx,%eax
  80fe28:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fe2a:	39 c1                	cmp    %eax,%ecx
  80fe2c:	72 29                	jb     80fe57 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80fe2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe32:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fe39:	48 89 c7             	mov    %rax,%rdi
  80fe3c:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  80fe43:	00 00 00 
  80fe46:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80fe48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe4c:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80fe53:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80fe57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe5b:	8b 40 18             	mov    0x18(%rax),%eax
  80fe5e:	83 f8 03             	cmp    $0x3,%eax
  80fe61:	75 20                	jne    80fe83 <tcp_slowtmr+0x4c5>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fe63:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe6a:	00 00 00 
  80fe6d:	8b 10                	mov    (%rax),%edx
  80fe6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe73:	8b 40 38             	mov    0x38(%rax),%eax
  80fe76:	29 c2                	sub    %eax,%edx
  80fe78:	89 d0                	mov    %edx,%eax
  80fe7a:	83 f8 28             	cmp    $0x28,%eax
  80fe7d:	76 04                	jbe    80fe83 <tcp_slowtmr+0x4c5>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fe7f:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80fe83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe87:	8b 40 18             	mov    0x18(%rax),%eax
  80fe8a:	83 f8 09             	cmp    $0x9,%eax
  80fe8d:	75 22                	jne    80feb1 <tcp_slowtmr+0x4f3>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80fe8f:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe96:	00 00 00 
  80fe99:	8b 10                	mov    (%rax),%edx
  80fe9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9f:	8b 40 38             	mov    0x38(%rax),%eax
  80fea2:	29 c2                	sub    %eax,%edx
  80fea4:	89 d0                	mov    %edx,%eax
  80fea6:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80feab:	76 04                	jbe    80feb1 <tcp_slowtmr+0x4f3>
        ++pcb_remove;
  80fead:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80feb1:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80feb5:	0f 84 19 01 00 00    	je     80ffd4 <tcp_slowtmr+0x616>
      tcp_pcb_purge(pcb);      
  80febb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80febf:	48 89 c7             	mov    %rax,%rdi
  80fec2:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  80fec9:	00 00 00 
  80fecc:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80fece:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fed3:	74 4f                	je     80ff24 <tcp_slowtmr+0x566>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80fed5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fedc:	00 00 00 
  80fedf:	48 8b 00             	mov    (%rax),%rax
  80fee2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fee6:	75 2a                	jne    80ff12 <tcp_slowtmr+0x554>
  80fee8:	48 ba c0 23 82 00 00 	movabs $0x8223c0,%rdx
  80feef:	00 00 00 
  80fef2:	be c1 02 00 00       	mov    $0x2c1,%esi
  80fef7:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80fefe:	00 00 00 
  80ff01:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff06:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80ff0d:	00 00 00 
  80ff10:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80ff12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff16:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ff1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ff1e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ff22:	eb 52                	jmp    80ff76 <tcp_slowtmr+0x5b8>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80ff24:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ff2b:	00 00 00 
  80ff2e:	48 8b 00             	mov    (%rax),%rax
  80ff31:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80ff35:	74 2a                	je     80ff61 <tcp_slowtmr+0x5a3>
  80ff37:	48 ba f0 23 82 00 00 	movabs $0x8223f0,%rdx
  80ff3e:	00 00 00 
  80ff41:	be c5 02 00 00       	mov    $0x2c5,%esi
  80ff46:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  80ff4d:	00 00 00 
  80ff50:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff55:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  80ff5c:	00 00 00 
  80ff5f:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  80ff61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff65:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ff69:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ff70:	00 00 00 
  80ff73:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80ff76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff7a:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80ff81:	48 85 c0             	test   %rax,%rax
  80ff84:	74 1d                	je     80ffa3 <tcp_slowtmr+0x5e5>
  80ff86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff8a:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80ff91:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ff95:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80ff99:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80ff9e:	48 89 d7             	mov    %rdx,%rdi
  80ffa1:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  80ffa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffa7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ffab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80ffaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffb3:	48 89 c6             	mov    %rax,%rsi
  80ffb6:	bf 02 00 00 00       	mov    $0x2,%edi
  80ffbb:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  80ffc2:	00 00 00 
  80ffc5:	ff d0                	callq  *%rax
      pcb = pcb2;
  80ffc7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ffcb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ffcf:	e9 8d 00 00 00       	jmpq   810061 <tcp_slowtmr+0x6a3>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80ffd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffd8:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  80ffdc:	8d 50 01             	lea    0x1(%rax),%edx
  80ffdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffe3:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  80ffe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffea:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  80ffee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fff2:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  80fff6:	38 c2                	cmp    %al,%dl
  80fff8:	72 53                	jb     81004d <tcp_slowtmr+0x68f>
        pcb->polltmr = 0;
  80fffa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fffe:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  810002:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810006:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  81000d:	48 85 c0             	test   %rax,%rax
  810010:	74 22                	je     810034 <tcp_slowtmr+0x676>
  810012:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810016:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  81001d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  810021:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  810025:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  810029:	48 89 ce             	mov    %rcx,%rsi
  81002c:	48 89 d7             	mov    %rdx,%rdi
  81002f:	ff d0                	callq  *%rax
  810031:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  810034:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  810038:	75 13                	jne    81004d <tcp_slowtmr+0x68f>
          tcp_output(pcb);
  81003a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81003e:	48 89 c7             	mov    %rax,%rdi
  810041:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  810048:	00 00 00 
  81004b:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  81004d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810051:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810059:	48 8b 40 10          	mov    0x10(%rax),%rax
  81005d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  810061:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810066:	0f 85 97 f9 ff ff    	jne    80fa03 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  81006c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810073:	00 
  pcb = tcp_tw_pcbs;
  810074:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81007b:	00 00 00 
  81007e:	48 8b 00             	mov    (%rax),%rax
  810081:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  810085:	e9 63 01 00 00       	jmpq   8101ed <tcp_slowtmr+0x82f>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81008a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81008e:	8b 40 18             	mov    0x18(%rax),%eax
  810091:	83 f8 0a             	cmp    $0xa,%eax
  810094:	74 2a                	je     8100c0 <tcp_slowtmr+0x702>
  810096:	48 ba 20 24 82 00 00 	movabs $0x822420,%rdx
  81009d:	00 00 00 
  8100a0:	be e5 02 00 00       	mov    $0x2e5,%esi
  8100a5:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  8100ac:	00 00 00 
  8100af:	b8 00 00 00 00       	mov    $0x0,%eax
  8100b4:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8100bb:	00 00 00 
  8100be:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  8100c0:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8100c4:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8100cb:	00 00 00 
  8100ce:	8b 10                	mov    (%rax),%edx
  8100d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100d4:	8b 40 38             	mov    0x38(%rax),%eax
  8100d7:	29 c2                	sub    %eax,%edx
  8100d9:	89 d0                	mov    %edx,%eax
  8100db:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8100e0:	76 04                	jbe    8100e6 <tcp_slowtmr+0x728>
      ++pcb_remove;
  8100e2:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8100e6:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8100ea:	0f 84 e9 00 00 00    	je     8101d9 <tcp_slowtmr+0x81b>
      tcp_pcb_purge(pcb);      
  8100f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100f4:	48 89 c7             	mov    %rax,%rdi
  8100f7:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  8100fe:	00 00 00 
  810101:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  810103:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810108:	74 4f                	je     810159 <tcp_slowtmr+0x79b>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  81010a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810111:	00 00 00 
  810114:	48 8b 00             	mov    (%rax),%rax
  810117:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  81011b:	75 2a                	jne    810147 <tcp_slowtmr+0x789>
  81011d:	48 ba 50 24 82 00 00 	movabs $0x822450,%rdx
  810124:	00 00 00 
  810127:	be f4 02 00 00       	mov    $0x2f4,%esi
  81012c:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  810133:	00 00 00 
  810136:	b8 00 00 00 00       	mov    $0x0,%eax
  81013b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  810142:	00 00 00 
  810145:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  810147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81014b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81014f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810153:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810157:	eb 52                	jmp    8101ab <tcp_slowtmr+0x7ed>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  810159:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810160:	00 00 00 
  810163:	48 8b 00             	mov    (%rax),%rax
  810166:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81016a:	74 2a                	je     810196 <tcp_slowtmr+0x7d8>
  81016c:	48 ba 78 24 82 00 00 	movabs $0x822478,%rdx
  810173:	00 00 00 
  810176:	be f8 02 00 00       	mov    $0x2f8,%esi
  81017b:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  810182:	00 00 00 
  810185:	b8 00 00 00 00       	mov    $0x0,%eax
  81018a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  810191:	00 00 00 
  810194:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  810196:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81019a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81019e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8101a5:	00 00 00 
  8101a8:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  8101ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101af:	48 8b 40 10          	mov    0x10(%rax),%rax
  8101b3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  8101b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101bb:	48 89 c6             	mov    %rax,%rsi
  8101be:	bf 02 00 00 00       	mov    $0x2,%edi
  8101c3:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  8101ca:	00 00 00 
  8101cd:	ff d0                	callq  *%rax
      pcb = pcb2;
  8101cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8101d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8101d7:	eb 14                	jmp    8101ed <tcp_slowtmr+0x82f>
    } else {
      prev = pcb;
  8101d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  8101e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101e5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8101e9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8101ed:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8101f2:	0f 85 92 fe ff ff    	jne    81008a <tcp_slowtmr+0x6cc>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8101f8:	c9                   	leaveq 
  8101f9:	c3                   	retq   

00000000008101fa <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8101fa:	55                   	push   %rbp
  8101fb:	48 89 e5             	mov    %rsp,%rbp
  8101fe:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810202:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  810209:	00 00 00 
  81020c:	48 8b 00             	mov    (%rax),%rax
  81020f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810213:	e9 ee 00 00 00       	jmpq   810306 <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81021c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810223:	48 85 c0             	test   %rax,%rax
  810226:	0f 84 81 00 00 00    	je     8102ad <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81022c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810230:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810237:	48 85 c0             	test   %rax,%rax
  81023a:	74 2e                	je     81026a <tcp_fasttmr+0x70>
  81023c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810240:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810247:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81024b:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  810252:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  810256:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81025a:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81025e:	b9 00 00 00 00       	mov    $0x0,%ecx
  810263:	ff d0                	callq  *%rax
  810265:	88 45 f7             	mov    %al,-0x9(%rbp)
  810268:	eb 2e                	jmp    810298 <tcp_fasttmr+0x9e>
  81026a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  81026e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810272:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810279:	48 85 c0             	test   %rax,%rax
  81027c:	74 1a                	je     810298 <tcp_fasttmr+0x9e>
  81027e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810282:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810289:	48 89 c7             	mov    %rax,%rdi
  81028c:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  810293:	00 00 00 
  810296:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  810298:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  81029c:	75 0f                	jne    8102ad <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  81029e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102a2:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  8102a9:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8102ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102b1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8102b5:	0f b6 c0             	movzbl %al,%eax
  8102b8:	83 e0 01             	and    $0x1,%eax
  8102bb:	85 c0                	test   %eax,%eax
  8102bd:	74 3b                	je     8102fa <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8102bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102c3:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8102c7:	83 c8 02             	or     $0x2,%eax
  8102ca:	89 c2                	mov    %eax,%edx
  8102cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102d0:	88 50 2c             	mov    %dl,0x2c(%rax)
  8102d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102d7:	48 89 c7             	mov    %rax,%rdi
  8102da:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  8102e1:	00 00 00 
  8102e4:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8102e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102ea:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8102ee:	83 e0 fc             	and    $0xfffffffc,%eax
  8102f1:	89 c2                	mov    %eax,%edx
  8102f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102f7:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8102fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102fe:	48 8b 40 10          	mov    0x10(%rax),%rax
  810302:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810306:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81030b:	0f 85 07 ff ff ff    	jne    810218 <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  810311:	c9                   	leaveq 
  810312:	c3                   	retq   

0000000000810313 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  810313:	55                   	push   %rbp
  810314:	48 89 e5             	mov    %rsp,%rbp
  810317:	48 83 ec 20          	sub    $0x20,%rsp
  81031b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  81031f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  810323:	eb 29                	jmp    81034e <tcp_segs_free+0x3b>
    next = seg->next;
  810325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810329:	48 8b 00             	mov    (%rax),%rax
  81032c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  810330:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810334:	48 89 c7             	mov    %rax,%rdi
  810337:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81033e:	00 00 00 
  810341:	ff d0                	callq  *%rax
  810343:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  810346:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81034a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  81034e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810353:	75 d0                	jne    810325 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  810355:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  810359:	c9                   	leaveq 
  81035a:	c3                   	retq   

000000000081035b <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  81035b:	55                   	push   %rbp
  81035c:	48 89 e5             	mov    %rsp,%rbp
  81035f:	48 83 ec 20          	sub    $0x20,%rsp
  810363:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810367:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  81036b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810370:	74 3f                	je     8103b1 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  810372:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810376:	48 8b 40 08          	mov    0x8(%rax),%rax
  81037a:	48 85 c0             	test   %rax,%rax
  81037d:	74 1a                	je     810399 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  81037f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810383:	48 8b 40 08          	mov    0x8(%rax),%rax
  810387:	48 89 c7             	mov    %rax,%rdi
  81038a:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  810391:	00 00 00 
  810394:	ff d0                	callq  *%rax
  810396:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  810399:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81039d:	48 89 c6             	mov    %rax,%rsi
  8103a0:	bf 04 00 00 00       	mov    $0x4,%edi
  8103a5:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  8103ac:	00 00 00 
  8103af:	ff d0                	callq  *%rax
  }
  return count;
  8103b1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8103b5:	c9                   	leaveq 
  8103b6:	c3                   	retq   

00000000008103b7 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8103b7:	55                   	push   %rbp
  8103b8:	48 89 e5             	mov    %rsp,%rbp
  8103bb:	48 83 ec 0c          	sub    $0xc,%rsp
  8103bf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8103c3:	89 f0                	mov    %esi,%eax
  8103c5:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  8103c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103cc:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8103d0:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  8103d3:	c9                   	leaveq 
  8103d4:	c3                   	retq   

00000000008103d5 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8103d5:	55                   	push   %rbp
  8103d6:	48 89 e5             	mov    %rsp,%rbp
  8103d9:	48 83 ec 20          	sub    $0x20,%rsp
  8103dd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8103e1:	bf 04 00 00 00       	mov    $0x4,%edi
  8103e6:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  8103ed:	00 00 00 
  8103f0:	ff d0                	callq  *%rax
  8103f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  8103f6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8103fb:	75 07                	jne    810404 <tcp_seg_copy+0x2f>
    return NULL;
  8103fd:	b8 00 00 00 00       	mov    $0x0,%eax
  810402:	eb 3a                	jmp    81043e <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  810404:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  810408:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81040c:	ba 28 00 00 00       	mov    $0x28,%edx
  810411:	48 89 ce             	mov    %rcx,%rsi
  810414:	48 89 c7             	mov    %rax,%rdi
  810417:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  81041e:	00 00 00 
  810421:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  810423:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810427:	48 8b 40 08          	mov    0x8(%rax),%rax
  81042b:	48 89 c7             	mov    %rax,%rdi
  81042e:	48 b8 02 de 80 00 00 	movabs $0x80de02,%rax
  810435:	00 00 00 
  810438:	ff d0                	callq  *%rax
  return cseg;
  81043a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81043e:	c9                   	leaveq 
  81043f:	c3                   	retq   

0000000000810440 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810440:	55                   	push   %rbp
  810441:	48 89 e5             	mov    %rsp,%rbp
  810444:	48 83 ec 20          	sub    $0x20,%rsp
  810448:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81044c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810450:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  810454:	89 c8                	mov    %ecx,%eax
  810456:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  810459:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81045e:	74 15                	je     810475 <tcp_recv_null+0x35>
    pbuf_free(p);
  810460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810464:	48 89 c7             	mov    %rax,%rdi
  810467:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81046e:	00 00 00 
  810471:	ff d0                	callq  *%rax
  810473:	eb 1b                	jmp    810490 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  810475:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  810479:	75 15                	jne    810490 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  81047b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81047f:	48 89 c7             	mov    %rax,%rdi
  810482:	48 b8 58 eb 80 00 00 	movabs $0x80eb58,%rax
  810489:	00 00 00 
  81048c:	ff d0                	callq  *%rax
  81048e:	eb 05                	jmp    810495 <tcp_recv_null+0x55>
  }
  return ERR_OK;
  810490:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810495:	c9                   	leaveq 
  810496:	c3                   	retq   

0000000000810497 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  810497:	55                   	push   %rbp
  810498:	48 89 e5             	mov    %rsp,%rbp
  81049b:	48 83 ec 30          	sub    $0x30,%rsp
  81049f:	89 f8                	mov    %edi,%eax
  8104a1:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8104a4:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8104a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8104af:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8104b6:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8104b7:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8104be:	00 00 00 
  8104c1:	48 8b 00             	mov    (%rax),%rax
  8104c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8104c8:	eb 6f                	jmp    810539 <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  8104ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104ce:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8104d2:	3a 45 dc             	cmp    -0x24(%rbp),%al
  8104d5:	77 56                	ja     81052d <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  8104d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104db:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8104df:	3a 45 eb             	cmp    -0x15(%rbp),%al
  8104e2:	77 49                	ja     81052d <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8104e4:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8104eb:	00 00 00 
  8104ee:	8b 10                	mov    (%rax),%edx
  8104f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104f4:	8b 40 38             	mov    0x38(%rax),%eax
  8104f7:	29 c2                	sub    %eax,%edx
  8104f9:	89 d0                	mov    %edx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8104fb:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8104fe:	72 2d                	jb     81052d <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  810500:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810507:	00 00 00 
  81050a:	8b 10                	mov    (%rax),%edx
  81050c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810510:	8b 40 38             	mov    0x38(%rax),%eax
  810513:	29 c2                	sub    %eax,%edx
  810515:	89 d0                	mov    %edx,%eax
  810517:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81051a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81051e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  810522:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810526:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81052a:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81052d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810531:	48 8b 40 10          	mov    0x10(%rax),%rax
  810535:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810539:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81053e:	75 8a                	jne    8104ca <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  810540:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810545:	74 13                	je     81055a <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  810547:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81054b:	48 89 c7             	mov    %rax,%rdi
  81054e:	48 b8 de ed 80 00 00 	movabs $0x80edde,%rax
  810555:	00 00 00 
  810558:	ff d0                	callq  *%rax
  }      
}
  81055a:	c9                   	leaveq 
  81055b:	c3                   	retq   

000000000081055c <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  81055c:	55                   	push   %rbp
  81055d:	48 89 e5             	mov    %rsp,%rbp
  810560:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  810564:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  81056b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810572:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810573:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81057a:	00 00 00 
  81057d:	48 8b 00             	mov    (%rax),%rax
  810580:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810584:	eb 4a                	jmp    8105d0 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  810586:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81058d:	00 00 00 
  810590:	8b 10                	mov    (%rax),%edx
  810592:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810596:	8b 40 38             	mov    0x38(%rax),%eax
  810599:	29 c2                	sub    %eax,%edx
  81059b:	89 d0                	mov    %edx,%eax
  81059d:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8105a0:	72 22                	jb     8105c4 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  8105a2:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8105a9:	00 00 00 
  8105ac:	8b 10                	mov    (%rax),%edx
  8105ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105b2:	8b 40 38             	mov    0x38(%rax),%eax
  8105b5:	29 c2                	sub    %eax,%edx
  8105b7:	89 d0                	mov    %edx,%eax
  8105b9:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  8105bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105c0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8105c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105c8:	48 8b 40 10          	mov    0x10(%rax),%rax
  8105cc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8105d0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8105d5:	75 af                	jne    810586 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8105d7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8105dc:	74 13                	je     8105f1 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8105de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105e2:	48 89 c7             	mov    %rax,%rdi
  8105e5:	48 b8 de ed 80 00 00 	movabs $0x80edde,%rax
  8105ec:	00 00 00 
  8105ef:	ff d0                	callq  *%rax
  }      
}
  8105f1:	c9                   	leaveq 
  8105f2:	c3                   	retq   

00000000008105f3 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8105f3:	55                   	push   %rbp
  8105f4:	48 89 e5             	mov    %rsp,%rbp
  8105f7:	48 83 ec 20          	sub    $0x20,%rsp
  8105fb:	89 f8                	mov    %edi,%eax
  8105fd:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  810600:	bf 02 00 00 00       	mov    $0x2,%edi
  810605:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  81060c:	00 00 00 
  81060f:	ff d0                	callq  *%rax
  810611:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  810615:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81061a:	75 4f                	jne    81066b <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  81061c:	48 b8 5c 05 81 00 00 	movabs $0x81055c,%rax
  810623:	00 00 00 
  810626:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  810628:	bf 02 00 00 00       	mov    $0x2,%edi
  81062d:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  810634:	00 00 00 
  810637:	ff d0                	callq  *%rax
  810639:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  81063d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810642:	75 27                	jne    81066b <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  810644:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  810648:	89 c7                	mov    %eax,%edi
  81064a:	48 b8 97 04 81 00 00 	movabs $0x810497,%rax
  810651:	00 00 00 
  810654:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  810656:	bf 02 00 00 00       	mov    $0x2,%edi
  81065b:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  810662:	00 00 00 
  810665:	ff d0                	callq  *%rax
  810667:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  81066b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810670:	0f 84 23 01 00 00    	je     810799 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  810676:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81067a:	ba e0 00 00 00       	mov    $0xe0,%edx
  81067f:	be 00 00 00 00       	mov    $0x0,%esi
  810684:	48 89 c7             	mov    %rax,%rdi
  810687:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  81068e:	00 00 00 
  810691:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  810693:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810697:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  81069b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81069f:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  8106a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106a9:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  8106af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106b3:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  8106b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106bd:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  8106c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106c7:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  8106cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106cf:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8106d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106d7:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8106dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106e1:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  8106e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106eb:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8106f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106f5:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  8106fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106ff:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  810705:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810709:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  81070f:	48 b8 85 0b 81 00 00 	movabs $0x810b85,%rax
  810716:	00 00 00 
  810719:	ff d0                	callq  *%rax
  81071b:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  81071e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810722:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810725:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  810728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81072c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81072f:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  810732:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810736:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810739:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  81073c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810740:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810743:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  810746:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81074a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81074d:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  810750:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810757:	00 00 00 
  81075a:	8b 10                	mov    (%rax),%edx
  81075c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810760:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  810763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810767:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  81076b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81076f:	48 b9 40 04 81 00 00 	movabs $0x810440,%rcx
  810776:	00 00 00 
  810779:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  810780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810784:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  81078b:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  81078e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810792:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  810799:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81079d:	c9                   	leaveq 
  81079e:	c3                   	retq   

000000000081079f <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  81079f:	55                   	push   %rbp
  8107a0:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8107a3:	bf 40 00 00 00       	mov    $0x40,%edi
  8107a8:	48 b8 f3 05 81 00 00 	movabs $0x8105f3,%rax
  8107af:	00 00 00 
  8107b2:	ff d0                	callq  *%rax
}
  8107b4:	5d                   	pop    %rbp
  8107b5:	c3                   	retq   

00000000008107b6 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8107b6:	55                   	push   %rbp
  8107b7:	48 89 e5             	mov    %rsp,%rbp
  8107ba:	48 83 ec 10          	sub    $0x10,%rsp
  8107be:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8107c2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  8107c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107ca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8107ce:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  8107d2:	c9                   	leaveq 
  8107d3:	c3                   	retq   

00000000008107d4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8107d4:	55                   	push   %rbp
  8107d5:	48 89 e5             	mov    %rsp,%rbp
  8107d8:	48 83 ec 10          	sub    $0x10,%rsp
  8107dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8107e0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  8107e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8107ec:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8107f3:	c9                   	leaveq 
  8107f4:	c3                   	retq   

00000000008107f5 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8107f5:	55                   	push   %rbp
  8107f6:	48 89 e5             	mov    %rsp,%rbp
  8107f9:	48 83 ec 10          	sub    $0x10,%rsp
  8107fd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810801:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  810805:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810809:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81080d:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  810814:	c9                   	leaveq 
  810815:	c3                   	retq   

0000000000810816 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810816:	55                   	push   %rbp
  810817:	48 89 e5             	mov    %rsp,%rbp
  81081a:	48 83 ec 10          	sub    $0x10,%rsp
  81081e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810822:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  810826:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81082a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81082e:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  810835:	c9                   	leaveq 
  810836:	c3                   	retq   

0000000000810837 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  810837:	55                   	push   %rbp
  810838:	48 89 e5             	mov    %rsp,%rbp
  81083b:	48 83 ec 10          	sub    $0x10,%rsp
  81083f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810843:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  810847:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81084b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81084f:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  810853:	c9                   	leaveq 
  810854:	c3                   	retq   

0000000000810855 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  810855:	55                   	push   %rbp
  810856:	48 89 e5             	mov    %rsp,%rbp
  810859:	48 83 ec 14          	sub    $0x14,%rsp
  81085d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810861:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810865:	89 d0                	mov    %edx,%eax
  810867:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  81086a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81086e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810872:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  810879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81087d:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  810881:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  810884:	c9                   	leaveq 
  810885:	c3                   	retq   

0000000000810886 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  810886:	55                   	push   %rbp
  810887:	48 89 e5             	mov    %rsp,%rbp
  81088a:	48 83 ec 10          	sub    $0x10,%rsp
  81088e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  810892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810896:	8b 40 18             	mov    0x18(%rax),%eax
  810899:	85 c0                	test   %eax,%eax
  81089b:	0f 84 e5 00 00 00    	je     810986 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  8108a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108a5:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  8108a8:	83 f8 0a             	cmp    $0xa,%eax
  8108ab:	0f 84 d5 00 00 00    	je     810986 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  8108b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108b5:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  8108b8:	83 f8 01             	cmp    $0x1,%eax
  8108bb:	0f 84 c5 00 00 00    	je     810986 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8108c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108c5:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8108cc:	48 85 c0             	test   %rax,%rax
  8108cf:	74 29                	je     8108fa <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8108d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108d5:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8108dc:	48 89 c7             	mov    %rax,%rdi
  8108df:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8108e6:	00 00 00 
  8108e9:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  8108eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108ef:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  8108f6:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8108fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108fe:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810904:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810908:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81090f:	48 89 c7             	mov    %rax,%rdi
  810912:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  810919:	00 00 00 
  81091c:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  81091e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810922:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810929:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  81092d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810931:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810938:	48 89 c7             	mov    %rax,%rdi
  81093b:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  810942:	00 00 00 
  810945:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  810947:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81094b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810952:	48 89 c7             	mov    %rax,%rdi
  810955:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  81095c:	00 00 00 
  81095f:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  810961:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810965:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  81096c:	00 00 00 00 
  810970:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810974:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  81097b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81097f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810986:	c9                   	leaveq 
  810987:	c3                   	retq   

0000000000810988 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810988:	55                   	push   %rbp
  810989:	48 89 e5             	mov    %rsp,%rbp
  81098c:	48 83 ec 10          	sub    $0x10,%rsp
  810990:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810994:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810998:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81099c:	48 8b 00             	mov    (%rax),%rax
  81099f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8109a3:	75 17                	jne    8109bc <tcp_pcb_remove+0x34>
  8109a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109a9:	48 8b 00             	mov    (%rax),%rax
  8109ac:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8109b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109b4:	48 89 10             	mov    %rdx,(%rax)
  8109b7:	e9 8e 00 00 00       	jmpq   810a4a <tcp_pcb_remove+0xc2>
  8109bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109c0:	48 8b 10             	mov    (%rax),%rdx
  8109c3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8109ca:	00 00 00 
  8109cd:	48 89 10             	mov    %rdx,(%rax)
  8109d0:	eb 66                	jmp    810a38 <tcp_pcb_remove+0xb0>
  8109d2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8109d9:	00 00 00 
  8109dc:	48 8b 00             	mov    (%rax),%rax
  8109df:	48 8b 40 10          	mov    0x10(%rax),%rax
  8109e3:	48 85 c0             	test   %rax,%rax
  8109e6:	74 32                	je     810a1a <tcp_pcb_remove+0x92>
  8109e8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8109ef:	00 00 00 
  8109f2:	48 8b 00             	mov    (%rax),%rax
  8109f5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8109f9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8109fd:	75 1b                	jne    810a1a <tcp_pcb_remove+0x92>
  8109ff:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810a06:	00 00 00 
  810a09:	48 8b 00             	mov    (%rax),%rax
  810a0c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810a10:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810a14:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810a18:	eb 30                	jmp    810a4a <tcp_pcb_remove+0xc2>
  810a1a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810a21:	00 00 00 
  810a24:	48 8b 00             	mov    (%rax),%rax
  810a27:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810a2b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810a32:	00 00 00 
  810a35:	48 89 10             	mov    %rdx,(%rax)
  810a38:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810a3f:	00 00 00 
  810a42:	48 8b 00             	mov    (%rax),%rax
  810a45:	48 85 c0             	test   %rax,%rax
  810a48:	75 88                	jne    8109d2 <tcp_pcb_remove+0x4a>
  810a4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a4e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  810a55:	00 

  tcp_pcb_purge(pcb);
  810a56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a5a:	48 89 c7             	mov    %rax,%rdi
  810a5d:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  810a64:	00 00 00 
  810a67:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810a69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a6d:	8b 40 18             	mov    0x18(%rax),%eax
  810a70:	83 f8 0a             	cmp    $0xa,%eax
  810a73:	74 45                	je     810aba <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  810a75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a79:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810a7c:	83 f8 01             	cmp    $0x1,%eax
  810a7f:	74 39                	je     810aba <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810a81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a85:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810a89:	0f b6 c0             	movzbl %al,%eax
  810a8c:	83 e0 01             	and    $0x1,%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  810a8f:	85 c0                	test   %eax,%eax
  810a91:	74 27                	je     810aba <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810a93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810a97:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810a9b:	83 c8 02             	or     $0x2,%eax
  810a9e:	89 c2                	mov    %eax,%edx
  810aa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810aa4:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810aa7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810aab:	48 89 c7             	mov    %rax,%rdi
  810aae:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  810ab5:	00 00 00 
  810ab8:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  810aba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810abe:	8b 40 18             	mov    0x18(%rax),%eax
  810ac1:	83 f8 01             	cmp    $0x1,%eax
  810ac4:	0f 84 ae 00 00 00    	je     810b78 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  810aca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810ace:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810ad5:	48 85 c0             	test   %rax,%rax
  810ad8:	74 2a                	je     810b04 <tcp_pcb_remove+0x17c>
  810ada:	48 ba 9e 24 82 00 00 	movabs $0x82249e,%rdx
  810ae1:	00 00 00 
  810ae4:	be b4 04 00 00       	mov    $0x4b4,%esi
  810ae9:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  810af0:	00 00 00 
  810af3:	b8 00 00 00 00       	mov    $0x0,%eax
  810af8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  810aff:	00 00 00 
  810b02:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810b04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b08:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810b0f:	48 85 c0             	test   %rax,%rax
  810b12:	74 2a                	je     810b3e <tcp_pcb_remove+0x1b6>
  810b14:	48 ba b6 24 82 00 00 	movabs $0x8224b6,%rdx
  810b1b:	00 00 00 
  810b1e:	be b5 04 00 00       	mov    $0x4b5,%esi
  810b23:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  810b2a:	00 00 00 
  810b2d:	b8 00 00 00 00       	mov    $0x0,%eax
  810b32:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  810b39:	00 00 00 
  810b3c:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  810b3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b42:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810b49:	48 85 c0             	test   %rax,%rax
  810b4c:	74 2a                	je     810b78 <tcp_pcb_remove+0x1f0>
  810b4e:	48 ba cf 24 82 00 00 	movabs $0x8224cf,%rdx
  810b55:	00 00 00 
  810b58:	be b7 04 00 00       	mov    $0x4b7,%esi
  810b5d:	48 bf bb 22 82 00 00 	movabs $0x8222bb,%rdi
  810b64:	00 00 00 
  810b67:	b8 00 00 00 00       	mov    $0x0,%eax
  810b6c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  810b73:	00 00 00 
  810b76:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  810b78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b7c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810b83:	c9                   	leaveq 
  810b84:	c3                   	retq   

0000000000810b85 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810b85:	55                   	push   %rbp
  810b86:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810b89:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810b90:	00 00 00 
  810b93:	8b 10                	mov    (%rax),%edx
  810b95:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810b9c:	00 00 00 
  810b9f:	8b 00                	mov    (%rax),%eax
  810ba1:	01 c2                	add    %eax,%edx
  810ba3:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810baa:	00 00 00 
  810bad:	89 10                	mov    %edx,(%rax)
  return iss;
  810baf:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810bb6:	00 00 00 
  810bb9:	8b 00                	mov    (%rax),%eax
}
  810bbb:	5d                   	pop    %rbp
  810bbc:	c3                   	retq   

0000000000810bbd <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  810bbd:	55                   	push   %rbp
  810bbe:	48 89 e5             	mov    %rsp,%rbp
  810bc1:	48 83 ec 20          	sub    $0x20,%rsp
  810bc5:	89 f8                	mov    %edi,%eax
  810bc7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  810bcb:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  810bcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810bd3:	48 89 c7             	mov    %rax,%rdi
  810bd6:	48 b8 bd 0c 81 00 00 	movabs $0x810cbd,%rax
  810bdd:	00 00 00 
  810be0:	ff d0                	callq  *%rax
  810be2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810be6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810beb:	74 2d                	je     810c1a <tcp_eff_send_mss+0x5d>
  810bed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810bf1:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810bf5:	66 85 c0             	test   %ax,%ax
  810bf8:	74 20                	je     810c1a <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  810bfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810bfe:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810c02:	83 e8 28             	sub    $0x28,%eax
  810c05:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810c09:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  810c0d:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810c11:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810c16:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810c1a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810c1e:	c9                   	leaveq 
  810c1f:	c3                   	retq   

0000000000810c20 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810c20:	55                   	push   %rbp
  810c21:	48 89 e5             	mov    %rsp,%rbp
  810c24:	48 83 ec 20          	sub    $0x20,%rsp
  810c28:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810c2c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810c30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c34:	8b 00                	mov    (%rax),%eax
  810c36:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810c39:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810c3d:	74 06                	je     810c45 <ip_addr_isbroadcast+0x25>
  810c3f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  810c43:	75 07                	jne    810c4c <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  810c45:	b8 01 00 00 00       	mov    $0x1,%eax
  810c4a:	eb 6f                	jmp    810cbb <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810c4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c50:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  810c54:	0f b6 c0             	movzbl %al,%eax
  810c57:	83 e0 02             	and    $0x2,%eax
  810c5a:	85 c0                	test   %eax,%eax
  810c5c:	75 07                	jne    810c65 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810c5e:	b8 00 00 00 00       	mov    $0x0,%eax
  810c63:	eb 56                	jmp    810cbb <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  810c65:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c69:	8b 40 08             	mov    0x8(%rax),%eax
  810c6c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810c6f:	75 07                	jne    810c78 <ip_addr_isbroadcast+0x58>
    return 0;
  810c71:	b8 00 00 00 00       	mov    $0x0,%eax
  810c76:	eb 43                	jmp    810cbb <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  810c78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c7c:	8b 10                	mov    (%rax),%edx
  810c7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c82:	8b 40 08             	mov    0x8(%rax),%eax
  810c85:	31 c2                	xor    %eax,%edx
  810c87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c8b:	8b 40 0c             	mov    0xc(%rax),%eax
  810c8e:	21 d0                	and    %edx,%eax
  810c90:	85 c0                	test   %eax,%eax
  810c92:	75 22                	jne    810cb6 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810c94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c98:	8b 40 0c             	mov    0xc(%rax),%eax
  810c9b:	f7 d0                	not    %eax
  810c9d:	23 45 fc             	and    -0x4(%rbp),%eax
  810ca0:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810ca2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ca6:	8b 40 0c             	mov    0xc(%rax),%eax
  810ca9:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810cab:	39 c2                	cmp    %eax,%edx
  810cad:	75 07                	jne    810cb6 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810caf:	b8 01 00 00 00       	mov    $0x1,%eax
  810cb4:	eb 05                	jmp    810cbb <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810cb6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810cbb:	c9                   	leaveq 
  810cbc:	c3                   	retq   

0000000000810cbd <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810cbd:	55                   	push   %rbp
  810cbe:	48 89 e5             	mov    %rsp,%rbp
  810cc1:	48 83 ec 20          	sub    $0x20,%rsp
  810cc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810cc9:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810cd0:	00 00 00 
  810cd3:	48 8b 00             	mov    (%rax),%rax
  810cd6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810cda:	eb 44                	jmp    810d20 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810cdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ce0:	48 89 c7             	mov    %rax,%rdi
  810ce3:	48 b8 1f d3 80 00 00 	movabs $0x80d31f,%rax
  810cea:	00 00 00 
  810ced:	ff d0                	callq  *%rax
  810cef:	84 c0                	test   %al,%al
  810cf1:	74 22                	je     810d15 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810cf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810cf7:	8b 10                	mov    (%rax),%edx
  810cf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810cfd:	8b 40 08             	mov    0x8(%rax),%eax
  810d00:	31 c2                	xor    %eax,%edx
  810d02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d06:	8b 40 0c             	mov    0xc(%rax),%eax
  810d09:	21 d0                	and    %edx,%eax
  810d0b:	85 c0                	test   %eax,%eax
  810d0d:	75 06                	jne    810d15 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810d0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d13:	eb 58                	jmp    810d6d <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810d15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d19:	48 8b 00             	mov    (%rax),%rax
  810d1c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810d20:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810d25:	75 b5                	jne    810cdc <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810d27:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810d2e:	00 00 00 
  810d31:	48 8b 00             	mov    (%rax),%rax
  810d34:	48 85 c0             	test   %rax,%rax
  810d37:	74 20                	je     810d59 <ip_route+0x9c>
  810d39:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810d40:	00 00 00 
  810d43:	48 8b 00             	mov    (%rax),%rax
  810d46:	48 89 c7             	mov    %rax,%rdi
  810d49:	48 b8 1f d3 80 00 00 	movabs $0x80d31f,%rax
  810d50:	00 00 00 
  810d53:	ff d0                	callq  *%rax
  810d55:	84 c0                	test   %al,%al
  810d57:	75 07                	jne    810d60 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810d59:	b8 00 00 00 00       	mov    $0x0,%eax
  810d5e:	eb 0d                	jmp    810d6d <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810d60:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810d67:	00 00 00 
  810d6a:	48 8b 00             	mov    (%rax),%rax
}
  810d6d:	c9                   	leaveq 
  810d6e:	c3                   	retq   

0000000000810d6f <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810d6f:	55                   	push   %rbp
  810d70:	48 89 e5             	mov    %rsp,%rbp
  810d73:	53                   	push   %rbx
  810d74:	48 83 ec 38          	sub    $0x38,%rsp
  810d78:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810d7c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810d80:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810d87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d8b:	48 8b 40 08          	mov    0x8(%rax),%rax
  810d8f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810d93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d97:	0f b7 00             	movzwl (%rax),%eax
  810d9a:	0f b7 c0             	movzwl %ax,%eax
  810d9d:	89 c7                	mov    %eax,%edi
  810d9f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  810da6:	00 00 00 
  810da9:	ff d0                	callq  *%rax
  810dab:	66 c1 e8 0c          	shr    $0xc,%ax
  810daf:	66 83 f8 04          	cmp    $0x4,%ax
  810db3:	74 1d                	je     810dd2 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810db5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810db9:	48 89 c7             	mov    %rax,%rdi
  810dbc:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  810dc3:	00 00 00 
  810dc6:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810dc8:	b8 00 00 00 00       	mov    $0x0,%eax
  810dcd:	e9 19 04 00 00       	jmpq   8111eb <ip_input+0x47c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810dd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dd6:	0f b7 00             	movzwl (%rax),%eax
  810dd9:	0f b7 c0             	movzwl %ax,%eax
  810ddc:	89 c7                	mov    %eax,%edi
  810dde:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  810de5:	00 00 00 
  810de8:	ff d0                	callq  *%rax
  810dea:	66 c1 e8 08          	shr    $0x8,%ax
  810dee:	83 e0 0f             	and    $0xf,%eax
  810df1:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810df5:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810dfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dfe:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810e02:	0f b7 c0             	movzwl %ax,%eax
  810e05:	89 c7                	mov    %eax,%edi
  810e07:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  810e0e:	00 00 00 
  810e11:	ff d0                	callq  *%rax
  810e13:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810e17:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e1b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810e1f:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810e23:	72 0e                	jb     810e33 <ip_input+0xc4>
  810e25:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e29:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810e2d:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810e31:	73 1d                	jae    810e50 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810e33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e37:	48 89 c7             	mov    %rax,%rdi
  810e3a:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  810e41:	00 00 00 
  810e44:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  810e46:	b8 00 00 00 00       	mov    $0x0,%eax
  810e4b:	e9 9b 03 00 00       	jmpq   8111eb <ip_input+0x47c>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810e50:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e58:	89 d6                	mov    %edx,%esi
  810e5a:	48 89 c7             	mov    %rax,%rdi
  810e5d:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  810e64:	00 00 00 
  810e67:	ff d0                	callq  *%rax
  810e69:	66 85 c0             	test   %ax,%ax
  810e6c:	74 1d                	je     810e8b <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  810e6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e72:	48 89 c7             	mov    %rax,%rdi
  810e75:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  810e7c:	00 00 00 
  810e7f:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810e81:	b8 00 00 00 00       	mov    $0x0,%eax
  810e86:	e9 60 03 00 00       	jmpq   8111eb <ip_input+0x47c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810e8b:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810e8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e93:	89 d6                	mov    %edx,%esi
  810e95:	48 89 c7             	mov    %rax,%rdi
  810e98:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  810e9f:	00 00 00 
  810ea2:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810ea4:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810eab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810eaf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  810eb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810eb7:	48 89 c7             	mov    %rax,%rdi
  810eba:	48 b8 1f d3 80 00 00 	movabs $0x80d31f,%rax
  810ec1:	00 00 00 
  810ec4:	ff d0                	callq  *%rax
  810ec6:	84 c0                	test   %al,%al
  810ec8:	74 4e                	je     810f18 <ip_input+0x1a9>
  810eca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ece:	48 83 c0 08          	add    $0x8,%rax
  810ed2:	48 85 c0             	test   %rax,%rax
  810ed5:	74 41                	je     810f18 <ip_input+0x1a9>
  810ed7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810edb:	8b 40 08             	mov    0x8(%rax),%eax
  810ede:	85 c0                	test   %eax,%eax
  810ee0:	74 36                	je     810f18 <ip_input+0x1a9>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810ee2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ee6:	8b 50 10             	mov    0x10(%rax),%edx
  810ee9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810eed:	8b 40 08             	mov    0x8(%rax),%eax
  810ef0:	39 c2                	cmp    %eax,%edx
  810ef2:	74 22                	je     810f16 <ip_input+0x1a7>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  810ef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ef8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810efc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810f00:	48 89 c6             	mov    %rax,%rsi
  810f03:	48 89 d7             	mov    %rdx,%rdi
  810f06:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  810f0d:	00 00 00 
  810f10:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810f12:	84 c0                	test   %al,%al
  810f14:	74 02                	je     810f18 <ip_input+0x1a9>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  810f16:	eb 4b                	jmp    810f63 <ip_input+0x1f4>
        }
      }
      if (first) {
  810f18:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  810f1c:	74 1a                	je     810f38 <ip_input+0x1c9>
        first = 0;
  810f1e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  810f25:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810f2c:	00 00 00 
  810f2f:	48 8b 00             	mov    (%rax),%rax
  810f32:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  810f36:	eb 0b                	jmp    810f43 <ip_input+0x1d4>
      } else {
        netif = netif->next;
  810f38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810f3c:	48 8b 00             	mov    (%rax),%rax
  810f3f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  810f43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810f47:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  810f4b:	75 0b                	jne    810f58 <ip_input+0x1e9>
        netif = netif->next;
  810f4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810f51:	48 8b 00             	mov    (%rax),%rax
  810f54:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  810f58:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810f5d:	0f 85 50 ff ff ff    	jne    810eb3 <ip_input+0x144>
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  810f63:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810f68:	75 59                	jne    810fc3 <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  810f6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f6e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810f72:	0f b7 c0             	movzwl %ax,%eax
  810f75:	89 c7                	mov    %eax,%edi
  810f77:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  810f7e:	00 00 00 
  810f81:	ff d0                	callq  *%rax
  810f83:	0f b7 c0             	movzwl %ax,%eax
  810f86:	0f b6 c0             	movzbl %al,%eax
  810f89:	83 f8 11             	cmp    $0x11,%eax
  810f8c:	75 35                	jne    810fc3 <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  810f8e:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810f92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f96:	48 01 d0             	add    %rdx,%rax
  810f99:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810f9d:	0f b7 c0             	movzwl %ax,%eax
  810fa0:	89 c7                	mov    %eax,%edi
  810fa2:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  810fa9:	00 00 00 
  810fac:	ff d0                	callq  *%rax
  810fae:	66 83 f8 44          	cmp    $0x44,%ax
  810fb2:	75 0f                	jne    810fc3 <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  810fb4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810fb8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  810fbc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  810fc3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  810fc7:	74 6e                	je     811037 <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810fc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fcd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  810fd1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810fd5:	48 89 c6             	mov    %rax,%rsi
  810fd8:	48 89 d7             	mov    %rdx,%rdi
  810fdb:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  810fe2:	00 00 00 
  810fe5:	ff d0                	callq  *%rax
  810fe7:	84 c0                	test   %al,%al
  810fe9:	75 2f                	jne    81101a <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  810feb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fef:	8b 58 0c             	mov    0xc(%rax),%ebx
  810ff2:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810ff7:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  810ffe:	00 00 00 
  811001:	ff d0                	callq  *%rax
  811003:	21 c3                	and    %eax,%ebx
  811005:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81100a:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  811011:	00 00 00 
  811014:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  811016:	39 c3                	cmp    %eax,%ebx
  811018:	75 1d                	jne    811037 <ip_input+0x2c8>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  81101a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81101e:	48 89 c7             	mov    %rax,%rdi
  811021:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  811028:	00 00 00 
  81102b:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  81102d:	b8 00 00 00 00       	mov    $0x0,%eax
  811032:	e9 b4 01 00 00       	jmpq   8111eb <ip_input+0x47c>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  811037:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81103c:	75 1d                	jne    81105b <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  81103e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811042:	48 89 c7             	mov    %rax,%rdi
  811045:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81104c:	00 00 00 
  81104f:	ff d0                	callq  *%rax
    return ERR_OK;
  811051:	b8 00 00 00 00       	mov    $0x0,%eax
  811056:	e9 90 01 00 00       	jmpq   8111eb <ip_input+0x47c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  81105b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81105f:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  811063:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  811068:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81106f:	00 00 00 
  811072:	ff d0                	callq  *%rax
  811074:	21 d8                	and    %ebx,%eax
  811076:	66 85 c0             	test   %ax,%ax
  811079:	74 34                	je     8110af <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  81107b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81107f:	48 89 c7             	mov    %rax,%rdi
  811082:	48 b8 c8 1e 81 00 00 	movabs $0x811ec8,%rax
  811089:	00 00 00 
  81108c:	ff d0                	callq  *%rax
  81108e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  811092:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811097:	75 0a                	jne    8110a3 <ip_input+0x334>
      return ERR_OK;
  811099:	b8 00 00 00 00       	mov    $0x0,%eax
  81109e:	e9 48 01 00 00       	jmpq   8111eb <ip_input+0x47c>
    }
    iphdr = p->payload;
  8110a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8110a7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8110ab:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  8110af:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8110b3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8110b7:	48 89 d6             	mov    %rdx,%rsi
  8110ba:	48 89 c7             	mov    %rax,%rdi
  8110bd:	48 b8 13 fc 81 00 00 	movabs $0x81fc13,%rax
  8110c4:	00 00 00 
  8110c7:	ff d0                	callq  *%rax
  8110c9:	84 c0                	test   %al,%al
  8110cb:	0f 85 15 01 00 00    	jne    8111e6 <ip_input+0x477>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  8110d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110d5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8110d9:	0f b7 c0             	movzwl %ax,%eax
  8110dc:	89 c7                	mov    %eax,%edi
  8110de:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8110e5:	00 00 00 
  8110e8:	ff d0                	callq  *%rax
  8110ea:	0f b7 c0             	movzwl %ax,%eax
  8110ed:	0f b6 c0             	movzbl %al,%eax
  8110f0:	83 f8 06             	cmp    $0x6,%eax
  8110f3:	74 2b                	je     811120 <ip_input+0x3b1>
  8110f5:	83 f8 11             	cmp    $0x11,%eax
  8110f8:	74 07                	je     811101 <ip_input+0x392>
  8110fa:	83 f8 01             	cmp    $0x1,%eax
  8110fd:	74 40                	je     81113f <ip_input+0x3d0>
  8110ff:	eb 5d                	jmp    81115e <ip_input+0x3ef>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  811101:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811105:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811109:	48 89 d6             	mov    %rdx,%rsi
  81110c:	48 89 c7             	mov    %rax,%rdi
  81110f:	48 b8 5b 4c 81 00 00 	movabs $0x814c5b,%rax
  811116:	00 00 00 
  811119:	ff d0                	callq  *%rax
      break;
  81111b:	e9 c6 00 00 00       	jmpq   8111e6 <ip_input+0x477>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  811120:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811124:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811128:	48 89 d6             	mov    %rdx,%rsi
  81112b:	48 89 c7             	mov    %rax,%rdi
  81112e:	48 b8 f8 c2 81 00 00 	movabs $0x81c2f8,%rax
  811135:	00 00 00 
  811138:	ff d0                	callq  *%rax
      break;
  81113a:	e9 a7 00 00 00       	jmpq   8111e6 <ip_input+0x477>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  81113f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811143:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811147:	48 89 d6             	mov    %rdx,%rsi
  81114a:	48 89 c7             	mov    %rax,%rdi
  81114d:	48 b8 c4 00 82 00 00 	movabs $0x8200c4,%rax
  811154:	00 00 00 
  811157:	ff d0                	callq  *%rax
      break;
  811159:	e9 88 00 00 00       	jmpq   8111e6 <ip_input+0x477>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  81115e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811162:	48 8d 50 10          	lea    0x10(%rax),%rdx
  811166:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81116a:	48 89 c6             	mov    %rax,%rsi
  81116d:	48 89 d7             	mov    %rdx,%rdi
  811170:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  811177:	00 00 00 
  81117a:	ff d0                	callq  *%rax
  81117c:	84 c0                	test   %al,%al
  81117e:	75 53                	jne    8111d3 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  811180:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811184:	8b 58 10             	mov    0x10(%rax),%ebx
  811187:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81118c:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  811193:	00 00 00 
  811196:	ff d0                	callq  *%rax
  811198:	21 c3                	and    %eax,%ebx
  81119a:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81119f:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8111a6:	00 00 00 
  8111a9:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8111ab:	39 c3                	cmp    %eax,%ebx
  8111ad:	74 24                	je     8111d3 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  8111af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8111b7:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8111bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111bf:	be 02 00 00 00       	mov    $0x2,%esi
  8111c4:	48 89 c7             	mov    %rax,%rdi
  8111c7:	48 b8 e7 05 82 00 00 	movabs $0x8205e7,%rax
  8111ce:	00 00 00 
  8111d1:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  8111d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111d7:	48 89 c7             	mov    %rax,%rdi
  8111da:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8111e1:	00 00 00 
  8111e4:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  8111e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8111eb:	48 83 c4 38          	add    $0x38,%rsp
  8111ef:	5b                   	pop    %rbx
  8111f0:	5d                   	pop    %rbp
  8111f1:	c3                   	retq   

00000000008111f2 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8111f2:	55                   	push   %rbp
  8111f3:	48 89 e5             	mov    %rsp,%rbp
  8111f6:	53                   	push   %rbx
  8111f7:	48 83 ec 48          	sub    $0x48,%rsp
  8111fb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8111ff:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  811203:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  811207:	89 c8                	mov    %ecx,%eax
  811209:	44 89 c1             	mov    %r8d,%ecx
  81120c:	44 89 ca             	mov    %r9d,%edx
  81120f:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811212:	88 4d c0             	mov    %cl,-0x40(%rbp)
  811215:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  811218:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81121d:	0f 84 0e 02 00 00    	je     811431 <ip_output_if+0x23f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  811223:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811227:	be 14 00 00 00       	mov    $0x14,%esi
  81122c:	48 89 c7             	mov    %rax,%rdi
  81122f:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  811236:	00 00 00 
  811239:	ff d0                	callq  *%rax
  81123b:	84 c0                	test   %al,%al
  81123d:	74 0a                	je     811249 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  81123f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  811244:	e9 58 02 00 00       	jmpq   8114a1 <ip_output_if+0x2af>
    }

    iphdr = p->payload;
  811249:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81124d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811251:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  811255:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811259:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81125d:	66 83 f8 13          	cmp    $0x13,%ax
  811261:	77 2a                	ja     81128d <ip_output_if+0x9b>
  811263:	48 ba f0 24 82 00 00 	movabs $0x8224f0,%rdx
  81126a:	00 00 00 
  81126d:	be ee 01 00 00       	mov    $0x1ee,%esi
  811272:	48 bf 1d 25 82 00 00 	movabs $0x82251d,%rdi
  811279:	00 00 00 
  81127c:	b8 00 00 00 00       	mov    $0x0,%eax
  811281:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811288:	00 00 00 
  81128b:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  81128d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811291:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811295:	0f b7 c0             	movzwl %ax,%eax
  811298:	89 c7                	mov    %eax,%edi
  81129a:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8112a1:	00 00 00 
  8112a4:	ff d0                	callq  *%rax
  8112a6:	0f b6 d0             	movzbl %al,%edx
  8112a9:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8112ad:	c1 e0 08             	shl    $0x8,%eax
  8112b0:	09 d0                	or     %edx,%eax
  8112b2:	0f b7 c0             	movzwl %ax,%eax
  8112b5:	89 c7                	mov    %eax,%edi
  8112b7:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8112be:	00 00 00 
  8112c1:	ff d0                	callq  *%rax
  8112c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8112c7:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_PROTO_SET(iphdr, proto);
  8112cb:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  8112cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112d3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8112d7:	0f b7 c0             	movzwl %ax,%eax
  8112da:	89 c7                	mov    %eax,%edi
  8112dc:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8112e3:	00 00 00 
  8112e6:	ff d0                	callq  *%rax
  8112e8:	66 c1 e8 08          	shr    $0x8,%ax
  8112ec:	0f b7 c0             	movzwl %ax,%eax
  8112ef:	c1 e0 08             	shl    $0x8,%eax
  8112f2:	09 d8                	or     %ebx,%eax
  8112f4:	0f b7 c0             	movzwl %ax,%eax
  8112f7:	89 c7                	mov    %eax,%edi
  8112f9:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  811300:	00 00 00 
  811303:	ff d0                	callq  *%rax
  811305:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811309:	66 89 42 08          	mov    %ax,0x8(%rdx)

    ip_addr_set(&(iphdr->dest), dest);
  81130d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811312:	74 08                	je     81131c <ip_output_if+0x12a>
  811314:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811318:	8b 00                	mov    (%rax),%eax
  81131a:	eb 05                	jmp    811321 <ip_output_if+0x12f>
  81131c:	b8 00 00 00 00       	mov    $0x0,%eax
  811321:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811325:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  811328:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  81132c:	80 cc 45             	or     $0x45,%ah
  81132f:	0f b7 c0             	movzwl %ax,%eax
  811332:	89 c7                	mov    %eax,%edi
  811334:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81133b:	00 00 00 
  81133e:	ff d0                	callq  *%rax
  811340:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811344:	66 89 02             	mov    %ax,(%rdx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  811347:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81134b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81134f:	0f b7 c0             	movzwl %ax,%eax
  811352:	89 c7                	mov    %eax,%edi
  811354:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81135b:	00 00 00 
  81135e:	ff d0                	callq  *%rax
  811360:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811364:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(iphdr, 0);
  811368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81136c:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  811372:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  811379:	00 00 00 
  81137c:	0f b7 00             	movzwl (%rax),%eax
  81137f:	0f b7 c0             	movzwl %ax,%eax
  811382:	89 c7                	mov    %eax,%edi
  811384:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81138b:	00 00 00 
  81138e:	ff d0                	callq  *%rax
  811390:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811394:	66 89 42 04          	mov    %ax,0x4(%rdx)
    ++ip_id;
  811398:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81139f:	00 00 00 
  8113a2:	0f b7 00             	movzwl (%rax),%eax
  8113a5:	8d 50 01             	lea    0x1(%rax),%edx
  8113a8:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  8113af:	00 00 00 
  8113b2:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  8113b5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8113ba:	74 0a                	je     8113c6 <ip_output_if+0x1d4>
  8113bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8113c0:	8b 00                	mov    (%rax),%eax
  8113c2:	85 c0                	test   %eax,%eax
  8113c4:	75 24                	jne    8113ea <ip_output_if+0x1f8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8113c6:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8113ca:	48 83 c0 08          	add    $0x8,%rax
  8113ce:	48 85 c0             	test   %rax,%rax
  8113d1:	74 09                	je     8113dc <ip_output_if+0x1ea>
  8113d3:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8113d7:	8b 40 08             	mov    0x8(%rax),%eax
  8113da:	eb 05                	jmp    8113e1 <ip_output_if+0x1ef>
  8113dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8113e1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8113e5:	89 42 0c             	mov    %eax,0xc(%rdx)
  8113e8:	eb 1b                	jmp    811405 <ip_output_if+0x213>
    } else {
      ip_addr_set(&(iphdr->src), src);
  8113ea:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8113ef:	74 08                	je     8113f9 <ip_output_if+0x207>
  8113f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8113f5:	8b 00                	mov    (%rax),%eax
  8113f7:	eb 05                	jmp    8113fe <ip_output_if+0x20c>
  8113f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8113fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811402:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  811405:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811409:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  81140f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811413:	be 14 00 00 00       	mov    $0x14,%esi
  811418:	48 89 c7             	mov    %rax,%rdi
  81141b:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  811422:	00 00 00 
  811425:	ff d0                	callq  *%rax
  811427:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81142b:	66 89 42 0a          	mov    %ax,0xa(%rdx)
  81142f:	eb 18                	jmp    811449 <ip_output_if+0x257>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  811431:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811435:	48 8b 40 08          	mov    0x8(%rax),%rax
  811439:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  81143d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811441:	48 83 c0 10          	add    $0x10,%rax
  811445:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  811449:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81144d:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811451:	66 85 c0             	test   %ax,%ax
  811454:	74 32                	je     811488 <ip_output_if+0x296>
  811456:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81145a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81145e:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811462:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811466:	66 39 c2             	cmp    %ax,%dx
  811469:	76 1d                	jbe    811488 <ip_output_if+0x296>
    return ip_frag(p,netif,dest);
  81146b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81146f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811473:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  811477:	48 89 c7             	mov    %rax,%rdi
  81147a:	48 b8 0e 23 81 00 00 	movabs $0x81230e,%rax
  811481:	00 00 00 
  811484:	ff d0                	callq  *%rax
  811486:	eb 19                	jmp    8114a1 <ip_output_if+0x2af>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  811488:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81148c:	48 8b 40 20          	mov    0x20(%rax),%rax
  811490:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  811494:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  811498:	48 89 ce             	mov    %rcx,%rsi
  81149b:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  81149f:	ff d0                	callq  *%rax
  }
}
  8114a1:	48 83 c4 48          	add    $0x48,%rsp
  8114a5:	5b                   	pop    %rbx
  8114a6:	5d                   	pop    %rbp
  8114a7:	c3                   	retq   

00000000008114a8 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8114a8:	55                   	push   %rbp
  8114a9:	48 89 e5             	mov    %rsp,%rbp
  8114ac:	48 83 ec 40          	sub    $0x40,%rsp
  8114b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8114b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8114b8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8114bc:	89 c8                	mov    %ecx,%eax
  8114be:	44 89 c1             	mov    %r8d,%ecx
  8114c1:	44 89 ca             	mov    %r9d,%edx
  8114c4:	88 45 d4             	mov    %al,-0x2c(%rbp)
  8114c7:	88 4d d0             	mov    %cl,-0x30(%rbp)
  8114ca:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8114cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8114d1:	48 89 c7             	mov    %rax,%rdi
  8114d4:	48 b8 bd 0c 81 00 00 	movabs $0x810cbd,%rax
  8114db:	00 00 00 
  8114de:	ff d0                	callq  *%rax
  8114e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8114e4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8114e9:	75 07                	jne    8114f2 <ip_output+0x4a>
    return ERR_RTE;
  8114eb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8114f0:	eb 31                	jmp    811523 <ip_output+0x7b>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8114f2:	44 0f b6 4d cc       	movzbl -0x34(%rbp),%r9d
  8114f7:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
  8114fc:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  811500:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811504:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  811508:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81150c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  811510:	48 89 3c 24          	mov    %rdi,(%rsp)
  811514:	48 89 c7             	mov    %rax,%rdi
  811517:	48 b8 f2 11 81 00 00 	movabs $0x8111f2,%rax
  81151e:	00 00 00 
  811521:	ff d0                	callq  *%rax
}
  811523:	c9                   	leaveq 
  811524:	c3                   	retq   

0000000000811525 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  811525:	55                   	push   %rbp
  811526:	48 89 e5             	mov    %rsp,%rbp
  811529:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  81152d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811534:	00 

  r = reassdatagrams;
  811535:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81153c:	00 00 00 
  81153f:	48 8b 00             	mov    (%rax),%rax
  811542:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  811546:	eb 60                	jmp    8115a8 <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  811548:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81154c:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811550:	84 c0                	test   %al,%al
  811552:	74 27                	je     81157b <ip_reass_tmr+0x56>
      r->timer--;
  811554:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811558:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81155c:	8d 50 ff             	lea    -0x1(%rax),%edx
  81155f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811563:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  811566:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81156a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  81156e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811572:	48 8b 00             	mov    (%rax),%rax
  811575:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811579:	eb 2d                	jmp    8115a8 <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  81157b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81157f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  811583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811587:	48 8b 00             	mov    (%rax),%rax
  81158a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  81158e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  811592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811596:	48 89 d6             	mov    %rdx,%rsi
  811599:	48 89 c7             	mov    %rax,%rdi
  81159c:	48 b8 b1 15 81 00 00 	movabs $0x8115b1,%rax
  8115a3:	00 00 00 
  8115a6:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  8115a8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8115ad:	75 99                	jne    811548 <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  8115af:	c9                   	leaveq 
  8115b0:	c3                   	retq   

00000000008115b1 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8115b1:	55                   	push   %rbp
  8115b2:	48 89 e5             	mov    %rsp,%rbp
  8115b5:	48 83 ec 30          	sub    $0x30,%rsp
  8115b9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8115bd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  8115c1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8115c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8115cc:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8115d0:	75 2a                	jne    8115fc <ip_reass_free_complete_datagram+0x4b>
  8115d2:	48 ba 38 25 82 00 00 	movabs $0x822538,%rdx
  8115d9:	00 00 00 
  8115dc:	be 99 00 00 00       	mov    $0x99,%esi
  8115e1:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  8115e8:	00 00 00 
  8115eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8115f0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8115f7:	00 00 00 
  8115fa:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  8115fc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811601:	74 37                	je     81163a <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  811603:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811607:	48 8b 00             	mov    (%rax),%rax
  81160a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81160e:	74 2a                	je     81163a <ip_reass_free_complete_datagram+0x89>
  811610:	48 ba 61 25 82 00 00 	movabs $0x822561,%rdx
  811617:	00 00 00 
  81161a:	be 9b 00 00 00       	mov    $0x9b,%esi
  81161f:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811626:	00 00 00 
  811629:	b8 00 00 00 00       	mov    $0x0,%eax
  81162e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811635:	00 00 00 
  811638:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  81163a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81163e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811642:	48 8b 40 08          	mov    0x8(%rax),%rax
  811646:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  81164a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81164e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811652:	66 85 c0             	test   %ax,%ax
  811655:	0f 85 86 00 00 00    	jne    8116e1 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  81165b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81165f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811663:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  811667:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81166b:	48 8b 10             	mov    (%rax),%rdx
  81166e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811672:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  811676:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81167a:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81167e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811682:	48 8b 40 08          	mov    0x8(%rax),%rax
  811686:	ba 14 00 00 00       	mov    $0x14,%edx
  81168b:	48 89 ce             	mov    %rcx,%rsi
  81168e:	48 89 c7             	mov    %rax,%rdi
  811691:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  811698:	00 00 00 
  81169b:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  81169d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8116a1:	be 01 00 00 00       	mov    $0x1,%esi
  8116a6:	48 89 c7             	mov    %rax,%rdi
  8116a9:	48 b8 83 07 82 00 00 	movabs $0x820783,%rax
  8116b0:	00 00 00 
  8116b3:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  8116b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8116b9:	48 89 c7             	mov    %rax,%rdi
  8116bc:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  8116c3:	00 00 00 
  8116c6:	ff d0                	callq  *%rax
  8116c8:	0f b6 c0             	movzbl %al,%eax
  8116cb:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  8116ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8116d2:	48 89 c7             	mov    %rax,%rdi
  8116d5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8116dc:	00 00 00 
  8116df:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  8116e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8116e5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116e9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  8116ed:	eb 4b                	jmp    81173a <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  8116ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8116f3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116f7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  8116fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8116ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  811703:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811707:	48 8b 00             	mov    (%rax),%rax
  81170a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  81170e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811712:	48 89 c7             	mov    %rax,%rdi
  811715:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81171c:	00 00 00 
  81171f:	ff d0                	callq  *%rax
  811721:	0f b6 c0             	movzbl %al,%eax
  811724:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  811727:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81172b:	48 89 c7             	mov    %rax,%rdi
  81172e:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  811735:	00 00 00 
  811738:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  81173a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81173f:	75 ae                	jne    8116ef <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  811741:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811745:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811749:	48 89 d6             	mov    %rdx,%rsi
  81174c:	48 89 c7             	mov    %rax,%rdi
  81174f:	48 b8 b4 19 81 00 00 	movabs $0x8119b4,%rax
  811756:	00 00 00 
  811759:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  81175b:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811762:	00 00 00 
  811765:	0f b7 00             	movzwl (%rax),%eax
  811768:	0f b7 c0             	movzwl %ax,%eax
  81176b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  81176e:	7d 2a                	jge    81179a <ip_reass_free_complete_datagram+0x1e9>
  811770:	48 ba 73 25 82 00 00 	movabs $0x822573,%rdx
  811777:	00 00 00 
  81177a:	be bc 00 00 00       	mov    $0xbc,%esi
  81177f:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811786:	00 00 00 
  811789:	b8 00 00 00 00       	mov    $0x0,%eax
  81178e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811795:	00 00 00 
  811798:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  81179a:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8117a1:	00 00 00 
  8117a4:	0f b7 10             	movzwl (%rax),%edx
  8117a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8117aa:	29 c2                	sub    %eax,%edx
  8117ac:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8117b3:	00 00 00 
  8117b6:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  8117b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8117bc:	c9                   	leaveq 
  8117bd:	c3                   	retq   

00000000008117be <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  8117be:	55                   	push   %rbp
  8117bf:	48 89 e5             	mov    %rsp,%rbp
  8117c2:	48 83 ec 40          	sub    $0x40,%rsp
  8117c6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8117ca:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8117cd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8117d4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8117db:	00 
    prev = NULL;
  8117dc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8117e3:	00 
    other_datagrams = 0;
  8117e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  8117eb:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8117f2:	00 00 00 
  8117f5:	48 8b 00             	mov    (%rax),%rax
  8117f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  8117fc:	e9 89 00 00 00       	jmpq   81188a <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  811801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811805:	8b 50 1c             	mov    0x1c(%rax),%edx
  811808:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81180c:	8b 40 0c             	mov    0xc(%rax),%eax
  81180f:	39 c2                	cmp    %eax,%edx
  811811:	75 27                	jne    81183a <ip_reass_remove_oldest_datagram+0x7c>
  811813:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811817:	8b 50 20             	mov    0x20(%rax),%edx
  81181a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81181e:	8b 40 10             	mov    0x10(%rax),%eax
  811821:	39 c2                	cmp    %eax,%edx
  811823:	75 15                	jne    81183a <ip_reass_remove_oldest_datagram+0x7c>
  811825:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811829:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  81182d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811831:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811835:	66 39 c2             	cmp    %ax,%dx
  811838:	74 31                	je     81186b <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  81183a:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  81183e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811843:	75 0a                	jne    81184f <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  811845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811849:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81184d:	eb 1c                	jmp    81186b <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  81184f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811853:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  811857:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81185b:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81185f:	38 c2                	cmp    %al,%dl
  811861:	77 08                	ja     81186b <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  811863:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811867:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  81186b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81186f:	48 8b 00             	mov    (%rax),%rax
  811872:	48 85 c0             	test   %rax,%rax
  811875:	74 08                	je     81187f <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  811877:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81187b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  81187f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811883:	48 8b 00             	mov    (%rax),%rax
  811886:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  81188a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81188f:	0f 85 6c ff ff ff    	jne    811801 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  811895:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81189a:	74 23                	je     8118bf <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  81189c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8118a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8118a4:	48 89 d6             	mov    %rdx,%rsi
  8118a7:	48 89 c7             	mov    %rax,%rdi
  8118aa:	48 b8 b1 15 81 00 00 	movabs $0x8115b1,%rax
  8118b1:	00 00 00 
  8118b4:	ff d0                	callq  *%rax
  8118b6:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  8118b9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8118bc:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8118bf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8118c2:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8118c5:	7d 0a                	jge    8118d1 <ip_reass_remove_oldest_datagram+0x113>
  8118c7:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  8118cb:	0f 8f 03 ff ff ff    	jg     8117d4 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  8118d1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  8118d4:	c9                   	leaveq 
  8118d5:	c3                   	retq   

00000000008118d6 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  8118d6:	55                   	push   %rbp
  8118d7:	48 89 e5             	mov    %rsp,%rbp
  8118da:	48 83 ec 20          	sub    $0x20,%rsp
  8118de:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8118e2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  8118e5:	bf 05 00 00 00       	mov    $0x5,%edi
  8118ea:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  8118f1:	00 00 00 
  8118f4:	ff d0                	callq  *%rax
  8118f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  8118fa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8118ff:	75 40                	jne    811941 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811901:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  811904:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811908:	89 d6                	mov    %edx,%esi
  81190a:	48 89 c7             	mov    %rax,%rdi
  81190d:	48 b8 be 17 81 00 00 	movabs $0x8117be,%rax
  811914:	00 00 00 
  811917:	ff d0                	callq  *%rax
  811919:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  81191c:	7c 15                	jl     811933 <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  81191e:	bf 05 00 00 00       	mov    $0x5,%edi
  811923:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  81192a:	00 00 00 
  81192d:	ff d0                	callq  *%rax
  81192f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  811933:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811938:	75 07                	jne    811941 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  81193a:	b8 00 00 00 00       	mov    $0x0,%eax
  81193f:	eb 71                	jmp    8119b2 <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  811941:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811945:	ba 28 00 00 00       	mov    $0x28,%edx
  81194a:	be 00 00 00 00       	mov    $0x0,%esi
  81194f:	48 89 c7             	mov    %rax,%rdi
  811952:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  811959:	00 00 00 
  81195c:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  81195e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811962:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  811966:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81196d:	00 00 00 
  811970:	48 8b 10             	mov    (%rax),%rdx
  811973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811977:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  81197a:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811981:	00 00 00 
  811984:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811988:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  81198b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81198f:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811993:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811997:	ba 14 00 00 00       	mov    $0x14,%edx
  81199c:	48 89 c6             	mov    %rax,%rsi
  81199f:	48 89 cf             	mov    %rcx,%rdi
  8119a2:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8119a9:	00 00 00 
  8119ac:	ff d0                	callq  *%rax
  return ipr;
  8119ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8119b2:	c9                   	leaveq 
  8119b3:	c3                   	retq   

00000000008119b4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8119b4:	55                   	push   %rbp
  8119b5:	48 89 e5             	mov    %rsp,%rbp
  8119b8:	48 83 ec 10          	sub    $0x10,%rsp
  8119bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8119c0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8119c4:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8119cb:	00 00 00 
  8119ce:	48 8b 00             	mov    (%rax),%rax
  8119d1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8119d5:	75 16                	jne    8119ed <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8119d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119db:	48 8b 10             	mov    (%rax),%rdx
  8119de:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8119e5:	00 00 00 
  8119e8:	48 89 10             	mov    %rdx,(%rax)
  8119eb:	eb 3f                	jmp    811a2c <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8119ed:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8119f2:	75 2a                	jne    811a1e <ip_reass_dequeue_datagram+0x6a>
  8119f4:	48 ba 8e 25 82 00 00 	movabs $0x82258e,%rdx
  8119fb:	00 00 00 
  8119fe:	be 29 01 00 00       	mov    $0x129,%esi
  811a03:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811a0a:	00 00 00 
  811a0d:	b8 00 00 00 00       	mov    $0x0,%eax
  811a12:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811a19:	00 00 00 
  811a1c:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  811a1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a22:	48 8b 10             	mov    (%rax),%rdx
  811a25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811a29:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  811a2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a30:	48 89 c6             	mov    %rax,%rsi
  811a33:	bf 05 00 00 00       	mov    $0x5,%edi
  811a38:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  811a3f:	00 00 00 
  811a42:	ff d0                	callq  *%rax
}
  811a44:	c9                   	leaveq 
  811a45:	c3                   	retq   

0000000000811a46 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  811a46:	55                   	push   %rbp
  811a47:	48 89 e5             	mov    %rsp,%rbp
  811a4a:	53                   	push   %rbx
  811a4b:	48 83 ec 58          	sub    $0x58,%rsp
  811a4f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  811a53:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  811a57:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  811a5e:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  811a5f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  811a66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811a6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a6e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811a72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811a76:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811a7a:	0f b7 c0             	movzwl %ax,%eax
  811a7d:	89 c7                	mov    %eax,%edi
  811a7f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811a86:	00 00 00 
  811a89:	ff d0                	callq  *%rax
  811a8b:	89 c3                	mov    %eax,%ebx
  811a8d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811a91:	0f b7 00             	movzwl (%rax),%eax
  811a94:	0f b7 c0             	movzwl %ax,%eax
  811a97:	89 c7                	mov    %eax,%edi
  811a99:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811aa0:	00 00 00 
  811aa3:	ff d0                	callq  *%rax
  811aa5:	66 c1 e8 08          	shr    $0x8,%ax
  811aa9:	83 e0 0f             	and    $0xf,%eax
  811aac:	89 c2                	mov    %eax,%edx
  811aae:	b8 00 00 00 00       	mov    $0x0,%eax
  811ab3:	29 d0                	sub    %edx,%eax
  811ab5:	c1 e0 02             	shl    $0x2,%eax
  811ab8:	01 d8                	add    %ebx,%eax
  811aba:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811abe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811ac2:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811ac6:	0f b7 c0             	movzwl %ax,%eax
  811ac9:	89 c7                	mov    %eax,%edi
  811acb:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811ad2:	00 00 00 
  811ad5:	ff d0                	callq  *%rax
  811ad7:	66 25 ff 1f          	and    $0x1fff,%ax
  811adb:	c1 e0 03             	shl    $0x3,%eax
  811ade:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  811ae2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811ae6:	48 8b 40 08          	mov    0x8(%rax),%rax
  811aea:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811aee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811af2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811af9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811afd:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811b01:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  811b05:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811b09:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811b0d:	01 c2                	add    %eax,%edx
  811b0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b13:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811b17:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811b1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b1f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811b23:	e9 ed 00 00 00       	jmpq   811c15 <ip_reass_chain_frag_into_datagram_and_validate+0x1cf>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811b28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811b2c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b30:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811b34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b38:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811b3c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811b40:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811b44:	66 39 c2             	cmp    %ax,%dx
  811b47:	73 62                	jae    811bab <ip_reass_chain_frag_into_datagram_and_validate+0x165>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811b49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b4d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811b51:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  811b54:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811b59:	74 42                	je     811b9d <ip_reass_chain_frag_into_datagram_and_validate+0x157>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  811b5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b5f:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811b63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811b67:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811b6b:	66 39 c2             	cmp    %ax,%dx
  811b6e:	0f 82 01 03 00 00    	jb     811e75 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
  811b74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b78:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811b7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811b80:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811b84:	66 39 c2             	cmp    %ax,%dx
  811b87:	0f 87 e8 02 00 00    	ja     811e75 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  811b8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811b91:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811b95:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811b98:	e9 83 00 00 00       	jmpq   811c20 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811b9d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ba1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811ba5:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811ba9:	eb 75                	jmp    811c20 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
    } else if(iprh->start == iprh_tmp->start) {
  811bab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811baf:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811bb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811bb7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811bbb:	66 39 c2             	cmp    %ax,%dx
  811bbe:	75 05                	jne    811bc5 <ip_reass_chain_frag_into_datagram_and_validate+0x17f>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  811bc0:	e9 b0 02 00 00       	jmpq   811e75 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  811bc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811bc9:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811bcd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811bd1:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811bd5:	66 39 c2             	cmp    %ax,%dx
  811bd8:	73 05                	jae    811bdf <ip_reass_chain_frag_into_datagram_and_validate+0x199>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  811bda:	e9 96 02 00 00       	jmpq   811e75 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811bdf:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811be4:	74 1c                	je     811c02 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
        if (iprh_prev->end != iprh_tmp->start) {
  811be6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811bea:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811bee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811bf2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811bf6:	66 39 c2             	cmp    %ax,%dx
  811bf9:	74 07                	je     811c02 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811bfb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811c02:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811c06:	48 8b 00             	mov    (%rax),%rax
  811c09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811c0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811c11:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811c15:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811c1a:	0f 85 08 ff ff ff    	jne    811b28 <ip_reass_chain_frag_into_datagram_and_validate+0xe2>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811c20:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811c25:	0f 85 b2 00 00 00    	jne    811cdd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
    if (iprh_prev != NULL) {
  811c2b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811c30:	74 68                	je     811c9a <ip_reass_chain_frag_into_datagram_and_validate+0x254>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811c32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c36:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811c3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c3e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811c42:	66 39 c2             	cmp    %ax,%dx
  811c45:	76 2a                	jbe    811c71 <ip_reass_chain_frag_into_datagram_and_validate+0x22b>
  811c47:	48 ba a7 25 82 00 00 	movabs $0x8225a7,%rdx
  811c4e:	00 00 00 
  811c51:	be 83 01 00 00       	mov    $0x183,%esi
  811c56:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811c5d:	00 00 00 
  811c60:	b8 00 00 00 00       	mov    $0x0,%eax
  811c65:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811c6c:	00 00 00 
  811c6f:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  811c71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c75:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811c79:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811c7c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c80:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811c84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c88:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811c8c:	66 39 c2             	cmp    %ax,%dx
  811c8f:	74 4c                	je     811cdd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
        valid = 0;
  811c91:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811c98:	eb 43                	jmp    811cdd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811c9a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811c9e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ca2:	48 85 c0             	test   %rax,%rax
  811ca5:	74 2a                	je     811cd1 <ip_reass_chain_frag_into_datagram_and_validate+0x28b>
  811ca7:	48 ba c8 25 82 00 00 	movabs $0x8225c8,%rdx
  811cae:	00 00 00 
  811cb1:	be 8c 01 00 00       	mov    $0x18c,%esi
  811cb6:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811cbd:	00 00 00 
  811cc0:	b8 00 00 00 00       	mov    $0x0,%eax
  811cc5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811ccc:	00 00 00 
  811ccf:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811cd1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811cd5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811cd9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811cdd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ce1:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811ce5:	0f b6 c0             	movzbl %al,%eax
  811ce8:	83 e0 01             	and    $0x1,%eax
  811ceb:	85 c0                	test   %eax,%eax
  811ced:	0f 84 7b 01 00 00    	je     811e6e <ip_reass_chain_frag_into_datagram_and_validate+0x428>
    /* and had no wholes so far */
    if (valid) {
  811cf3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811cf7:	0f 84 6c 01 00 00    	je     811e69 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811cfd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811d01:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d05:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d09:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d0d:	66 85 c0             	test   %ax,%ax
  811d10:	74 0c                	je     811d1e <ip_reass_chain_frag_into_datagram_and_validate+0x2d8>
        valid = 0;
  811d12:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811d19:	e9 4b 01 00 00       	jmpq   811e69 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811d1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811d26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d2a:	48 8b 00             	mov    (%rax),%rax
  811d2d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811d31:	eb 3d                	jmp    811d70 <ip_reass_chain_frag_into_datagram_and_validate+0x32a>
          iprh = (struct ip_reass_helper*)q->payload;
  811d33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811d37:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d3b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811d3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d43:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d4b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d4f:	66 39 c2             	cmp    %ax,%dx
  811d52:	74 09                	je     811d5d <ip_reass_chain_frag_into_datagram_and_validate+0x317>
            valid = 0;
  811d54:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811d5b:	eb 1a                	jmp    811d77 <ip_reass_chain_frag_into_datagram_and_validate+0x331>
          }
          iprh_prev = iprh;
  811d5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d61:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d69:	48 8b 00             	mov    (%rax),%rax
  811d6c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811d70:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811d75:	75 bc                	jne    811d33 <ip_reass_chain_frag_into_datagram_and_validate+0x2ed>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811d77:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811d7b:	0f 84 e8 00 00 00    	je     811e69 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811d81:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811d85:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d89:	48 85 c0             	test   %rax,%rax
  811d8c:	75 2a                	jne    811db8 <ip_reass_chain_frag_into_datagram_and_validate+0x372>
  811d8e:	48 ba ff 25 82 00 00 	movabs $0x8225ff,%rdx
  811d95:	00 00 00 
  811d98:	be ac 01 00 00       	mov    $0x1ac,%esi
  811d9d:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811da4:	00 00 00 
  811da7:	b8 00 00 00 00       	mov    $0x0,%eax
  811dac:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811db3:	00 00 00 
  811db6:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811db8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811dbc:	48 8b 40 08          	mov    0x8(%rax),%rax
  811dc0:	48 8b 40 08          	mov    0x8(%rax),%rax
  811dc4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811dc8:	75 2a                	jne    811df4 <ip_reass_chain_frag_into_datagram_and_validate+0x3ae>
  811dca:	48 ba ff 25 82 00 00 	movabs $0x8225ff,%rdx
  811dd1:	00 00 00 
  811dd4:	be ae 01 00 00       	mov    $0x1ae,%esi
  811dd9:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811de0:	00 00 00 
  811de3:	b8 00 00 00 00       	mov    $0x0,%eax
  811de8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811def:	00 00 00 
  811df2:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811df4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811df8:	48 8b 00             	mov    (%rax),%rax
  811dfb:	48 85 c0             	test   %rax,%rax
  811dfe:	74 2a                	je     811e2a <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
  811e00:	48 ba 10 26 82 00 00 	movabs $0x822610,%rdx
  811e07:	00 00 00 
  811e0a:	be b0 01 00 00       	mov    $0x1b0,%esi
  811e0f:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811e16:	00 00 00 
  811e19:	b8 00 00 00 00       	mov    $0x0,%eax
  811e1e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811e25:	00 00 00 
  811e28:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811e2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e2e:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811e32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e36:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811e3a:	66 39 c2             	cmp    %ax,%dx
  811e3d:	74 2a                	je     811e69 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
  811e3f:	48 ba 38 26 82 00 00 	movabs $0x822638,%rdx
  811e46:	00 00 00 
  811e49:	be b2 01 00 00       	mov    $0x1b2,%esi
  811e4e:	48 bf 44 25 82 00 00 	movabs $0x822544,%rdi
  811e55:	00 00 00 
  811e58:	b8 00 00 00 00       	mov    $0x0,%eax
  811e5d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  811e64:	00 00 00 
  811e67:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  811e69:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  811e6c:	eb 53                	jmp    811ec1 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  811e6e:	b8 00 00 00 00       	mov    $0x0,%eax
  811e73:	eb 4c                	jmp    811ec1 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811e75:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811e7c:	00 00 00 
  811e7f:	0f b7 18             	movzwl (%rax),%ebx
  811e82:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811e86:	48 89 c7             	mov    %rax,%rdi
  811e89:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  811e90:	00 00 00 
  811e93:	ff d0                	callq  *%rax
  811e95:	0f b6 c0             	movzbl %al,%eax
  811e98:	29 c3                	sub    %eax,%ebx
  811e9a:	89 da                	mov    %ebx,%edx
  811e9c:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811ea3:	00 00 00 
  811ea6:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  811ea9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811ead:	48 89 c7             	mov    %rax,%rdi
  811eb0:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  811eb7:	00 00 00 
  811eba:	ff d0                	callq  *%rax
  return 0;
  811ebc:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  811ec1:	48 83 c4 58          	add    $0x58,%rsp
  811ec5:	5b                   	pop    %rbx
  811ec6:	5d                   	pop    %rbp
  811ec7:	c3                   	retq   

0000000000811ec8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811ec8:	55                   	push   %rbp
  811ec9:	48 89 e5             	mov    %rsp,%rbp
  811ecc:	53                   	push   %rbx
  811ecd:	48 83 ec 48          	sub    $0x48,%rsp
  811ed1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811ed5:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811edc:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  811edd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811ee1:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  811ee9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811eed:	0f b7 00             	movzwl (%rax),%eax
  811ef0:	0f b7 c0             	movzwl %ax,%eax
  811ef3:	89 c7                	mov    %eax,%edi
  811ef5:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811efc:	00 00 00 
  811eff:	ff d0                	callq  *%rax
  811f01:	66 c1 e8 08          	shr    $0x8,%ax
  811f05:	0f b7 c0             	movzwl %ax,%eax
  811f08:	83 e0 0f             	and    $0xf,%eax
  811f0b:	c1 e0 02             	shl    $0x2,%eax
  811f0e:	83 f8 14             	cmp    $0x14,%eax
  811f11:	74 05                	je     811f18 <ip_reass+0x50>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  811f13:	e9 d7 03 00 00       	jmpq   8122ef <ip_reass+0x427>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811f18:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f1c:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811f20:	0f b7 c0             	movzwl %ax,%eax
  811f23:	89 c7                	mov    %eax,%edi
  811f25:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811f2c:	00 00 00 
  811f2f:	ff d0                	callq  *%rax
  811f31:	66 25 ff 1f          	and    $0x1fff,%ax
  811f35:	c1 e0 03             	shl    $0x3,%eax
  811f38:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811f3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f40:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811f44:	0f b7 c0             	movzwl %ax,%eax
  811f47:	89 c7                	mov    %eax,%edi
  811f49:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811f50:	00 00 00 
  811f53:	ff d0                	callq  *%rax
  811f55:	89 c3                	mov    %eax,%ebx
  811f57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f5b:	0f b7 00             	movzwl (%rax),%eax
  811f5e:	0f b7 c0             	movzwl %ax,%eax
  811f61:	89 c7                	mov    %eax,%edi
  811f63:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  811f6a:	00 00 00 
  811f6d:	ff d0                	callq  *%rax
  811f6f:	66 c1 e8 08          	shr    $0x8,%ax
  811f73:	83 e0 0f             	and    $0xf,%eax
  811f76:	89 c2                	mov    %eax,%edx
  811f78:	b8 00 00 00 00       	mov    $0x0,%eax
  811f7d:	29 d0                	sub    %edx,%eax
  811f7f:	c1 e0 02             	shl    $0x2,%eax
  811f82:	01 d8                	add    %ebx,%eax
  811f84:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  811f88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811f8c:	48 89 c7             	mov    %rax,%rdi
  811f8f:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  811f96:	00 00 00 
  811f99:	ff d0                	callq  *%rax
  811f9b:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  811f9e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811fa5:	00 00 00 
  811fa8:	0f b7 00             	movzwl (%rax),%eax
  811fab:	0f b7 d0             	movzwl %ax,%edx
  811fae:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811fb2:	01 d0                	add    %edx,%eax
  811fb4:	83 f8 0a             	cmp    $0xa,%eax
  811fb7:	7e 3d                	jle    811ff6 <ip_reass+0x12e>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811fb9:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811fbd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811fc1:	89 d6                	mov    %edx,%esi
  811fc3:	48 89 c7             	mov    %rax,%rdi
  811fc6:	48 b8 be 17 81 00 00 	movabs $0x8117be,%rax
  811fcd:	00 00 00 
  811fd0:	ff d0                	callq  *%rax
  811fd2:	85 c0                	test   %eax,%eax
  811fd4:	74 1b                	je     811ff1 <ip_reass+0x129>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  811fd6:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811fdd:	00 00 00 
  811fe0:	0f b7 00             	movzwl (%rax),%eax
  811fe3:	0f b7 d0             	movzwl %ax,%edx
  811fe6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811fea:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811fec:	83 f8 0a             	cmp    $0xa,%eax
  811fef:	7e 05                	jle    811ff6 <ip_reass+0x12e>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  811ff1:	e9 f9 02 00 00       	jmpq   8122ef <ip_reass+0x427>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811ff6:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811ffd:	00 00 00 
  812000:	48 8b 00             	mov    (%rax),%rax
  812003:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812007:	eb 4e                	jmp    812057 <ip_reass+0x18f>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  812009:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81200d:	8b 50 1c             	mov    0x1c(%rax),%edx
  812010:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812014:	8b 40 0c             	mov    0xc(%rax),%eax
  812017:	39 c2                	cmp    %eax,%edx
  812019:	75 29                	jne    812044 <ip_reass+0x17c>
  81201b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81201f:	8b 50 20             	mov    0x20(%rax),%edx
  812022:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812026:	8b 40 10             	mov    0x10(%rax),%eax
  812029:	39 c2                	cmp    %eax,%edx
  81202b:	75 17                	jne    812044 <ip_reass+0x17c>
  81202d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812031:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  812035:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812039:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81203d:	66 39 c2             	cmp    %ax,%dx
  812040:	75 02                	jne    812044 <ip_reass+0x17c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  812042:	eb 1a                	jmp    81205e <ip_reass+0x196>
    }
    ipr_prev = ipr;
  812044:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812048:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  81204c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812050:	48 8b 00             	mov    (%rax),%rax
  812053:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812057:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81205c:	75 ab                	jne    812009 <ip_reass+0x141>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  81205e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812063:	75 29                	jne    81208e <ip_reass+0x1c6>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  812065:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  812069:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81206d:	89 d6                	mov    %edx,%esi
  81206f:	48 89 c7             	mov    %rax,%rdi
  812072:	48 b8 d6 18 81 00 00 	movabs $0x8118d6,%rax
  812079:	00 00 00 
  81207c:	ff d0                	callq  *%rax
  81207e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  812082:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812087:	75 72                	jne    8120fb <ip_reass+0x233>
      goto nullreturn;
  812089:	e9 61 02 00 00       	jmpq   8122ef <ip_reass+0x427>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  81208e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812092:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812096:	0f b7 c0             	movzwl %ax,%eax
  812099:	89 c7                	mov    %eax,%edi
  81209b:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8120a2:	00 00 00 
  8120a5:	ff d0                	callq  *%rax
  8120a7:	0f b7 c0             	movzwl %ax,%eax
  8120aa:	25 ff 1f 00 00       	and    $0x1fff,%eax
  8120af:	85 c0                	test   %eax,%eax
  8120b1:	75 48                	jne    8120fb <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8120b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8120b7:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8120bb:	0f b7 c0             	movzwl %ax,%eax
  8120be:	89 c7                	mov    %eax,%edi
  8120c0:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8120c7:	00 00 00 
  8120ca:	ff d0                	callq  *%rax
  8120cc:	0f b7 c0             	movzwl %ax,%eax
  8120cf:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8120d4:	85 c0                	test   %eax,%eax
  8120d6:	74 23                	je     8120fb <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  8120d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8120dc:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8120e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120e4:	ba 14 00 00 00       	mov    $0x14,%edx
  8120e9:	48 89 c6             	mov    %rax,%rsi
  8120ec:	48 89 cf             	mov    %rcx,%rdi
  8120ef:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8120f6:	00 00 00 
  8120f9:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8120fb:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  8120ff:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812106:	00 00 00 
  812109:	0f b7 00             	movzwl (%rax),%eax
  81210c:	01 c2                	add    %eax,%edx
  81210e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812115:	00 00 00 
  812118:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  81211b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81211f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812123:	0f b7 c0             	movzwl %ax,%eax
  812126:	89 c7                	mov    %eax,%edi
  812128:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81212f:	00 00 00 
  812132:	ff d0                	callq  *%rax
  812134:	0f b7 c0             	movzwl %ax,%eax
  812137:	25 00 20 00 00       	and    $0x2000,%eax
  81213c:	85 c0                	test   %eax,%eax
  81213e:	75 26                	jne    812166 <ip_reass+0x29e>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  812140:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812144:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  812148:	83 c8 01             	or     $0x1,%eax
  81214b:	89 c2                	mov    %eax,%edx
  81214d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812151:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  812154:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  812158:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  81215c:	01 c2                	add    %eax,%edx
  81215e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812162:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  812166:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81216a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81216e:	48 89 d6             	mov    %rdx,%rsi
  812171:	48 89 c7             	mov    %rax,%rdi
  812174:	48 b8 46 1a 81 00 00 	movabs $0x811a46,%rax
  81217b:	00 00 00 
  81217e:	ff d0                	callq  *%rax
  812180:	85 c0                	test   %eax,%eax
  812182:	0f 84 60 01 00 00    	je     8122e8 <ip_reass+0x420>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  812188:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81218c:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  812190:	8d 50 14             	lea    0x14(%rax),%edx
  812193:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812197:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  81219b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81219f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8121a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8121a7:	48 8b 00             	mov    (%rax),%rax
  8121aa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  8121ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8121b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8121ba:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8121be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121c2:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8121c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8121ca:	ba 14 00 00 00       	mov    $0x14,%edx
  8121cf:	48 89 ce             	mov    %rcx,%rsi
  8121d2:	48 89 c7             	mov    %rax,%rdi
  8121d5:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8121dc:	00 00 00 
  8121df:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8121e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121e5:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8121e9:	0f b7 c0             	movzwl %ax,%eax
  8121ec:	89 c7                	mov    %eax,%edi
  8121ee:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8121f5:	00 00 00 
  8121f8:	ff d0                	callq  *%rax
  8121fa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8121fe:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(fraghdr, 0);
  812202:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812206:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  81220c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812210:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  812216:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81221a:	be 14 00 00 00       	mov    $0x14,%esi
  81221f:	48 89 c7             	mov    %rax,%rdi
  812222:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  812229:	00 00 00 
  81222c:	ff d0                	callq  *%rax
  81222e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  812232:	66 89 42 0a          	mov    %ax,0xa(%rdx)

    p = ipr->p;
  812236:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81223a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81223e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  812242:	eb 49                	jmp    81228d <ip_reass+0x3c5>
      iprh = (struct ip_reass_helper*)r->payload;
  812244:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812248:	48 8b 40 08          	mov    0x8(%rax),%rax
  81224c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  812250:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812254:	be ec ff ff ff       	mov    $0xffffffec,%esi
  812259:	48 89 c7             	mov    %rax,%rdi
  81225c:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  812263:	00 00 00 
  812266:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  812268:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81226c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812270:	48 89 d6             	mov    %rdx,%rsi
  812273:	48 89 c7             	mov    %rax,%rdi
  812276:	48 b8 2a de 80 00 00 	movabs $0x80de2a,%rax
  81227d:	00 00 00 
  812280:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  812282:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812286:	48 8b 00             	mov    (%rax),%rax
  812289:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  81228d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812292:	75 b0                	jne    812244 <ip_reass+0x37c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  812294:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812298:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81229c:	48 89 d6             	mov    %rdx,%rsi
  81229f:	48 89 c7             	mov    %rax,%rdi
  8122a2:	48 b8 b4 19 81 00 00 	movabs $0x8119b4,%rax
  8122a9:	00 00 00 
  8122ac:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8122ae:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8122b5:	00 00 00 
  8122b8:	0f b7 18             	movzwl (%rax),%ebx
  8122bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8122bf:	48 89 c7             	mov    %rax,%rdi
  8122c2:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  8122c9:	00 00 00 
  8122cc:	ff d0                	callq  *%rax
  8122ce:	0f b6 c0             	movzbl %al,%eax
  8122d1:	29 c3                	sub    %eax,%ebx
  8122d3:	89 da                	mov    %ebx,%edx
  8122d5:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8122dc:	00 00 00 
  8122df:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  8122e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8122e6:	eb 1f                	jmp    812307 <ip_reass+0x43f>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8122e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8122ed:	eb 18                	jmp    812307 <ip_reass+0x43f>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8122ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8122f3:	48 89 c7             	mov    %rax,%rdi
  8122f6:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8122fd:	00 00 00 
  812300:	ff d0                	callq  *%rax
  return NULL;
  812302:	b8 00 00 00 00       	mov    $0x0,%eax
}
  812307:	48 83 c4 48          	add    $0x48,%rsp
  81230b:	5b                   	pop    %rbx
  81230c:	5d                   	pop    %rbp
  81230d:	c3                   	retq   

000000000081230e <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  81230e:	55                   	push   %rbp
  81230f:	48 89 e5             	mov    %rsp,%rbp
  812312:	48 83 ec 50          	sub    $0x50,%rsp
  812316:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81231a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81231e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  812322:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812326:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81232a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  81232e:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  812334:	ba 02 00 00 00       	mov    $0x2,%edx
  812339:	be 00 00 00 00       	mov    $0x0,%esi
  81233e:	bf 02 00 00 00       	mov    $0x2,%edi
  812343:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81234a:	00 00 00 
  81234d:	ff d0                	callq  *%rax
  81234f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  812353:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812358:	75 0a                	jne    812364 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  81235a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81235f:	e9 7f 02 00 00       	jmpq   8125e3 <ip_frag+0x2d5>
  }
  rambuf->tot_len = rambuf->len = mtu;
  812364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812368:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  81236c:	66 89 50 12          	mov    %dx,0x12(%rax)
  812370:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812374:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  812378:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81237c:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  812380:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  812387:	00 00 00 
  81238a:	48 83 c0 03          	add    $0x3,%rax
  81238e:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  812392:	48 89 c2             	mov    %rax,%rdx
  812395:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812399:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  81239d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8123a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8123a5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8123a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8123ad:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8123b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8123b5:	ba 14 00 00 00       	mov    $0x14,%edx
  8123ba:	48 89 ce             	mov    %rcx,%rsi
  8123bd:	48 89 c7             	mov    %rax,%rdi
  8123c0:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8123c7:	00 00 00 
  8123ca:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8123cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8123d0:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8123d4:	0f b7 c0             	movzwl %ax,%eax
  8123d7:	89 c7                	mov    %eax,%edi
  8123d9:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8123e0:	00 00 00 
  8123e3:	ff d0                	callq  *%rax
  8123e5:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  8123e9:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8123ed:	66 25 ff 1f          	and    $0x1fff,%ax
  8123f1:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  8123f5:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8123f9:	66 25 00 20          	and    $0x2000,%ax
  8123fd:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  812401:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812405:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  812409:	83 e8 14             	sub    $0x14,%eax
  81240c:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  812410:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  812414:	83 e8 14             	sub    $0x14,%eax
  812417:	8d 50 07             	lea    0x7(%rax),%edx
  81241a:	85 c0                	test   %eax,%eax
  81241c:	0f 48 c2             	cmovs  %edx,%eax
  81241f:	c1 f8 03             	sar    $0x3,%eax
  812422:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  812426:	e9 95 01 00 00       	jmpq   8125c0 <ip_frag+0x2b2>
    last = (left <= mtu - IP_HLEN);
  81242b:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81242f:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  812433:	83 ea 14             	sub    $0x14,%edx
  812436:	39 d0                	cmp    %edx,%eax
  812438:	0f 9e c0             	setle  %al
  81243b:	0f b6 c0             	movzbl %al,%eax
  81243e:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  812442:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812446:	66 25 ff 1f          	and    $0x1fff,%ax
  81244a:	66 0b 45 de          	or     -0x22(%rbp),%ax
  81244e:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  812452:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812457:	75 06                	jne    81245f <ip_frag+0x151>
      tmp = tmp | IP_MF;
  812459:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  81245f:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812464:	75 09                	jne    81246f <ip_frag+0x161>
  812466:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81246a:	c1 e0 03             	shl    $0x3,%eax
  81246d:	eb 04                	jmp    812473 <ip_frag+0x165>
  81246f:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812473:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  812477:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  81247b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  81247f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812483:	48 8d 70 14          	lea    0x14(%rax),%rsi
  812487:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81248b:	48 89 c7             	mov    %rax,%rdi
  81248e:	48 b8 2d e3 80 00 00 	movabs $0x80e32d,%rax
  812495:	00 00 00 
  812498:	ff d0                	callq  *%rax
  81249a:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  81249e:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8124a2:	89 c7                	mov    %eax,%edi
  8124a4:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8124ab:	00 00 00 
  8124ae:	ff d0                	callq  *%rax
  8124b0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8124b4:	66 89 42 06          	mov    %ax,0x6(%rdx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8124b8:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  8124bc:	83 c0 14             	add    $0x14,%eax
  8124bf:	0f b7 c0             	movzwl %ax,%eax
  8124c2:	89 c7                	mov    %eax,%edi
  8124c4:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8124cb:	00 00 00 
  8124ce:	ff d0                	callq  *%rax
  8124d0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8124d4:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8124d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8124dc:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8124e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8124e6:	be 14 00 00 00       	mov    $0x14,%esi
  8124eb:	48 89 c7             	mov    %rax,%rdi
  8124ee:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  8124f5:	00 00 00 
  8124f8:	ff d0                	callq  *%rax
  8124fa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8124fe:	66 89 42 0a          	mov    %ax,0xa(%rdx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  812502:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812507:	74 1f                	je     812528 <ip_frag+0x21a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  812509:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81250d:	83 c0 14             	add    $0x14,%eax
  812510:	0f b7 d0             	movzwl %ax,%edx
  812513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812517:	89 d6                	mov    %edx,%esi
  812519:	48 89 c7             	mov    %rax,%rdi
  81251c:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  812523:	00 00 00 
  812526:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  812528:	ba 00 00 00 00       	mov    $0x0,%edx
  81252d:	be 00 00 00 00       	mov    $0x0,%esi
  812532:	bf 02 00 00 00       	mov    $0x2,%edi
  812537:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81253e:	00 00 00 
  812541:	ff d0                	callq  *%rax
  812543:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  812547:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81254c:	74 58                	je     8125a6 <ip_frag+0x298>
      pbuf_chain(header, rambuf);
  81254e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812552:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812556:	48 89 d6             	mov    %rdx,%rsi
  812559:	48 89 c7             	mov    %rax,%rdi
  81255c:	48 b8 49 df 80 00 00 	movabs $0x80df49,%rax
  812563:	00 00 00 
  812566:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  812568:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81256c:	48 8b 40 20          	mov    0x20(%rax),%rax
  812570:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812574:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  812578:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  81257c:	48 89 cf             	mov    %rcx,%rdi
  81257f:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  812581:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812585:	48 89 c7             	mov    %rax,%rdi
  812588:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81258f:	00 00 00 
  812592:	ff d0                	callq  *%rax
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  812594:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812598:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  81259c:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8125a0:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  8125a4:	eb 1a                	jmp    8125c0 <ip_frag+0x2b2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8125a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8125aa:	48 89 c7             	mov    %rax,%rdi
  8125ad:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8125b4:	00 00 00 
  8125b7:	ff d0                	callq  *%rax
      return ERR_MEM;
  8125b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8125be:	eb 23                	jmp    8125e3 <ip_frag+0x2d5>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8125c0:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  8125c5:	0f 85 60 fe ff ff    	jne    81242b <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8125cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8125cf:	48 89 c7             	mov    %rax,%rdi
  8125d2:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8125d9:	00 00 00 
  8125dc:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8125de:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8125e3:	c9                   	leaveq 
  8125e4:	c3                   	retq   

00000000008125e5 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8125e5:	55                   	push   %rbp
  8125e6:	48 89 e5             	mov    %rsp,%rbp
  8125e9:	48 83 ec 30          	sub    $0x30,%rsp
  8125ed:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8125f1:	89 f0                	mov    %esi,%eax
  8125f3:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8125f7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  8125fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812602:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  812606:	eb 35                	jmp    81263d <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  812608:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81260c:	0f b6 00             	movzbl (%rax),%eax
  81260f:	0f b6 c0             	movzbl %al,%eax
  812612:	c1 e0 08             	shl    $0x8,%eax
  812615:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  812619:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  81261e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812622:	0f b6 00             	movzbl (%rax),%eax
  812625:	0f b6 c0             	movzbl %al,%eax
  812628:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  81262c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  812631:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812635:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  812638:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  81263d:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  812642:	77 c4                	ja     812608 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  812644:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  812649:	74 18                	je     812663 <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  81264b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81264f:	0f b6 00             	movzbl (%rax),%eax
  812652:	0f b6 c0             	movzbl %al,%eax
  812655:	c1 e0 08             	shl    $0x8,%eax
  812658:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  81265c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812660:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  812663:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812666:	c1 e8 10             	shr    $0x10,%eax
  812669:	89 c2                	mov    %eax,%edx
  81266b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81266e:	0f b7 c0             	movzwl %ax,%eax
  812671:	01 d0                	add    %edx,%eax
  812673:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  812676:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812679:	66 b8 00 00          	mov    $0x0,%ax
  81267d:	85 c0                	test   %eax,%eax
  81267f:	74 13                	je     812694 <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  812681:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812684:	c1 e8 10             	shr    $0x10,%eax
  812687:	89 c2                	mov    %eax,%edx
  812689:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81268c:	0f b7 c0             	movzwl %ax,%eax
  81268f:	01 d0                	add    %edx,%eax
  812691:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  812694:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812697:	0f b7 c0             	movzwl %ax,%eax
  81269a:	89 c7                	mov    %eax,%edi
  81269c:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8126a3:	00 00 00 
  8126a6:	ff d0                	callq  *%rax
}
  8126a8:	c9                   	leaveq 
  8126a9:	c3                   	retq   

00000000008126aa <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8126aa:	55                   	push   %rbp
  8126ab:	48 89 e5             	mov    %rsp,%rbp
  8126ae:	48 83 ec 40          	sub    $0x40,%rsp
  8126b2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8126b6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8126ba:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8126be:	89 c8                	mov    %ecx,%eax
  8126c0:	44 89 c2             	mov    %r8d,%edx
  8126c3:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8126c6:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8126ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8126d1:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8126d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8126d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8126dd:	eb 7d                	jmp    81275c <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8126df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8126e3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8126e7:	0f b7 d0             	movzwl %ax,%edx
  8126ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8126ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  8126f2:	89 d6                	mov    %edx,%esi
  8126f4:	48 89 c7             	mov    %rax,%rdi
  8126f7:	48 b8 e5 25 81 00 00 	movabs $0x8125e5,%rax
  8126fe:	00 00 00 
  812701:	ff d0                	callq  *%rax
  812703:	0f b7 c0             	movzwl %ax,%eax
  812706:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  812709:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81270c:	c1 e8 10             	shr    $0x10,%eax
  81270f:	89 c2                	mov    %eax,%edx
  812711:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812714:	0f b7 c0             	movzwl %ax,%eax
  812717:	01 d0                	add    %edx,%eax
  812719:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81271c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812720:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812724:	83 e0 01             	and    $0x1,%eax
  812727:	66 85 c0             	test   %ax,%ax
  81272a:	74 25                	je     812751 <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  81272c:	b8 01 00 00 00       	mov    $0x1,%eax
  812731:	2a 45 ef             	sub    -0x11(%rbp),%al
  812734:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812737:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81273a:	c1 e0 08             	shl    $0x8,%eax
  81273d:	0f b7 c0             	movzwl %ax,%eax
  812740:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812743:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812749:	c1 ea 08             	shr    $0x8,%edx
  81274c:	09 d0                	or     %edx,%eax
  81274e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812751:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812755:	48 8b 00             	mov    (%rax),%rax
  812758:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81275c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812761:	0f 85 78 ff ff ff    	jne    8126df <inet_chksum_pseudo+0x35>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812767:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81276b:	74 1a                	je     812787 <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  81276d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812770:	c1 e0 08             	shl    $0x8,%eax
  812773:	0f b7 c0             	movzwl %ax,%eax
  812776:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812779:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81277f:	c1 ea 08             	shr    $0x8,%edx
  812782:	09 d0                	or     %edx,%eax
  812784:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812787:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81278b:	8b 00                	mov    (%rax),%eax
  81278d:	0f b7 c0             	movzwl %ax,%eax
  812790:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812793:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812797:	8b 00                	mov    (%rax),%eax
  812799:	c1 e8 10             	shr    $0x10,%eax
  81279c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81279f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8127a3:	8b 00                	mov    (%rax),%eax
  8127a5:	0f b7 c0             	movzwl %ax,%eax
  8127a8:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  8127ab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8127af:	8b 00                	mov    (%rax),%eax
  8127b1:	c1 e8 10             	shr    $0x10,%eax
  8127b4:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  8127b7:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8127bb:	89 c7                	mov    %eax,%edi
  8127bd:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8127c4:	00 00 00 
  8127c7:	ff d0                	callq  *%rax
  8127c9:	0f b7 c0             	movzwl %ax,%eax
  8127cc:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  8127cf:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  8127d3:	89 c7                	mov    %eax,%edi
  8127d5:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8127dc:	00 00 00 
  8127df:	ff d0                	callq  *%rax
  8127e1:	0f b7 c0             	movzwl %ax,%eax
  8127e4:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8127e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127ea:	c1 e8 10             	shr    $0x10,%eax
  8127ed:	89 c2                	mov    %eax,%edx
  8127ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127f2:	0f b7 c0             	movzwl %ax,%eax
  8127f5:	01 d0                	add    %edx,%eax
  8127f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8127fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127fd:	c1 e8 10             	shr    $0x10,%eax
  812800:	89 c2                	mov    %eax,%edx
  812802:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812805:	0f b7 c0             	movzwl %ax,%eax
  812808:	01 d0                	add    %edx,%eax
  81280a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  81280d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812810:	f7 d0                	not    %eax
}
  812812:	c9                   	leaveq 
  812813:	c3                   	retq   

0000000000812814 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  812814:	55                   	push   %rbp
  812815:	48 89 e5             	mov    %rsp,%rbp
  812818:	48 83 ec 50          	sub    $0x50,%rsp
  81281c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812820:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812824:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  812828:	89 c8                	mov    %ecx,%eax
  81282a:	44 89 c1             	mov    %r8d,%ecx
  81282d:	44 89 ca             	mov    %r9d,%edx
  812830:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812833:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  812837:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  81283b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812842:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812846:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81284a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81284e:	e9 ce 00 00 00       	jmpq   812921 <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  812853:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812857:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81285b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  81285f:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812863:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  812867:	76 08                	jbe    812871 <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  812869:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  81286d:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  812871:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812875:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812879:	48 8b 40 08          	mov    0x8(%rax),%rax
  81287d:	89 d6                	mov    %edx,%esi
  81287f:	48 89 c7             	mov    %rax,%rdi
  812882:	48 b8 e5 25 81 00 00 	movabs $0x8125e5,%rax
  812889:	00 00 00 
  81288c:	ff d0                	callq  *%rax
  81288e:	0f b7 c0             	movzwl %ax,%eax
  812891:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812894:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812898:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  81289c:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  8128a2:	76 2a                	jbe    8128ce <inet_chksum_pseudo_partial+0xba>
  8128a4:	48 ba 68 26 82 00 00 	movabs $0x822668,%rdx
  8128ab:	00 00 00 
  8128ae:	be 60 01 00 00       	mov    $0x160,%esi
  8128b3:	48 bf 78 26 82 00 00 	movabs $0x822678,%rdi
  8128ba:	00 00 00 
  8128bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8128c2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8128c9:	00 00 00 
  8128cc:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8128ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128d1:	c1 e8 10             	shr    $0x10,%eax
  8128d4:	89 c2                	mov    %eax,%edx
  8128d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128d9:	0f b7 c0             	movzwl %ax,%eax
  8128dc:	01 d0                	add    %edx,%eax
  8128de:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  8128e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8128e5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8128e9:	83 e0 01             	and    $0x1,%eax
  8128ec:	66 85 c0             	test   %ax,%ax
  8128ef:	74 25                	je     812916 <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  8128f1:	b8 01 00 00 00       	mov    $0x1,%eax
  8128f6:	2a 45 ef             	sub    -0x11(%rbp),%al
  8128f9:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8128fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128ff:	c1 e0 08             	shl    $0x8,%eax
  812902:	0f b7 c0             	movzwl %ax,%eax
  812905:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812908:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81290e:	c1 ea 08             	shr    $0x8,%edx
  812911:	09 d0                	or     %edx,%eax
  812913:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812916:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81291a:	48 8b 00             	mov    (%rax),%rax
  81291d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812921:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812926:	74 0b                	je     812933 <inet_chksum_pseudo_partial+0x11f>
  812928:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  81292d:	0f 85 20 ff ff ff    	jne    812853 <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812933:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812937:	74 1a                	je     812953 <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  812939:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81293c:	c1 e0 08             	shl    $0x8,%eax
  81293f:	0f b7 c0             	movzwl %ax,%eax
  812942:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812945:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81294b:	c1 ea 08             	shr    $0x8,%edx
  81294e:	09 d0                	or     %edx,%eax
  812950:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812953:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812957:	8b 00                	mov    (%rax),%eax
  812959:	0f b7 c0             	movzwl %ax,%eax
  81295c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  81295f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812963:	8b 00                	mov    (%rax),%eax
  812965:	c1 e8 10             	shr    $0x10,%eax
  812968:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81296b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81296f:	8b 00                	mov    (%rax),%eax
  812971:	0f b7 c0             	movzwl %ax,%eax
  812974:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812977:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81297b:	8b 00                	mov    (%rax),%eax
  81297d:	c1 e8 10             	shr    $0x10,%eax
  812980:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812983:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812987:	89 c7                	mov    %eax,%edi
  812989:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  812990:	00 00 00 
  812993:	ff d0                	callq  *%rax
  812995:	0f b7 c0             	movzwl %ax,%eax
  812998:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  81299b:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  81299f:	89 c7                	mov    %eax,%edi
  8129a1:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8129a8:	00 00 00 
  8129ab:	ff d0                	callq  *%rax
  8129ad:	0f b7 c0             	movzwl %ax,%eax
  8129b0:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8129b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129b6:	c1 e8 10             	shr    $0x10,%eax
  8129b9:	89 c2                	mov    %eax,%edx
  8129bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129be:	0f b7 c0             	movzwl %ax,%eax
  8129c1:	01 d0                	add    %edx,%eax
  8129c3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8129c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129c9:	c1 e8 10             	shr    $0x10,%eax
  8129cc:	89 c2                	mov    %eax,%edx
  8129ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129d1:	0f b7 c0             	movzwl %ax,%eax
  8129d4:	01 d0                	add    %edx,%eax
  8129d6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8129d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129dc:	f7 d0                	not    %eax
}
  8129de:	c9                   	leaveq 
  8129df:	c3                   	retq   

00000000008129e0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8129e0:	55                   	push   %rbp
  8129e1:	48 89 e5             	mov    %rsp,%rbp
  8129e4:	48 83 ec 10          	sub    $0x10,%rsp
  8129e8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8129ec:	89 f0                	mov    %esi,%eax
  8129ee:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  8129f2:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  8129f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8129fa:	89 d6                	mov    %edx,%esi
  8129fc:	48 89 c7             	mov    %rax,%rdi
  8129ff:	48 b8 e5 25 81 00 00 	movabs $0x8125e5,%rax
  812a06:	00 00 00 
  812a09:	ff d0                	callq  *%rax
  812a0b:	f7 d0                	not    %eax
}
  812a0d:	c9                   	leaveq 
  812a0e:	c3                   	retq   

0000000000812a0f <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  812a0f:	55                   	push   %rbp
  812a10:	48 89 e5             	mov    %rsp,%rbp
  812a13:	48 83 ec 30          	sub    $0x30,%rsp
  812a17:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812a1b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812a22:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  812a26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812a2a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812a2e:	eb 7d                	jmp    812aad <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  812a30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a34:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812a38:	0f b7 d0             	movzwl %ax,%edx
  812a3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a3f:	48 8b 40 08          	mov    0x8(%rax),%rax
  812a43:	89 d6                	mov    %edx,%esi
  812a45:	48 89 c7             	mov    %rax,%rdi
  812a48:	48 b8 e5 25 81 00 00 	movabs $0x8125e5,%rax
  812a4f:	00 00 00 
  812a52:	ff d0                	callq  *%rax
  812a54:	0f b7 c0             	movzwl %ax,%eax
  812a57:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  812a5a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a5d:	c1 e8 10             	shr    $0x10,%eax
  812a60:	89 c2                	mov    %eax,%edx
  812a62:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a65:	0f b7 c0             	movzwl %ax,%eax
  812a68:	01 d0                	add    %edx,%eax
  812a6a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812a6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a71:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812a75:	83 e0 01             	and    $0x1,%eax
  812a78:	66 85 c0             	test   %ax,%ax
  812a7b:	74 25                	je     812aa2 <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  812a7d:	b8 01 00 00 00       	mov    $0x1,%eax
  812a82:	2a 45 ef             	sub    -0x11(%rbp),%al
  812a85:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812a88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a8b:	c1 e0 08             	shl    $0x8,%eax
  812a8e:	0f b7 c0             	movzwl %ax,%eax
  812a91:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812a94:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812a9a:	c1 ea 08             	shr    $0x8,%edx
  812a9d:	09 d0                	or     %edx,%eax
  812a9f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  812aa2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812aa6:	48 8b 00             	mov    (%rax),%rax
  812aa9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812aad:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812ab2:	0f 85 78 ff ff ff    	jne    812a30 <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812ab8:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812abc:	74 1a                	je     812ad8 <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  812abe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ac1:	c1 e0 08             	shl    $0x8,%eax
  812ac4:	0f b7 c0             	movzwl %ax,%eax
  812ac7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812aca:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812ad0:	c1 ea 08             	shr    $0x8,%edx
  812ad3:	09 d0                	or     %edx,%eax
  812ad5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812ad8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812adb:	f7 d0                	not    %eax
}
  812add:	c9                   	leaveq 
  812ade:	c3                   	retq   

0000000000812adf <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  812adf:	55                   	push   %rbp
  812ae0:	48 89 e5             	mov    %rsp,%rbp
  812ae3:	48 83 ec 20          	sub    $0x20,%rsp
  812ae7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812aeb:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  812aef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812af3:	48 89 d6             	mov    %rdx,%rsi
  812af6:	48 89 c7             	mov    %rax,%rdi
  812af9:	48 b8 15 2b 81 00 00 	movabs $0x812b15,%rax
  812b00:	00 00 00 
  812b03:	ff d0                	callq  *%rax
  812b05:	85 c0                	test   %eax,%eax
  812b07:	74 05                	je     812b0e <inet_addr+0x2f>
    return (val.s_addr);
  812b09:	8b 45 f0             	mov    -0x10(%rbp),%eax
  812b0c:	eb 05                	jmp    812b13 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  812b0e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  812b13:	c9                   	leaveq 
  812b14:	c3                   	retq   

0000000000812b15 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  812b15:	55                   	push   %rbp
  812b16:	48 89 e5             	mov    %rsp,%rbp
  812b19:	48 83 ec 40          	sub    $0x40,%rsp
  812b1d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812b21:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  812b25:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812b29:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  812b2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812b31:	0f b6 00             	movzbl (%rax),%eax
  812b34:	0f be c0             	movsbl %al,%eax
  812b37:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  812b3a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812b3d:	3c 2f                	cmp    $0x2f,%al
  812b3f:	76 07                	jbe    812b48 <inet_aton+0x33>
  812b41:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812b44:	3c 39                	cmp    $0x39,%al
  812b46:	76 0a                	jbe    812b52 <inet_aton+0x3d>
      return (0);
  812b48:	b8 00 00 00 00       	mov    $0x0,%eax
  812b4d:	e9 68 02 00 00       	jmpq   812dba <inet_aton+0x2a5>
    val = 0;
  812b52:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  812b59:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  812b60:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  812b64:	75 40                	jne    812ba6 <inet_aton+0x91>
      c = *++cp;
  812b66:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812b6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812b6f:	0f b6 00             	movzbl (%rax),%eax
  812b72:	0f be c0             	movsbl %al,%eax
  812b75:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  812b78:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  812b7c:	74 06                	je     812b84 <inet_aton+0x6f>
  812b7e:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  812b82:	75 1b                	jne    812b9f <inet_aton+0x8a>
        base = 16;
  812b84:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  812b8b:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812b90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812b94:	0f b6 00             	movzbl (%rax),%eax
  812b97:	0f be c0             	movsbl %al,%eax
  812b9a:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812b9d:	eb 07                	jmp    812ba6 <inet_aton+0x91>
      } else
        base = 8;
  812b9f:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812ba6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812ba9:	3c 2f                	cmp    $0x2f,%al
  812bab:	76 2f                	jbe    812bdc <inet_aton+0xc7>
  812bad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812bb0:	3c 39                	cmp    $0x39,%al
  812bb2:	77 28                	ja     812bdc <inet_aton+0xc7>
        val = (val * base) + (int)(c - '0');
  812bb4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  812bb7:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  812bbb:	89 c2                	mov    %eax,%edx
  812bbd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812bc0:	01 d0                	add    %edx,%eax
  812bc2:	83 e8 30             	sub    $0x30,%eax
  812bc5:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812bc8:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812bcd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812bd1:	0f b6 00             	movzbl (%rax),%eax
  812bd4:	0f be c0             	movsbl %al,%eax
  812bd7:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
  812bda:	eb ca                	jmp    812ba6 <inet_aton+0x91>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  812bdc:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  812be0:	75 72                	jne    812c54 <inet_aton+0x13f>
  812be2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812be5:	3c 2f                	cmp    $0x2f,%al
  812be7:	76 07                	jbe    812bf0 <inet_aton+0xdb>
  812be9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812bec:	3c 39                	cmp    $0x39,%al
  812bee:	76 1c                	jbe    812c0c <inet_aton+0xf7>
  812bf0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812bf3:	3c 60                	cmp    $0x60,%al
  812bf5:	76 07                	jbe    812bfe <inet_aton+0xe9>
  812bf7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812bfa:	3c 66                	cmp    $0x66,%al
  812bfc:	76 0e                	jbe    812c0c <inet_aton+0xf7>
  812bfe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c01:	3c 40                	cmp    $0x40,%al
  812c03:	76 4f                	jbe    812c54 <inet_aton+0x13f>
  812c05:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c08:	3c 46                	cmp    $0x46,%al
  812c0a:	77 48                	ja     812c54 <inet_aton+0x13f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  812c0c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c0f:	c1 e0 04             	shl    $0x4,%eax
  812c12:	89 c2                	mov    %eax,%edx
  812c14:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c17:	8d 48 0a             	lea    0xa(%rax),%ecx
  812c1a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c1d:	3c 60                	cmp    $0x60,%al
  812c1f:	76 0e                	jbe    812c2f <inet_aton+0x11a>
  812c21:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c24:	3c 7a                	cmp    $0x7a,%al
  812c26:	77 07                	ja     812c2f <inet_aton+0x11a>
  812c28:	b8 61 00 00 00       	mov    $0x61,%eax
  812c2d:	eb 05                	jmp    812c34 <inet_aton+0x11f>
  812c2f:	b8 41 00 00 00       	mov    $0x41,%eax
  812c34:	29 c1                	sub    %eax,%ecx
  812c36:	89 c8                	mov    %ecx,%eax
  812c38:	09 d0                	or     %edx,%eax
  812c3a:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812c3d:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812c42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812c46:	0f b6 00             	movzbl (%rax),%eax
  812c49:	0f be c0             	movsbl %al,%eax
  812c4c:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  812c4f:	e9 52 ff ff ff       	jmpq   812ba6 <inet_aton+0x91>
    if (c == '.') {
  812c54:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  812c58:	75 40                	jne    812c9a <inet_aton+0x185>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  812c5a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812c5e:	48 83 c0 0c          	add    $0xc,%rax
  812c62:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  812c66:	72 0a                	jb     812c72 <inet_aton+0x15d>
        return (0);
  812c68:	b8 00 00 00 00       	mov    $0x0,%eax
  812c6d:	e9 48 01 00 00       	jmpq   812dba <inet_aton+0x2a5>
      *pp++ = val;
  812c72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c76:	48 8d 50 04          	lea    0x4(%rax),%rdx
  812c7a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  812c7e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812c81:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  812c83:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812c88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812c8c:	0f b6 00             	movzbl (%rax),%eax
  812c8f:	0f be c0             	movsbl %al,%eax
  812c92:	89 45 f4             	mov    %eax,-0xc(%rbp)
    } else
      break;
  }
  812c95:	e9 a0 fe ff ff       	jmpq   812b3a <inet_aton+0x25>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812c9a:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812c9b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  812c9f:	74 3c                	je     812cdd <inet_aton+0x1c8>
  812ca1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812ca4:	3c 1f                	cmp    $0x1f,%al
  812ca6:	76 2b                	jbe    812cd3 <inet_aton+0x1be>
  812ca8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812cab:	84 c0                	test   %al,%al
  812cad:	78 24                	js     812cd3 <inet_aton+0x1be>
  812caf:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  812cb3:	74 28                	je     812cdd <inet_aton+0x1c8>
  812cb5:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812cb9:	74 22                	je     812cdd <inet_aton+0x1c8>
  812cbb:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  812cbf:	74 1c                	je     812cdd <inet_aton+0x1c8>
  812cc1:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812cc5:	74 16                	je     812cdd <inet_aton+0x1c8>
  812cc7:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812ccb:	74 10                	je     812cdd <inet_aton+0x1c8>
  812ccd:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  812cd1:	74 0a                	je     812cdd <inet_aton+0x1c8>
    return (0);
  812cd3:	b8 00 00 00 00       	mov    $0x0,%eax
  812cd8:	e9 dd 00 00 00       	jmpq   812dba <inet_aton+0x2a5>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812cdd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812ce1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812ce5:	48 29 c2             	sub    %rax,%rdx
  812ce8:	48 89 d0             	mov    %rdx,%rax
  812ceb:	48 c1 f8 02          	sar    $0x2,%rax
  812cef:	83 c0 01             	add    $0x1,%eax
  812cf2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812cf5:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812cf9:	0f 87 98 00 00 00    	ja     812d97 <inet_aton+0x282>
  812cff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812d02:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812d09:	00 
  812d0a:	48 b8 a0 26 82 00 00 	movabs $0x8226a0,%rax
  812d11:	00 00 00 
  812d14:	48 01 d0             	add    %rdx,%rax
  812d17:	48 8b 00             	mov    (%rax),%rax
  812d1a:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812d1c:	b8 00 00 00 00       	mov    $0x0,%eax
  812d21:	e9 94 00 00 00       	jmpq   812dba <inet_aton+0x2a5>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812d26:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812d2d:	76 0a                	jbe    812d39 <inet_aton+0x224>
      return (0);
  812d2f:	b8 00 00 00 00       	mov    $0x0,%eax
  812d34:	e9 81 00 00 00       	jmpq   812dba <inet_aton+0x2a5>
    val |= parts[0] << 24;
  812d39:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812d3c:	c1 e0 18             	shl    $0x18,%eax
  812d3f:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812d42:	eb 53                	jmp    812d97 <inet_aton+0x282>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812d44:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  812d4b:	76 07                	jbe    812d54 <inet_aton+0x23f>
      return (0);
  812d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  812d52:	eb 66                	jmp    812dba <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812d54:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812d57:	c1 e0 18             	shl    $0x18,%eax
  812d5a:	89 c2                	mov    %eax,%edx
  812d5c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812d5f:	c1 e0 10             	shl    $0x10,%eax
  812d62:	09 d0                	or     %edx,%eax
  812d64:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812d67:	eb 2e                	jmp    812d97 <inet_aton+0x282>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812d69:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  812d70:	76 07                	jbe    812d79 <inet_aton+0x264>
      return (0);
  812d72:	b8 00 00 00 00       	mov    $0x0,%eax
  812d77:	eb 41                	jmp    812dba <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812d79:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812d7c:	c1 e0 18             	shl    $0x18,%eax
  812d7f:	89 c2                	mov    %eax,%edx
  812d81:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812d84:	c1 e0 10             	shl    $0x10,%eax
  812d87:	09 c2                	or     %eax,%edx
  812d89:	8b 45 d8             	mov    -0x28(%rbp),%eax
  812d8c:	c1 e0 08             	shl    $0x8,%eax
  812d8f:	09 d0                	or     %edx,%eax
  812d91:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812d94:	eb 01                	jmp    812d97 <inet_aton+0x282>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812d96:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812d97:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  812d9c:	74 17                	je     812db5 <inet_aton+0x2a0>
    addr->s_addr = htonl(val);
  812d9e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812da1:	89 c7                	mov    %eax,%edi
  812da3:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  812daa:	00 00 00 
  812dad:	ff d0                	callq  *%rax
  812daf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  812db3:	89 02                	mov    %eax,(%rdx)
  return (1);
  812db5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812dba:	c9                   	leaveq 
  812dbb:	c3                   	retq   

0000000000812dbc <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812dbc:	55                   	push   %rbp
  812dbd:	48 89 e5             	mov    %rsp,%rbp
  812dc0:	48 83 ec 30          	sub    $0x30,%rsp
  812dc4:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812dc7:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812dca:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812dcd:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812dd4:	00 00 00 
  812dd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812ddb:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  812ddf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812de3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812de7:	e9 e0 00 00 00       	jmpq   812ecc <inet_ntoa+0x110>
    i = 0;
  812dec:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  812df0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812df4:	0f b6 08             	movzbl (%rax),%ecx
  812df7:	0f b6 d1             	movzbl %cl,%edx
  812dfa:	89 d0                	mov    %edx,%eax
  812dfc:	c1 e0 02             	shl    $0x2,%eax
  812dff:	01 d0                	add    %edx,%eax
  812e01:	c1 e0 03             	shl    $0x3,%eax
  812e04:	01 d0                	add    %edx,%eax
  812e06:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812e0d:	01 d0                	add    %edx,%eax
  812e0f:	66 c1 e8 08          	shr    $0x8,%ax
  812e13:	c0 e8 03             	shr    $0x3,%al
  812e16:	88 45 ed             	mov    %al,-0x13(%rbp)
  812e19:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812e1d:	89 d0                	mov    %edx,%eax
  812e1f:	c1 e0 02             	shl    $0x2,%eax
  812e22:	01 d0                	add    %edx,%eax
  812e24:	01 c0                	add    %eax,%eax
  812e26:	29 c1                	sub    %eax,%ecx
  812e28:	89 c8                	mov    %ecx,%eax
  812e2a:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  812e2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812e31:	0f b6 00             	movzbl (%rax),%eax
  812e34:	0f b6 d0             	movzbl %al,%edx
  812e37:	89 d0                	mov    %edx,%eax
  812e39:	c1 e0 02             	shl    $0x2,%eax
  812e3c:	01 d0                	add    %edx,%eax
  812e3e:	c1 e0 03             	shl    $0x3,%eax
  812e41:	01 d0                	add    %edx,%eax
  812e43:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812e4a:	01 d0                	add    %edx,%eax
  812e4c:	66 c1 e8 08          	shr    $0x8,%ax
  812e50:	89 c2                	mov    %eax,%edx
  812e52:	c0 ea 03             	shr    $0x3,%dl
  812e55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812e59:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  812e5b:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812e5f:	8d 50 01             	lea    0x1(%rax),%edx
  812e62:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812e65:	0f b6 c0             	movzbl %al,%eax
  812e68:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812e6c:	83 c2 30             	add    $0x30,%edx
  812e6f:	48 98                	cltq   
  812e71:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  812e75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812e79:	0f b6 00             	movzbl (%rax),%eax
  812e7c:	84 c0                	test   %al,%al
  812e7e:	0f 85 6c ff ff ff    	jne    812df0 <inet_ntoa+0x34>
    while(i--)
  812e84:	eb 1a                	jmp    812ea0 <inet_ntoa+0xe4>
      *rp++ = inv[i];
  812e86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812e8a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812e8e:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812e92:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  812e96:	48 63 d2             	movslq %edx,%rdx
  812e99:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  812e9e:	88 10                	mov    %dl,(%rax)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  812ea0:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812ea4:	8d 50 ff             	lea    -0x1(%rax),%edx
  812ea7:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812eaa:	84 c0                	test   %al,%al
  812eac:	75 d8                	jne    812e86 <inet_ntoa+0xca>
      *rp++ = inv[i];
    *rp++ = '.';
  812eae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812eb2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812eb6:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812eba:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  812ebd:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  812ec2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  812ec6:	83 c0 01             	add    $0x1,%eax
  812ec9:	88 45 ef             	mov    %al,-0x11(%rbp)
  812ecc:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  812ed0:	0f 86 16 ff ff ff    	jbe    812dec <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  812ed6:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812edb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812edf:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  812ee2:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812ee9:	00 00 00 
}
  812eec:	c9                   	leaveq 
  812eed:	c3                   	retq   

0000000000812eee <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  812eee:	55                   	push   %rbp
  812eef:	48 89 e5             	mov    %rsp,%rbp
  812ef2:	48 83 ec 04          	sub    $0x4,%rsp
  812ef6:	89 f8                	mov    %edi,%eax
  812ef8:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  812efc:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812f00:	c1 e0 08             	shl    $0x8,%eax
  812f03:	89 c2                	mov    %eax,%edx
  812f05:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812f09:	66 c1 e8 08          	shr    $0x8,%ax
  812f0d:	09 d0                	or     %edx,%eax
}
  812f0f:	c9                   	leaveq 
  812f10:	c3                   	retq   

0000000000812f11 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  812f11:	55                   	push   %rbp
  812f12:	48 89 e5             	mov    %rsp,%rbp
  812f15:	48 83 ec 08          	sub    $0x8,%rsp
  812f19:	89 f8                	mov    %edi,%eax
  812f1b:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  812f1f:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812f23:	89 c7                	mov    %eax,%edi
  812f25:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  812f2c:	00 00 00 
  812f2f:	ff d0                	callq  *%rax
}
  812f31:	c9                   	leaveq 
  812f32:	c3                   	retq   

0000000000812f33 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  812f33:	55                   	push   %rbp
  812f34:	48 89 e5             	mov    %rsp,%rbp
  812f37:	48 83 ec 04          	sub    $0x4,%rsp
  812f3b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  812f3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f41:	c1 e0 18             	shl    $0x18,%eax
  812f44:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  812f46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f49:	25 00 ff 00 00       	and    $0xff00,%eax
  812f4e:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812f51:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  812f53:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f56:	25 00 00 ff 00       	and    $0xff0000,%eax
  812f5b:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812f5f:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  812f61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f64:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812f67:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  812f69:	c9                   	leaveq 
  812f6a:	c3                   	retq   

0000000000812f6b <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  812f6b:	55                   	push   %rbp
  812f6c:	48 89 e5             	mov    %rsp,%rbp
  812f6f:	48 83 ec 08          	sub    $0x8,%rsp
  812f73:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  812f76:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f79:	89 c7                	mov    %eax,%edi
  812f7b:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  812f82:	00 00 00 
  812f85:	ff d0                	callq  *%rax
}
  812f87:	c9                   	leaveq 
  812f88:	c3                   	retq   

0000000000812f89 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  812f89:	55                   	push   %rbp
  812f8a:	48 89 e5             	mov    %rsp,%rbp
  812f8d:	48 83 ec 20          	sub    $0x20,%rsp
  812f91:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812f95:	89 f0                	mov    %esi,%eax
  812f97:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  812f9a:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  812f9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812fa2:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812fa9:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812faf:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  812fb5:	89 d1                	mov    %edx,%ecx
  812fb7:	ba 00 00 00 00       	mov    $0x0,%edx
  812fbc:	be 00 00 00 00       	mov    $0x0,%esi
  812fc1:	48 89 c7             	mov    %rax,%rdi
  812fc4:	48 b8 66 30 81 00 00 	movabs $0x813066,%rax
  812fcb:	00 00 00 
  812fce:	ff d0                	callq  *%rax
}
  812fd0:	c9                   	leaveq 
  812fd1:	c3                   	retq   

0000000000812fd2 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  812fd2:	55                   	push   %rbp
  812fd3:	48 89 e5             	mov    %rsp,%rbp
  812fd6:	48 83 ec 20          	sub    $0x20,%rsp
  812fda:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812fde:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  812fe2:	89 c8                	mov    %ecx,%eax
  812fe4:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  812fe8:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812feb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812fef:	8b 40 18             	mov    0x18(%rax),%eax
  812ff2:	83 f8 04             	cmp    $0x4,%eax
  812ff5:	74 24                	je     81301b <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  812ff7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812ffb:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812ffe:	83 f8 07             	cmp    $0x7,%eax
  813001:	74 18                	je     81301b <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813003:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813007:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  81300a:	83 f8 02             	cmp    $0x2,%eax
  81300d:	74 0c                	je     81301b <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  81300f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813013:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813016:	83 f8 03             	cmp    $0x3,%eax
  813019:	75 44                	jne    81305f <tcp_write+0x8d>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  81301b:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  813020:	74 36                	je     813058 <tcp_write+0x86>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  813022:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  813026:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  81302a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81302e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813032:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  813039:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  81303f:	41 89 c8             	mov    %ecx,%r8d
  813042:	b9 00 00 00 00       	mov    $0x0,%ecx
  813047:	48 89 c7             	mov    %rax,%rdi
  81304a:	48 b8 66 30 81 00 00 	movabs $0x813066,%rax
  813051:	00 00 00 
  813054:	ff d0                	callq  *%rax
  813056:	eb 0c                	jmp    813064 <tcp_write+0x92>
    }
    return ERR_OK;
  813058:	b8 00 00 00 00       	mov    $0x0,%eax
  81305d:	eb 05                	jmp    813064 <tcp_write+0x92>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  81305f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  813064:	c9                   	leaveq 
  813065:	c3                   	retq   

0000000000813066 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  813066:	55                   	push   %rbp
  813067:	48 89 e5             	mov    %rsp,%rbp
  81306a:	41 54                	push   %r12
  81306c:	53                   	push   %rbx
  81306d:	48 83 ec 70          	sub    $0x70,%rsp
  813071:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  813075:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  813079:	89 c8                	mov    %ecx,%eax
  81307b:	44 89 c6             	mov    %r8d,%esi
  81307e:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  813082:	8b 4d 10             	mov    0x10(%rbp),%ecx
  813085:	66 89 55 9c          	mov    %dx,-0x64(%rbp)
  813089:	88 45 98             	mov    %al,-0x68(%rbp)
  81308c:	40 88 75 94          	mov    %sil,-0x6c(%rbp)
  813090:	88 4d 90             	mov    %cl,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  813093:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  813098:	74 30                	je     8130ca <tcp_enqueue+0x64>
  81309a:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  81309e:	74 2a                	je     8130ca <tcp_enqueue+0x64>
  8130a0:	48 ba c8 26 82 00 00 	movabs $0x8226c8,%rdx
  8130a7:	00 00 00 
  8130aa:	be 90 00 00 00       	mov    $0x90,%esi
  8130af:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  8130b6:	00 00 00 
  8130b9:	b8 00 00 00 00       	mov    $0x0,%eax
  8130be:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8130c5:	00 00 00 
  8130c8:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8130ca:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8130cf:	74 31                	je     813102 <tcp_enqueue+0x9c>
  8130d1:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8130d6:	74 2a                	je     813102 <tcp_enqueue+0x9c>
  8130d8:	48 ba 20 27 82 00 00 	movabs $0x822720,%rdx
  8130df:	00 00 00 
  8130e2:	be 92 00 00 00       	mov    $0x92,%esi
  8130e7:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  8130ee:	00 00 00 
  8130f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8130f6:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8130fd:	00 00 00 
  813100:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  813102:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813106:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81310a:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  81310e:	73 1e                	jae    81312e <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  813110:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813114:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813118:	83 c8 80             	or     $0xffffff80,%eax
  81311b:	89 c2                	mov    %eax,%edx
  81311d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813121:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  813124:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  813129:	e9 e5 09 00 00       	jmpq   813b13 <tcp_enqueue+0xaad>
  }
  left = len;
  81312e:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813132:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  813136:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81313a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  81313e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813142:	8b 40 74             	mov    0x74(%rax),%eax
  813145:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  813148:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81314c:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813150:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813154:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  813159:	77 07                	ja     813162 <tcp_enqueue+0xfc>
  81315b:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813160:	76 1e                	jbe    813180 <tcp_enqueue+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  813162:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813166:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81316a:	83 c8 80             	or     $0xffffff80,%eax
  81316d:	89 c2                	mov    %eax,%edx
  81316f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813173:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  813176:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81317b:	e9 93 09 00 00       	jmpq   813b13 <tcp_enqueue+0xaad>
  }
  if (queuelen != 0) {
  813180:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  813185:	74 4e                	je     8131d5 <tcp_enqueue+0x16f>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  813187:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81318b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813192:	48 85 c0             	test   %rax,%rax
  813195:	0f 85 84 00 00 00    	jne    81321f <tcp_enqueue+0x1b9>
  81319b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81319f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8131a6:	48 85 c0             	test   %rax,%rax
  8131a9:	75 74                	jne    81321f <tcp_enqueue+0x1b9>
  8131ab:	48 ba 68 27 82 00 00 	movabs $0x822768,%rdx
  8131b2:	00 00 00 
  8131b5:	be ae 00 00 00       	mov    $0xae,%esi
  8131ba:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  8131c1:	00 00 00 
  8131c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8131c9:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8131d0:	00 00 00 
  8131d3:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8131d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8131d9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8131e0:	48 85 c0             	test   %rax,%rax
  8131e3:	75 10                	jne    8131f5 <tcp_enqueue+0x18f>
  8131e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8131e9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8131f0:	48 85 c0             	test   %rax,%rax
  8131f3:	74 2a                	je     81321f <tcp_enqueue+0x1b9>
  8131f5:	48 ba a8 27 82 00 00 	movabs $0x8227a8,%rdx
  8131fc:	00 00 00 
  8131ff:	be b1 00 00 00       	mov    $0xb1,%esi
  813204:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  81320b:	00 00 00 
  81320e:	b8 00 00 00 00       	mov    $0x0,%eax
  813213:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81321a:	00 00 00 
  81321d:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  81321f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813226:	00 
  813227:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81322b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81322f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813233:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  813237:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  81323d:	e9 f9 04 00 00       	jmpq   81373b <tcp_enqueue+0x6d5>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  813242:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813246:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81324a:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  81324e:	66 39 c2             	cmp    %ax,%dx
  813251:	0f 46 c2             	cmovbe %edx,%eax
  813254:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  813258:	bf 04 00 00 00       	mov    $0x4,%edi
  81325d:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  813264:	00 00 00 
  813267:	ff d0                	callq  *%rax
  813269:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  81326d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813272:	75 05                	jne    813279 <tcp_enqueue+0x213>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  813274:	e9 10 08 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
    }
    seg->next = NULL;
  813279:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81327d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  813284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813288:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81328f:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  813290:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813295:	75 0a                	jne    8132a1 <tcp_enqueue+0x23b>
      queue = seg;
  813297:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81329b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81329f:	eb 3c                	jmp    8132dd <tcp_enqueue+0x277>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  8132a1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8132a6:	75 2a                	jne    8132d2 <tcp_enqueue+0x26c>
  8132a8:	48 ba dc 27 82 00 00 	movabs $0x8227dc,%rdx
  8132af:	00 00 00 
  8132b2:	be ce 00 00 00       	mov    $0xce,%esi
  8132b7:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  8132be:	00 00 00 
  8132c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8132c6:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8132cd:	00 00 00 
  8132d0:	ff d1                	callq  *%rcx
      useg->next = seg;
  8132d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8132d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8132da:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  8132dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132e1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  8132e5:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8132ea:	0f 84 ac 00 00 00    	je     81339c <tcp_enqueue+0x336>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8132f0:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8132f4:	ba 00 00 00 00       	mov    $0x0,%edx
  8132f9:	89 c6                	mov    %eax,%esi
  8132fb:	bf 00 00 00 00       	mov    $0x0,%edi
  813300:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  813307:	00 00 00 
  81330a:	ff d0                	callq  *%rax
  81330c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813310:	48 89 42 08          	mov    %rax,0x8(%rdx)
  813314:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813318:	48 8b 40 08          	mov    0x8(%rax),%rax
  81331c:	48 85 c0             	test   %rax,%rax
  81331f:	75 05                	jne    813326 <tcp_enqueue+0x2c0>
        goto memerr;
  813321:	e9 63 07 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  813326:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81332a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81332e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  813332:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813336:	66 39 c2             	cmp    %ax,%dx
  813339:	73 2a                	jae    813365 <tcp_enqueue+0x2ff>
  81333b:	48 ba f0 27 82 00 00 	movabs $0x8227f0,%rdx
  813342:	00 00 00 
  813345:	be df 00 00 00       	mov    $0xdf,%esi
  81334a:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  813351:	00 00 00 
  813354:	b8 00 00 00 00       	mov    $0x0,%eax
  813359:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  813360:	00 00 00 
  813363:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  813365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813369:	48 8b 40 08          	mov    0x8(%rax),%rax
  81336d:	48 89 c7             	mov    %rax,%rdi
  813370:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  813377:	00 00 00 
  81337a:	ff d0                	callq  *%rax
  81337c:	0f b6 c0             	movzbl %al,%eax
  81337f:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  813383:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813387:	48 8b 40 08          	mov    0x8(%rax),%rax
  81338b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81338f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813393:	48 89 50 10          	mov    %rdx,0x10(%rax)
  813397:	e9 ba 01 00 00       	jmpq   813556 <tcp_enqueue+0x4f0>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  81339c:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  8133a0:	83 e0 01             	and    $0x1,%eax
  8133a3:	85 c0                	test   %eax,%eax
  8133a5:	0f 84 d6 00 00 00    	je     813481 <tcp_enqueue+0x41b>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8133ab:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8133af:	ba 00 00 00 00       	mov    $0x0,%edx
  8133b4:	89 c6                	mov    %eax,%esi
  8133b6:	bf 00 00 00 00       	mov    $0x0,%edi
  8133bb:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  8133c2:	00 00 00 
  8133c5:	ff d0                	callq  *%rax
  8133c7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8133cb:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8133cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8133d7:	48 85 c0             	test   %rax,%rax
  8133da:	75 05                	jne    8133e1 <tcp_enqueue+0x37b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  8133dc:	e9 a8 06 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  8133e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133e5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8133e9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8133ed:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  8133f1:	73 2a                	jae    81341d <tcp_enqueue+0x3b7>
  8133f3:	48 ba 18 28 82 00 00 	movabs $0x822818,%rdx
  8133fa:	00 00 00 
  8133fd:	be ea 00 00 00       	mov    $0xea,%esi
  813402:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  813409:	00 00 00 
  81340c:	b8 00 00 00 00       	mov    $0x0,%eax
  813411:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  813418:	00 00 00 
  81341b:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  81341d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813421:	48 8b 40 08          	mov    0x8(%rax),%rax
  813425:	48 89 c7             	mov    %rax,%rdi
  813428:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81342f:	00 00 00 
  813432:	ff d0                	callq  *%rax
  813434:	0f b6 c0             	movzbl %al,%eax
  813437:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  81343b:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813440:	74 26                	je     813468 <tcp_enqueue+0x402>
        MEMCPY(seg->p->payload, ptr, seglen);
  813442:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81344a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81344e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813452:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  813456:	48 89 ce             	mov    %rcx,%rsi
  813459:	48 89 c7             	mov    %rax,%rdi
  81345c:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  813463:	00 00 00 
  813466:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  813468:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81346c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813470:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813474:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813478:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81347c:	e9 d5 00 00 00       	jmpq   813556 <tcp_enqueue+0x4f0>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  813481:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813485:	ba 01 00 00 00       	mov    $0x1,%edx
  81348a:	89 c6                	mov    %eax,%esi
  81348c:	bf 00 00 00 00       	mov    $0x0,%edi
  813491:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  813498:	00 00 00 
  81349b:	ff d0                	callq  *%rax
  81349d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8134a1:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8134a6:	75 05                	jne    8134ad <tcp_enqueue+0x447>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  8134a8:	e9 dc 05 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
      }
      ++queuelen;
  8134ad:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8134b2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8134b6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8134ba:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  8134be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134c2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8134c6:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8134ca:	ba 00 00 00 00       	mov    $0x0,%edx
  8134cf:	be 00 00 00 00       	mov    $0x0,%esi
  8134d4:	bf 00 00 00 00       	mov    $0x0,%edi
  8134d9:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  8134e0:	00 00 00 
  8134e3:	ff d0                	callq  *%rax
  8134e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8134e9:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8134ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8134f5:	48 85 c0             	test   %rax,%rax
  8134f8:	75 18                	jne    813512 <tcp_enqueue+0x4ac>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8134fa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8134fe:	48 89 c7             	mov    %rax,%rdi
  813501:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  813508:	00 00 00 
  81350b:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  81350d:	e9 77 05 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
      }
      queuelen += pbuf_clen(seg->p);
  813512:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813516:	48 8b 40 08          	mov    0x8(%rax),%rax
  81351a:	48 89 c7             	mov    %rax,%rdi
  81351d:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  813524:	00 00 00 
  813527:	ff d0                	callq  *%rax
  813529:	0f b6 c0             	movzbl %al,%eax
  81352c:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  813530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813534:	48 8b 40 08          	mov    0x8(%rax),%rax
  813538:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81353c:	48 89 d6             	mov    %rdx,%rsi
  81353f:	48 89 c7             	mov    %rax,%rdi
  813542:	48 b8 2a de 80 00 00 	movabs $0x80de2a,%rax
  813549:	00 00 00 
  81354c:	ff d0                	callq  *%rax
      p = NULL;
  81354e:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  813555:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813556:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  81355b:	77 07                	ja     813564 <tcp_enqueue+0x4fe>
  81355d:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813562:	76 05                	jbe    813569 <tcp_enqueue+0x503>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  813564:	e9 20 05 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
    }

    seg->len = seglen;
  813569:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81356d:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813571:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  813575:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813579:	48 8b 40 08          	mov    0x8(%rax),%rax
  81357d:	be 14 00 00 00       	mov    $0x14,%esi
  813582:	48 89 c7             	mov    %rax,%rdi
  813585:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81358c:	00 00 00 
  81358f:	ff d0                	callq  *%rax
  813591:	84 c0                	test   %al,%al
  813593:	74 05                	je     81359a <tcp_enqueue+0x534>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  813595:	e9 ef 04 00 00       	jmpq   813a89 <tcp_enqueue+0xa23>
    }
    seg->tcphdr = seg->p->payload;
  81359a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81359e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8135a2:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8135a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135aa:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  8135ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135b2:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8135b6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8135ba:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8135be:	0f b7 c0             	movzwl %ax,%eax
  8135c1:	89 c7                	mov    %eax,%edi
  8135c3:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8135ca:	00 00 00 
  8135cd:	ff d0                	callq  *%rax
  8135cf:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  8135d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135d6:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8135da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8135de:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  8135e2:	0f b7 c0             	movzwl %ax,%eax
  8135e5:	89 c7                	mov    %eax,%edi
  8135e7:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8135ee:	00 00 00 
  8135f1:	ff d0                	callq  *%rax
  8135f3:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  8135f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135fb:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8135ff:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  813602:	89 c7                	mov    %eax,%edi
  813604:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  81360b:	00 00 00 
  81360e:	ff d0                	callq  *%rax
  813610:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  813613:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813617:	48 8b 40 20          	mov    0x20(%rax),%rax
  81361b:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  813621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813625:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813629:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81362d:	48 8b 40 20          	mov    0x20(%rax),%rax
  813631:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813635:	0f b7 c0             	movzwl %ax,%eax
  813638:	89 c7                	mov    %eax,%edi
  81363a:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813641:	00 00 00 
  813644:	ff d0                	callq  *%rax
  813646:	83 e0 c0             	and    $0xffffffc0,%eax
  813649:	89 c2                	mov    %eax,%edx
  81364b:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81364f:	09 d0                	or     %edx,%eax
  813651:	0f b7 c0             	movzwl %ax,%eax
  813654:	89 c7                	mov    %eax,%edi
  813656:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81365d:	00 00 00 
  813660:	ff d0                	callq  *%rax
  813662:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  813666:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81366b:	75 42                	jne    8136af <tcp_enqueue+0x649>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  81366d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813671:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813675:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813679:	48 8b 40 20          	mov    0x20(%rax),%rax
  81367d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813681:	0f b7 c0             	movzwl %ax,%eax
  813684:	89 c7                	mov    %eax,%edi
  813686:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81368d:	00 00 00 
  813690:	ff d0                	callq  *%rax
  813692:	83 e0 3f             	and    $0x3f,%eax
  813695:	80 cc 50             	or     $0x50,%ah
  813698:	0f b7 c0             	movzwl %ax,%eax
  81369b:	89 c7                	mov    %eax,%edi
  81369d:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8136a4:	00 00 00 
  8136a7:	ff d0                	callq  *%rax
  8136a9:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  8136ad:	eb 75                	jmp    813724 <tcp_enqueue+0x6be>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8136af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136b3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8136b7:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8136bb:	c0 e8 02             	shr    $0x2,%al
  8136be:	0f b6 c0             	movzbl %al,%eax
  8136c1:	83 c0 05             	add    $0x5,%eax
  8136c4:	c1 e0 0c             	shl    $0xc,%eax
  8136c7:	41 89 c4             	mov    %eax,%r12d
  8136ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136ce:	48 8b 40 20          	mov    0x20(%rax),%rax
  8136d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8136d6:	0f b7 c0             	movzwl %ax,%eax
  8136d9:	89 c7                	mov    %eax,%edi
  8136db:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8136e2:	00 00 00 
  8136e5:	ff d0                	callq  *%rax
  8136e7:	83 e0 3f             	and    $0x3f,%eax
  8136ea:	44 09 e0             	or     %r12d,%eax
  8136ed:	0f b7 c0             	movzwl %ax,%eax
  8136f0:	89 c7                	mov    %eax,%edi
  8136f2:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8136f9:	00 00 00 
  8136fc:	ff d0                	callq  *%rax
  8136fe:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  813702:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  813706:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81370a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81370e:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  813712:	48 89 ce             	mov    %rcx,%rsi
  813715:	48 89 c7             	mov    %rax,%rdi
  813718:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  81371f:	00 00 00 
  813722:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  813724:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813728:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  81372c:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813730:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  813733:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813737:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  81373b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813740:	0f 84 fc fa ff ff    	je     813242 <tcp_enqueue+0x1dc>
  813746:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  81374b:	0f 85 f1 fa ff ff    	jne    813242 <tcp_enqueue+0x1dc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  813751:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813755:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81375c:	48 85 c0             	test   %rax,%rax
  81375f:	75 0a                	jne    81376b <tcp_enqueue+0x705>
    useg = NULL;
  813761:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  813768:	00 
  813769:	eb 28                	jmp    813793 <tcp_enqueue+0x72d>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  81376b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81376f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813776:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81377a:	eb 0b                	jmp    813787 <tcp_enqueue+0x721>
  81377c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813780:	48 8b 00             	mov    (%rax),%rax
  813783:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813787:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81378b:	48 8b 00             	mov    (%rax),%rax
  81378e:	48 85 c0             	test   %rax,%rax
  813791:	75 e9                	jne    81377c <tcp_enqueue+0x716>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813793:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813798:	0f 84 94 01 00 00    	je     813932 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
  81379e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8137a2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8137a6:	0f b7 d8             	movzwl %ax,%ebx
  8137a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8137ad:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137b1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137b5:	0f b7 c0             	movzwl %ax,%eax
  8137b8:	89 c7                	mov    %eax,%edi
  8137ba:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8137c1:	00 00 00 
  8137c4:	ff d0                	callq  *%rax
  8137c6:	0f b7 c0             	movzwl %ax,%eax
  8137c9:	83 e0 01             	and    $0x1,%eax
  8137cc:	85 c0                	test   %eax,%eax
  8137ce:	75 27                	jne    8137f7 <tcp_enqueue+0x791>
  8137d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8137d4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137d8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137dc:	0f b7 c0             	movzwl %ax,%eax
  8137df:	89 c7                	mov    %eax,%edi
  8137e1:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8137e8:	00 00 00 
  8137eb:	ff d0                	callq  *%rax
  8137ed:	0f b7 c0             	movzwl %ax,%eax
  8137f0:	83 e0 02             	and    $0x2,%eax
  8137f3:	85 c0                	test   %eax,%eax
  8137f5:	74 07                	je     8137fe <tcp_enqueue+0x798>
  8137f7:	b8 01 00 00 00       	mov    $0x1,%eax
  8137fc:	eb 05                	jmp    813803 <tcp_enqueue+0x79d>
  8137fe:	b8 00 00 00 00       	mov    $0x0,%eax
  813803:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813805:	85 c0                	test   %eax,%eax
  813807:	0f 84 25 01 00 00    	je     813932 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  81380d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813811:	48 8b 40 20          	mov    0x20(%rax),%rax
  813815:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813819:	0f b7 c0             	movzwl %ax,%eax
  81381c:	89 c7                	mov    %eax,%edi
  81381e:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813825:	00 00 00 
  813828:	ff d0                	callq  *%rax
  81382a:	0f b7 c0             	movzwl %ax,%eax
  81382d:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  813830:	85 c0                	test   %eax,%eax
  813832:	0f 85 fa 00 00 00    	jne    813932 <tcp_enqueue+0x8cc>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813838:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81383c:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  81383f:	85 c0                	test   %eax,%eax
  813841:	0f 85 eb 00 00 00    	jne    813932 <tcp_enqueue+0x8cc>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  813847:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81384b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81384f:	0f b7 d0             	movzwl %ax,%edx
  813852:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813856:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81385a:	0f b7 c0             	movzwl %ax,%eax
  81385d:	01 c2                	add    %eax,%edx
  81385f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813863:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  813867:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  81386a:	39 c2                	cmp    %eax,%edx
  81386c:	0f 8f c0 00 00 00    	jg     813932 <tcp_enqueue+0x8cc>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813872:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813876:	48 8b 40 08          	mov    0x8(%rax),%rax
  81387a:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81387f:	48 89 c7             	mov    %rax,%rdi
  813882:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  813889:	00 00 00 
  81388c:	ff d0                	callq  *%rax
  81388e:	84 c0                	test   %al,%al
  813890:	74 2a                	je     8138bc <tcp_enqueue+0x856>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813892:	48 ba 4b 28 82 00 00 	movabs $0x82284b,%rdx
  813899:	00 00 00 
  81389c:	be 52 01 00 00       	mov    $0x152,%esi
  8138a1:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  8138a8:	00 00 00 
  8138ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8138b0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8138b7:	00 00 00 
  8138ba:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8138bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138c0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8138c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8138cc:	48 89 d6             	mov    %rdx,%rsi
  8138cf:	48 89 c7             	mov    %rax,%rdi
  8138d2:	48 b8 2a de 80 00 00 	movabs $0x80de2a,%rax
  8138d9:	00 00 00 
  8138dc:	ff d0                	callq  *%rax
    useg->len += queue->len;
  8138de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138e2:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  8138e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138ea:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8138ee:	01 c2                	add    %eax,%edx
  8138f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138f4:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  8138f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8138fc:	48 8b 10             	mov    (%rax),%rdx
  8138ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813903:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  813906:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81390a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81390e:	75 08                	jne    813918 <tcp_enqueue+0x8b2>
      seg = NULL;
  813910:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813917:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  813918:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81391c:	48 89 c6             	mov    %rax,%rsi
  81391f:	bf 04 00 00 00       	mov    $0x4,%edi
  813924:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81392b:	00 00 00 
  81392e:	ff d0                	callq  *%rax
  813930:	eb 23                	jmp    813955 <tcp_enqueue+0x8ef>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  813932:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813937:	75 11                	jne    81394a <tcp_enqueue+0x8e4>
      /* initialize list with this segment */
      pcb->unsent = queue;
  813939:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81393d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813941:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  813948:	eb 0b                	jmp    813955 <tcp_enqueue+0x8ef>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  81394a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81394e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813952:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  813955:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813959:	83 e0 02             	and    $0x2,%eax
  81395c:	85 c0                	test   %eax,%eax
  81395e:	75 0b                	jne    81396b <tcp_enqueue+0x905>
  813960:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813964:	83 e0 01             	and    $0x1,%eax
  813967:	85 c0                	test   %eax,%eax
  813969:	74 05                	je     813970 <tcp_enqueue+0x90a>
    ++len;
  81396b:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813970:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813974:	83 e0 01             	and    $0x1,%eax
  813977:	85 c0                	test   %eax,%eax
  813979:	74 14                	je     81398f <tcp_enqueue+0x929>
    pcb->flags |= TF_FIN;
  81397b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81397f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813983:	83 c8 20             	or     $0x20,%eax
  813986:	89 c2                	mov    %eax,%edx
  813988:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81398c:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  81398f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813993:	8b 50 74             	mov    0x74(%rax),%edx
  813996:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  81399a:	01 c2                	add    %eax,%edx
  81399c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139a0:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  8139a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139a7:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  8139ab:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  8139af:	89 c2                	mov    %eax,%edx
  8139b1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139b5:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  8139b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139bd:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  8139c1:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  8139c5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139c9:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  8139cd:	66 85 c0             	test   %ax,%ax
  8139d0:	74 4a                	je     813a1c <tcp_enqueue+0x9b6>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  8139d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139d6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8139dd:	48 85 c0             	test   %rax,%rax
  8139e0:	75 3a                	jne    813a1c <tcp_enqueue+0x9b6>
  8139e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139e6:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8139ed:	48 85 c0             	test   %rax,%rax
  8139f0:	75 2a                	jne    813a1c <tcp_enqueue+0x9b6>
  8139f2:	48 ba 60 28 82 00 00 	movabs $0x822860,%rdx
  8139f9:	00 00 00 
  8139fc:	be 7a 01 00 00       	mov    $0x17a,%esi
  813a01:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  813a08:	00 00 00 
  813a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  813a10:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  813a17:	00 00 00 
  813a1a:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  813a1c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813a21:	74 5c                	je     813a7f <tcp_enqueue+0xa19>
  813a23:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  813a28:	74 55                	je     813a7f <tcp_enqueue+0xa19>
  813a2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813a2e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813a32:	48 85 c0             	test   %rax,%rax
  813a35:	74 48                	je     813a7f <tcp_enqueue+0xa19>
  813a37:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813a3b:	83 e0 02             	and    $0x2,%eax
  813a3e:	85 c0                	test   %eax,%eax
  813a40:	75 3d                	jne    813a7f <tcp_enqueue+0xa19>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  813a42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813a46:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813a4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813a4e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813a52:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813a56:	0f b7 c0             	movzwl %ax,%eax
  813a59:	89 c7                	mov    %eax,%edi
  813a5b:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813a62:	00 00 00 
  813a65:	ff d0                	callq  *%rax
  813a67:	83 c8 08             	or     $0x8,%eax
  813a6a:	0f b7 c0             	movzwl %ax,%eax
  813a6d:	89 c7                	mov    %eax,%edi
  813a6f:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813a76:	00 00 00 
  813a79:	ff d0                	callq  *%rax
  813a7b:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813a7f:	b8 00 00 00 00       	mov    $0x0,%eax
  813a84:	e9 8a 00 00 00       	jmpq   813b13 <tcp_enqueue+0xaad>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  813a89:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813a8d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813a91:	83 c8 80             	or     $0xffffff80,%eax
  813a94:	89 c2                	mov    %eax,%edx
  813a96:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813a9a:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813a9d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813aa2:	74 13                	je     813ab7 <tcp_enqueue+0xa51>
    tcp_segs_free(queue);
  813aa4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813aa8:	48 89 c7             	mov    %rax,%rdi
  813aab:	48 b8 13 03 81 00 00 	movabs $0x810313,%rax
  813ab2:	00 00 00 
  813ab5:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  813ab7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813abb:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813abf:	66 85 c0             	test   %ax,%ax
  813ac2:	74 4a                	je     813b0e <tcp_enqueue+0xaa8>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  813ac4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ac8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813acf:	48 85 c0             	test   %rax,%rax
  813ad2:	75 3a                	jne    813b0e <tcp_enqueue+0xaa8>
  813ad4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ad8:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813adf:	48 85 c0             	test   %rax,%rax
  813ae2:	75 2a                	jne    813b0e <tcp_enqueue+0xaa8>
  813ae4:	48 ba 60 28 82 00 00 	movabs $0x822860,%rdx
  813aeb:	00 00 00 
  813aee:	be 8d 01 00 00       	mov    $0x18d,%esi
  813af3:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  813afa:	00 00 00 
  813afd:	b8 00 00 00 00       	mov    $0x0,%eax
  813b02:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  813b09:	00 00 00 
  813b0c:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  813b0e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813b13:	48 83 c4 70          	add    $0x70,%rsp
  813b17:	5b                   	pop    %rbx
  813b18:	41 5c                	pop    %r12
  813b1a:	5d                   	pop    %rbp
  813b1b:	c3                   	retq   

0000000000813b1c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  813b1c:	55                   	push   %rbp
  813b1d:	48 89 e5             	mov    %rsp,%rbp
  813b20:	41 54                	push   %r12
  813b22:	53                   	push   %rbx
  813b23:	48 83 ec 40          	sub    $0x40,%rsp
  813b27:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  813b2b:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  813b32:	00 00 00 
  813b35:	48 8b 00             	mov    (%rax),%rax
  813b38:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  813b3c:	75 0a                	jne    813b48 <tcp_output+0x2c>
    return ERR_OK;
  813b3e:	b8 00 00 00 00       	mov    $0x0,%eax
  813b43:	e9 c0 06 00 00       	jmpq   814208 <tcp_output+0x6ec>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  813b48:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b4c:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813b50:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b54:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813b58:	66 39 c2             	cmp    %ax,%dx
  813b5b:	0f 46 c2             	cmovbe %edx,%eax
  813b5e:	0f b7 c0             	movzwl %ax,%eax
  813b61:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  813b64:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b68:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813b6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813b73:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b77:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813b7e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813b82:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813b87:	74 19                	je     813ba2 <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  813b89:	eb 0b                	jmp    813b96 <tcp_output+0x7a>
  813b8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b8f:	48 8b 00             	mov    (%rax),%rax
  813b92:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813b96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b9a:	48 8b 00             	mov    (%rax),%rax
  813b9d:	48 85 c0             	test   %rax,%rax
  813ba0:	75 e9                	jne    813b8b <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813ba2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ba6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813baa:	0f b6 c0             	movzbl %al,%eax
  813bad:	83 e0 02             	and    $0x2,%eax
  813bb0:	85 c0                	test   %eax,%eax
  813bb2:	0f 84 49 02 00 00    	je     813e01 <tcp_output+0x2e5>
  813bb8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813bbd:	74 3a                	je     813bf9 <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813bbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bc3:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bc7:	8b 40 04             	mov    0x4(%rax),%eax
  813bca:	89 c7                	mov    %eax,%edi
  813bcc:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  813bd3:	00 00 00 
  813bd6:	ff d0                	callq  *%rax
  813bd8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813bdc:	8b 52 54             	mov    0x54(%rdx),%edx
  813bdf:	29 d0                	sub    %edx,%eax
  813be1:	89 c2                	mov    %eax,%edx
  813be3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813be7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813beb:	0f b7 c0             	movzwl %ax,%eax
  813bee:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  813bf0:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813bf3:	0f 86 08 02 00 00    	jbe    813e01 <tcp_output+0x2e5>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813bf9:	ba 00 00 00 00       	mov    $0x0,%edx
  813bfe:	be 14 00 00 00       	mov    $0x14,%esi
  813c03:	bf 01 00 00 00       	mov    $0x1,%edi
  813c08:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  813c0f:	00 00 00 
  813c12:	ff d0                	callq  *%rax
  813c14:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813c18:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  813c1d:	75 0a                	jne    813c29 <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  813c1f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813c24:	e9 df 05 00 00       	jmpq   814208 <tcp_output+0x6ec>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813c29:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c2d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813c31:	83 e0 fc             	and    $0xfffffffc,%eax
  813c34:	89 c2                	mov    %eax,%edx
  813c36:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c3a:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813c3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813c41:	48 8b 40 08          	mov    0x8(%rax),%rax
  813c45:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813c49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c4d:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813c51:	0f b7 c0             	movzwl %ax,%eax
  813c54:	89 c7                	mov    %eax,%edi
  813c56:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813c5d:	00 00 00 
  813c60:	ff d0                	callq  *%rax
  813c62:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813c66:	66 89 02             	mov    %ax,(%rdx)
    tcphdr->dest = htons(pcb->remote_port);
  813c69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c6d:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813c71:	0f b7 c0             	movzwl %ax,%eax
  813c74:	89 c7                	mov    %eax,%edi
  813c76:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813c7d:	00 00 00 
  813c80:	ff d0                	callq  *%rax
  813c82:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813c86:	66 89 42 02          	mov    %ax,0x2(%rdx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813c8a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c8e:	8b 40 60             	mov    0x60(%rax),%eax
  813c91:	89 c7                	mov    %eax,%edi
  813c93:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  813c9a:	00 00 00 
  813c9d:	ff d0                	callq  *%rax
  813c9f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813ca3:	89 42 04             	mov    %eax,0x4(%rdx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813ca6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813caa:	8b 40 30             	mov    0x30(%rax),%eax
  813cad:	89 c7                	mov    %eax,%edi
  813caf:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  813cb6:	00 00 00 
  813cb9:	ff d0                	callq  *%rax
  813cbb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813cbf:	89 42 08             	mov    %eax,0x8(%rdx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813cc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813cc6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813cca:	0f b7 c0             	movzwl %ax,%eax
  813ccd:	89 c7                	mov    %eax,%edi
  813ccf:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813cd6:	00 00 00 
  813cd9:	ff d0                	callq  *%rax
  813cdb:	83 e0 c0             	and    $0xffffffc0,%eax
  813cde:	83 c8 10             	or     $0x10,%eax
  813ce1:	0f b7 c0             	movzwl %ax,%eax
  813ce4:	89 c7                	mov    %eax,%edi
  813ce6:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813ced:	00 00 00 
  813cf0:	ff d0                	callq  *%rax
  813cf2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813cf6:	66 89 42 0c          	mov    %ax,0xc(%rdx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813cfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cfe:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813d02:	0f b7 c0             	movzwl %ax,%eax
  813d05:	89 c7                	mov    %eax,%edi
  813d07:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813d0e:	00 00 00 
  813d11:	ff d0                	callq  *%rax
  813d13:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813d17:	66 89 42 0e          	mov    %ax,0xe(%rdx)
    tcphdr->urgp = 0;
  813d1b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813d1f:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813d25:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813d29:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813d2d:	0f b7 c0             	movzwl %ax,%eax
  813d30:	89 c7                	mov    %eax,%edi
  813d32:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813d39:	00 00 00 
  813d3c:	ff d0                	callq  *%rax
  813d3e:	83 e0 3f             	and    $0x3f,%eax
  813d41:	80 cc 50             	or     $0x50,%ah
  813d44:	0f b7 c0             	movzwl %ax,%eax
  813d47:	89 c7                	mov    %eax,%edi
  813d49:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813d50:	00 00 00 
  813d53:	ff d0                	callq  *%rax
  813d55:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813d59:	66 89 42 0c          	mov    %ax,0xc(%rdx)

    tcphdr->chksum = 0;
  813d5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813d61:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813d67:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813d6b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813d6f:	0f b7 c8             	movzwl %ax,%ecx
  813d72:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d76:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813d7a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813d7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813d82:	41 89 c8             	mov    %ecx,%r8d
  813d85:	b9 06 00 00 00       	mov    $0x6,%ecx
  813d8a:	48 89 c7             	mov    %rax,%rdi
  813d8d:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  813d94:	00 00 00 
  813d97:	ff d0                	callq  *%rax
  813d99:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813d9d:	66 89 42 10          	mov    %ax,0x10(%rdx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813da1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813da5:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813da9:	0f b6 c8             	movzbl %al,%ecx
  813dac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813db0:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813db4:	0f b6 d0             	movzbl %al,%edx
  813db7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dbb:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813dbf:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813dc3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813dc7:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813dcd:	41 89 c8             	mov    %ecx,%r8d
  813dd0:	89 d1                	mov    %edx,%ecx
  813dd2:	48 89 fa             	mov    %rdi,%rdx
  813dd5:	48 89 c7             	mov    %rax,%rdi
  813dd8:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  813ddf:	00 00 00 
  813de2:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813de4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813de8:	48 89 c7             	mov    %rax,%rdi
  813deb:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  813df2:	00 00 00 
  813df5:	ff d0                	callq  *%rax

    return ERR_OK;
  813df7:	b8 00 00 00 00       	mov    $0x0,%eax
  813dfc:	e9 07 04 00 00       	jmpq   814208 <tcp_output+0x6ec>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813e01:	e9 39 03 00 00       	jmpq   81413f <tcp_output+0x623>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813e06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e0a:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e0e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e12:	0f b7 c0             	movzwl %ax,%eax
  813e15:	89 c7                	mov    %eax,%edi
  813e17:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813e1e:	00 00 00 
  813e21:	ff d0                	callq  *%rax
  813e23:	0f b7 c0             	movzwl %ax,%eax
  813e26:	83 e0 04             	and    $0x4,%eax
  813e29:	85 c0                	test   %eax,%eax
  813e2b:	74 2a                	je     813e57 <tcp_output+0x33b>
  813e2d:	48 ba 80 28 82 00 00 	movabs $0x822880,%rdx
  813e34:	00 00 00 
  813e37:	be 05 02 00 00       	mov    $0x205,%esi
  813e3c:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  813e43:	00 00 00 
  813e46:	b8 00 00 00 00       	mov    $0x0,%eax
  813e4b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  813e52:	00 00 00 
  813e55:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813e57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e5b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813e62:	48 85 c0             	test   %rax,%rax
  813e65:	74 35                	je     813e9c <tcp_output+0x380>
  813e67:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e6b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813e6f:	0f b6 c0             	movzbl %al,%eax
  813e72:	83 e0 40             	and    $0x40,%eax
  813e75:	85 c0                	test   %eax,%eax
  813e77:	75 23                	jne    813e9c <tcp_output+0x380>
  813e79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e7d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813e84:	48 85 c0             	test   %rax,%rax
  813e87:	74 1a                	je     813ea3 <tcp_output+0x387>
  813e89:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e8d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813e94:	48 8b 00             	mov    (%rax),%rax
  813e97:	48 85 c0             	test   %rax,%rax
  813e9a:	74 07                	je     813ea3 <tcp_output+0x387>
  813e9c:	b8 01 00 00 00       	mov    $0x1,%eax
  813ea1:	eb 05                	jmp    813ea8 <tcp_output+0x38c>
  813ea3:	b8 00 00 00 00       	mov    $0x0,%eax
  813ea8:	85 c0                	test   %eax,%eax
  813eaa:	75 19                	jne    813ec5 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813eac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813eb0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813eb4:	0f b6 c0             	movzbl %al,%eax
  813eb7:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813ebc:	85 c0                	test   %eax,%eax
  813ebe:	75 05                	jne    813ec5 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  813ec0:	e9 bb 02 00 00       	jmpq   814180 <tcp_output+0x664>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813ec5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ec9:	48 8b 10             	mov    (%rax),%rdx
  813ecc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ed0:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813ed7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813edb:	8b 40 18             	mov    0x18(%rax),%eax
  813ede:	83 f8 02             	cmp    $0x2,%eax
  813ee1:	74 51                	je     813f34 <tcp_output+0x418>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  813ee3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ee7:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813eeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813eef:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ef3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813ef7:	0f b7 c0             	movzwl %ax,%eax
  813efa:	89 c7                	mov    %eax,%edi
  813efc:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813f03:	00 00 00 
  813f06:	ff d0                	callq  *%rax
  813f08:	83 c8 10             	or     $0x10,%eax
  813f0b:	0f b7 c0             	movzwl %ax,%eax
  813f0e:	89 c7                	mov    %eax,%edi
  813f10:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  813f17:	00 00 00 
  813f1a:	ff d0                	callq  *%rax
  813f1c:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813f20:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f24:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813f28:	83 e0 fc             	and    $0xfffffffc,%eax
  813f2b:	89 c2                	mov    %eax,%edx
  813f2d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f31:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  813f34:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813f38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f3c:	48 89 d6             	mov    %rdx,%rsi
  813f3f:	48 89 c7             	mov    %rax,%rdi
  813f42:	48 b8 11 42 81 00 00 	movabs $0x814211,%rax
  813f49:	00 00 00 
  813f4c:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  813f4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f52:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f56:	8b 40 04             	mov    0x4(%rax),%eax
  813f59:	89 c7                	mov    %eax,%edi
  813f5b:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  813f62:	00 00 00 
  813f65:	ff d0                	callq  *%rax
  813f67:	89 c3                	mov    %eax,%ebx
  813f69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f6d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813f71:	44 0f b7 e0          	movzwl %ax,%r12d
  813f75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f79:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f7d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813f81:	0f b7 c0             	movzwl %ax,%eax
  813f84:	89 c7                	mov    %eax,%edi
  813f86:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813f8d:	00 00 00 
  813f90:	ff d0                	callq  *%rax
  813f92:	0f b7 c0             	movzwl %ax,%eax
  813f95:	83 e0 01             	and    $0x1,%eax
  813f98:	85 c0                	test   %eax,%eax
  813f9a:	75 27                	jne    813fc3 <tcp_output+0x4a7>
  813f9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813fa0:	48 8b 40 20          	mov    0x20(%rax),%rax
  813fa4:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813fa8:	0f b7 c0             	movzwl %ax,%eax
  813fab:	89 c7                	mov    %eax,%edi
  813fad:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  813fb4:	00 00 00 
  813fb7:	ff d0                	callq  *%rax
  813fb9:	0f b7 c0             	movzwl %ax,%eax
  813fbc:	83 e0 02             	and    $0x2,%eax
  813fbf:	85 c0                	test   %eax,%eax
  813fc1:	74 07                	je     813fca <tcp_output+0x4ae>
  813fc3:	b8 01 00 00 00       	mov    $0x1,%eax
  813fc8:	eb 05                	jmp    813fcf <tcp_output+0x4b3>
  813fca:	b8 00 00 00 00       	mov    $0x0,%eax
  813fcf:	44 01 e0             	add    %r12d,%eax
  813fd2:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  813fd5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fd9:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  813fdc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fe0:	8b 50 64             	mov    0x64(%rax),%edx
  813fe3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fe7:	8b 40 60             	mov    0x60(%rax),%eax
  813fea:	29 c2                	sub    %eax,%edx
  813fec:	89 d0                	mov    %edx,%eax
  813fee:	85 c0                	test   %eax,%eax
  813ff0:	79 0e                	jns    814000 <tcp_output+0x4e4>
      pcb->snd_max = pcb->snd_nxt;
  813ff2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ff6:	8b 50 60             	mov    0x60(%rax),%edx
  813ff9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ffd:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  814000:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814004:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814008:	0f b7 d8             	movzwl %ax,%ebx
  81400b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81400f:	48 8b 40 20          	mov    0x20(%rax),%rax
  814013:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814017:	0f b7 c0             	movzwl %ax,%eax
  81401a:	89 c7                	mov    %eax,%edi
  81401c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814023:	00 00 00 
  814026:	ff d0                	callq  *%rax
  814028:	0f b7 c0             	movzwl %ax,%eax
  81402b:	83 e0 01             	and    $0x1,%eax
  81402e:	85 c0                	test   %eax,%eax
  814030:	75 27                	jne    814059 <tcp_output+0x53d>
  814032:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814036:	48 8b 40 20          	mov    0x20(%rax),%rax
  81403a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81403e:	0f b7 c0             	movzwl %ax,%eax
  814041:	89 c7                	mov    %eax,%edi
  814043:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81404a:	00 00 00 
  81404d:	ff d0                	callq  *%rax
  81404f:	0f b7 c0             	movzwl %ax,%eax
  814052:	83 e0 02             	and    $0x2,%eax
  814055:	85 c0                	test   %eax,%eax
  814057:	74 07                	je     814060 <tcp_output+0x544>
  814059:	b8 01 00 00 00       	mov    $0x1,%eax
  81405e:	eb 05                	jmp    814065 <tcp_output+0x549>
  814060:	b8 00 00 00 00       	mov    $0x0,%eax
  814065:	01 d8                	add    %ebx,%eax
  814067:	85 c0                	test   %eax,%eax
  814069:	0f 8e ae 00 00 00    	jle    81411d <tcp_output+0x601>
      seg->next = NULL;
  81406f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814073:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  81407a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81407e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814085:	48 85 c0             	test   %rax,%rax
  814088:	75 1c                	jne    8140a6 <tcp_output+0x58a>
        pcb->unacked = seg;
  81408a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81408e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814092:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  814099:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81409d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8140a1:	e9 8a 00 00 00       	jmpq   814130 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8140a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140aa:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140ae:	8b 40 04             	mov    0x4(%rax),%eax
  8140b1:	89 c7                	mov    %eax,%edi
  8140b3:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8140ba:	00 00 00 
  8140bd:	ff d0                	callq  *%rax
  8140bf:	89 c3                	mov    %eax,%ebx
  8140c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8140c5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140c9:	8b 40 04             	mov    0x4(%rax),%eax
  8140cc:	89 c7                	mov    %eax,%edi
  8140ce:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8140d5:	00 00 00 
  8140d8:	ff d0                	callq  *%rax
  8140da:	29 c3                	sub    %eax,%ebx
  8140dc:	89 d8                	mov    %ebx,%eax
  8140de:	85 c0                	test   %eax,%eax
  8140e0:	79 23                	jns    814105 <tcp_output+0x5e9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8140e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140e6:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  8140ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140f1:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  8140f4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140f8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8140fc:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  814103:	eb 2b                	jmp    814130 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  814105:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814109:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81410d:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  814110:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814114:	48 8b 00             	mov    (%rax),%rax
  814117:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81411b:	eb 13                	jmp    814130 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  81411d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814121:	48 89 c7             	mov    %rax,%rdi
  814124:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81412b:	00 00 00 
  81412e:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  814130:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814134:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81413b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  81413f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814144:	74 3a                	je     814180 <tcp_output+0x664>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  814146:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81414a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81414e:	8b 40 04             	mov    0x4(%rax),%eax
  814151:	89 c7                	mov    %eax,%edi
  814153:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81415a:	00 00 00 
  81415d:	ff d0                	callq  *%rax
  81415f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  814163:	8b 52 54             	mov    0x54(%rdx),%edx
  814166:	29 d0                	sub    %edx,%eax
  814168:	89 c2                	mov    %eax,%edx
  81416a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81416e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814172:	0f b7 c0             	movzwl %ax,%eax
  814175:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  814177:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  81417a:	0f 86 86 fc ff ff    	jbe    813e06 <tcp_output+0x2ea>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  814180:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814185:	74 68                	je     8141ef <tcp_output+0x6d3>
  814187:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81418b:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  814192:	84 c0                	test   %al,%al
  814194:	75 59                	jne    8141ef <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  814196:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81419a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81419e:	8b 40 04             	mov    0x4(%rax),%eax
  8141a1:	89 c7                	mov    %eax,%edi
  8141a3:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8141aa:	00 00 00 
  8141ad:	ff d0                	callq  *%rax
  8141af:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8141b3:	8b 52 54             	mov    0x54(%rdx),%edx
  8141b6:	29 d0                	sub    %edx,%eax
  8141b8:	89 c2                	mov    %eax,%edx
  8141ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141be:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8141c2:	0f b7 c0             	movzwl %ax,%eax
  8141c5:	01 c2                	add    %eax,%edx
  8141c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141cb:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  8141cf:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8141d2:	39 c2                	cmp    %eax,%edx
  8141d4:	76 19                	jbe    8141ef <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  8141d6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141da:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8141e1:	00 00 00 
    pcb->persist_backoff = 1;
  8141e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141e8:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  8141ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141f3:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8141f7:	83 e0 7f             	and    $0x7f,%eax
  8141fa:	89 c2                	mov    %eax,%edx
  8141fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814200:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  814203:	b8 00 00 00 00       	mov    $0x0,%eax
}
  814208:	48 83 c4 40          	add    $0x40,%rsp
  81420c:	5b                   	pop    %rbx
  81420d:	41 5c                	pop    %r12
  81420f:	5d                   	pop    %rbp
  814210:	c3                   	retq   

0000000000814211 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  814211:	55                   	push   %rbp
  814212:	48 89 e5             	mov    %rsp,%rbp
  814215:	53                   	push   %rbx
  814216:	48 83 ec 28          	sub    $0x28,%rsp
  81421a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81421e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  814222:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814226:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81422a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81422e:	8b 40 30             	mov    0x30(%rax),%eax
  814231:	89 c7                	mov    %eax,%edi
  814233:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  81423a:	00 00 00 
  81423d:	ff d0                	callq  *%rax
  81423f:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814242:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814246:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81424a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81424e:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814252:	0f b7 c0             	movzwl %ax,%eax
  814255:	89 c7                	mov    %eax,%edi
  814257:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81425e:	00 00 00 
  814261:	ff d0                	callq  *%rax
  814263:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  814267:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81426b:	48 85 c0             	test   %rax,%rax
  81426e:	74 0a                	je     81427a <tcp_output_segment+0x69>
  814270:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814274:	8b 00                	mov    (%rax),%eax
  814276:	85 c0                	test   %eax,%eax
  814278:	75 48                	jne    8142c2 <tcp_output_segment+0xb1>
    netif = ip_route(&(pcb->remote_ip));
  81427a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81427e:	48 83 c0 04          	add    $0x4,%rax
  814282:	48 89 c7             	mov    %rax,%rdi
  814285:	48 b8 bd 0c 81 00 00 	movabs $0x810cbd,%rax
  81428c:	00 00 00 
  81428f:	ff d0                	callq  *%rax
  814291:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  814295:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81429a:	75 05                	jne    8142a1 <tcp_output_segment+0x90>
      return;
  81429c:	e9 7f 01 00 00       	jmpq   814420 <tcp_output_segment+0x20f>
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8142a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142a5:	48 83 c0 08          	add    $0x8,%rax
  8142a9:	48 85 c0             	test   %rax,%rax
  8142ac:	74 09                	je     8142b7 <tcp_output_segment+0xa6>
  8142ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142b2:	8b 40 08             	mov    0x8(%rax),%eax
  8142b5:	eb 05                	jmp    8142bc <tcp_output_segment+0xab>
  8142b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8142bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8142c0:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8142c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8142c6:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8142ca:	66 83 f8 ff          	cmp    $0xffff,%ax
  8142ce:	75 0a                	jne    8142da <tcp_output_segment+0xc9>
    pcb->rtime = 0;
  8142d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8142d4:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  8142da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8142de:	8b 40 44             	mov    0x44(%rax),%eax
  8142e1:	85 c0                	test   %eax,%eax
  8142e3:	75 33                	jne    814318 <tcp_output_segment+0x107>
    pcb->rttest = tcp_ticks;
  8142e5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8142ec:	00 00 00 
  8142ef:	8b 10                	mov    (%rax),%edx
  8142f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8142f5:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8142f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8142fc:	48 8b 40 20          	mov    0x20(%rax),%rax
  814300:	8b 40 04             	mov    0x4(%rax),%eax
  814303:	89 c7                	mov    %eax,%edi
  814305:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81430c:	00 00 00 
  81430f:	ff d0                	callq  *%rax
  814311:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814315:	89 42 48             	mov    %eax,0x48(%rdx)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  814318:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81431c:	48 8b 40 20          	mov    0x20(%rax),%rax
  814320:	48 89 c2             	mov    %rax,%rdx
  814323:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814327:	48 8b 40 08          	mov    0x8(%rax),%rax
  81432b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81432f:	48 29 c2             	sub    %rax,%rdx
  814332:	48 89 d0             	mov    %rdx,%rax
  814335:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  814339:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81433d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814341:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814345:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814349:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  81434d:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  814351:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  814355:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814359:	48 8b 40 08          	mov    0x8(%rax),%rax
  81435d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814361:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814365:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  814369:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  81436d:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  814371:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814375:	48 8b 40 08          	mov    0x8(%rax),%rax
  814379:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81437d:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  814381:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  814385:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814389:	48 8b 40 20          	mov    0x20(%rax),%rax
  81438d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814393:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814397:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  81439b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81439f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8143a3:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8143a7:	0f b7 c8             	movzwl %ax,%ecx
  8143aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143ae:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8143b2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8143b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8143ba:	48 8b 40 08          	mov    0x8(%rax),%rax
  8143be:	41 89 c8             	mov    %ecx,%r8d
  8143c1:	b9 06 00 00 00       	mov    $0x6,%ecx
  8143c6:	48 89 c7             	mov    %rax,%rdi
  8143c9:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  8143d0:	00 00 00 
  8143d3:	ff d0                	callq  *%rax
  8143d5:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8143d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143dd:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8143e1:	0f b6 c8             	movzbl %al,%ecx
  8143e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143e8:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8143ec:	0f b6 d0             	movzbl %al,%edx
  8143ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143f3:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8143f7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8143fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8143ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  814403:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814409:	41 89 c8             	mov    %ecx,%r8d
  81440c:	89 d1                	mov    %edx,%ecx
  81440e:	48 89 fa             	mov    %rdi,%rdx
  814411:	48 89 c7             	mov    %rax,%rdi
  814414:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  81441b:	00 00 00 
  81441e:	ff d0                	callq  *%rax
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  814420:	48 83 c4 28          	add    $0x28,%rsp
  814424:	5b                   	pop    %rbx
  814425:	5d                   	pop    %rbp
  814426:	c3                   	retq   

0000000000814427 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  814427:	55                   	push   %rbp
  814428:	48 89 e5             	mov    %rsp,%rbp
  81442b:	48 83 ec 30          	sub    $0x30,%rsp
  81442f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  814432:	89 75 e8             	mov    %esi,-0x18(%rbp)
  814435:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  814439:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  81443d:	44 89 c2             	mov    %r8d,%edx
  814440:	44 89 c8             	mov    %r9d,%eax
  814443:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  814447:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  81444b:	ba 00 00 00 00       	mov    $0x0,%edx
  814450:	be 14 00 00 00       	mov    $0x14,%esi
  814455:	bf 01 00 00 00       	mov    $0x1,%edi
  81445a:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  814461:	00 00 00 
  814464:	ff d0                	callq  *%rax
  814466:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  81446a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81446f:	75 05                	jne    814476 <tcp_rst+0x4f>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  814471:	e9 b9 01 00 00       	jmpq   81462f <tcp_rst+0x208>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814476:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81447a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81447e:	66 83 f8 13          	cmp    $0x13,%ax
  814482:	77 2a                	ja     8144ae <tcp_rst+0x87>
  814484:	48 ba 98 28 82 00 00 	movabs $0x822898,%rdx
  81448b:	00 00 00 
  81448e:	be be 02 00 00       	mov    $0x2be,%esi
  814493:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  81449a:	00 00 00 
  81449d:	b8 00 00 00 00       	mov    $0x0,%eax
  8144a2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8144a9:	00 00 00 
  8144ac:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8144ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8144b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8144b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  8144ba:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  8144be:	89 c7                	mov    %eax,%edi
  8144c0:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8144c7:	00 00 00 
  8144ca:	ff d0                	callq  *%rax
  8144cc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8144d0:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(remote_port);
  8144d3:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8144d7:	89 c7                	mov    %eax,%edi
  8144d9:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8144e0:	00 00 00 
  8144e3:	ff d0                	callq  *%rax
  8144e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8144e9:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(seqno);
  8144ed:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8144f0:	89 c7                	mov    %eax,%edi
  8144f2:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  8144f9:	00 00 00 
  8144fc:	ff d0                	callq  *%rax
  8144fe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814502:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(ackno);
  814505:	8b 45 e8             	mov    -0x18(%rbp),%eax
  814508:	89 c7                	mov    %eax,%edi
  81450a:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  814511:	00 00 00 
  814514:	ff d0                	callq  *%rax
  814516:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81451a:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  81451d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814521:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814525:	0f b7 c0             	movzwl %ax,%eax
  814528:	89 c7                	mov    %eax,%edi
  81452a:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814531:	00 00 00 
  814534:	ff d0                	callq  *%rax
  814536:	83 e0 c0             	and    $0xffffffc0,%eax
  814539:	83 c8 14             	or     $0x14,%eax
  81453c:	0f b7 c0             	movzwl %ax,%eax
  81453f:	89 c7                	mov    %eax,%edi
  814541:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814548:	00 00 00 
  81454b:	ff d0                	callq  *%rax
  81454d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814551:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(TCP_WND);
  814555:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  81455a:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814561:	00 00 00 
  814564:	ff d0                	callq  *%rax
  814566:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81456a:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81456e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814572:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814578:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81457c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814580:	0f b7 c0             	movzwl %ax,%eax
  814583:	89 c7                	mov    %eax,%edi
  814585:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81458c:	00 00 00 
  81458f:	ff d0                	callq  *%rax
  814591:	83 e0 3f             	and    $0x3f,%eax
  814594:	80 cc 50             	or     $0x50,%ah
  814597:	0f b7 c0             	movzwl %ax,%eax
  81459a:	89 c7                	mov    %eax,%edi
  81459c:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8145a3:	00 00 00 
  8145a6:	ff d0                	callq  *%rax
  8145a8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8145ac:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  8145b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8145b4:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  8145ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145be:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8145c2:	0f b7 c8             	movzwl %ax,%ecx
  8145c5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8145c9:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8145cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145d1:	41 89 c8             	mov    %ecx,%r8d
  8145d4:	b9 06 00 00 00       	mov    $0x6,%ecx
  8145d9:	48 89 c7             	mov    %rax,%rdi
  8145dc:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  8145e3:	00 00 00 
  8145e6:	ff d0                	callq  *%rax
  8145e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8145ec:	66 89 42 10          	mov    %ax,0x10(%rdx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8145f0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8145f4:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8145f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145fc:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814602:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814608:	b9 ff 00 00 00       	mov    $0xff,%ecx
  81460d:	48 89 c7             	mov    %rax,%rdi
  814610:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  814617:	00 00 00 
  81461a:	ff d0                	callq  *%rax
  pbuf_free(p);
  81461c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814620:	48 89 c7             	mov    %rax,%rdi
  814623:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81462a:	00 00 00 
  81462d:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  81462f:	c9                   	leaveq 
  814630:	c3                   	retq   

0000000000814631 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  814631:	55                   	push   %rbp
  814632:	48 89 e5             	mov    %rsp,%rbp
  814635:	48 83 ec 20          	sub    $0x20,%rsp
  814639:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  81463d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814641:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814648:	48 85 c0             	test   %rax,%rax
  81464b:	75 05                	jne    814652 <tcp_rexmit_rto+0x21>
    return;
  81464d:	e9 b6 00 00 00       	jmpq   814708 <tcp_rexmit_rto+0xd7>
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814656:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81465d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814661:	eb 0b                	jmp    81466e <tcp_rexmit_rto+0x3d>
  814663:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814667:	48 8b 00             	mov    (%rax),%rax
  81466a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81466e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814672:	48 8b 00             	mov    (%rax),%rax
  814675:	48 85 c0             	test   %rax,%rax
  814678:	75 e9                	jne    814663 <tcp_rexmit_rto+0x32>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  81467a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81467e:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  814685:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814689:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  81468c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814690:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81469b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8146a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146a6:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  8146ad:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8146b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146b5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8146bc:	48 8b 40 20          	mov    0x20(%rax),%rax
  8146c0:	8b 40 04             	mov    0x4(%rax),%eax
  8146c3:	89 c7                	mov    %eax,%edi
  8146c5:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8146cc:	00 00 00 
  8146cf:	ff d0                	callq  *%rax
  8146d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8146d5:	89 42 60             	mov    %eax,0x60(%rdx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8146d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146dc:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8146e0:	8d 50 01             	lea    0x1(%rax),%edx
  8146e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146e7:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8146ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146ee:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8146f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146f9:	48 89 c7             	mov    %rax,%rdi
  8146fc:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  814703:	00 00 00 
  814706:	ff d0                	callq  *%rax
}
  814708:	c9                   	leaveq 
  814709:	c3                   	retq   

000000000081470a <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  81470a:	55                   	push   %rbp
  81470b:	48 89 e5             	mov    %rsp,%rbp
  81470e:	48 83 ec 20          	sub    $0x20,%rsp
  814712:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  814716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81471a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814721:	48 85 c0             	test   %rax,%rax
  814724:	75 05                	jne    81472b <tcp_rexmit+0x21>
    return;
  814726:	e9 a7 00 00 00       	jmpq   8147d2 <tcp_rexmit+0xc8>
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  81472b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81472f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814736:	48 8b 00             	mov    (%rax),%rax
  814739:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  81473d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814741:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814748:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81474c:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814753:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  814756:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81475a:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814765:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  81476c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814770:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814774:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  81477b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81477f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814786:	48 8b 40 20          	mov    0x20(%rax),%rax
  81478a:	8b 40 04             	mov    0x4(%rax),%eax
  81478d:	89 c7                	mov    %eax,%edi
  81478f:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  814796:	00 00 00 
  814799:	ff d0                	callq  *%rax
  81479b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81479f:	89 42 60             	mov    %eax,0x60(%rdx)

  ++pcb->nrtx;
  8147a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147a6:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8147aa:	8d 50 01             	lea    0x1(%rax),%edx
  8147ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147b1:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  8147b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147b8:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8147bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147c3:	48 89 c7             	mov    %rax,%rdi
  8147c6:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  8147cd:	00 00 00 
  8147d0:	ff d0                	callq  *%rax
}
  8147d2:	c9                   	leaveq 
  8147d3:	c3                   	retq   

00000000008147d4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8147d4:	55                   	push   %rbp
  8147d5:	48 89 e5             	mov    %rsp,%rbp
  8147d8:	48 83 ec 20          	sub    $0x20,%rsp
  8147dc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8147e0:	ba 00 00 00 00       	mov    $0x0,%edx
  8147e5:	be 14 00 00 00       	mov    $0x14,%esi
  8147ea:	bf 01 00 00 00       	mov    $0x1,%edi
  8147ef:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  8147f6:	00 00 00 
  8147f9:	ff d0                	callq  *%rax
  8147fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  8147ff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814804:	75 05                	jne    81480b <tcp_keepalive+0x37>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  814806:	e9 ec 01 00 00       	jmpq   8149f7 <tcp_keepalive+0x223>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  81480b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81480f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814813:	66 83 f8 13          	cmp    $0x13,%ax
  814817:	77 2a                	ja     814843 <tcp_keepalive+0x6f>
  814819:	48 ba 98 28 82 00 00 	movabs $0x822898,%rdx
  814820:	00 00 00 
  814823:	be 3a 03 00 00       	mov    $0x33a,%esi
  814828:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  81482f:	00 00 00 
  814832:	b8 00 00 00 00       	mov    $0x0,%eax
  814837:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81483e:	00 00 00 
  814841:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814843:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814847:	48 8b 40 08          	mov    0x8(%rax),%rax
  81484b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  81484f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814853:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814857:	0f b7 c0             	movzwl %ax,%eax
  81485a:	89 c7                	mov    %eax,%edi
  81485c:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814863:	00 00 00 
  814866:	ff d0                	callq  *%rax
  814868:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81486c:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  81486f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814873:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814877:	0f b7 c0             	movzwl %ax,%eax
  81487a:	89 c7                	mov    %eax,%edi
  81487c:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814883:	00 00 00 
  814886:	ff d0                	callq  *%rax
  814888:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81488c:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814890:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814894:	8b 40 60             	mov    0x60(%rax),%eax
  814897:	83 e8 01             	sub    $0x1,%eax
  81489a:	89 c7                	mov    %eax,%edi
  81489c:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  8148a3:	00 00 00 
  8148a6:	ff d0                	callq  *%rax
  8148a8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8148ac:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8148af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148b3:	8b 40 30             	mov    0x30(%rax),%eax
  8148b6:	89 c7                	mov    %eax,%edi
  8148b8:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  8148bf:	00 00 00 
  8148c2:	ff d0                	callq  *%rax
  8148c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8148c8:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8148cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8148cf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8148d3:	0f b7 c0             	movzwl %ax,%eax
  8148d6:	89 c7                	mov    %eax,%edi
  8148d8:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8148df:	00 00 00 
  8148e2:	ff d0                	callq  *%rax
  8148e4:	0f b7 c0             	movzwl %ax,%eax
  8148e7:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8148ec:	89 c7                	mov    %eax,%edi
  8148ee:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8148f5:	00 00 00 
  8148f8:	ff d0                	callq  *%rax
  8148fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8148fe:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814902:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814906:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81490a:	0f b7 c0             	movzwl %ax,%eax
  81490d:	89 c7                	mov    %eax,%edi
  81490f:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814916:	00 00 00 
  814919:	ff d0                	callq  *%rax
  81491b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81491f:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814923:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814927:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  81492d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814931:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814935:	0f b7 c0             	movzwl %ax,%eax
  814938:	89 c7                	mov    %eax,%edi
  81493a:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814941:	00 00 00 
  814944:	ff d0                	callq  *%rax
  814946:	83 e0 3f             	and    $0x3f,%eax
  814949:	80 cc 50             	or     $0x50,%ah
  81494c:	0f b7 c0             	movzwl %ax,%eax
  81494f:	89 c7                	mov    %eax,%edi
  814951:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814958:	00 00 00 
  81495b:	ff d0                	callq  *%rax
  81495d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814961:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  814965:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814969:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  81496f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814973:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814977:	0f b7 c8             	movzwl %ax,%ecx
  81497a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81497e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814982:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814986:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81498a:	41 89 c8             	mov    %ecx,%r8d
  81498d:	b9 06 00 00 00       	mov    $0x6,%ecx
  814992:	48 89 c7             	mov    %rax,%rdi
  814995:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  81499c:	00 00 00 
  81499f:	ff d0                	callq  *%rax
  8149a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8149a5:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8149a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149ad:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8149b1:	0f b6 d0             	movzbl %al,%edx
  8149b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149b8:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8149bc:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8149c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8149c4:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8149ca:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8149d0:	89 d1                	mov    %edx,%ecx
  8149d2:	48 89 fa             	mov    %rdi,%rdx
  8149d5:	48 89 c7             	mov    %rax,%rdi
  8149d8:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  8149df:	00 00 00 
  8149e2:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8149e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8149e8:	48 89 c7             	mov    %rax,%rdi
  8149eb:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8149f2:	00 00 00 
  8149f5:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8149f7:	c9                   	leaveq 
  8149f8:	c3                   	retq   

00000000008149f9 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8149f9:	55                   	push   %rbp
  8149fa:	48 89 e5             	mov    %rsp,%rbp
  8149fd:	48 83 ec 30          	sub    $0x30,%rsp
  814a01:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  814a05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814a09:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814a10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814a14:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814a19:	75 0f                	jne    814a2a <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  814a1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814a1f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814a26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814a2a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814a2f:	75 05                	jne    814a36 <tcp_zero_window_probe+0x3d>
    return;
  814a31:	e9 23 02 00 00       	jmpq   814c59 <tcp_zero_window_probe+0x260>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  814a36:	ba 00 00 00 00       	mov    $0x0,%edx
  814a3b:	be 15 00 00 00       	mov    $0x15,%esi
  814a40:	bf 01 00 00 00       	mov    $0x1,%edi
  814a45:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  814a4c:	00 00 00 
  814a4f:	ff d0                	callq  *%rax
  814a51:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  814a55:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814a5a:	75 05                	jne    814a61 <tcp_zero_window_probe+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814a5c:	e9 f8 01 00 00       	jmpq   814c59 <tcp_zero_window_probe+0x260>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814a61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a65:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814a69:	66 83 f8 13          	cmp    $0x13,%ax
  814a6d:	77 2a                	ja     814a99 <tcp_zero_window_probe+0xa0>
  814a6f:	48 ba 98 28 82 00 00 	movabs $0x822898,%rdx
  814a76:	00 00 00 
  814a79:	be 8d 03 00 00       	mov    $0x38d,%esi
  814a7e:	48 bf 07 27 82 00 00 	movabs $0x822707,%rdi
  814a85:	00 00 00 
  814a88:	b8 00 00 00 00       	mov    $0x0,%eax
  814a8d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  814a94:	00 00 00 
  814a97:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814a99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a9d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814aa1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814aa5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814aa9:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814aad:	0f b7 c0             	movzwl %ax,%eax
  814ab0:	89 c7                	mov    %eax,%edi
  814ab2:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814ab9:	00 00 00 
  814abc:	ff d0                	callq  *%rax
  814abe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814ac2:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  814ac5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814ac9:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814acd:	0f b7 c0             	movzwl %ax,%eax
  814ad0:	89 c7                	mov    %eax,%edi
  814ad2:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814ad9:	00 00 00 
  814adc:	ff d0                	callq  *%rax
  814ade:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814ae2:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = seg->tcphdr->seqno;
  814ae6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814aea:	48 8b 40 20          	mov    0x20(%rax),%rax
  814aee:	8b 50 04             	mov    0x4(%rax),%edx
  814af1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814af5:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814af8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814afc:	8b 40 30             	mov    0x30(%rax),%eax
  814aff:	89 c7                	mov    %eax,%edi
  814b01:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  814b08:	00 00 00 
  814b0b:	ff d0                	callq  *%rax
  814b0d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814b11:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  814b14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b18:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814b1c:	0f b7 c0             	movzwl %ax,%eax
  814b1f:	89 c7                	mov    %eax,%edi
  814b21:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814b28:	00 00 00 
  814b2b:	ff d0                	callq  *%rax
  814b2d:	0f b7 c0             	movzwl %ax,%eax
  814b30:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814b35:	89 c7                	mov    %eax,%edi
  814b37:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814b3e:	00 00 00 
  814b41:	ff d0                	callq  *%rax
  814b43:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814b47:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814b4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814b4f:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814b53:	0f b7 c0             	movzwl %ax,%eax
  814b56:	89 c7                	mov    %eax,%edi
  814b58:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814b5f:	00 00 00 
  814b62:	ff d0                	callq  *%rax
  814b64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814b68:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814b6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b70:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814b76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b7a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814b7e:	0f b7 c0             	movzwl %ax,%eax
  814b81:	89 c7                	mov    %eax,%edi
  814b83:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814b8a:	00 00 00 
  814b8d:	ff d0                	callq  *%rax
  814b8f:	83 e0 3f             	and    $0x3f,%eax
  814b92:	80 cc 50             	or     $0x50,%ah
  814b95:	0f b7 c0             	movzwl %ax,%eax
  814b98:	89 c7                	mov    %eax,%edi
  814b9a:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  814ba1:	00 00 00 
  814ba4:	ff d0                	callq  *%rax
  814ba6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814baa:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814bae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814bb2:	48 8b 40 08          	mov    0x8(%rax),%rax
  814bb6:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814bba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814bbe:	48 8b 40 10          	mov    0x10(%rax),%rax
  814bc2:	0f b6 00             	movzbl (%rax),%eax
  814bc5:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  814bc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bcb:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814bd1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814bd5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814bd9:	0f b7 c8             	movzwl %ax,%ecx
  814bdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814be0:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814be4:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814be8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814bec:	41 89 c8             	mov    %ecx,%r8d
  814bef:	b9 06 00 00 00       	mov    $0x6,%ecx
  814bf4:	48 89 c7             	mov    %rax,%rdi
  814bf7:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  814bfe:	00 00 00 
  814c01:	ff d0                	callq  *%rax
  814c03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c07:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814c0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c0f:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814c13:	0f b6 d0             	movzbl %al,%edx
  814c16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c1a:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814c1e:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814c22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814c26:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814c2c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814c32:	89 d1                	mov    %edx,%ecx
  814c34:	48 89 fa             	mov    %rdi,%rdx
  814c37:	48 89 c7             	mov    %rax,%rdi
  814c3a:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  814c41:	00 00 00 
  814c44:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814c46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814c4a:	48 89 c7             	mov    %rax,%rdi
  814c4d:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  814c54:	00 00 00 
  814c57:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814c59:	c9                   	leaveq 
  814c5a:	c3                   	retq   

0000000000814c5b <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814c5b:	55                   	push   %rbp
  814c5c:	48 89 e5             	mov    %rsp,%rbp
  814c5f:	53                   	push   %rbx
  814c60:	48 83 ec 58          	sub    $0x58,%rsp
  814c64:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814c68:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814c6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814c70:	48 8b 40 08          	mov    0x8(%rax),%rax
  814c74:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814c78:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814c7c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814c80:	0f b7 d8             	movzwl %ax,%ebx
  814c83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c87:	0f b7 00             	movzwl (%rax),%eax
  814c8a:	0f b7 c0             	movzwl %ax,%eax
  814c8d:	89 c7                	mov    %eax,%edi
  814c8f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814c96:	00 00 00 
  814c99:	ff d0                	callq  *%rax
  814c9b:	66 c1 e8 08          	shr    $0x8,%ax
  814c9f:	0f b7 c0             	movzwl %ax,%eax
  814ca2:	83 e0 0f             	and    $0xf,%eax
  814ca5:	83 c0 02             	add    $0x2,%eax
  814ca8:	c1 e0 02             	shl    $0x2,%eax
  814cab:	39 c3                	cmp    %eax,%ebx
  814cad:	7c 40                	jl     814cef <udp_input+0x94>
  814caf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814cb3:	0f b7 00             	movzwl (%rax),%eax
  814cb6:	0f b7 c0             	movzwl %ax,%eax
  814cb9:	89 c7                	mov    %eax,%edi
  814cbb:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814cc2:	00 00 00 
  814cc5:	ff d0                	callq  *%rax
  814cc7:	66 c1 e8 08          	shr    $0x8,%ax
  814ccb:	83 e0 0f             	and    $0xf,%eax
  814cce:	c1 e0 02             	shl    $0x2,%eax
  814cd1:	f7 d8                	neg    %eax
  814cd3:	0f bf d0             	movswl %ax,%edx
  814cd6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814cda:	89 d6                	mov    %edx,%esi
  814cdc:	48 89 c7             	mov    %rax,%rdi
  814cdf:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  814ce6:	00 00 00 
  814ce9:	ff d0                	callq  *%rax
  814ceb:	84 c0                	test   %al,%al
  814ced:	74 18                	je     814d07 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814cef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814cf3:	48 89 c7             	mov    %rax,%rdi
  814cf6:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  814cfd:	00 00 00 
  814d00:	ff d0                	callq  *%rax
    goto end;
  814d02:	e9 62 04 00 00       	jmpq   815169 <udp_input+0x50e>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814d07:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d0b:	48 8b 40 08          	mov    0x8(%rax),%rax
  814d0f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814d13:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814d17:	0f b7 00             	movzwl (%rax),%eax
  814d1a:	0f b7 c0             	movzwl %ax,%eax
  814d1d:	89 c7                	mov    %eax,%edi
  814d1f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814d26:	00 00 00 
  814d29:	ff d0                	callq  *%rax
  814d2b:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814d2f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814d33:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814d37:	0f b7 c0             	movzwl %ax,%eax
  814d3a:	89 c7                	mov    %eax,%edi
  814d3c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  814d43:	00 00 00 
  814d46:	ff d0                	callq  *%rax
  814d48:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814d4c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814d53:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814d54:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814d59:	0f 85 8c 00 00 00    	jne    814deb <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814d5f:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814d64:	0f 85 d3 01 00 00    	jne    814f3d <udp_input+0x2e2>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  814d6a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814d6e:	48 8b 40 38          	mov    0x38(%rax),%rax
  814d72:	48 85 c0             	test   %rax,%rax
  814d75:	0f 84 c2 01 00 00    	je     814f3d <udp_input+0x2e2>
  814d7b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814d7f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814d83:	48 8b 40 08          	mov    0x8(%rax),%rax
  814d87:	48 85 c0             	test   %rax,%rax
  814d8a:	0f 84 ad 01 00 00    	je     814f3d <udp_input+0x2e2>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814d90:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814d94:	48 8b 40 38          	mov    0x38(%rax),%rax
  814d98:	48 8b 40 08          	mov    0x8(%rax),%rax
  814d9c:	48 83 c0 04          	add    $0x4,%rax
  814da0:	48 85 c0             	test   %rax,%rax
  814da3:	74 31                	je     814dd6 <udp_input+0x17b>
  814da5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814da9:	48 8b 40 38          	mov    0x38(%rax),%rax
  814dad:	48 8b 40 08          	mov    0x8(%rax),%rax
  814db1:	8b 40 04             	mov    0x4(%rax),%eax
  814db4:	85 c0                	test   %eax,%eax
  814db6:	74 1e                	je     814dd6 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814db8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814dbc:	48 8b 40 38          	mov    0x38(%rax),%rax
  814dc0:	48 8b 40 08          	mov    0x8(%rax),%rax
  814dc4:	8b 50 04             	mov    0x4(%rax),%edx
  814dc7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814dcb:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814dce:	39 c2                	cmp    %eax,%edx
  814dd0:	0f 85 67 01 00 00    	jne    814f3d <udp_input+0x2e2>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  814dd6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814dda:	48 8b 40 38          	mov    0x38(%rax),%rax
  814dde:	48 8b 40 08          	mov    0x8(%rax),%rax
  814de2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814de6:	e9 52 01 00 00       	jmpq   814f3d <udp_input+0x2e2>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  814deb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  814df2:	00 
    local_match = 0;
  814df3:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  814df7:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  814dfe:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814dff:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814e06:	00 00 00 
  814e09:	48 8b 00             	mov    (%rax),%rax
  814e0c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814e10:	e9 0e 01 00 00       	jmpq   814f23 <udp_input+0x2c8>
      local_match = 0;
  814e15:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814e19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e1d:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814e21:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  814e25:	75 6b                	jne    814e92 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  814e27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814e2b:	48 85 c0             	test   %rax,%rax
  814e2e:	74 3d                	je     814e6d <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  814e30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e34:	8b 00                	mov    (%rax),%eax
  814e36:	85 c0                	test   %eax,%eax
  814e38:	74 33                	je     814e6d <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814e3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e3e:	8b 10                	mov    (%rax),%edx
  814e40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e44:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  814e47:	39 c2                	cmp    %eax,%edx
  814e49:	74 22                	je     814e6d <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  814e4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e4f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814e53:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814e57:	48 89 c6             	mov    %rax,%rsi
  814e5a:	48 89 d7             	mov    %rdx,%rdi
  814e5d:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  814e64:	00 00 00 
  814e67:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814e69:	84 c0                	test   %al,%al
  814e6b:	74 25                	je     814e92 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  814e6d:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814e71:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814e76:	75 1a                	jne    814e92 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814e78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e7c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814e80:	0f b6 c0             	movzbl %al,%eax
  814e83:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  814e86:	85 c0                	test   %eax,%eax
  814e88:	75 08                	jne    814e92 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  814e8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e8e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814e92:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814e96:	74 77                	je     814f0f <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814e98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e9c:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814ea0:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814ea4:	75 69                	jne    814f0f <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814ea6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814eaa:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  814eae:	48 85 c0             	test   %rax,%rax
  814eb1:	74 1d                	je     814ed0 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814eb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814eb7:	8b 40 04             	mov    0x4(%rax),%eax
  814eba:	85 c0                	test   %eax,%eax
  814ebc:	74 12                	je     814ed0 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  814ebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ec2:	8b 50 04             	mov    0x4(%rax),%edx
  814ec5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814ec9:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814ecc:	39 c2                	cmp    %eax,%edx
  814ece:	75 3f                	jne    814f0f <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  814ed0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814ed5:	74 36                	je     814f0d <udp_input+0x2b2>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814ed7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814edb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814edf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814ee3:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  814ee7:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814eee:	00 00 00 
  814ef1:	48 8b 10             	mov    (%rax),%rdx
  814ef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ef8:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  814efc:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814f03:	00 00 00 
  814f06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814f0a:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814f0d:	eb 1f                	jmp    814f2e <udp_input+0x2d3>
      }
      prev = pcb;
  814f0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f13:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814f17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f1b:	48 8b 40 10          	mov    0x10(%rax),%rax
  814f1f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814f23:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814f28:	0f 85 e7 fe ff ff    	jne    814e15 <udp_input+0x1ba>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  814f2e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814f33:	75 08                	jne    814f3d <udp_input+0x2e2>
      pcb = uncon_pcb;
  814f35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f39:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  814f3d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814f42:	75 16                	jne    814f5a <udp_input+0x2ff>
  814f44:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814f48:	8b 50 08             	mov    0x8(%rax),%edx
  814f4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f4f:	8b 40 10             	mov    0x10(%rax),%eax
  814f52:	39 c2                	cmp    %eax,%edx
  814f54:	0f 85 fc 01 00 00    	jne    815156 <udp_input+0x4fb>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  814f5a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814f5e:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814f62:	66 85 c0             	test   %ax,%ax
  814f65:	74 53                	je     814fba <udp_input+0x35f>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  814f67:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f6b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  814f6f:	0f b7 c8             	movzwl %ax,%ecx
  814f72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f76:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814f7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f7e:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  814f82:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f86:	41 89 c8             	mov    %ecx,%r8d
  814f89:	b9 11 00 00 00       	mov    $0x11,%ecx
  814f8e:	48 89 c7             	mov    %rax,%rdi
  814f91:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  814f98:	00 00 00 
  814f9b:	ff d0                	callq  *%rax
  814f9d:	66 85 c0             	test   %ax,%ax
  814fa0:	74 18                	je     814fba <udp_input+0x35f>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  814fa2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814fa6:	48 89 c7             	mov    %rax,%rdi
  814fa9:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  814fb0:	00 00 00 
  814fb3:	ff d0                	callq  *%rax
          goto end;
  814fb5:	e9 af 01 00 00       	jmpq   815169 <udp_input+0x50e>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  814fba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814fbe:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  814fc3:	48 89 c7             	mov    %rax,%rdi
  814fc6:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  814fcd:	00 00 00 
  814fd0:	ff d0                	callq  *%rax
  814fd2:	84 c0                	test   %al,%al
  814fd4:	74 2a                	je     815000 <udp_input+0x3a5>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  814fd6:	48 ba c8 28 82 00 00 	movabs $0x8228c8,%rdx
  814fdd:	00 00 00 
  814fe0:	be 0a 01 00 00       	mov    $0x10a,%esi
  814fe5:	48 bf dc 28 82 00 00 	movabs $0x8228dc,%rdi
  814fec:	00 00 00 
  814fef:	b8 00 00 00 00       	mov    $0x0,%eax
  814ff4:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  814ffb:	00 00 00 
  814ffe:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  815000:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815005:	74 51                	je     815058 <udp_input+0x3fd>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  815007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81500b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81500f:	48 85 c0             	test   %rax,%rax
  815012:	74 2c                	je     815040 <udp_input+0x3e5>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  815014:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815018:	48 8b 40 20          	mov    0x20(%rax),%rax
  81501c:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  815021:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815025:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  815029:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81502d:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  815031:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  815035:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  815039:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  81503b:	e9 29 01 00 00       	jmpq   815169 <udp_input+0x50e>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  815040:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815044:	48 89 c7             	mov    %rax,%rdi
  815047:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81504e:	00 00 00 
  815051:	ff d0                	callq  *%rax
        goto end;
  815053:	e9 11 01 00 00       	jmpq   815169 <udp_input+0x50e>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  815058:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81505c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  815060:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815064:	48 89 c6             	mov    %rax,%rsi
  815067:	48 89 d7             	mov    %rdx,%rdi
  81506a:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  815071:	00 00 00 
  815074:	ff d0                	callq  *%rax
  815076:	84 c0                	test   %al,%al
  815078:	0f 85 c3 00 00 00    	jne    815141 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
  81507e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815082:	8b 58 10             	mov    0x10(%rax),%ebx
  815085:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81508a:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  815091:	00 00 00 
  815094:	ff d0                	callq  *%rax
  815096:	21 c3                	and    %eax,%ebx
  815098:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81509d:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8150a4:	00 00 00 
  8150a7:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8150a9:	39 c3                	cmp    %eax,%ebx
  8150ab:	0f 84 90 00 00 00    	je     815141 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  8150b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8150b5:	0f b7 00             	movzwl (%rax),%eax
  8150b8:	0f b7 c0             	movzwl %ax,%eax
  8150bb:	89 c7                	mov    %eax,%edi
  8150bd:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8150c4:	00 00 00 
  8150c7:	ff d0                	callq  *%rax
  8150c9:	66 c1 e8 08          	shr    $0x8,%ax
  8150cd:	0f b7 c0             	movzwl %ax,%eax
  8150d0:	83 e0 0f             	and    $0xf,%eax
  8150d3:	83 c0 02             	add    $0x2,%eax
  8150d6:	c1 e0 02             	shl    $0x2,%eax
  8150d9:	0f bf d0             	movswl %ax,%edx
  8150dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8150e0:	89 d6                	mov    %edx,%esi
  8150e2:	48 89 c7             	mov    %rax,%rdi
  8150e5:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  8150ec:	00 00 00 
  8150ef:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  8150f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8150f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8150f9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8150fd:	74 2a                	je     815129 <udp_input+0x4ce>
  8150ff:	48 ba f0 28 82 00 00 	movabs $0x8228f0,%rdx
  815106:	00 00 00 
  815109:	be 25 01 00 00       	mov    $0x125,%esi
  81510e:	48 bf dc 28 82 00 00 	movabs $0x8228dc,%rdi
  815115:	00 00 00 
  815118:	b8 00 00 00 00       	mov    $0x0,%eax
  81511d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  815124:	00 00 00 
  815127:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  815129:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81512d:	be 03 00 00 00       	mov    $0x3,%esi
  815132:	48 89 c7             	mov    %rax,%rdi
  815135:	48 b8 e7 05 82 00 00 	movabs $0x8205e7,%rax
  81513c:	00 00 00 
  81513f:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  815141:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815145:	48 89 c7             	mov    %rax,%rdi
  815148:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81514f:	00 00 00 
  815152:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  815154:	eb 13                	jmp    815169 <udp_input+0x50e>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  815156:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81515a:	48 89 c7             	mov    %rax,%rdi
  81515d:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  815164:	00 00 00 
  815167:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  815169:	48 83 c4 58          	add    $0x58,%rsp
  81516d:	5b                   	pop    %rbx
  81516e:	5d                   	pop    %rbp
  81516f:	c3                   	retq   

0000000000815170 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  815170:	55                   	push   %rbp
  815171:	48 89 e5             	mov    %rsp,%rbp
  815174:	48 83 ec 10          	sub    $0x10,%rsp
  815178:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81517c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  815180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815184:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  815188:	0f b7 d0             	movzwl %ax,%edx
  81518b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81518f:	48 8d 78 04          	lea    0x4(%rax),%rdi
  815193:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  815197:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81519b:	89 d1                	mov    %edx,%ecx
  81519d:	48 89 fa             	mov    %rdi,%rdx
  8151a0:	48 89 c7             	mov    %rax,%rdi
  8151a3:	48 b8 b1 51 81 00 00 	movabs $0x8151b1,%rax
  8151aa:	00 00 00 
  8151ad:	ff d0                	callq  *%rax
}
  8151af:	c9                   	leaveq 
  8151b0:	c3                   	retq   

00000000008151b1 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  8151b1:	55                   	push   %rbp
  8151b2:	48 89 e5             	mov    %rsp,%rbp
  8151b5:	48 83 ec 30          	sub    $0x30,%rsp
  8151b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8151bd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8151c1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8151c5:	89 c8                	mov    %ecx,%eax
  8151c7:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8151cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151cf:	48 89 c7             	mov    %rax,%rdi
  8151d2:	48 b8 bd 0c 81 00 00 	movabs $0x810cbd,%rax
  8151d9:	00 00 00 
  8151dc:	ff d0                	callq  *%rax
  8151de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  8151e2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8151e7:	75 07                	jne    8151f0 <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  8151e9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8151ee:	eb 26                	jmp    815216 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  8151f0:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  8151f4:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8151f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8151fc:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  815200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815204:	49 89 f8             	mov    %rdi,%r8
  815207:	48 89 c7             	mov    %rax,%rdi
  81520a:	48 b8 18 52 81 00 00 	movabs $0x815218,%rax
  815211:	00 00 00 
  815214:	ff d0                	callq  *%rax
}
  815216:	c9                   	leaveq 
  815217:	c3                   	retq   

0000000000815218 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  815218:	55                   	push   %rbp
  815219:	48 89 e5             	mov    %rsp,%rbp
  81521c:	48 83 ec 50          	sub    $0x50,%rsp
  815220:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  815224:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  815228:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81522c:	89 c8                	mov    %ecx,%eax
  81522e:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  815232:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  815236:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81523a:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81523e:	66 85 c0             	test   %ax,%ax
  815241:	75 37                	jne    81527a <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815243:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815247:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81524b:	0f b7 d0             	movzwl %ax,%edx
  81524e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  815252:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815256:	48 89 ce             	mov    %rcx,%rsi
  815259:	48 89 c7             	mov    %rax,%rdi
  81525c:	48 b8 c9 54 81 00 00 	movabs $0x8154c9,%rax
  815263:	00 00 00 
  815266:	ff d0                	callq  *%rax
  815268:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  81526b:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81526f:	74 09                	je     81527a <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  815271:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815275:	e9 4d 02 00 00       	jmpq   8154c7 <udp_sendto_if+0x2af>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  81527a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81527e:	be 08 00 00 00       	mov    $0x8,%esi
  815283:	48 89 c7             	mov    %rax,%rdi
  815286:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81528d:	00 00 00 
  815290:	ff d0                	callq  *%rax
  815292:	84 c0                	test   %al,%al
  815294:	74 4c                	je     8152e2 <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  815296:	ba 00 00 00 00       	mov    $0x0,%edx
  81529b:	be 08 00 00 00       	mov    $0x8,%esi
  8152a0:	bf 01 00 00 00       	mov    $0x1,%edi
  8152a5:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  8152ac:	00 00 00 
  8152af:	ff d0                	callq  *%rax
  8152b1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8152b5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8152ba:	75 0a                	jne    8152c6 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8152bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8152c1:	e9 01 02 00 00       	jmpq   8154c7 <udp_sendto_if+0x2af>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8152c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8152ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8152ce:	48 89 d6             	mov    %rdx,%rsi
  8152d1:	48 89 c7             	mov    %rax,%rdi
  8152d4:	48 b8 49 df 80 00 00 	movabs $0x80df49,%rax
  8152db:	00 00 00 
  8152de:	ff d0                	callq  *%rax
  8152e0:	eb 08                	jmp    8152ea <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  8152e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8152e6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8152ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8152ee:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8152f2:	66 83 f8 07          	cmp    $0x7,%ax
  8152f6:	77 2a                	ja     815322 <udp_sendto_if+0x10a>
  8152f8:	48 ba 08 29 82 00 00 	movabs $0x822908,%rdx
  8152ff:	00 00 00 
  815302:	be b2 01 00 00       	mov    $0x1b2,%esi
  815307:	48 bf dc 28 82 00 00 	movabs $0x8228dc,%rdi
  81530e:	00 00 00 
  815311:	b8 00 00 00 00       	mov    $0x0,%eax
  815316:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81531d:	00 00 00 
  815320:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  815322:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815326:	48 8b 40 08          	mov    0x8(%rax),%rax
  81532a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  81532e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815332:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815336:	0f b7 c0             	movzwl %ax,%eax
  815339:	89 c7                	mov    %eax,%edi
  81533b:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  815342:	00 00 00 
  815345:	ff d0                	callq  *%rax
  815347:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81534b:	66 89 02             	mov    %ax,(%rdx)
  udphdr->dest = htons(dst_port);
  81534e:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  815352:	89 c7                	mov    %eax,%edi
  815354:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81535b:	00 00 00 
  81535e:	ff d0                	callq  *%rax
  815360:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815364:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  815368:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81536c:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  815372:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815376:	48 85 c0             	test   %rax,%rax
  815379:	74 0a                	je     815385 <udp_sendto_if+0x16d>
  81537b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81537f:	8b 00                	mov    (%rax),%eax
  815381:	85 c0                	test   %eax,%eax
  815383:	75 0e                	jne    815393 <udp_sendto_if+0x17b>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  815385:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815389:	48 83 c0 08          	add    $0x8,%rax
  81538d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815391:	eb 48                	jmp    8153db <udp_sendto_if+0x1c3>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  815393:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815397:	8b 10                	mov    (%rax),%edx
  815399:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81539d:	8b 40 08             	mov    0x8(%rax),%eax
  8153a0:	39 c2                	cmp    %eax,%edx
  8153a2:	74 2f                	je     8153d3 <udp_sendto_if+0x1bb>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8153a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8153a8:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8153ac:	74 1b                	je     8153c9 <udp_sendto_if+0x1b1>
        /* free the header pbuf */
        pbuf_free(q);
  8153ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8153b2:	48 89 c7             	mov    %rax,%rdi
  8153b5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8153bc:	00 00 00 
  8153bf:	ff d0                	callq  *%rax
        q = NULL;
  8153c1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8153c8:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8153c9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8153ce:	e9 f4 00 00 00       	jmpq   8154c7 <udp_sendto_if+0x2af>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8153d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8153d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8153db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8153df:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8153e3:	0f b7 c0             	movzwl %ax,%eax
  8153e6:	89 c7                	mov    %eax,%edi
  8153e8:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8153ef:	00 00 00 
  8153f2:	ff d0                	callq  *%rax
  8153f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8153f8:	66 89 42 04          	mov    %ax,0x4(%rdx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8153fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815400:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815404:	0f b6 c0             	movzbl %al,%eax
  815407:	83 e0 01             	and    $0x1,%eax
  81540a:	85 c0                	test   %eax,%eax
  81540c:	75 4d                	jne    81545b <udp_sendto_if+0x243>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  81540e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815412:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815416:	0f b7 c8             	movzwl %ax,%ecx
  815419:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81541d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815421:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815425:	41 89 c8             	mov    %ecx,%r8d
  815428:	b9 11 00 00 00       	mov    $0x11,%ecx
  81542d:	48 89 c7             	mov    %rax,%rdi
  815430:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  815437:	00 00 00 
  81543a:	ff d0                	callq  *%rax
  81543c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815440:	66 89 42 06          	mov    %ax,0x6(%rdx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  815444:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815448:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81544c:	66 85 c0             	test   %ax,%ax
  81544f:	75 0a                	jne    81545b <udp_sendto_if+0x243>
  815451:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815455:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  81545b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81545f:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  815463:	44 0f b6 c0          	movzbl %al,%r8d
  815467:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81546b:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81546f:	0f b6 c8             	movzbl %al,%ecx
  815472:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815476:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81547a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81547e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  815482:	48 89 3c 24          	mov    %rdi,(%rsp)
  815486:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  81548c:	48 89 c7             	mov    %rax,%rdi
  81548f:	48 b8 f2 11 81 00 00 	movabs $0x8111f2,%rax
  815496:	00 00 00 
  815499:	ff d0                	callq  *%rax
  81549b:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  81549e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8154a2:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8154a6:	74 1b                	je     8154c3 <udp_sendto_if+0x2ab>
    /* free the header pbuf */
    pbuf_free(q);
  8154a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8154ac:	48 89 c7             	mov    %rax,%rdi
  8154af:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8154b6:	00 00 00 
  8154b9:	ff d0                	callq  *%rax
    q = NULL;
  8154bb:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8154c2:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8154c3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  8154c7:	c9                   	leaveq 
  8154c8:	c3                   	retq   

00000000008154c9 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8154c9:	55                   	push   %rbp
  8154ca:	48 89 e5             	mov    %rsp,%rbp
  8154cd:	48 83 ec 30          	sub    $0x30,%rsp
  8154d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8154d5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8154d9:	89 d0                	mov    %edx,%eax
  8154db:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  8154df:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8154e3:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154ea:	00 00 00 
  8154ed:	48 8b 00             	mov    (%rax),%rax
  8154f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8154f4:	eb 4a                	jmp    815540 <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  8154f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154fa:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8154fe:	75 34                	jne    815534 <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  815500:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815504:	74 2a                	je     815530 <udp_bind+0x67>
  815506:	48 ba 36 29 82 00 00 	movabs $0x822936,%rdx
  81550d:	00 00 00 
  815510:	be 41 02 00 00       	mov    $0x241,%esi
  815515:	48 bf dc 28 82 00 00 	movabs $0x8228dc,%rdi
  81551c:	00 00 00 
  81551f:	b8 00 00 00 00       	mov    $0x0,%eax
  815524:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81552b:	00 00 00 
  81552e:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  815530:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815538:	48 8b 40 10          	mov    0x10(%rax),%rax
  81553c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815540:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815545:	75 af                	jne    8154f6 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815547:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81554c:	74 08                	je     815556 <udp_bind+0x8d>
  81554e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815552:	8b 00                	mov    (%rax),%eax
  815554:	eb 05                	jmp    81555b <udp_bind+0x92>
  815556:	b8 00 00 00 00       	mov    $0x0,%eax
  81555b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81555f:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  815561:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815566:	75 6e                	jne    8155d6 <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815568:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  81556e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815575:	00 00 00 
  815578:	48 8b 00             	mov    (%rax),%rax
  81557b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  81557f:	eb 38                	jmp    8155b9 <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  815581:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815585:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815589:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  81558d:	75 1e                	jne    8155ad <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  81558f:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  815593:	83 c0 01             	add    $0x1,%eax
  815596:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  81559a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8155a1:	00 00 00 
  8155a4:	48 8b 00             	mov    (%rax),%rax
  8155a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8155ab:	eb 0c                	jmp    8155b9 <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8155ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155b1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8155b9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8155be:	74 08                	je     8155c8 <udp_bind+0xff>
  8155c0:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  8155c6:	75 b9                	jne    815581 <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8155c8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8155cd:	74 07                	je     8155d6 <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8155cf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8155d4:	eb 3d                	jmp    815613 <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  8155d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155da:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8155de:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8155e2:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8155e6:	75 26                	jne    81560e <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8155e8:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8155ef:	00 00 00 
  8155f2:	48 8b 10             	mov    (%rax),%rdx
  8155f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155f9:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  8155fd:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815604:	00 00 00 
  815607:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81560b:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  81560e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815613:	c9                   	leaveq 
  815614:	c3                   	retq   

0000000000815615 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815615:	55                   	push   %rbp
  815616:	48 89 e5             	mov    %rsp,%rbp
  815619:	48 83 ec 30          	sub    $0x30,%rsp
  81561d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815621:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815625:	89 d0                	mov    %edx,%eax
  815627:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  81562b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81562f:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815633:	66 85 c0             	test   %ax,%ax
  815636:	75 37                	jne    81566f <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815638:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81563c:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815640:	0f b7 d0             	movzwl %ax,%edx
  815643:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  815647:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81564b:	48 89 ce             	mov    %rcx,%rsi
  81564e:	48 89 c7             	mov    %rax,%rdi
  815651:	48 b8 c9 54 81 00 00 	movabs $0x8154c9,%rax
  815658:	00 00 00 
  81565b:	ff d0                	callq  *%rax
  81565d:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815660:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815664:	74 09                	je     81566f <udp_connect+0x5a>
      return err;
  815666:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  81566a:	e9 9d 00 00 00       	jmpq   81570c <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  81566f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815674:	74 08                	je     81567e <udp_connect+0x69>
  815676:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81567a:	8b 00                	mov    (%rax),%eax
  81567c:	eb 05                	jmp    815683 <udp_connect+0x6e>
  81567e:	b8 00 00 00 00       	mov    $0x0,%eax
  815683:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815687:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  81568a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81568e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  815692:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  815696:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81569a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81569e:	83 c8 04             	or     $0x4,%eax
  8156a1:	89 c2                	mov    %eax,%edx
  8156a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156a7:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8156aa:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8156b1:	00 00 00 
  8156b4:	48 8b 00             	mov    (%rax),%rax
  8156b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8156bb:	eb 1d                	jmp    8156da <udp_connect+0xc5>
    if (pcb == ipcb) {
  8156bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156c1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8156c5:	75 07                	jne    8156ce <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  8156c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8156cc:	eb 3e                	jmp    81570c <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8156ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156d2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8156d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8156da:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8156df:	75 dc                	jne    8156bd <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  8156e1:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8156e8:	00 00 00 
  8156eb:	48 8b 10             	mov    (%rax),%rdx
  8156ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156f2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  8156f6:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8156fd:	00 00 00 
  815700:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815704:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  815707:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81570c:	c9                   	leaveq 
  81570d:	c3                   	retq   

000000000081570e <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  81570e:	55                   	push   %rbp
  81570f:	48 89 e5             	mov    %rsp,%rbp
  815712:	48 83 ec 08          	sub    $0x8,%rsp
  815716:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  81571a:	48 b8 e8 24 82 00 00 	movabs $0x8224e8,%rax
  815721:	00 00 00 
  815724:	8b 10                	mov    (%rax),%edx
  815726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81572a:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  81572d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815731:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  815737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81573b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81573f:	83 e0 fb             	and    $0xfffffffb,%eax
  815742:	89 c2                	mov    %eax,%edx
  815744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815748:	88 50 18             	mov    %dl,0x18(%rax)
}
  81574b:	c9                   	leaveq 
  81574c:	c3                   	retq   

000000000081574d <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  81574d:	55                   	push   %rbp
  81574e:	48 89 e5             	mov    %rsp,%rbp
  815751:	48 83 ec 18          	sub    $0x18,%rsp
  815755:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  815759:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81575d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815761:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815765:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815769:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81576d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815771:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815775:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  815779:	c9                   	leaveq 
  81577a:	c3                   	retq   

000000000081577b <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  81577b:	55                   	push   %rbp
  81577c:	48 89 e5             	mov    %rsp,%rbp
  81577f:	48 83 ec 20          	sub    $0x20,%rsp
  815783:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  815787:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81578e:	00 00 00 
  815791:	48 8b 00             	mov    (%rax),%rax
  815794:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815798:	75 20                	jne    8157ba <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  81579a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157a1:	00 00 00 
  8157a4:	48 8b 00             	mov    (%rax),%rax
  8157a7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8157ab:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157b2:	00 00 00 
  8157b5:	48 89 10             	mov    %rdx,(%rax)
  8157b8:	eb 51                	jmp    81580b <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8157ba:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157c1:	00 00 00 
  8157c4:	48 8b 00             	mov    (%rax),%rax
  8157c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8157cb:	eb 37                	jmp    815804 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8157cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157d1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8157d5:	48 85 c0             	test   %rax,%rax
  8157d8:	74 1e                	je     8157f8 <udp_remove+0x7d>
  8157da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157de:	48 8b 40 10          	mov    0x10(%rax),%rax
  8157e2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8157e6:	75 10                	jne    8157f8 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8157e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157ec:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8157f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157f4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8157f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157fc:	48 8b 40 10          	mov    0x10(%rax),%rax
  815800:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815804:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815809:	75 c2                	jne    8157cd <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  81580b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81580f:	48 89 c6             	mov    %rax,%rsi
  815812:	bf 01 00 00 00       	mov    $0x1,%edi
  815817:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81581e:	00 00 00 
  815821:	ff d0                	callq  *%rax
}
  815823:	c9                   	leaveq 
  815824:	c3                   	retq   

0000000000815825 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815825:	55                   	push   %rbp
  815826:	48 89 e5             	mov    %rsp,%rbp
  815829:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  81582d:	bf 01 00 00 00       	mov    $0x1,%edi
  815832:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  815839:	00 00 00 
  81583c:	ff d0                	callq  *%rax
  81583e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815842:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815847:	74 25                	je     81586e <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  815849:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81584d:	ba 30 00 00 00       	mov    $0x30,%edx
  815852:	be 00 00 00 00       	mov    $0x0,%esi
  815857:	48 89 c7             	mov    %rax,%rdi
  81585a:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  815861:	00 00 00 
  815864:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  815866:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81586a:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  81586e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815872:	c9                   	leaveq 
  815873:	c3                   	retq   

0000000000815874 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815874:	55                   	push   %rbp
  815875:	48 89 e5             	mov    %rsp,%rbp
  815878:	48 83 ec 20          	sub    $0x20,%rsp
  81587c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815880:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815885:	75 2a                	jne    8158b1 <free_etharp_q+0x3d>
  815887:	48 ba 54 29 82 00 00 	movabs $0x822954,%rdx
  81588e:	00 00 00 
  815891:	be 93 00 00 00       	mov    $0x93,%esi
  815896:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  81589d:	00 00 00 
  8158a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8158a5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8158ac:	00 00 00 
  8158af:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8158b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8158b9:	48 85 c0             	test   %rax,%rax
  8158bc:	75 2a                	jne    8158e8 <free_etharp_q+0x74>
  8158be:	48 ba 76 29 82 00 00 	movabs $0x822976,%rdx
  8158c5:	00 00 00 
  8158c8:	be 94 00 00 00       	mov    $0x94,%esi
  8158cd:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  8158d4:	00 00 00 
  8158d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8158dc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8158e3:	00 00 00 
  8158e6:	ff d1                	callq  *%rcx
  while (q) {
  8158e8:	eb 79                	jmp    815963 <free_etharp_q+0xef>
    r = q;
  8158ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  8158f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158f6:	48 8b 00             	mov    (%rax),%rax
  8158f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8158fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815901:	48 8b 40 08          	mov    0x8(%rax),%rax
  815905:	48 85 c0             	test   %rax,%rax
  815908:	75 2a                	jne    815934 <free_etharp_q+0xc0>
  81590a:	48 ba 83 29 82 00 00 	movabs $0x822983,%rdx
  815911:	00 00 00 
  815914:	be 98 00 00 00       	mov    $0x98,%esi
  815919:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  815920:	00 00 00 
  815923:	b8 00 00 00 00       	mov    $0x0,%eax
  815928:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81592f:	00 00 00 
  815932:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  815934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815938:	48 8b 40 08          	mov    0x8(%rax),%rax
  81593c:	48 89 c7             	mov    %rax,%rdi
  81593f:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  815946:	00 00 00 
  815949:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  81594b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81594f:	48 89 c6             	mov    %rax,%rsi
  815952:	bf 0a 00 00 00       	mov    $0xa,%edi
  815957:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81595e:	00 00 00 
  815961:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815963:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815968:	75 80                	jne    8158ea <free_etharp_q+0x76>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  81596a:	c9                   	leaveq 
  81596b:	c3                   	retq   

000000000081596c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  81596c:	55                   	push   %rbp
  81596d:	48 89 e5             	mov    %rsp,%rbp
  815970:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815974:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  815978:	e9 df 01 00 00       	jmpq   815b5c <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  81597d:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815981:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815988:	00 00 00 
  81598b:	48 63 ca             	movslq %edx,%rcx
  81598e:	48 89 c8             	mov    %rcx,%rax
  815991:	48 c1 e0 02          	shl    $0x2,%rax
  815995:	48 01 c8             	add    %rcx,%rax
  815998:	48 c1 e0 03          	shl    $0x3,%rax
  81599c:	48 01 f0             	add    %rsi,%rax
  81599f:	48 83 c0 10          	add    $0x10,%rax
  8159a3:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  8159a7:	8d 48 01             	lea    0x1(%rax),%ecx
  8159aa:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8159b1:	00 00 00 
  8159b4:	48 63 d2             	movslq %edx,%rdx
  8159b7:	48 89 d0             	mov    %rdx,%rax
  8159ba:	48 c1 e0 02          	shl    $0x2,%rax
  8159be:	48 01 d0             	add    %rdx,%rax
  8159c1:	48 c1 e0 03          	shl    $0x3,%rax
  8159c5:	48 01 f0             	add    %rsi,%rax
  8159c8:	48 83 c0 10          	add    $0x10,%rax
  8159cc:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8159cf:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8159d3:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8159da:	00 00 00 
  8159dd:	48 63 d0             	movslq %eax,%rdx
  8159e0:	48 89 d0             	mov    %rdx,%rax
  8159e3:	48 c1 e0 02          	shl    $0x2,%rax
  8159e7:	48 01 d0             	add    %rdx,%rax
  8159ea:	48 c1 e0 03          	shl    $0x3,%rax
  8159ee:	48 01 c8             	add    %rcx,%rax
  8159f1:	48 83 c0 10          	add    $0x10,%rax
  8159f5:	8b 40 04             	mov    0x4(%rax),%eax
  8159f8:	83 f8 02             	cmp    $0x2,%eax
  8159fb:	75 2e                	jne    815a2b <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  8159fd:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815a01:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a08:	00 00 00 
  815a0b:	48 63 d0             	movslq %eax,%rdx
  815a0e:	48 89 d0             	mov    %rdx,%rax
  815a11:	48 c1 e0 02          	shl    $0x2,%rax
  815a15:	48 01 d0             	add    %rdx,%rax
  815a18:	48 c1 e0 03          	shl    $0x3,%rax
  815a1c:	48 01 c8             	add    %rcx,%rax
  815a1f:	48 83 c0 10          	add    $0x10,%rax
  815a23:	0f b6 40 08          	movzbl 0x8(%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815a27:	3c ef                	cmp    $0xef,%al
  815a29:	77 64                	ja     815a8f <etharp_tmr+0x123>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815a2b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815a2f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a36:	00 00 00 
  815a39:	48 63 d0             	movslq %eax,%rdx
  815a3c:	48 89 d0             	mov    %rdx,%rax
  815a3f:	48 c1 e0 02          	shl    $0x2,%rax
  815a43:	48 01 d0             	add    %rdx,%rax
  815a46:	48 c1 e0 03          	shl    $0x3,%rax
  815a4a:	48 01 c8             	add    %rcx,%rax
  815a4d:	48 83 c0 10          	add    $0x10,%rax
  815a51:	8b 40 04             	mov    0x4(%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815a54:	83 f8 01             	cmp    $0x1,%eax
  815a57:	0f 85 e6 00 00 00    	jne    815b43 <etharp_tmr+0x1d7>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815a5d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815a61:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a68:	00 00 00 
  815a6b:	48 63 d0             	movslq %eax,%rdx
  815a6e:	48 89 d0             	mov    %rdx,%rax
  815a71:	48 c1 e0 02          	shl    $0x2,%rax
  815a75:	48 01 d0             	add    %rdx,%rax
  815a78:	48 c1 e0 03          	shl    $0x3,%rax
  815a7c:	48 01 c8             	add    %rcx,%rax
  815a7f:	48 83 c0 10          	add    $0x10,%rax
  815a83:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815a87:	3c 01                	cmp    $0x1,%al
  815a89:	0f 86 b4 00 00 00    	jbe    815b43 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815a8f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815a93:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a9a:	00 00 00 
  815a9d:	48 63 d0             	movslq %eax,%rdx
  815aa0:	48 89 d0             	mov    %rdx,%rax
  815aa3:	48 c1 e0 02          	shl    $0x2,%rax
  815aa7:	48 01 d0             	add    %rdx,%rax
  815aaa:	48 c1 e0 03          	shl    $0x3,%rax
  815aae:	48 01 c8             	add    %rcx,%rax
  815ab1:	48 8b 00             	mov    (%rax),%rax
  815ab4:	48 85 c0             	test   %rax,%rax
  815ab7:	74 5d                	je     815b16 <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  815ab9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815abd:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ac4:	00 00 00 
  815ac7:	48 63 d0             	movslq %eax,%rdx
  815aca:	48 89 d0             	mov    %rdx,%rax
  815acd:	48 c1 e0 02          	shl    $0x2,%rax
  815ad1:	48 01 d0             	add    %rdx,%rax
  815ad4:	48 c1 e0 03          	shl    $0x3,%rax
  815ad8:	48 01 c8             	add    %rcx,%rax
  815adb:	48 8b 00             	mov    (%rax),%rax
  815ade:	48 89 c7             	mov    %rax,%rdi
  815ae1:	48 b8 74 58 81 00 00 	movabs $0x815874,%rax
  815ae8:	00 00 00 
  815aeb:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  815aed:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815af1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815af8:	00 00 00 
  815afb:	48 63 d0             	movslq %eax,%rdx
  815afe:	48 89 d0             	mov    %rdx,%rax
  815b01:	48 c1 e0 02          	shl    $0x2,%rax
  815b05:	48 01 d0             	add    %rdx,%rax
  815b08:	48 c1 e0 03          	shl    $0x3,%rax
  815b0c:	48 01 c8             	add    %rcx,%rax
  815b0f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  815b16:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b1a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b21:	00 00 00 
  815b24:	48 63 d0             	movslq %eax,%rdx
  815b27:	48 89 d0             	mov    %rdx,%rax
  815b2a:	48 c1 e0 02          	shl    $0x2,%rax
  815b2e:	48 01 d0             	add    %rdx,%rax
  815b31:	48 c1 e0 03          	shl    $0x3,%rax
  815b35:	48 01 c8             	add    %rcx,%rax
  815b38:	48 83 c0 10          	add    $0x10,%rax
  815b3c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815b43:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b47:	48 63 d0             	movslq %eax,%rdx
  815b4a:	48 89 d0             	mov    %rdx,%rax
  815b4d:	48 c1 e0 02          	shl    $0x2,%rax
  815b51:	48 01 d0             	add    %rdx,%rax
  815b54:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815b58:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815b5c:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815b60:	0f 86 17 fe ff ff    	jbe    81597d <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  815b66:	c9                   	leaveq 
  815b67:	c3                   	retq   

0000000000815b68 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815b68:	55                   	push   %rbp
  815b69:	48 89 e5             	mov    %rsp,%rbp
  815b6c:	48 83 ec 20          	sub    $0x20,%rsp
  815b70:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815b74:	89 f0                	mov    %esi,%eax
  815b76:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815b79:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815b7d:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815b81:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815b85:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815b89:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815b8d:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815b91:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815b95:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815b99:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815b9e:	0f 84 87 00 00 00    	je     815c2b <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815ba4:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815bab:	00 00 00 
  815bae:	0f b6 00             	movzbl (%rax),%eax
  815bb1:	0f b6 c0             	movzbl %al,%eax
  815bb4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815bbb:	00 00 00 
  815bbe:	48 63 d0             	movslq %eax,%rdx
  815bc1:	48 89 d0             	mov    %rdx,%rax
  815bc4:	48 c1 e0 02          	shl    $0x2,%rax
  815bc8:	48 01 d0             	add    %rdx,%rax
  815bcb:	48 c1 e0 03          	shl    $0x3,%rax
  815bcf:	48 01 c8             	add    %rcx,%rax
  815bd2:	48 83 c0 10          	add    $0x10,%rax
  815bd6:	8b 40 04             	mov    0x4(%rax),%eax
  815bd9:	83 f8 02             	cmp    $0x2,%eax
  815bdc:	75 4d                	jne    815c2b <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  815bde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815be2:	8b 08                	mov    (%rax),%ecx
  815be4:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815beb:	00 00 00 
  815bee:	0f b6 00             	movzbl (%rax),%eax
  815bf1:	0f b6 c0             	movzbl %al,%eax
  815bf4:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815bfb:	00 00 00 
  815bfe:	48 63 d0             	movslq %eax,%rdx
  815c01:	48 89 d0             	mov    %rdx,%rax
  815c04:	48 c1 e0 02          	shl    $0x2,%rax
  815c08:	48 01 d0             	add    %rdx,%rax
  815c0b:	48 c1 e0 03          	shl    $0x3,%rax
  815c0f:	48 01 f0             	add    %rsi,%rax
  815c12:	8b 40 08             	mov    0x8(%rax),%eax
  815c15:	39 c1                	cmp    %eax,%ecx
  815c17:	75 12                	jne    815c2b <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  815c19:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815c20:	00 00 00 
  815c23:	0f b6 00             	movzbl (%rax),%eax
  815c26:	e9 cf 04 00 00       	jmpq   8160fa <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815c2b:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815c2f:	e9 aa 02 00 00       	jmpq   815ede <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  815c34:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815c38:	75 39                	jne    815c73 <find_entry+0x10b>
  815c3a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c3e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c45:	00 00 00 
  815c48:	48 63 d0             	movslq %eax,%rdx
  815c4b:	48 89 d0             	mov    %rdx,%rax
  815c4e:	48 c1 e0 02          	shl    $0x2,%rax
  815c52:	48 01 d0             	add    %rdx,%rax
  815c55:	48 c1 e0 03          	shl    $0x3,%rax
  815c59:	48 01 c8             	add    %rcx,%rax
  815c5c:	48 83 c0 10          	add    $0x10,%rax
  815c60:	8b 40 04             	mov    0x4(%rax),%eax
  815c63:	85 c0                	test   %eax,%eax
  815c65:	75 0c                	jne    815c73 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815c67:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c6b:	88 45 fd             	mov    %al,-0x3(%rbp)
  815c6e:	e9 67 02 00 00       	jmpq   815eda <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815c73:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c77:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c7e:	00 00 00 
  815c81:	48 63 d0             	movslq %eax,%rdx
  815c84:	48 89 d0             	mov    %rdx,%rax
  815c87:	48 c1 e0 02          	shl    $0x2,%rax
  815c8b:	48 01 d0             	add    %rdx,%rax
  815c8e:	48 c1 e0 03          	shl    $0x3,%rax
  815c92:	48 01 c8             	add    %rcx,%rax
  815c95:	48 83 c0 10          	add    $0x10,%rax
  815c99:	8b 40 04             	mov    0x4(%rax),%eax
  815c9c:	83 f8 01             	cmp    $0x1,%eax
  815c9f:	0f 85 51 01 00 00    	jne    815df6 <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815ca5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815caa:	74 48                	je     815cf4 <find_entry+0x18c>
  815cac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815cb0:	8b 08                	mov    (%rax),%ecx
  815cb2:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815cb6:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815cbd:	00 00 00 
  815cc0:	48 63 d0             	movslq %eax,%rdx
  815cc3:	48 89 d0             	mov    %rdx,%rax
  815cc6:	48 c1 e0 02          	shl    $0x2,%rax
  815cca:	48 01 d0             	add    %rdx,%rax
  815ccd:	48 c1 e0 03          	shl    $0x3,%rax
  815cd1:	48 01 f0             	add    %rsi,%rax
  815cd4:	8b 40 08             	mov    0x8(%rax),%eax
  815cd7:	39 c1                	cmp    %eax,%ecx
  815cd9:	75 19                	jne    815cf4 <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815cdb:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815ce2:	00 00 00 
  815ce5:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815ce9:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815ceb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815cef:	e9 06 04 00 00       	jmpq   8160fa <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815cf4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815cf8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cff:	00 00 00 
  815d02:	48 63 d0             	movslq %eax,%rdx
  815d05:	48 89 d0             	mov    %rdx,%rax
  815d08:	48 c1 e0 02          	shl    $0x2,%rax
  815d0c:	48 01 d0             	add    %rdx,%rax
  815d0f:	48 c1 e0 03          	shl    $0x3,%rax
  815d13:	48 01 c8             	add    %rcx,%rax
  815d16:	48 8b 00             	mov    (%rax),%rax
  815d19:	48 85 c0             	test   %rax,%rax
  815d1c:	74 6c                	je     815d8a <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  815d1e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d22:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d29:	00 00 00 
  815d2c:	48 63 d0             	movslq %eax,%rdx
  815d2f:	48 89 d0             	mov    %rdx,%rax
  815d32:	48 c1 e0 02          	shl    $0x2,%rax
  815d36:	48 01 d0             	add    %rdx,%rax
  815d39:	48 c1 e0 03          	shl    $0x3,%rax
  815d3d:	48 01 c8             	add    %rcx,%rax
  815d40:	48 83 c0 10          	add    $0x10,%rax
  815d44:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815d48:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815d4b:	0f 82 89 01 00 00    	jb     815eda <find_entry+0x372>
          old_queue = i;
  815d51:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d55:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815d58:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d5c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d63:	00 00 00 
  815d66:	48 63 d0             	movslq %eax,%rdx
  815d69:	48 89 d0             	mov    %rdx,%rax
  815d6c:	48 c1 e0 02          	shl    $0x2,%rax
  815d70:	48 01 d0             	add    %rdx,%rax
  815d73:	48 c1 e0 03          	shl    $0x3,%rax
  815d77:	48 01 c8             	add    %rcx,%rax
  815d7a:	48 83 c0 10          	add    $0x10,%rax
  815d7e:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815d82:	88 45 f8             	mov    %al,-0x8(%rbp)
  815d85:	e9 50 01 00 00       	jmpq   815eda <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815d8a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d8e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d95:	00 00 00 
  815d98:	48 63 d0             	movslq %eax,%rdx
  815d9b:	48 89 d0             	mov    %rdx,%rax
  815d9e:	48 c1 e0 02          	shl    $0x2,%rax
  815da2:	48 01 d0             	add    %rdx,%rax
  815da5:	48 c1 e0 03          	shl    $0x3,%rax
  815da9:	48 01 c8             	add    %rcx,%rax
  815dac:	48 83 c0 10          	add    $0x10,%rax
  815db0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815db4:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815db7:	0f 82 1d 01 00 00    	jb     815eda <find_entry+0x372>
          old_pending = i;
  815dbd:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815dc1:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815dc4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815dc8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815dcf:	00 00 00 
  815dd2:	48 63 d0             	movslq %eax,%rdx
  815dd5:	48 89 d0             	mov    %rdx,%rax
  815dd8:	48 c1 e0 02          	shl    $0x2,%rax
  815ddc:	48 01 d0             	add    %rdx,%rax
  815ddf:	48 c1 e0 03          	shl    $0x3,%rax
  815de3:	48 01 c8             	add    %rcx,%rax
  815de6:	48 83 c0 10          	add    $0x10,%rax
  815dea:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815dee:	88 45 fb             	mov    %al,-0x5(%rbp)
  815df1:	e9 e4 00 00 00       	jmpq   815eda <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  815df6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815dfa:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e01:	00 00 00 
  815e04:	48 63 d0             	movslq %eax,%rdx
  815e07:	48 89 d0             	mov    %rdx,%rax
  815e0a:	48 c1 e0 02          	shl    $0x2,%rax
  815e0e:	48 01 d0             	add    %rdx,%rax
  815e11:	48 c1 e0 03          	shl    $0x3,%rax
  815e15:	48 01 c8             	add    %rcx,%rax
  815e18:	48 83 c0 10          	add    $0x10,%rax
  815e1c:	8b 40 04             	mov    0x4(%rax),%eax
  815e1f:	83 f8 02             	cmp    $0x2,%eax
  815e22:	0f 85 b2 00 00 00    	jne    815eda <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815e28:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e2d:	74 48                	je     815e77 <find_entry+0x30f>
  815e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815e33:	8b 08                	mov    (%rax),%ecx
  815e35:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e39:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815e40:	00 00 00 
  815e43:	48 63 d0             	movslq %eax,%rdx
  815e46:	48 89 d0             	mov    %rdx,%rax
  815e49:	48 c1 e0 02          	shl    $0x2,%rax
  815e4d:	48 01 d0             	add    %rdx,%rax
  815e50:	48 c1 e0 03          	shl    $0x3,%rax
  815e54:	48 01 f0             	add    %rsi,%rax
  815e57:	8b 40 08             	mov    0x8(%rax),%eax
  815e5a:	39 c1                	cmp    %eax,%ecx
  815e5c:	75 19                	jne    815e77 <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815e5e:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e65:	00 00 00 
  815e68:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815e6c:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815e6e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e72:	e9 83 02 00 00       	jmpq   8160fa <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815e77:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e7b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e82:	00 00 00 
  815e85:	48 63 d0             	movslq %eax,%rdx
  815e88:	48 89 d0             	mov    %rdx,%rax
  815e8b:	48 c1 e0 02          	shl    $0x2,%rax
  815e8f:	48 01 d0             	add    %rdx,%rax
  815e92:	48 c1 e0 03          	shl    $0x3,%rax
  815e96:	48 01 c8             	add    %rcx,%rax
  815e99:	48 83 c0 10          	add    $0x10,%rax
  815e9d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ea1:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815ea4:	72 34                	jb     815eda <find_entry+0x372>
        old_stable = i;
  815ea6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815eaa:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  815ead:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815eb1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815eb8:	00 00 00 
  815ebb:	48 63 d0             	movslq %eax,%rdx
  815ebe:	48 89 d0             	mov    %rdx,%rax
  815ec1:	48 c1 e0 02          	shl    $0x2,%rax
  815ec5:	48 01 d0             	add    %rdx,%rax
  815ec8:	48 c1 e0 03          	shl    $0x3,%rax
  815ecc:	48 01 c8             	add    %rcx,%rax
  815ecf:	48 83 c0 10          	add    $0x10,%rax
  815ed3:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ed7:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815eda:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  815ede:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815ee2:	0f 86 4c fd ff ff    	jbe    815c34 <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  815ee8:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815eec:	75 0b                	jne    815ef9 <find_entry+0x391>
  815eee:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815ef2:	83 e0 01             	and    $0x1,%eax
  815ef5:	85 c0                	test   %eax,%eax
  815ef7:	74 0b                	je     815f04 <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  815ef9:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815efd:	83 e0 02             	and    $0x2,%eax
  815f00:	85 c0                	test   %eax,%eax
  815f02:	74 0a                	je     815f0e <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  815f04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815f09:	e9 ec 01 00 00       	jmpq   8160fa <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  815f0e:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  815f12:	7f 0c                	jg     815f20 <find_entry+0x3b8>
    i = empty;
  815f14:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  815f18:	88 45 fc             	mov    %al,-0x4(%rbp)
  815f1b:	e9 ea 00 00 00       	jmpq   81600a <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  815f20:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  815f24:	7f 5f                	jg     815f85 <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  815f26:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  815f2a:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  815f2d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f31:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f38:	00 00 00 
  815f3b:	48 63 d0             	movslq %eax,%rdx
  815f3e:	48 89 d0             	mov    %rdx,%rax
  815f41:	48 c1 e0 02          	shl    $0x2,%rax
  815f45:	48 01 d0             	add    %rdx,%rax
  815f48:	48 c1 e0 03          	shl    $0x3,%rax
  815f4c:	48 01 c8             	add    %rcx,%rax
  815f4f:	48 8b 00             	mov    (%rax),%rax
  815f52:	48 85 c0             	test   %rax,%rax
  815f55:	0f 84 af 00 00 00    	je     81600a <find_entry+0x4a2>
  815f5b:	48 ba 90 29 82 00 00 	movabs $0x822990,%rdx
  815f62:	00 00 00 
  815f65:	be 75 01 00 00       	mov    $0x175,%esi
  815f6a:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  815f71:	00 00 00 
  815f74:	b8 00 00 00 00       	mov    $0x0,%eax
  815f79:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  815f80:	00 00 00 
  815f83:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  815f85:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815f89:	7f 09                	jg     815f94 <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  815f8b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f8f:	88 45 fc             	mov    %al,-0x4(%rbp)
  815f92:	eb 76                	jmp    81600a <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  815f94:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  815f98:	7f 66                	jg     816000 <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  815f9a:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  815f9e:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  815fa1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fa5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fac:	00 00 00 
  815faf:	48 63 d0             	movslq %eax,%rdx
  815fb2:	48 89 d0             	mov    %rdx,%rax
  815fb5:	48 c1 e0 02          	shl    $0x2,%rax
  815fb9:	48 01 d0             	add    %rdx,%rax
  815fbc:	48 c1 e0 03          	shl    $0x3,%rax
  815fc0:	48 01 c8             	add    %rcx,%rax
  815fc3:	48 8b 00             	mov    (%rax),%rax
  815fc6:	48 89 c7             	mov    %rax,%rdi
  815fc9:	48 b8 74 58 81 00 00 	movabs $0x815874,%rax
  815fd0:	00 00 00 
  815fd3:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  815fd5:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fd9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fe0:	00 00 00 
  815fe3:	48 63 d0             	movslq %eax,%rdx
  815fe6:	48 89 d0             	mov    %rdx,%rax
  815fe9:	48 c1 e0 02          	shl    $0x2,%rax
  815fed:	48 01 d0             	add    %rdx,%rax
  815ff0:	48 c1 e0 03          	shl    $0x3,%rax
  815ff4:	48 01 c8             	add    %rcx,%rax
  815ff7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  815ffe:	eb 0a                	jmp    81600a <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  816000:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816005:	e9 f0 00 00 00       	jmpq   8160fa <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  81600a:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  81600e:	76 2a                	jbe    81603a <find_entry+0x4d2>
  816010:	48 ba a7 29 82 00 00 	movabs $0x8229a7,%rdx
  816017:	00 00 00 
  81601a:	be 8b 01 00 00       	mov    $0x18b,%esi
  81601f:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816026:	00 00 00 
  816029:	b8 00 00 00 00       	mov    $0x0,%eax
  81602e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816035:	00 00 00 
  816038:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  81603a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81603e:	48 63 d0             	movslq %eax,%rdx
  816041:	48 89 d0             	mov    %rdx,%rax
  816044:	48 c1 e0 02          	shl    $0x2,%rax
  816048:	48 01 d0             	add    %rdx,%rax
  81604b:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  81604f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816053:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81605a:	00 00 00 
  81605d:	48 63 d0             	movslq %eax,%rdx
  816060:	48 89 d0             	mov    %rdx,%rax
  816063:	48 c1 e0 02          	shl    $0x2,%rax
  816067:	48 01 d0             	add    %rdx,%rax
  81606a:	48 c1 e0 03          	shl    $0x3,%rax
  81606e:	48 01 c8             	add    %rcx,%rax
  816071:	48 83 c0 10          	add    $0x10,%rax
  816075:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  81607c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816081:	74 39                	je     8160bc <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  816083:	0f b6 4d fc          	movzbl -0x4(%rbp),%ecx
  816087:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81608c:	74 08                	je     816096 <find_entry+0x52e>
  81608e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816092:	8b 10                	mov    (%rax),%edx
  816094:	eb 05                	jmp    81609b <find_entry+0x533>
  816096:	ba 00 00 00 00       	mov    $0x0,%edx
  81609b:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8160a2:	00 00 00 
  8160a5:	48 63 c9             	movslq %ecx,%rcx
  8160a8:	48 89 c8             	mov    %rcx,%rax
  8160ab:	48 c1 e0 02          	shl    $0x2,%rax
  8160af:	48 01 c8             	add    %rcx,%rax
  8160b2:	48 c1 e0 03          	shl    $0x3,%rax
  8160b6:	48 01 f0             	add    %rsi,%rax
  8160b9:	89 50 08             	mov    %edx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  8160bc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160c0:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160c7:	00 00 00 
  8160ca:	48 63 d0             	movslq %eax,%rdx
  8160cd:	48 89 d0             	mov    %rdx,%rax
  8160d0:	48 c1 e0 02          	shl    $0x2,%rax
  8160d4:	48 01 d0             	add    %rdx,%rax
  8160d7:	48 c1 e0 03          	shl    $0x3,%rax
  8160db:	48 01 c8             	add    %rcx,%rax
  8160de:	48 83 c0 10          	add    $0x10,%rax
  8160e2:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  8160e6:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  8160ed:	00 00 00 
  8160f0:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  8160f4:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  8160f6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  8160fa:	c9                   	leaveq 
  8160fb:	c3                   	retq   

00000000008160fc <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8160fc:	55                   	push   %rbp
  8160fd:	48 89 e5             	mov    %rsp,%rbp
  816100:	48 83 ec 30          	sub    $0x30,%rsp
  816104:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816108:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81610c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  816110:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  816114:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816118:	48 8b 40 08          	mov    0x8(%rax),%rax
  81611c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816120:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816124:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816128:	3c 06                	cmp    $0x6,%al
  81612a:	74 2a                	je     816156 <etharp_send_ip+0x5a>
  81612c:	48 ba c0 29 82 00 00 	movabs $0x8229c0,%rdx
  816133:	00 00 00 
  816136:	be b3 01 00 00       	mov    $0x1b3,%esi
  81613b:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816142:	00 00 00 
  816145:	b8 00 00 00 00       	mov    $0x0,%eax
  81614a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816151:	00 00 00 
  816154:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816156:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  81615a:	eb 43                	jmp    81619f <etharp_send_ip+0xa3>
    k--;
  81615c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816160:	83 e8 01             	sub    $0x1,%eax
  816163:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  816166:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81616a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81616e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816172:	48 98                	cltq   
  816174:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816178:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81617c:	48 63 c6             	movslq %esi,%rax
  81617f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  816182:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816186:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81618a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81618e:	48 98                	cltq   
  816190:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816194:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816198:	48 63 c6             	movslq %esi,%rax
  81619b:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  81619f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8161a3:	75 b7                	jne    81615c <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8161a5:	bf 00 08 00 00       	mov    $0x800,%edi
  8161aa:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8161b1:	00 00 00 
  8161b4:	ff d0                	callq  *%rax
  8161b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8161ba:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8161be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8161c2:	48 8b 40 28          	mov    0x28(%rax),%rax
  8161c6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8161ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8161ce:	48 89 ce             	mov    %rcx,%rsi
  8161d1:	48 89 d7             	mov    %rdx,%rdi
  8161d4:	ff d0                	callq  *%rax
}
  8161d6:	c9                   	leaveq 
  8161d7:	c3                   	retq   

00000000008161d8 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  8161d8:	55                   	push   %rbp
  8161d9:	48 89 e5             	mov    %rsp,%rbp
  8161dc:	53                   	push   %rbx
  8161dd:	48 83 ec 48          	sub    $0x48,%rsp
  8161e1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8161e5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8161e9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8161ed:	89 c8                	mov    %ecx,%eax
  8161ef:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8161f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8161f6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8161fa:	3c 06                	cmp    $0x6,%al
  8161fc:	74 2a                	je     816228 <update_arp_entry+0x50>
  8161fe:	48 ba 08 2a 82 00 00 	movabs $0x822a08,%rdx
  816205:	00 00 00 
  816208:	be d9 01 00 00       	mov    $0x1d9,%esi
  81620d:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816214:	00 00 00 
  816217:	b8 00 00 00 00       	mov    $0x0,%eax
  81621c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816223:	00 00 00 
  816226:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816228:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  81622d:	74 56                	je     816285 <update_arp_entry+0xad>
  81622f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816233:	8b 00                	mov    (%rax),%eax
  816235:	85 c0                	test   %eax,%eax
  816237:	74 4c                	je     816285 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  816239:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81623d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816241:	48 89 d6             	mov    %rdx,%rsi
  816244:	48 89 c7             	mov    %rax,%rdi
  816247:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  81624e:	00 00 00 
  816251:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816253:	84 c0                	test   %al,%al
  816255:	75 2e                	jne    816285 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816257:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81625b:	8b 18                	mov    (%rax),%ebx
  81625d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816262:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  816269:	00 00 00 
  81626c:	ff d0                	callq  *%rax
  81626e:	21 c3                	and    %eax,%ebx
  816270:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816275:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81627c:	00 00 00 
  81627f:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  816281:	39 c3                	cmp    %eax,%ebx
  816283:	75 0a                	jne    81628f <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816285:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81628a:	e9 f0 01 00 00       	jmpq   81647f <update_arp_entry+0x2a7>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  81628f:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  816293:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816297:	89 d6                	mov    %edx,%esi
  816299:	48 89 c7             	mov    %rax,%rdi
  81629c:	48 b8 68 5b 81 00 00 	movabs $0x815b68,%rax
  8162a3:	00 00 00 
  8162a6:	ff d0                	callq  *%rax
  8162a8:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8162ab:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8162af:	79 09                	jns    8162ba <update_arp_entry+0xe2>
    return (err_t)i;
  8162b1:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8162b5:	e9 c5 01 00 00       	jmpq   81647f <update_arp_entry+0x2a7>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8162ba:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8162be:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8162c5:	00 00 00 
  8162c8:	48 63 d0             	movslq %eax,%rdx
  8162cb:	48 89 d0             	mov    %rdx,%rax
  8162ce:	48 c1 e0 02          	shl    $0x2,%rax
  8162d2:	48 01 d0             	add    %rdx,%rax
  8162d5:	48 c1 e0 03          	shl    $0x3,%rax
  8162d9:	48 01 c8             	add    %rcx,%rax
  8162dc:	48 83 c0 10          	add    $0x10,%rax
  8162e0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  8162e7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8162eb:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8162f2:	00 00 00 
  8162f5:	48 63 d0             	movslq %eax,%rdx
  8162f8:	48 89 d0             	mov    %rdx,%rax
  8162fb:	48 c1 e0 02          	shl    $0x2,%rax
  8162ff:	48 01 d0             	add    %rdx,%rax
  816302:	48 c1 e0 03          	shl    $0x3,%rax
  816306:	48 01 c8             	add    %rcx,%rax
  816309:	48 8d 50 20          	lea    0x20(%rax),%rdx
  81630d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816311:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  816314:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  816318:	eb 48                	jmp    816362 <update_arp_entry+0x18a>
    k--;
  81631a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81631e:	83 e8 01             	sub    $0x1,%eax
  816321:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  816324:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  816329:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  81632d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816331:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816335:	48 98                	cltq   
  816337:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81633b:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  816342:	00 00 00 
  816345:	48 63 ff             	movslq %edi,%rdi
  816348:	49 63 d0             	movslq %r8d,%rdx
  81634b:	48 89 d0             	mov    %rdx,%rax
  81634e:	48 c1 e0 02          	shl    $0x2,%rax
  816352:	48 01 d0             	add    %rdx,%rax
  816355:	48 c1 e0 03          	shl    $0x3,%rax
  816359:	48 01 f8             	add    %rdi,%rax
  81635c:	48 01 f0             	add    %rsi,%rax
  81635f:	88 48 0c             	mov    %cl,0xc(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  816362:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816366:	75 b2                	jne    81631a <update_arp_entry+0x142>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816368:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81636c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816373:	00 00 00 
  816376:	48 63 d0             	movslq %eax,%rdx
  816379:	48 89 d0             	mov    %rdx,%rax
  81637c:	48 c1 e0 02          	shl    $0x2,%rax
  816380:	48 01 d0             	add    %rdx,%rax
  816383:	48 c1 e0 03          	shl    $0x3,%rax
  816387:	48 01 c8             	add    %rcx,%rax
  81638a:	48 83 c0 10          	add    $0x10,%rax
  81638e:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  816392:	e9 b5 00 00 00       	jmpq   81644c <update_arp_entry+0x274>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  816397:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81639b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8163a2:	00 00 00 
  8163a5:	48 63 d0             	movslq %eax,%rdx
  8163a8:	48 89 d0             	mov    %rdx,%rax
  8163ab:	48 c1 e0 02          	shl    $0x2,%rax
  8163af:	48 01 d0             	add    %rdx,%rax
  8163b2:	48 c1 e0 03          	shl    $0x3,%rax
  8163b6:	48 01 c8             	add    %rcx,%rax
  8163b9:	48 8b 00             	mov    (%rax),%rax
  8163bc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8163c0:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  8163c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163c8:	48 8b 08             	mov    (%rax),%rcx
  8163cb:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8163d2:	00 00 00 
  8163d5:	48 63 d2             	movslq %edx,%rdx
  8163d8:	48 89 d0             	mov    %rdx,%rax
  8163db:	48 c1 e0 02          	shl    $0x2,%rax
  8163df:	48 01 d0             	add    %rdx,%rax
  8163e2:	48 c1 e0 03          	shl    $0x3,%rax
  8163e6:	48 01 f0             	add    %rsi,%rax
  8163e9:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  8163ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8163f4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8163f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163fc:	48 89 c6             	mov    %rax,%rsi
  8163ff:	bf 0a 00 00 00       	mov    $0xa,%edi
  816404:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81640b:	00 00 00 
  81640e:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  816410:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816414:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816418:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81641c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  816420:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816424:	48 89 d1             	mov    %rdx,%rcx
  816427:	48 89 fa             	mov    %rdi,%rdx
  81642a:	48 89 c7             	mov    %rax,%rdi
  81642d:	48 b8 fc 60 81 00 00 	movabs $0x8160fc,%rax
  816434:	00 00 00 
  816437:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  816439:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81643d:	48 89 c7             	mov    %rax,%rdi
  816440:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  816447:	00 00 00 
  81644a:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81644c:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816450:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816457:	00 00 00 
  81645a:	48 63 d0             	movslq %eax,%rdx
  81645d:	48 89 d0             	mov    %rdx,%rax
  816460:	48 c1 e0 02          	shl    $0x2,%rax
  816464:	48 01 d0             	add    %rdx,%rax
  816467:	48 c1 e0 03          	shl    $0x3,%rax
  81646b:	48 01 c8             	add    %rcx,%rax
  81646e:	48 8b 00             	mov    (%rax),%rax
  816471:	48 85 c0             	test   %rax,%rax
  816474:	0f 85 1d ff ff ff    	jne    816397 <update_arp_entry+0x1bf>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  81647a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81647f:	48 83 c4 48          	add    $0x48,%rsp
  816483:	5b                   	pop    %rbx
  816484:	5d                   	pop    %rbp
  816485:	c3                   	retq   

0000000000816486 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  816486:	55                   	push   %rbp
  816487:	48 89 e5             	mov    %rsp,%rbp
  81648a:	48 83 ec 30          	sub    $0x30,%rsp
  81648e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816492:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816496:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81649a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  81649e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164a2:	be 02 00 00 00       	mov    $0x2,%esi
  8164a7:	48 89 c7             	mov    %rax,%rdi
  8164aa:	48 b8 68 5b 81 00 00 	movabs $0x815b68,%rax
  8164b1:	00 00 00 
  8164b4:	ff d0                	callq  *%rax
  8164b6:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8164b9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8164bd:	0f 88 8e 00 00 00    	js     816551 <etharp_find_addr+0xcb>
  8164c3:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8164c7:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8164ce:	00 00 00 
  8164d1:	48 63 d0             	movslq %eax,%rdx
  8164d4:	48 89 d0             	mov    %rdx,%rax
  8164d7:	48 c1 e0 02          	shl    $0x2,%rax
  8164db:	48 01 d0             	add    %rdx,%rax
  8164de:	48 c1 e0 03          	shl    $0x3,%rax
  8164e2:	48 01 c8             	add    %rcx,%rax
  8164e5:	48 83 c0 10          	add    $0x10,%rax
  8164e9:	8b 40 04             	mov    0x4(%rax),%eax
  8164ec:	83 f8 02             	cmp    $0x2,%eax
  8164ef:	75 60                	jne    816551 <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  8164f1:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8164f5:	48 63 d0             	movslq %eax,%rdx
  8164f8:	48 89 d0             	mov    %rdx,%rax
  8164fb:	48 c1 e0 02          	shl    $0x2,%rax
  8164ff:	48 01 d0             	add    %rdx,%rax
  816502:	48 c1 e0 03          	shl    $0x3,%rax
  816506:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81650d:	00 00 00 
  816510:	48 01 d0             	add    %rdx,%rax
  816513:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  816517:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81651b:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  81651e:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816522:	48 63 d0             	movslq %eax,%rdx
  816525:	48 89 d0             	mov    %rdx,%rax
  816528:	48 c1 e0 02          	shl    $0x2,%rax
  81652c:	48 01 d0             	add    %rdx,%rax
  81652f:	48 c1 e0 03          	shl    $0x3,%rax
  816533:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81653a:	00 00 00 
  81653d:	48 01 d0             	add    %rdx,%rax
  816540:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816544:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816548:	48 89 10             	mov    %rdx,(%rax)
      return i;
  81654b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81654f:	eb 05                	jmp    816556 <etharp_find_addr+0xd0>
  }
  return -1;
  816551:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816556:	c9                   	leaveq 
  816557:	c3                   	retq   

0000000000816558 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816558:	55                   	push   %rbp
  816559:	48 89 e5             	mov    %rsp,%rbp
  81655c:	48 83 ec 20          	sub    $0x20,%rsp
  816560:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816564:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816568:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81656d:	75 2a                	jne    816599 <etharp_ip_input+0x41>
  81656f:	48 ba 2f 2a 82 00 00 	movabs $0x822a2f,%rdx
  816576:	00 00 00 
  816579:	be 48 02 00 00       	mov    $0x248,%esi
  81657e:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816585:	00 00 00 
  816588:	b8 00 00 00 00       	mov    $0x0,%eax
  81658d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816594:	00 00 00 
  816597:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  816599:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81659d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8165a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  8165a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8165a9:	8b 50 1c             	mov    0x1c(%rax),%edx
  8165ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8165b0:	8b 40 08             	mov    0x8(%rax),%eax
  8165b3:	31 c2                	xor    %eax,%edx
  8165b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8165b9:	8b 40 0c             	mov    0xc(%rax),%eax
  8165bc:	21 d0                	and    %edx,%eax
  8165be:	85 c0                	test   %eax,%eax
  8165c0:	74 02                	je     8165c4 <etharp_ip_input+0x6c>
    /* do nothing */
    return;
  8165c2:	eb 28                	jmp    8165ec <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8165c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8165c8:	48 8d 50 06          	lea    0x6(%rax),%rdx
  8165cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8165d0:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  8165d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8165d8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8165dd:	48 89 c7             	mov    %rax,%rdi
  8165e0:	48 b8 d8 61 81 00 00 	movabs $0x8161d8,%rax
  8165e7:	00 00 00 
  8165ea:	ff d0                	callq  *%rax
}
  8165ec:	c9                   	leaveq 
  8165ed:	c3                   	retq   

00000000008165ee <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8165ee:	55                   	push   %rbp
  8165ef:	48 89 e5             	mov    %rsp,%rbp
  8165f2:	53                   	push   %rbx
  8165f3:	48 83 ec 58          	sub    $0x58,%rsp
  8165f7:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8165fb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8165ff:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816603:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816608:	75 2a                	jne    816634 <etharp_arp_input+0x46>
  81660a:	48 ba 2f 2a 82 00 00 	movabs $0x822a2f,%rdx
  816611:	00 00 00 
  816614:	be 75 02 00 00       	mov    $0x275,%esi
  816619:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816620:	00 00 00 
  816623:	b8 00 00 00 00       	mov    $0x0,%eax
  816628:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81662f:	00 00 00 
  816632:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  816634:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816638:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81663c:	66 83 f8 29          	cmp    $0x29,%ax
  816640:	77 18                	ja     81665a <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816642:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816646:	48 89 c7             	mov    %rax,%rdi
  816649:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  816650:	00 00 00 
  816653:	ff d0                	callq  *%rax
    return;
  816655:	e9 d3 02 00 00       	jmpq   81692d <etharp_arp_input+0x33f>
  }

  hdr = p->payload;
  81665a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81665e:	48 8b 40 08          	mov    0x8(%rax),%rax
  816662:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816666:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81666a:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  81666e:	bf 01 00 00 00       	mov    $0x1,%edi
  816673:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81667a:	00 00 00 
  81667d:	ff d0                	callq  *%rax
  81667f:	66 39 c3             	cmp    %ax,%bx
  816682:	75 5a                	jne    8166de <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  816684:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816688:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  81668c:	bf 04 06 00 00       	mov    $0x604,%edi
  816691:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  816698:	00 00 00 
  81669b:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  81669d:	66 39 c3             	cmp    %ax,%bx
  8166a0:	75 3c                	jne    8166de <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8166a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166a6:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  8166aa:	bf 00 08 00 00       	mov    $0x800,%edi
  8166af:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8166b6:	00 00 00 
  8166b9:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8166bb:	66 39 c3             	cmp    %ax,%bx
  8166be:	75 1e                	jne    8166de <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8166c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166c4:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  8166c8:	bf 06 08 00 00       	mov    $0x806,%edi
  8166cd:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8166d4:	00 00 00 
  8166d7:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8166d9:	66 39 c3             	cmp    %ax,%bx
  8166dc:	74 18                	je     8166f6 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8166de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8166e2:	48 89 c7             	mov    %rax,%rdi
  8166e5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8166ec:	00 00 00 
  8166ef:	ff d0                	callq  *%rax
    return;
  8166f1:	e9 37 02 00 00       	jmpq   81692d <etharp_arp_input+0x33f>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8166f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166fa:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  8166fe:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  816702:	ba 04 00 00 00       	mov    $0x4,%edx
  816707:	48 89 ce             	mov    %rcx,%rsi
  81670a:	48 89 c7             	mov    %rax,%rdi
  81670d:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  816714:	00 00 00 
  816717:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  816719:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81671d:	48 8d 48 26          	lea    0x26(%rax),%rcx
  816721:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  816725:	ba 04 00 00 00       	mov    $0x4,%edx
  81672a:	48 89 ce             	mov    %rcx,%rsi
  81672d:	48 89 c7             	mov    %rax,%rdi
  816730:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  816737:	00 00 00 
  81673a:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  81673c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816740:	8b 40 08             	mov    0x8(%rax),%eax
  816743:	85 c0                	test   %eax,%eax
  816745:	75 06                	jne    81674d <etharp_arp_input+0x15f>
    for_us = 0;
  816747:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  81674b:	eb 12                	jmp    81675f <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  81674d:	8b 55 c0             	mov    -0x40(%rbp),%edx
  816750:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816754:	8b 40 08             	mov    0x8(%rax),%eax
  816757:	39 c2                	cmp    %eax,%edx
  816759:	0f 94 c0             	sete   %al
  81675c:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  81675f:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816763:	74 26                	je     81678b <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816769:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81676d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816771:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816775:	b9 01 00 00 00       	mov    $0x1,%ecx
  81677a:	48 89 c7             	mov    %rax,%rdi
  81677d:	48 b8 d8 61 81 00 00 	movabs $0x8161d8,%rax
  816784:	00 00 00 
  816787:	ff d0                	callq  *%rax
  816789:	eb 24                	jmp    8167af <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  81678b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81678f:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816793:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816797:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81679b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8167a0:	48 89 c7             	mov    %rax,%rdi
  8167a3:	48 b8 d8 61 81 00 00 	movabs $0x8161d8,%rax
  8167aa:	00 00 00 
  8167ad:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  8167af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8167b3:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  8167b7:	0f b7 c0             	movzwl %ax,%eax
  8167ba:	89 c7                	mov    %eax,%edi
  8167bc:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8167c3:	00 00 00 
  8167c6:	ff d0                	callq  *%rax
  8167c8:	0f b7 c0             	movzwl %ax,%eax
  8167cb:	83 f8 01             	cmp    $0x1,%eax
  8167ce:	74 0e                	je     8167de <etharp_arp_input+0x1f0>
  8167d0:	83 f8 02             	cmp    $0x2,%eax
  8167d3:	0f 84 26 01 00 00    	je     8168ff <etharp_arp_input+0x311>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  8167d9:	e9 3c 01 00 00       	jmpq   81691a <etharp_arp_input+0x32c>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  8167de:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8167e2:	0f 84 15 01 00 00    	je     8168fd <etharp_arp_input+0x30f>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  8167e8:	bf 02 00 00 00       	mov    $0x2,%edi
  8167ed:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8167f4:	00 00 00 
  8167f7:	ff d0                	callq  *%rax
  8167f9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8167fd:	66 89 42 14          	mov    %ax,0x14(%rdx)

      hdr->dipaddr = hdr->sipaddr;
  816801:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816805:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816809:	8b 52 1c             	mov    0x1c(%rdx),%edx
  81680c:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  81680f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816813:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81681b:	8b 12                	mov    (%rdx),%edx
  81681d:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816820:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816824:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816828:	3c 06                	cmp    $0x6,%al
  81682a:	74 2a                	je     816856 <etharp_arp_input+0x268>
  81682c:	48 ba c0 29 82 00 00 	movabs $0x8229c0,%rdx
  816833:	00 00 00 
  816836:	be c7 02 00 00       	mov    $0x2c7,%esi
  81683b:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816842:	00 00 00 
  816845:	b8 00 00 00 00       	mov    $0x0,%eax
  81684a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816851:	00 00 00 
  816854:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816856:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  81685a:	eb 7f                	jmp    8168db <etharp_arp_input+0x2ed>
        i--;
  81685c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816860:	83 e8 01             	sub    $0x1,%eax
  816863:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  816866:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81686a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81686e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816872:	48 98                	cltq   
  816874:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816879:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81687d:	48 63 c6             	movslq %esi,%rax
  816880:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816884:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816888:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81688c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816890:	48 98                	cltq   
  816892:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816897:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81689b:	48 63 c6             	movslq %esi,%rax
  81689e:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8168a1:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8168a5:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8168a9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8168ad:	48 98                	cltq   
  8168af:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8168b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8168b7:	48 63 c6             	movslq %esi,%rax
  8168ba:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8168be:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8168c2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8168c6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8168ca:	48 98                	cltq   
  8168cc:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8168d0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8168d4:	48 63 c6             	movslq %esi,%rax
  8168d7:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8168db:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8168df:	0f 85 77 ff ff ff    	jne    81685c <etharp_arp_input+0x26e>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  8168e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8168e9:	48 8b 40 28          	mov    0x28(%rax),%rax
  8168ed:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8168f1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8168f5:	48 89 ce             	mov    %rcx,%rsi
  8168f8:	48 89 d7             	mov    %rdx,%rdi
  8168fb:	ff d0                	callq  *%rax
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8168fd:	eb 1b                	jmp    81691a <etharp_arp_input+0x32c>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  8168ff:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  816903:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816907:	48 89 d6             	mov    %rdx,%rsi
  81690a:	48 89 c7             	mov    %rax,%rdi
  81690d:	48 b8 47 a2 80 00 00 	movabs $0x80a247,%rax
  816914:	00 00 00 
  816917:	ff d0                	callq  *%rax
#endif
    break;
  816919:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  81691a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81691e:	48 89 c7             	mov    %rax,%rdi
  816921:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  816928:	00 00 00 
  81692b:	ff d0                	callq  *%rax
}
  81692d:	48 83 c4 58          	add    $0x58,%rsp
  816931:	5b                   	pop    %rbx
  816932:	5d                   	pop    %rbp
  816933:	c3                   	retq   

0000000000816934 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816934:	55                   	push   %rbp
  816935:	48 89 e5             	mov    %rsp,%rbp
  816938:	53                   	push   %rbx
  816939:	48 83 ec 38          	sub    $0x38,%rsp
  81693d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816941:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816945:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  816949:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81694d:	be 0e 00 00 00       	mov    $0xe,%esi
  816952:	48 89 c7             	mov    %rax,%rdi
  816955:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81695c:	00 00 00 
  81695f:	ff d0                	callq  *%rax
  816961:	84 c0                	test   %al,%al
  816963:	74 0a                	je     81696f <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  816965:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  81696a:	e9 50 01 00 00       	jmpq   816abf <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  81696f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816976:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  816977:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81697b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81697f:	48 89 d6             	mov    %rdx,%rsi
  816982:	48 89 c7             	mov    %rax,%rdi
  816985:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  81698c:	00 00 00 
  81698f:	ff d0                	callq  *%rax
  816991:	84 c0                	test   %al,%al
  816993:	74 13                	je     8169a8 <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  816995:	48 b8 48 29 82 00 00 	movabs $0x822948,%rax
  81699c:	00 00 00 
  81699f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8169a3:	e9 ee 00 00 00       	jmpq   816a96 <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  8169a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8169ac:	8b 18                	mov    (%rax),%ebx
  8169ae:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8169b3:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8169ba:	00 00 00 
  8169bd:	ff d0                	callq  *%rax
  8169bf:	21 c3                	and    %eax,%ebx
  8169c1:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8169c6:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8169cd:	00 00 00 
  8169d0:	ff d0                	callq  *%rax
  8169d2:	39 c3                	cmp    %eax,%ebx
  8169d4:	75 64                	jne    816a3a <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  8169d6:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  8169da:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  8169de:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  8169e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8169e6:	8b 00                	mov    (%rax),%eax
  8169e8:	89 c7                	mov    %eax,%edi
  8169ea:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8169f1:	00 00 00 
  8169f4:	ff d0                	callq  *%rax
  8169f6:	c1 e8 10             	shr    $0x10,%eax
  8169f9:	83 e0 7f             	and    $0x7f,%eax
  8169fc:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  8169ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816a03:	8b 00                	mov    (%rax),%eax
  816a05:	89 c7                	mov    %eax,%edi
  816a07:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  816a0e:	00 00 00 
  816a11:	ff d0                	callq  *%rax
  816a13:	c1 e8 08             	shr    $0x8,%eax
  816a16:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  816a19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816a1d:	8b 00                	mov    (%rax),%eax
  816a1f:	89 c7                	mov    %eax,%edi
  816a21:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  816a28:	00 00 00 
  816a2b:	ff d0                	callq  *%rax
  816a2d:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816a30:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816a34:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816a38:	eb 5c                	jmp    816a96 <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  816a3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816a3e:	8b 10                	mov    (%rax),%edx
  816a40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a44:	8b 40 08             	mov    0x8(%rax),%eax
  816a47:	31 c2                	xor    %eax,%edx
  816a49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a4d:	8b 40 0c             	mov    0xc(%rax),%eax
  816a50:	21 d0                	and    %edx,%eax
  816a52:	85 c0                	test   %eax,%eax
  816a54:	74 20                	je     816a76 <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816a56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a5a:	8b 40 10             	mov    0x10(%rax),%eax
  816a5d:	85 c0                	test   %eax,%eax
  816a5f:	74 0e                	je     816a6f <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816a61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a65:	48 83 c0 10          	add    $0x10,%rax
  816a69:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816a6d:	eb 07                	jmp    816a76 <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816a6f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816a74:	eb 49                	jmp    816abf <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816a76:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816a7a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816a7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a82:	48 89 ce             	mov    %rcx,%rsi
  816a85:	48 89 c7             	mov    %rax,%rdi
  816a88:	48 b8 c6 6a 81 00 00 	movabs $0x816ac6,%rax
  816a8f:	00 00 00 
  816a92:	ff d0                	callq  *%rax
  816a94:	eb 29                	jmp    816abf <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816a96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816a9a:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816a9e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816aa2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816aa6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816aaa:	48 89 d1             	mov    %rdx,%rcx
  816aad:	48 89 fa             	mov    %rdi,%rdx
  816ab0:	48 89 c7             	mov    %rax,%rdi
  816ab3:	48 b8 fc 60 81 00 00 	movabs $0x8160fc,%rax
  816aba:	00 00 00 
  816abd:	ff d0                	callq  *%rax
}
  816abf:	48 83 c4 38          	add    $0x38,%rsp
  816ac3:	5b                   	pop    %rbx
  816ac4:	5d                   	pop    %rbp
  816ac5:	c3                   	retq   

0000000000816ac6 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  816ac6:	55                   	push   %rbp
  816ac7:	48 89 e5             	mov    %rsp,%rbp
  816aca:	53                   	push   %rbx
  816acb:	48 83 ec 68          	sub    $0x68,%rsp
  816acf:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816ad3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  816ad7:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  816adb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816adf:	48 83 c0 41          	add    $0x41,%rax
  816ae3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  816ae7:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816aeb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  816aef:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816af3:	48 89 d6             	mov    %rdx,%rsi
  816af6:	48 89 c7             	mov    %rax,%rdi
  816af9:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  816b00:	00 00 00 
  816b03:	ff d0                	callq  *%rax
  816b05:	84 c0                	test   %al,%al
  816b07:	75 3f                	jne    816b48 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816b09:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816b0d:	8b 18                	mov    (%rax),%ebx
  816b0f:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816b14:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  816b1b:	00 00 00 
  816b1e:	ff d0                	callq  *%rax
  816b20:	21 c3                	and    %eax,%ebx
  816b22:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816b27:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  816b2e:	00 00 00 
  816b31:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816b33:	39 c3                	cmp    %eax,%ebx
  816b35:	74 11                	je     816b48 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816b37:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  816b3c:	74 0a                	je     816b48 <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816b3e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816b42:	8b 00                	mov    (%rax),%eax
  816b44:	85 c0                	test   %eax,%eax
  816b46:	75 0a                	jne    816b52 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816b48:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816b4d:	e9 1f 04 00 00       	jmpq   816f71 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816b52:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816b56:	be 01 00 00 00       	mov    $0x1,%esi
  816b5b:	48 89 c7             	mov    %rax,%rdi
  816b5e:	48 b8 68 5b 81 00 00 	movabs $0x815b68,%rax
  816b65:	00 00 00 
  816b68:	ff d0                	callq  *%rax
  816b6a:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816b6d:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816b71:	79 09                	jns    816b7c <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816b73:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816b77:	e9 f5 03 00 00       	jmpq   816f71 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816b7c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816b80:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816b87:	00 00 00 
  816b8a:	48 63 d0             	movslq %eax,%rdx
  816b8d:	48 89 d0             	mov    %rdx,%rax
  816b90:	48 c1 e0 02          	shl    $0x2,%rax
  816b94:	48 01 d0             	add    %rdx,%rax
  816b97:	48 c1 e0 03          	shl    $0x3,%rax
  816b9b:	48 01 c8             	add    %rcx,%rax
  816b9e:	48 83 c0 10          	add    $0x10,%rax
  816ba2:	8b 40 04             	mov    0x4(%rax),%eax
  816ba5:	85 c0                	test   %eax,%eax
  816ba7:	75 2d                	jne    816bd6 <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  816ba9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816bad:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816bb4:	00 00 00 
  816bb7:	48 63 d0             	movslq %eax,%rdx
  816bba:	48 89 d0             	mov    %rdx,%rax
  816bbd:	48 c1 e0 02          	shl    $0x2,%rax
  816bc1:	48 01 d0             	add    %rdx,%rax
  816bc4:	48 c1 e0 03          	shl    $0x3,%rax
  816bc8:	48 01 c8             	add    %rcx,%rax
  816bcb:	48 83 c0 10          	add    $0x10,%rax
  816bcf:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  816bd6:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816bda:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816be1:	00 00 00 
  816be4:	48 63 d0             	movslq %eax,%rdx
  816be7:	48 89 d0             	mov    %rdx,%rax
  816bea:	48 c1 e0 02          	shl    $0x2,%rax
  816bee:	48 01 d0             	add    %rdx,%rax
  816bf1:	48 c1 e0 03          	shl    $0x3,%rax
  816bf5:	48 01 c8             	add    %rcx,%rax
  816bf8:	48 83 c0 10          	add    $0x10,%rax
  816bfc:	8b 40 04             	mov    0x4(%rax),%eax
  816bff:	83 f8 01             	cmp    $0x1,%eax
  816c02:	74 58                	je     816c5c <etharp_query+0x196>
  816c04:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816c08:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816c0f:	00 00 00 
  816c12:	48 63 d0             	movslq %eax,%rdx
  816c15:	48 89 d0             	mov    %rdx,%rax
  816c18:	48 c1 e0 02          	shl    $0x2,%rax
  816c1c:	48 01 d0             	add    %rdx,%rax
  816c1f:	48 c1 e0 03          	shl    $0x3,%rax
  816c23:	48 01 c8             	add    %rcx,%rax
  816c26:	48 83 c0 10          	add    $0x10,%rax
  816c2a:	8b 40 04             	mov    0x4(%rax),%eax
  816c2d:	83 f8 02             	cmp    $0x2,%eax
  816c30:	74 2a                	je     816c5c <etharp_query+0x196>
  816c32:	48 ba 40 2a 82 00 00 	movabs $0x822a40,%rdx
  816c39:	00 00 00 
  816c3c:	be 92 03 00 00       	mov    $0x392,%esi
  816c41:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816c48:	00 00 00 
  816c4b:	b8 00 00 00 00       	mov    $0x0,%eax
  816c50:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816c57:	00 00 00 
  816c5a:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816c5c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816c60:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816c67:	00 00 00 
  816c6a:	48 63 d0             	movslq %eax,%rdx
  816c6d:	48 89 d0             	mov    %rdx,%rax
  816c70:	48 c1 e0 02          	shl    $0x2,%rax
  816c74:	48 01 d0             	add    %rdx,%rax
  816c77:	48 c1 e0 03          	shl    $0x3,%rax
  816c7b:	48 01 c8             	add    %rcx,%rax
  816c7e:	48 83 c0 10          	add    $0x10,%rax
  816c82:	8b 40 04             	mov    0x4(%rax),%eax
  816c85:	83 f8 01             	cmp    $0x1,%eax
  816c88:	74 07                	je     816c91 <etharp_query+0x1cb>
  816c8a:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816c8f:	75 1d                	jne    816cae <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816c91:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816c95:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816c99:	48 89 d6             	mov    %rdx,%rsi
  816c9c:	48 89 c7             	mov    %rax,%rdi
  816c9f:	48 b8 ae 71 81 00 00 	movabs $0x8171ae,%rax
  816ca6:	00 00 00 
  816ca9:	ff d0                	callq  *%rax
  816cab:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816cae:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816cb3:	0f 84 b4 02 00 00    	je     816f6d <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816cb9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816cbd:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816cc4:	00 00 00 
  816cc7:	48 63 d0             	movslq %eax,%rdx
  816cca:	48 89 d0             	mov    %rdx,%rax
  816ccd:	48 c1 e0 02          	shl    $0x2,%rax
  816cd1:	48 01 d0             	add    %rdx,%rax
  816cd4:	48 c1 e0 03          	shl    $0x3,%rax
  816cd8:	48 01 c8             	add    %rcx,%rax
  816cdb:	48 83 c0 10          	add    $0x10,%rax
  816cdf:	8b 40 04             	mov    0x4(%rax),%eax
  816ce2:	83 f8 02             	cmp    $0x2,%eax
  816ce5:	75 49                	jne    816d30 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816ce7:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ceb:	48 63 d0             	movslq %eax,%rdx
  816cee:	48 89 d0             	mov    %rdx,%rax
  816cf1:	48 c1 e0 02          	shl    $0x2,%rax
  816cf5:	48 01 d0             	add    %rdx,%rax
  816cf8:	48 c1 e0 03          	shl    $0x3,%rax
  816cfc:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816d03:	00 00 00 
  816d06:	48 01 d0             	add    %rdx,%rax
  816d09:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816d0d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816d11:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816d15:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816d19:	48 89 c7             	mov    %rax,%rdi
  816d1c:	48 b8 fc 60 81 00 00 	movabs $0x8160fc,%rax
  816d23:	00 00 00 
  816d26:	ff d0                	callq  *%rax
  816d28:	88 45 ef             	mov    %al,-0x11(%rbp)
  816d2b:	e9 3d 02 00 00       	jmpq   816f6d <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816d30:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816d34:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816d3b:	00 00 00 
  816d3e:	48 63 d0             	movslq %eax,%rdx
  816d41:	48 89 d0             	mov    %rdx,%rax
  816d44:	48 c1 e0 02          	shl    $0x2,%rax
  816d48:	48 01 d0             	add    %rdx,%rax
  816d4b:	48 c1 e0 03          	shl    $0x3,%rax
  816d4f:	48 01 c8             	add    %rcx,%rax
  816d52:	48 83 c0 10          	add    $0x10,%rax
  816d56:	8b 40 04             	mov    0x4(%rax),%eax
  816d59:	83 f8 01             	cmp    $0x1,%eax
  816d5c:	0f 85 0b 02 00 00    	jne    816f6d <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816d62:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  816d69:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816d6d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816d71:	eb 6b                	jmp    816dde <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816d73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816d77:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816d7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816d7f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816d83:	66 39 c2             	cmp    %ax,%dx
  816d86:	75 36                	jne    816dbe <etharp_query+0x2f8>
  816d88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816d8c:	48 8b 00             	mov    (%rax),%rax
  816d8f:	48 85 c0             	test   %rax,%rax
  816d92:	74 2a                	je     816dbe <etharp_query+0x2f8>
  816d94:	48 ba 68 2a 82 00 00 	movabs $0x822a68,%rdx
  816d9b:	00 00 00 
  816d9e:	be b1 03 00 00       	mov    $0x3b1,%esi
  816da3:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816daa:	00 00 00 
  816dad:	b8 00 00 00 00       	mov    $0x0,%eax
  816db2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  816db9:	00 00 00 
  816dbc:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816dbe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816dc2:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816dc6:	3c 01                	cmp    $0x1,%al
  816dc8:	74 09                	je     816dd3 <etharp_query+0x30d>
          copy_needed = 1;
  816dca:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816dd1:	eb 12                	jmp    816de5 <etharp_query+0x31f>
        }
        p = p->next;
  816dd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816dd7:	48 8b 00             	mov    (%rax),%rax
  816dda:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  816dde:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816de3:	75 8e                	jne    816d73 <etharp_query+0x2ad>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  816de5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  816de9:	74 69                	je     816e54 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  816deb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816def:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816df3:	0f b7 c0             	movzwl %ax,%eax
  816df6:	ba 00 00 00 00       	mov    $0x0,%edx
  816dfb:	89 c6                	mov    %eax,%esi
  816dfd:	bf 03 00 00 00       	mov    $0x3,%edi
  816e02:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  816e09:	00 00 00 
  816e0c:	ff d0                	callq  *%rax
  816e0e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  816e12:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816e17:	74 56                	je     816e6f <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  816e19:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  816e1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816e21:	48 89 d6             	mov    %rdx,%rsi
  816e24:	48 89 c7             	mov    %rax,%rdi
  816e27:	48 b8 9e e0 80 00 00 	movabs $0x80e09e,%rax
  816e2e:	00 00 00 
  816e31:	ff d0                	callq  *%rax
  816e33:	84 c0                	test   %al,%al
  816e35:	74 38                	je     816e6f <etharp_query+0x3a9>
            pbuf_free(p);
  816e37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816e3b:	48 89 c7             	mov    %rax,%rdi
  816e3e:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  816e45:	00 00 00 
  816e48:	ff d0                	callq  *%rax
            p = NULL;
  816e4a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816e51:	00 
  816e52:	eb 1b                	jmp    816e6f <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816e54:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816e58:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  816e5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816e60:	48 89 c7             	mov    %rax,%rdi
  816e63:	48 b8 02 de 80 00 00 	movabs $0x80de02,%rax
  816e6a:	00 00 00 
  816e6d:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816e6f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816e74:	0f 84 f3 00 00 00    	je     816f6d <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  816e7a:	bf 0a 00 00 00       	mov    $0xa,%edi
  816e7f:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  816e86:	00 00 00 
  816e89:	ff d0                	callq  *%rax
  816e8b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816e8f:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816e94:	0f 84 c0 00 00 00    	je     816f5a <etharp_query+0x494>
          new_entry->next = 0;
  816e9a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816e9e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816ea5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816ea9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816ead:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816eb1:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816eb5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ebc:	00 00 00 
  816ebf:	48 63 d0             	movslq %eax,%rdx
  816ec2:	48 89 d0             	mov    %rdx,%rax
  816ec5:	48 c1 e0 02          	shl    $0x2,%rax
  816ec9:	48 01 d0             	add    %rdx,%rax
  816ecc:	48 c1 e0 03          	shl    $0x3,%rax
  816ed0:	48 01 c8             	add    %rcx,%rax
  816ed3:	48 8b 00             	mov    (%rax),%rax
  816ed6:	48 85 c0             	test   %rax,%rax
  816ed9:	74 4f                	je     816f2a <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  816edb:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816edf:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ee6:	00 00 00 
  816ee9:	48 63 d0             	movslq %eax,%rdx
  816eec:	48 89 d0             	mov    %rdx,%rax
  816eef:	48 c1 e0 02          	shl    $0x2,%rax
  816ef3:	48 01 d0             	add    %rdx,%rax
  816ef6:	48 c1 e0 03          	shl    $0x3,%rax
  816efa:	48 01 c8             	add    %rcx,%rax
  816efd:	48 8b 00             	mov    (%rax),%rax
  816f00:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  816f04:	eb 0b                	jmp    816f11 <etharp_query+0x44b>
              r = r->next;
  816f06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816f0a:	48 8b 00             	mov    (%rax),%rax
  816f0d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  816f11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816f15:	48 8b 00             	mov    (%rax),%rax
  816f18:	48 85 c0             	test   %rax,%rax
  816f1b:	75 e9                	jne    816f06 <etharp_query+0x440>
              r = r->next;
            }
            r->next = new_entry;
  816f1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816f21:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816f25:	48 89 10             	mov    %rdx,(%rax)
  816f28:	eb 2a                	jmp    816f54 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  816f2a:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f2e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816f35:	00 00 00 
  816f38:	48 63 d0             	movslq %eax,%rdx
  816f3b:	48 89 d0             	mov    %rdx,%rax
  816f3e:	48 c1 e0 02          	shl    $0x2,%rax
  816f42:	48 01 d0             	add    %rdx,%rax
  816f45:	48 c1 e0 03          	shl    $0x3,%rax
  816f49:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  816f4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816f51:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  816f54:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  816f58:	eb 13                	jmp    816f6d <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  816f5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816f5e:	48 89 c7             	mov    %rax,%rdi
  816f61:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  816f68:	00 00 00 
  816f6b:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  816f6d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  816f71:	48 83 c4 68          	add    $0x68,%rsp
  816f75:	5b                   	pop    %rbx
  816f76:	5d                   	pop    %rbp
  816f77:	c3                   	retq   

0000000000816f78 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  816f78:	55                   	push   %rbp
  816f79:	48 89 e5             	mov    %rsp,%rbp
  816f7c:	48 83 ec 60          	sub    $0x60,%rsp
  816f80:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816f84:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816f88:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  816f8c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  816f90:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  816f94:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  816f98:	8b 45 18             	mov    0x18(%rbp),%eax
  816f9b:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  816f9f:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  816fa3:	ba 00 00 00 00       	mov    $0x0,%edx
  816fa8:	be 2a 00 00 00       	mov    $0x2a,%esi
  816fad:	bf 02 00 00 00       	mov    $0x2,%edi
  816fb2:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  816fb9:	00 00 00 
  816fbc:	ff d0                	callq  *%rax
  816fbe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  816fc2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  816fc7:	75 0a                	jne    816fd3 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  816fc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816fce:	e9 d9 01 00 00       	jmpq   8171ac <etharp_raw+0x234>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  816fd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816fd7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  816fdb:	66 83 f8 29          	cmp    $0x29,%ax
  816fdf:	77 2a                	ja     81700b <etharp_raw+0x93>
  816fe1:	48 ba 88 2a 82 00 00 	movabs $0x822a88,%rdx
  816fe8:	00 00 00 
  816feb:	be 1c 04 00 00       	mov    $0x41c,%esi
  816ff0:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  816ff7:	00 00 00 
  816ffa:	b8 00 00 00 00       	mov    $0x0,%eax
  816fff:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  817006:	00 00 00 
  817009:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  81700b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81700f:	48 8b 40 08          	mov    0x8(%rax),%rax
  817013:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  817017:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  81701b:	89 c7                	mov    %eax,%edi
  81701d:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  817024:	00 00 00 
  817027:	ff d0                	callq  *%rax
  817029:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81702d:	66 89 42 14          	mov    %ax,0x14(%rdx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  817031:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817035:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  817039:	3c 06                	cmp    $0x6,%al
  81703b:	74 2a                	je     817067 <etharp_raw+0xef>
  81703d:	48 ba c0 29 82 00 00 	movabs $0x8229c0,%rdx
  817044:	00 00 00 
  817047:	be 23 04 00 00       	mov    $0x423,%esi
  81704c:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  817053:	00 00 00 
  817056:	b8 00 00 00 00       	mov    $0x0,%eax
  81705b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  817062:	00 00 00 
  817065:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  817067:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  81706b:	eb 7d                	jmp    8170ea <etharp_raw+0x172>
    k--;
  81706d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817071:	83 e8 01             	sub    $0x1,%eax
  817074:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  817077:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81707b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81707f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  817083:	48 98                	cltq   
  817085:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  817089:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81708d:	48 63 c6             	movslq %esi,%rax
  817090:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  817094:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  817098:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81709c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8170a0:	48 98                	cltq   
  8170a2:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8170a6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8170aa:	48 63 c6             	movslq %esi,%rax
  8170ad:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8170b1:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8170b5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8170b9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8170bd:	48 98                	cltq   
  8170bf:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8170c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8170c7:	48 63 c6             	movslq %esi,%rax
  8170ca:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8170cd:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8170d1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8170d5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8170d9:	48 98                	cltq   
  8170db:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8170df:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8170e3:	48 63 c6             	movslq %esi,%rax
  8170e6:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  8170ea:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8170ee:	0f 85 79 ff ff ff    	jne    81706d <etharp_raw+0xf5>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8170f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8170f8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8170fc:	8b 12                	mov    (%rdx),%edx
  8170fe:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  817101:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817105:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  817109:	8b 12                	mov    (%rdx),%edx
  81710b:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  81710e:	bf 01 00 00 00       	mov    $0x1,%edi
  817113:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81711a:	00 00 00 
  81711d:	ff d0                	callq  *%rax
  81711f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817123:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  hdr->proto = htons(ETHTYPE_IP);
  817127:	bf 00 08 00 00       	mov    $0x800,%edi
  81712c:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  817133:	00 00 00 
  817136:	ff d0                	callq  *%rax
  817138:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81713c:	66 89 42 10          	mov    %ax,0x10(%rdx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  817140:	bf 04 06 00 00       	mov    $0x604,%edi
  817145:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  81714c:	00 00 00 
  81714f:	ff d0                	callq  *%rax
  817151:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817155:	66 89 42 12          	mov    %ax,0x12(%rdx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  817159:	bf 06 08 00 00       	mov    $0x806,%edi
  81715e:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  817165:	00 00 00 
  817168:	ff d0                	callq  *%rax
  81716a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81716e:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  817172:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817176:	48 8b 40 28          	mov    0x28(%rax),%rax
  81717a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81717e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  817182:	48 89 ce             	mov    %rcx,%rsi
  817185:	48 89 d7             	mov    %rdx,%rdi
  817188:	ff d0                	callq  *%rax
  81718a:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  81718d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  817191:	48 89 c7             	mov    %rax,%rdi
  817194:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81719b:	00 00 00 
  81719e:	ff d0                	callq  *%rax
  p = NULL;
  8171a0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8171a7:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  8171a8:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  8171ac:	c9                   	leaveq 
  8171ad:	c3                   	retq   

00000000008171ae <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8171ae:	55                   	push   %rbp
  8171af:	48 89 e5             	mov    %rsp,%rbp
  8171b2:	48 83 ec 20          	sub    $0x20,%rsp
  8171b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8171ba:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  8171be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171c2:	48 8d 78 08          	lea    0x8(%rax),%rdi
  8171c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171ca:	48 8d 48 41          	lea    0x41(%rax),%rcx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  8171ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171d2:	48 8d 70 41          	lea    0x41(%rax),%rsi
  8171d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171da:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
  8171e1:	00 
  8171e2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8171e6:	48 89 14 24          	mov    %rdx,(%rsp)
  8171ea:	49 b9 4e 29 82 00 00 	movabs $0x82294e,%r9
  8171f1:	00 00 00 
  8171f4:	49 89 f8             	mov    %rdi,%r8
  8171f7:	48 ba 48 29 82 00 00 	movabs $0x822948,%rdx
  8171fe:	00 00 00 
  817201:	48 89 c7             	mov    %rax,%rdi
  817204:	48 b8 78 6f 81 00 00 	movabs $0x816f78,%rax
  81720b:	00 00 00 
  81720e:	ff d0                	callq  *%rax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  817210:	c9                   	leaveq 
  817211:	c3                   	retq   

0000000000817212 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  817212:	55                   	push   %rbp
  817213:	48 89 e5             	mov    %rsp,%rbp
  817216:	48 83 ec 20          	sub    $0x20,%rsp
  81721a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81721e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  817222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817226:	48 8b 40 08          	mov    0x8(%rax),%rax
  81722a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  81722e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817232:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  817236:	0f b7 c0             	movzwl %ax,%eax
  817239:	89 c7                	mov    %eax,%edi
  81723b:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  817242:	00 00 00 
  817245:	ff d0                	callq  *%rax
  817247:	0f b7 c0             	movzwl %ax,%eax
  81724a:	3d 00 08 00 00       	cmp    $0x800,%eax
  81724f:	74 10                	je     817261 <ethernet_input+0x4f>
  817251:	3d 06 08 00 00       	cmp    $0x806,%eax
  817256:	0f 84 81 00 00 00    	je     8172dd <ethernet_input+0xcb>
  81725c:	e9 a0 00 00 00       	jmpq   817301 <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  817261:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817265:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817269:	48 89 d6             	mov    %rdx,%rsi
  81726c:	48 89 c7             	mov    %rax,%rdi
  81726f:	48 b8 58 65 81 00 00 	movabs $0x816558,%rax
  817276:	00 00 00 
  817279:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  81727b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81727f:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  817284:	48 89 c7             	mov    %rax,%rdi
  817287:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81728e:	00 00 00 
  817291:	ff d0                	callq  *%rax
  817293:	84 c0                	test   %al,%al
  817295:	74 2a                	je     8172c1 <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  817297:	48 ba c0 2a 82 00 00 	movabs $0x822ac0,%rdx
  81729e:	00 00 00 
  8172a1:	be 7e 04 00 00       	mov    $0x47e,%esi
  8172a6:	48 bf 5e 29 82 00 00 	movabs $0x82295e,%rdi
  8172ad:	00 00 00 
  8172b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8172b5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8172bc:	00 00 00 
  8172bf:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  8172c1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8172c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8172c9:	48 89 d6             	mov    %rdx,%rsi
  8172cc:	48 89 c7             	mov    %rax,%rdi
  8172cf:	48 b8 6f 0d 81 00 00 	movabs $0x810d6f,%rax
  8172d6:	00 00 00 
  8172d9:	ff d0                	callq  *%rax
      }
      break;
  8172db:	eb 40                	jmp    81731d <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  8172dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8172e1:	48 8d 48 41          	lea    0x41(%rax),%rcx
  8172e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8172e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8172ed:	48 89 ce             	mov    %rcx,%rsi
  8172f0:	48 89 c7             	mov    %rax,%rdi
  8172f3:	48 b8 ee 65 81 00 00 	movabs $0x8165ee,%rax
  8172fa:	00 00 00 
  8172fd:	ff d0                	callq  *%rax
      break;
  8172ff:	eb 1c                	jmp    81731d <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  817301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817305:	48 89 c7             	mov    %rax,%rdi
  817308:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81730f:	00 00 00 
  817312:	ff d0                	callq  *%rax
      p = NULL;
  817314:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81731b:	00 
      break;
  81731c:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  81731d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817322:	c9                   	leaveq 
  817323:	c3                   	retq   

0000000000817324 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  817324:	55                   	push   %rbp
  817325:	48 89 e5             	mov    %rsp,%rbp
  817328:	53                   	push   %rbx
  817329:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  81732d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    for (i = 0; i < NSEM; i++) {
  817334:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81733b:	e9 ea 00 00 00       	jmpq   81742a <sys_init+0x106>
	sems[i].freed = 1;
  817340:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817347:	00 00 00 
  81734a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81734d:	48 63 d2             	movslq %edx,%rdx
  817350:	48 c1 e2 05          	shl    $0x5,%rdx
  817354:	48 01 d0             	add    %rdx,%rax
  817357:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  81735d:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817364:	00 00 00 
  817367:	48 8b 00             	mov    (%rax),%rax
  81736a:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817371:	00 00 00 
  817374:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817377:	48 63 c9             	movslq %ecx,%rcx
  81737a:	48 c1 e1 05          	shl    $0x5,%rcx
  81737e:	48 01 ca             	add    %rcx,%rdx
  817381:	48 83 c2 10          	add    $0x10,%rdx
  817385:	48 89 02             	mov    %rax,(%rdx)
  817388:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81738f:	00 00 00 
  817392:	8b 55 f4             	mov    -0xc(%rbp),%edx
  817395:	48 63 d2             	movslq %edx,%rdx
  817398:	48 c1 e2 05          	shl    $0x5,%rdx
  81739c:	48 01 d0             	add    %rdx,%rax
  81739f:	48 83 c0 10          	add    $0x10,%rax
  8173a3:	48 8b 00             	mov    (%rax),%rax
  8173a6:	48 85 c0             	test   %rax,%rax
  8173a9:	74 2c                	je     8173d7 <sys_init+0xb3>
  8173ab:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8173b2:	00 00 00 
  8173b5:	48 8b 00             	mov    (%rax),%rax
  8173b8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8173bb:	48 63 d2             	movslq %edx,%rdx
  8173be:	48 c1 e2 05          	shl    $0x5,%rdx
  8173c2:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  8173c6:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8173cd:	00 00 00 
  8173d0:	48 01 ca             	add    %rcx,%rdx
  8173d3:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8173d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8173da:	48 98                	cltq   
  8173dc:	48 c1 e0 05          	shl    $0x5,%rax
  8173e0:	48 89 c2             	mov    %rax,%rdx
  8173e3:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8173ea:	00 00 00 
  8173ed:	48 01 c2             	add    %rax,%rdx
  8173f0:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8173f7:	00 00 00 
  8173fa:	48 89 10             	mov    %rdx,(%rax)
  8173fd:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817404:	00 00 00 
  817407:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81740a:	48 63 d2             	movslq %edx,%rdx
  81740d:	48 c1 e2 05          	shl    $0x5,%rdx
  817411:	48 01 d0             	add    %rdx,%rax
  817414:	48 83 c0 10          	add    $0x10,%rax
  817418:	48 bf 20 d8 b4 00 00 	movabs $0xb4d820,%rdi
  81741f:	00 00 00 
  817422:	48 89 78 08          	mov    %rdi,0x8(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  817426:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  81742a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%rbp)
  817431:	0f 8e 09 ff ff ff    	jle    817340 <sys_init+0x1c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81743e:	e9 60 01 00 00       	jmpq   8175a3 <sys_init+0x27f>
	mboxes[i].freed = 1;
  817443:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81744a:	00 00 00 
  81744d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817450:	48 63 d0             	movslq %eax,%rdx
  817453:	48 89 d0             	mov    %rdx,%rax
  817456:	48 c1 e0 03          	shl    $0x3,%rax
  81745a:	48 01 d0             	add    %rdx,%rax
  81745d:	48 c1 e0 02          	shl    $0x2,%rax
  817461:	48 01 d0             	add    %rdx,%rax
  817464:	48 c1 e0 03          	shl    $0x3,%rax
  817468:	48 01 c8             	add    %rcx,%rax
  81746b:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  817471:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817478:	00 00 00 
  81747b:	48 8b 08             	mov    (%rax),%rcx
  81747e:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817485:	00 00 00 
  817488:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81748b:	48 63 d0             	movslq %eax,%rdx
  81748e:	48 89 d0             	mov    %rdx,%rax
  817491:	48 c1 e0 03          	shl    $0x3,%rax
  817495:	48 01 d0             	add    %rdx,%rax
  817498:	48 c1 e0 02          	shl    $0x2,%rax
  81749c:	48 01 d0             	add    %rdx,%rax
  81749f:	48 c1 e0 03          	shl    $0x3,%rax
  8174a3:	48 01 f0             	add    %rsi,%rax
  8174a6:	48 05 10 01 00 00    	add    $0x110,%rax
  8174ac:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8174b0:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8174b7:	00 00 00 
  8174ba:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8174bd:	48 63 d0             	movslq %eax,%rdx
  8174c0:	48 89 d0             	mov    %rdx,%rax
  8174c3:	48 c1 e0 03          	shl    $0x3,%rax
  8174c7:	48 01 d0             	add    %rdx,%rax
  8174ca:	48 c1 e0 02          	shl    $0x2,%rax
  8174ce:	48 01 d0             	add    %rdx,%rax
  8174d1:	48 c1 e0 03          	shl    $0x3,%rax
  8174d5:	48 01 c8             	add    %rcx,%rax
  8174d8:	48 05 10 01 00 00    	add    $0x110,%rax
  8174de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8174e2:	48 85 c0             	test   %rax,%rax
  8174e5:	74 47                	je     81752e <sys_init+0x20a>
  8174e7:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8174ee:	00 00 00 
  8174f1:	48 8b 08             	mov    (%rax),%rcx
  8174f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8174f7:	48 63 d0             	movslq %eax,%rdx
  8174fa:	48 89 d0             	mov    %rdx,%rax
  8174fd:	48 c1 e0 03          	shl    $0x3,%rax
  817501:	48 01 d0             	add    %rdx,%rax
  817504:	48 c1 e0 02          	shl    $0x2,%rax
  817508:	48 01 d0             	add    %rdx,%rax
  81750b:	48 c1 e0 03          	shl    $0x3,%rax
  81750f:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817516:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81751d:	00 00 00 
  817520:	48 01 d0             	add    %rdx,%rax
  817523:	48 83 c0 08          	add    $0x8,%rax
  817527:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81752e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817531:	48 63 d0             	movslq %eax,%rdx
  817534:	48 89 d0             	mov    %rdx,%rax
  817537:	48 c1 e0 03          	shl    $0x3,%rax
  81753b:	48 01 d0             	add    %rdx,%rax
  81753e:	48 c1 e0 02          	shl    $0x2,%rax
  817542:	48 01 d0             	add    %rdx,%rax
  817545:	48 c1 e0 03          	shl    $0x3,%rax
  817549:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817550:	00 00 00 
  817553:	48 01 c2             	add    %rax,%rdx
  817556:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81755d:	00 00 00 
  817560:	48 89 10             	mov    %rdx,(%rax)
  817563:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81756a:	00 00 00 
  81756d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817570:	48 63 d0             	movslq %eax,%rdx
  817573:	48 89 d0             	mov    %rdx,%rax
  817576:	48 c1 e0 03          	shl    $0x3,%rax
  81757a:	48 01 d0             	add    %rdx,%rax
  81757d:	48 c1 e0 02          	shl    $0x2,%rax
  817581:	48 01 d0             	add    %rdx,%rax
  817584:	48 c1 e0 03          	shl    $0x3,%rax
  817588:	48 01 c8             	add    %rcx,%rax
  81758b:	48 05 10 01 00 00    	add    $0x110,%rax
  817591:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  817598:	00 00 00 
  81759b:	48 89 58 10          	mov    %rbx,0x10(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  81759f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8175a3:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  8175a7:	0f 8e 96 fe ff ff    	jle    817443 <sys_init+0x11f>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  8175ad:	48 83 c4 10          	add    $0x10,%rsp
  8175b1:	5b                   	pop    %rbx
  8175b2:	5d                   	pop    %rbp
  8175b3:	c3                   	retq   

00000000008175b4 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  8175b4:	55                   	push   %rbp
  8175b5:	48 89 e5             	mov    %rsp,%rbp
  8175b8:	48 83 ec 20          	sub    $0x20,%rsp
  8175bc:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  8175bf:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8175c3:	7e 35                	jle    8175fa <sys_mbox_new+0x46>
  8175c5:	48 b9 e8 2a 82 00 00 	movabs $0x822ae8,%rcx
  8175cc:	00 00 00 
  8175cf:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  8175d6:	00 00 00 
  8175d9:	be 45 00 00 00       	mov    $0x45,%esi
  8175de:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8175e5:	00 00 00 
  8175e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8175ed:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8175f4:	00 00 00 
  8175f7:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  8175fa:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817601:	00 00 00 
  817604:	48 8b 00             	mov    (%rax),%rax
  817607:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  81760b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817610:	75 25                	jne    817637 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  817612:	48 bf 30 2b 82 00 00 	movabs $0x822b30,%rdi
  817619:	00 00 00 
  81761c:	b8 00 00 00 00       	mov    $0x0,%eax
  817621:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  817628:	00 00 00 
  81762b:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  81762d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817632:	e9 5b 01 00 00       	jmpq   817792 <sys_mbox_new+0x1de>
    }
    LIST_REMOVE(mbe, link);
  817637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81763b:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817642:	48 85 c0             	test   %rax,%rax
  817645:	74 1d                	je     817664 <sys_mbox_new+0xb0>
  817647:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81764b:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817652:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817656:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  81765d:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  817664:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817668:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  81766f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817673:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  81767a:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  81767d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817681:	8b 00                	mov    (%rax),%eax
  817683:	85 c0                	test   %eax,%eax
  817685:	75 35                	jne    8176bc <sys_mbox_new+0x108>
  817687:	48 b9 56 2b 82 00 00 	movabs $0x822b56,%rcx
  81768e:	00 00 00 
  817691:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817698:	00 00 00 
  81769b:	be 4c 00 00 00       	mov    $0x4c,%esi
  8176a0:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8176a7:	00 00 00 
  8176aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8176af:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8176b6:	00 00 00 
  8176b9:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  8176bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8176c0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  8176c6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8176ca:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8176d1:	00 00 00 
  8176d4:	48 29 c2             	sub    %rax,%rdx
  8176d7:	48 89 d0             	mov    %rdx,%rax
  8176da:	48 c1 f8 03          	sar    $0x3,%rax
  8176de:	48 89 c2             	mov    %rax,%rdx
  8176e1:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  8176e8:	ba c1 14 
  8176eb:	48 0f af c2          	imul   %rdx,%rax
  8176ef:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  8176f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8176f6:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  8176fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817701:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  817708:	bf 00 00 00 00       	mov    $0x0,%edi
  81770d:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  817714:	00 00 00 
  817717:	ff d0                	callq  *%rax
  817719:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81771d:	89 82 10 01 00 00    	mov    %eax,0x110(%rdx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  817723:	bf 20 00 00 00       	mov    $0x20,%edi
  817728:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  81772f:	00 00 00 
  817732:	ff d0                	callq  *%rax
  817734:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817738:	89 82 14 01 00 00    	mov    %eax,0x114(%rdx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  81773e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817742:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  817748:	83 f8 ff             	cmp    $0xffffffff,%eax
  81774b:	74 0f                	je     81775c <sys_mbox_new+0x1a8>
	mbe->free_msg == SYS_SEM_NULL)
  81774d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817751:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  817757:	83 f8 ff             	cmp    $0xffffffff,%eax
  81775a:	75 33                	jne    81778f <sys_mbox_new+0x1db>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  81775c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81775f:	89 c7                	mov    %eax,%edi
  817761:	48 b8 94 77 81 00 00 	movabs $0x817794,%rax
  817768:	00 00 00 
  81776b:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  81776d:	48 bf 68 2b 82 00 00 	movabs $0x822b68,%rdi
  817774:	00 00 00 
  817777:	b8 00 00 00 00       	mov    $0x0,%eax
  81777c:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  817783:	00 00 00 
  817786:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  817788:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81778d:	eb 03                	jmp    817792 <sys_mbox_new+0x1de>
    }
    return i;
  81778f:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  817792:	c9                   	leaveq 
  817793:	c3                   	retq   

0000000000817794 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  817794:	55                   	push   %rbp
  817795:	48 89 e5             	mov    %rsp,%rbp
  817798:	53                   	push   %rbx
  817799:	48 83 ec 18          	sub    $0x18,%rsp
  81779d:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!mboxes[mbox].freed);
  8177a0:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8177a7:	00 00 00 
  8177aa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8177ad:	48 63 d0             	movslq %eax,%rdx
  8177b0:	48 89 d0             	mov    %rdx,%rax
  8177b3:	48 c1 e0 03          	shl    $0x3,%rax
  8177b7:	48 01 d0             	add    %rdx,%rax
  8177ba:	48 c1 e0 02          	shl    $0x2,%rax
  8177be:	48 01 d0             	add    %rdx,%rax
  8177c1:	48 c1 e0 03          	shl    $0x3,%rax
  8177c5:	48 01 c8             	add    %rcx,%rax
  8177c8:	8b 00                	mov    (%rax),%eax
  8177ca:	85 c0                	test   %eax,%eax
  8177cc:	74 35                	je     817803 <sys_mbox_free+0x6f>
  8177ce:	48 b9 91 2b 82 00 00 	movabs $0x822b91,%rcx
  8177d5:	00 00 00 
  8177d8:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  8177df:	00 00 00 
  8177e2:	be 62 00 00 00       	mov    $0x62,%esi
  8177e7:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8177ee:	00 00 00 
  8177f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8177f6:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8177fd:	00 00 00 
  817800:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817803:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81780a:	00 00 00 
  81780d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817810:	48 63 d0             	movslq %eax,%rdx
  817813:	48 89 d0             	mov    %rdx,%rax
  817816:	48 c1 e0 03          	shl    $0x3,%rax
  81781a:	48 01 d0             	add    %rdx,%rax
  81781d:	48 c1 e0 02          	shl    $0x2,%rax
  817821:	48 01 d0             	add    %rdx,%rax
  817824:	48 c1 e0 03          	shl    $0x3,%rax
  817828:	48 01 c8             	add    %rcx,%rax
  81782b:	48 05 10 01 00 00    	add    $0x110,%rax
  817831:	8b 00                	mov    (%rax),%eax
  817833:	89 c7                	mov    %eax,%edi
  817835:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  81783c:	00 00 00 
  81783f:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  817841:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817848:	00 00 00 
  81784b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81784e:	48 63 d0             	movslq %eax,%rdx
  817851:	48 89 d0             	mov    %rdx,%rax
  817854:	48 c1 e0 03          	shl    $0x3,%rax
  817858:	48 01 d0             	add    %rdx,%rax
  81785b:	48 c1 e0 02          	shl    $0x2,%rax
  81785f:	48 01 d0             	add    %rdx,%rax
  817862:	48 c1 e0 03          	shl    $0x3,%rax
  817866:	48 01 c8             	add    %rcx,%rax
  817869:	48 05 10 01 00 00    	add    $0x110,%rax
  81786f:	8b 40 04             	mov    0x4(%rax),%eax
  817872:	89 c7                	mov    %eax,%edi
  817874:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  81787b:	00 00 00 
  81787e:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  817880:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817887:	00 00 00 
  81788a:	48 8b 08             	mov    (%rax),%rcx
  81788d:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817894:	00 00 00 
  817897:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81789a:	48 63 d0             	movslq %eax,%rdx
  81789d:	48 89 d0             	mov    %rdx,%rax
  8178a0:	48 c1 e0 03          	shl    $0x3,%rax
  8178a4:	48 01 d0             	add    %rdx,%rax
  8178a7:	48 c1 e0 02          	shl    $0x2,%rax
  8178ab:	48 01 d0             	add    %rdx,%rax
  8178ae:	48 c1 e0 03          	shl    $0x3,%rax
  8178b2:	48 01 f0             	add    %rsi,%rax
  8178b5:	48 05 10 01 00 00    	add    $0x110,%rax
  8178bb:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8178bf:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8178c6:	00 00 00 
  8178c9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178cc:	48 63 d0             	movslq %eax,%rdx
  8178cf:	48 89 d0             	mov    %rdx,%rax
  8178d2:	48 c1 e0 03          	shl    $0x3,%rax
  8178d6:	48 01 d0             	add    %rdx,%rax
  8178d9:	48 c1 e0 02          	shl    $0x2,%rax
  8178dd:	48 01 d0             	add    %rdx,%rax
  8178e0:	48 c1 e0 03          	shl    $0x3,%rax
  8178e4:	48 01 c8             	add    %rcx,%rax
  8178e7:	48 05 10 01 00 00    	add    $0x110,%rax
  8178ed:	48 8b 40 08          	mov    0x8(%rax),%rax
  8178f1:	48 85 c0             	test   %rax,%rax
  8178f4:	74 47                	je     81793d <sys_mbox_free+0x1a9>
  8178f6:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8178fd:	00 00 00 
  817900:	48 8b 08             	mov    (%rax),%rcx
  817903:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817906:	48 63 d0             	movslq %eax,%rdx
  817909:	48 89 d0             	mov    %rdx,%rax
  81790c:	48 c1 e0 03          	shl    $0x3,%rax
  817910:	48 01 d0             	add    %rdx,%rax
  817913:	48 c1 e0 02          	shl    $0x2,%rax
  817917:	48 01 d0             	add    %rdx,%rax
  81791a:	48 c1 e0 03          	shl    $0x3,%rax
  81791e:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817925:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81792c:	00 00 00 
  81792f:	48 01 d0             	add    %rdx,%rax
  817932:	48 83 c0 08          	add    $0x8,%rax
  817936:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81793d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817940:	48 63 d0             	movslq %eax,%rdx
  817943:	48 89 d0             	mov    %rdx,%rax
  817946:	48 c1 e0 03          	shl    $0x3,%rax
  81794a:	48 01 d0             	add    %rdx,%rax
  81794d:	48 c1 e0 02          	shl    $0x2,%rax
  817951:	48 01 d0             	add    %rdx,%rax
  817954:	48 c1 e0 03          	shl    $0x3,%rax
  817958:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  81795f:	00 00 00 
  817962:	48 01 c2             	add    %rax,%rdx
  817965:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81796c:	00 00 00 
  81796f:	48 89 10             	mov    %rdx,(%rax)
  817972:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817979:	00 00 00 
  81797c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81797f:	48 63 d0             	movslq %eax,%rdx
  817982:	48 89 d0             	mov    %rdx,%rax
  817985:	48 c1 e0 03          	shl    $0x3,%rax
  817989:	48 01 d0             	add    %rdx,%rax
  81798c:	48 c1 e0 02          	shl    $0x2,%rax
  817990:	48 01 d0             	add    %rdx,%rax
  817993:	48 c1 e0 03          	shl    $0x3,%rax
  817997:	48 01 c8             	add    %rcx,%rax
  81799a:	48 05 10 01 00 00    	add    $0x110,%rax
  8179a0:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  8179a7:	00 00 00 
  8179aa:	48 89 58 10          	mov    %rbx,0x10(%rax)
    mboxes[mbox].freed = 1;
  8179ae:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8179b5:	00 00 00 
  8179b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179bb:	48 63 d0             	movslq %eax,%rdx
  8179be:	48 89 d0             	mov    %rdx,%rax
  8179c1:	48 c1 e0 03          	shl    $0x3,%rax
  8179c5:	48 01 d0             	add    %rdx,%rax
  8179c8:	48 c1 e0 02          	shl    $0x2,%rax
  8179cc:	48 01 d0             	add    %rdx,%rax
  8179cf:	48 c1 e0 03          	shl    $0x3,%rax
  8179d3:	48 01 c8             	add    %rcx,%rax
  8179d6:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  8179dc:	48 83 c4 18          	add    $0x18,%rsp
  8179e0:	5b                   	pop    %rbx
  8179e1:	5d                   	pop    %rbp
  8179e2:	c3                   	retq   

00000000008179e3 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  8179e3:	55                   	push   %rbp
  8179e4:	48 89 e5             	mov    %rsp,%rbp
  8179e7:	48 83 ec 10          	sub    $0x10,%rsp
  8179eb:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8179ee:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  8179f2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8179f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8179f9:	48 89 d6             	mov    %rdx,%rsi
  8179fc:	89 c7                	mov    %eax,%edi
  8179fe:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  817a05:	00 00 00 
  817a08:	ff d0                	callq  *%rax
  817a0a:	84 c0                	test   %al,%al
  817a0c:	74 35                	je     817a43 <sys_mbox_post+0x60>
  817a0e:	48 b9 a8 2b 82 00 00 	movabs $0x822ba8,%rcx
  817a15:	00 00 00 
  817a18:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817a1f:	00 00 00 
  817a22:	be 6c 00 00 00       	mov    $0x6c,%esi
  817a27:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  817a2e:	00 00 00 
  817a31:	b8 00 00 00 00       	mov    $0x0,%eax
  817a36:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  817a3d:	00 00 00 
  817a40:	41 ff d0             	callq  *%r8
}
  817a43:	c9                   	leaveq 
  817a44:	c3                   	retq   

0000000000817a45 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817a45:	55                   	push   %rbp
  817a46:	48 89 e5             	mov    %rsp,%rbp
  817a49:	48 83 ec 20          	sub    $0x20,%rsp
  817a4d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817a50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817a54:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a5b:	00 00 00 
  817a5e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a61:	48 63 d0             	movslq %eax,%rdx
  817a64:	48 89 d0             	mov    %rdx,%rax
  817a67:	48 c1 e0 03          	shl    $0x3,%rax
  817a6b:	48 01 d0             	add    %rdx,%rax
  817a6e:	48 c1 e0 02          	shl    $0x2,%rax
  817a72:	48 01 d0             	add    %rdx,%rax
  817a75:	48 c1 e0 03          	shl    $0x3,%rax
  817a79:	48 01 c8             	add    %rcx,%rax
  817a7c:	8b 00                	mov    (%rax),%eax
  817a7e:	85 c0                	test   %eax,%eax
  817a80:	74 35                	je     817ab7 <sys_mbox_trypost+0x72>
  817a82:	48 b9 91 2b 82 00 00 	movabs $0x822b91,%rcx
  817a89:	00 00 00 
  817a8c:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817a93:	00 00 00 
  817a96:	be 72 00 00 00       	mov    $0x72,%esi
  817a9b:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  817aa2:	00 00 00 
  817aa5:	b8 00 00 00 00       	mov    $0x0,%eax
  817aaa:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  817ab1:	00 00 00 
  817ab4:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  817ab7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817abe:	00 00 00 
  817ac1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ac4:	48 63 d0             	movslq %eax,%rdx
  817ac7:	48 89 d0             	mov    %rdx,%rax
  817aca:	48 c1 e0 03          	shl    $0x3,%rax
  817ace:	48 01 d0             	add    %rdx,%rax
  817ad1:	48 c1 e0 02          	shl    $0x2,%rax
  817ad5:	48 01 d0             	add    %rdx,%rax
  817ad8:	48 c1 e0 03          	shl    $0x3,%rax
  817adc:	48 01 c8             	add    %rcx,%rax
  817adf:	48 05 10 01 00 00    	add    $0x110,%rax
  817ae5:	8b 40 04             	mov    0x4(%rax),%eax
  817ae8:	be 00 00 00 00       	mov    $0x0,%esi
  817aed:	89 c7                	mov    %eax,%edi
  817aef:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  817af6:	00 00 00 
  817af9:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817afb:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817b02:	00 00 00 
  817b05:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817b08:	48 63 d0             	movslq %eax,%rdx
  817b0b:	48 89 d0             	mov    %rdx,%rax
  817b0e:	48 c1 e0 03          	shl    $0x3,%rax
  817b12:	48 01 d0             	add    %rdx,%rax
  817b15:	48 c1 e0 02          	shl    $0x2,%rax
  817b19:	48 01 d0             	add    %rdx,%rax
  817b1c:	48 c1 e0 03          	shl    $0x3,%rax
  817b20:	48 01 c8             	add    %rcx,%rax
  817b23:	8b 48 08             	mov    0x8(%rax),%ecx
  817b26:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817b2d:	00 00 00 
  817b30:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817b33:	48 63 d0             	movslq %eax,%rdx
  817b36:	48 89 d0             	mov    %rdx,%rax
  817b39:	48 c1 e0 03          	shl    $0x3,%rax
  817b3d:	48 01 d0             	add    %rdx,%rax
  817b40:	48 c1 e0 02          	shl    $0x2,%rax
  817b44:	48 01 d0             	add    %rdx,%rax
  817b47:	48 c1 e0 03          	shl    $0x3,%rax
  817b4b:	48 01 f0             	add    %rsi,%rax
  817b4e:	8b 40 04             	mov    0x4(%rax),%eax
  817b51:	39 c1                	cmp    %eax,%ecx
  817b53:	75 0a                	jne    817b5f <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  817b55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817b5a:	e9 4a 01 00 00       	jmpq   817ca9 <sys_mbox_trypost+0x264>

    int slot = mboxes[mbox].nextq;
  817b5f:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817b66:	00 00 00 
  817b69:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817b6c:	48 63 d0             	movslq %eax,%rdx
  817b6f:	48 89 d0             	mov    %rdx,%rax
  817b72:	48 c1 e0 03          	shl    $0x3,%rax
  817b76:	48 01 d0             	add    %rdx,%rax
  817b79:	48 c1 e0 02          	shl    $0x2,%rax
  817b7d:	48 01 d0             	add    %rdx,%rax
  817b80:	48 c1 e0 03          	shl    $0x3,%rax
  817b84:	48 01 c8             	add    %rcx,%rax
  817b87:	8b 40 08             	mov    0x8(%rax),%eax
  817b8a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  817b8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b90:	8d 50 01             	lea    0x1(%rax),%edx
  817b93:	89 d0                	mov    %edx,%eax
  817b95:	c1 f8 1f             	sar    $0x1f,%eax
  817b98:	c1 e8 1b             	shr    $0x1b,%eax
  817b9b:	01 c2                	add    %eax,%edx
  817b9d:	83 e2 1f             	and    $0x1f,%edx
  817ba0:	29 c2                	sub    %eax,%edx
  817ba2:	89 d0                	mov    %edx,%eax
  817ba4:	89 c1                	mov    %eax,%ecx
  817ba6:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817bad:	00 00 00 
  817bb0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817bb3:	48 63 d0             	movslq %eax,%rdx
  817bb6:	48 89 d0             	mov    %rdx,%rax
  817bb9:	48 c1 e0 03          	shl    $0x3,%rax
  817bbd:	48 01 d0             	add    %rdx,%rax
  817bc0:	48 c1 e0 02          	shl    $0x2,%rax
  817bc4:	48 01 d0             	add    %rdx,%rax
  817bc7:	48 c1 e0 03          	shl    $0x3,%rax
  817bcb:	48 01 f0             	add    %rsi,%rax
  817bce:	89 48 08             	mov    %ecx,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  817bd1:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817bd8:	00 00 00 
  817bdb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817bde:	48 63 f0             	movslq %eax,%rsi
  817be1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817be4:	48 63 d0             	movslq %eax,%rdx
  817be7:	48 89 d0             	mov    %rdx,%rax
  817bea:	48 c1 e0 03          	shl    $0x3,%rax
  817bee:	48 01 d0             	add    %rdx,%rax
  817bf1:	48 c1 e0 02          	shl    $0x2,%rax
  817bf5:	48 01 d0             	add    %rdx,%rax
  817bf8:	48 01 f0             	add    %rsi,%rax
  817bfb:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817bff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817c03:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  817c07:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c0e:	00 00 00 
  817c11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c14:	48 63 d0             	movslq %eax,%rdx
  817c17:	48 89 d0             	mov    %rdx,%rax
  817c1a:	48 c1 e0 03          	shl    $0x3,%rax
  817c1e:	48 01 d0             	add    %rdx,%rax
  817c21:	48 c1 e0 02          	shl    $0x2,%rax
  817c25:	48 01 d0             	add    %rdx,%rax
  817c28:	48 c1 e0 03          	shl    $0x3,%rax
  817c2c:	48 01 c8             	add    %rcx,%rax
  817c2f:	8b 40 04             	mov    0x4(%rax),%eax
  817c32:	83 f8 ff             	cmp    $0xffffffff,%eax
  817c35:	75 2f                	jne    817c66 <sys_mbox_trypost+0x221>
	mboxes[mbox].head = slot;
  817c37:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c3e:	00 00 00 
  817c41:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c44:	48 63 d0             	movslq %eax,%rdx
  817c47:	48 89 d0             	mov    %rdx,%rax
  817c4a:	48 c1 e0 03          	shl    $0x3,%rax
  817c4e:	48 01 d0             	add    %rdx,%rax
  817c51:	48 c1 e0 02          	shl    $0x2,%rax
  817c55:	48 01 d0             	add    %rdx,%rax
  817c58:	48 c1 e0 03          	shl    $0x3,%rax
  817c5c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  817c60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c63:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817c66:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c6d:	00 00 00 
  817c70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c73:	48 63 d0             	movslq %eax,%rdx
  817c76:	48 89 d0             	mov    %rdx,%rax
  817c79:	48 c1 e0 03          	shl    $0x3,%rax
  817c7d:	48 01 d0             	add    %rdx,%rax
  817c80:	48 c1 e0 02          	shl    $0x2,%rax
  817c84:	48 01 d0             	add    %rdx,%rax
  817c87:	48 c1 e0 03          	shl    $0x3,%rax
  817c8b:	48 01 c8             	add    %rcx,%rax
  817c8e:	48 05 10 01 00 00    	add    $0x110,%rax
  817c94:	8b 00                	mov    (%rax),%eax
  817c96:	89 c7                	mov    %eax,%edi
  817c98:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  817c9f:	00 00 00 
  817ca2:	ff d0                	callq  *%rax

    return ERR_OK;
  817ca4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817ca9:	c9                   	leaveq 
  817caa:	c3                   	retq   

0000000000817cab <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817cab:	55                   	push   %rbp
  817cac:	48 89 e5             	mov    %rsp,%rbp
  817caf:	48 83 ec 20          	sub    $0x20,%rsp
  817cb3:	89 f8                	mov    %edi,%eax
  817cb5:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817cb8:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817cbf:	00 00 00 
  817cc2:	48 8b 00             	mov    (%rax),%rax
  817cc5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817cc9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817cce:	75 25                	jne    817cf5 <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817cd0:	48 bf d0 2b 82 00 00 	movabs $0x822bd0,%rdi
  817cd7:	00 00 00 
  817cda:	b8 00 00 00 00       	mov    $0x0,%eax
  817cdf:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  817ce6:	00 00 00 
  817ce9:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817ceb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817cf0:	e9 b2 00 00 00       	jmpq   817da7 <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  817cf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817cf9:	48 8b 40 10          	mov    0x10(%rax),%rax
  817cfd:	48 85 c0             	test   %rax,%rax
  817d00:	74 14                	je     817d16 <sys_sem_new+0x6b>
  817d02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d06:	48 8b 40 10          	mov    0x10(%rax),%rax
  817d0a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817d0e:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817d12:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817d16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d1a:	48 8b 40 18          	mov    0x18(%rax),%rax
  817d1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817d22:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817d26:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d2d:	8b 00                	mov    (%rax),%eax
  817d2f:	85 c0                	test   %eax,%eax
  817d31:	75 35                	jne    817d68 <sys_sem_new+0xbd>
  817d33:	48 b9 f6 2b 82 00 00 	movabs $0x822bf6,%rcx
  817d3a:	00 00 00 
  817d3d:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817d44:	00 00 00 
  817d47:	be 8d 00 00 00       	mov    $0x8d,%esi
  817d4c:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  817d53:	00 00 00 
  817d56:	b8 00 00 00 00       	mov    $0x0,%eax
  817d5b:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  817d62:	00 00 00 
  817d65:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817d68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d6c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817d72:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817d76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d7a:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  817d7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d82:	8b 40 04             	mov    0x4(%rax),%eax
  817d85:	8d 50 01             	lea    0x1(%rax),%edx
  817d88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817d8c:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  817d8f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817d93:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817d9a:	00 00 00 
  817d9d:	48 29 c2             	sub    %rax,%rdx
  817da0:	48 89 d0             	mov    %rdx,%rax
  817da3:	48 c1 f8 05          	sar    $0x5,%rax
}
  817da7:	c9                   	leaveq 
  817da8:	c3                   	retq   

0000000000817da9 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817da9:	55                   	push   %rbp
  817daa:	48 89 e5             	mov    %rsp,%rbp
  817dad:	53                   	push   %rbx
  817dae:	48 83 ec 18          	sub    $0x18,%rsp
  817db2:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!sems[sem].freed);
  817db5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817dbc:	00 00 00 
  817dbf:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817dc2:	48 63 d2             	movslq %edx,%rdx
  817dc5:	48 c1 e2 05          	shl    $0x5,%rdx
  817dc9:	48 01 d0             	add    %rdx,%rax
  817dcc:	8b 00                	mov    (%rax),%eax
  817dce:	85 c0                	test   %eax,%eax
  817dd0:	74 35                	je     817e07 <sys_sem_free+0x5e>
  817dd2:	48 b9 00 2c 82 00 00 	movabs $0x822c00,%rcx
  817dd9:	00 00 00 
  817ddc:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817de3:	00 00 00 
  817de6:	be 98 00 00 00       	mov    $0x98,%esi
  817deb:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  817df2:	00 00 00 
  817df5:	b8 00 00 00 00       	mov    $0x0,%eax
  817dfa:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  817e01:	00 00 00 
  817e04:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  817e07:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e0e:	00 00 00 
  817e11:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817e14:	48 63 d2             	movslq %edx,%rdx
  817e17:	48 c1 e2 05          	shl    $0x5,%rdx
  817e1b:	48 01 d0             	add    %rdx,%rax
  817e1e:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  817e24:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e2b:	00 00 00 
  817e2e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817e31:	48 63 d2             	movslq %edx,%rdx
  817e34:	48 c1 e2 05          	shl    $0x5,%rdx
  817e38:	48 01 d0             	add    %rdx,%rax
  817e3b:	8b 40 04             	mov    0x4(%rax),%eax
  817e3e:	8d 50 01             	lea    0x1(%rax),%edx
  817e41:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e48:	00 00 00 
  817e4b:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817e4e:	48 63 c9             	movslq %ecx,%rcx
  817e51:	48 c1 e1 05          	shl    $0x5,%rcx
  817e55:	48 01 c8             	add    %rcx,%rax
  817e58:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  817e5b:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817e62:	00 00 00 
  817e65:	48 8b 00             	mov    (%rax),%rax
  817e68:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817e6f:	00 00 00 
  817e72:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817e75:	48 63 c9             	movslq %ecx,%rcx
  817e78:	48 c1 e1 05          	shl    $0x5,%rcx
  817e7c:	48 01 ca             	add    %rcx,%rdx
  817e7f:	48 83 c2 10          	add    $0x10,%rdx
  817e83:	48 89 02             	mov    %rax,(%rdx)
  817e86:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e8d:	00 00 00 
  817e90:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817e93:	48 63 d2             	movslq %edx,%rdx
  817e96:	48 c1 e2 05          	shl    $0x5,%rdx
  817e9a:	48 01 d0             	add    %rdx,%rax
  817e9d:	48 83 c0 10          	add    $0x10,%rax
  817ea1:	48 8b 00             	mov    (%rax),%rax
  817ea4:	48 85 c0             	test   %rax,%rax
  817ea7:	74 2c                	je     817ed5 <sys_sem_free+0x12c>
  817ea9:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817eb0:	00 00 00 
  817eb3:	48 8b 00             	mov    (%rax),%rax
  817eb6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817eb9:	48 63 d2             	movslq %edx,%rdx
  817ebc:	48 c1 e2 05          	shl    $0x5,%rdx
  817ec0:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  817ec4:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817ecb:	00 00 00 
  817ece:	48 01 ca             	add    %rcx,%rdx
  817ed1:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817ed5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ed8:	48 98                	cltq   
  817eda:	48 c1 e0 05          	shl    $0x5,%rax
  817ede:	48 89 c2             	mov    %rax,%rdx
  817ee1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ee8:	00 00 00 
  817eeb:	48 01 c2             	add    %rax,%rdx
  817eee:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817ef5:	00 00 00 
  817ef8:	48 89 10             	mov    %rdx,(%rax)
  817efb:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f02:	00 00 00 
  817f05:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817f08:	48 63 d2             	movslq %edx,%rdx
  817f0b:	48 c1 e2 05          	shl    $0x5,%rdx
  817f0f:	48 01 d0             	add    %rdx,%rax
  817f12:	48 83 c0 10          	add    $0x10,%rax
  817f16:	48 bb 20 d8 b4 00 00 	movabs $0xb4d820,%rbx
  817f1d:	00 00 00 
  817f20:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  817f24:	48 83 c4 18          	add    $0x18,%rsp
  817f28:	5b                   	pop    %rbx
  817f29:	5d                   	pop    %rbp
  817f2a:	c3                   	retq   

0000000000817f2b <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  817f2b:	55                   	push   %rbp
  817f2c:	48 89 e5             	mov    %rsp,%rbp
  817f2f:	48 83 ec 10          	sub    $0x10,%rsp
  817f33:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817f36:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f3d:	00 00 00 
  817f40:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817f43:	48 63 d2             	movslq %edx,%rdx
  817f46:	48 c1 e2 05          	shl    $0x5,%rdx
  817f4a:	48 01 d0             	add    %rdx,%rax
  817f4d:	8b 00                	mov    (%rax),%eax
  817f4f:	85 c0                	test   %eax,%eax
  817f51:	74 35                	je     817f88 <sys_sem_signal+0x5d>
  817f53:	48 b9 00 2c 82 00 00 	movabs $0x822c00,%rcx
  817f5a:	00 00 00 
  817f5d:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  817f64:	00 00 00 
  817f67:	be a1 00 00 00       	mov    $0xa1,%esi
  817f6c:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  817f73:	00 00 00 
  817f76:	b8 00 00 00 00       	mov    $0x0,%eax
  817f7b:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  817f82:	00 00 00 
  817f85:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  817f88:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f8f:	00 00 00 
  817f92:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817f95:	48 63 d2             	movslq %edx,%rdx
  817f98:	48 c1 e2 05          	shl    $0x5,%rdx
  817f9c:	48 01 d0             	add    %rdx,%rax
  817f9f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817fa3:	8d 50 01             	lea    0x1(%rax),%edx
  817fa6:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fad:	00 00 00 
  817fb0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817fb3:	48 63 c9             	movslq %ecx,%rcx
  817fb6:	48 c1 e1 05          	shl    $0x5,%rcx
  817fba:	48 01 c8             	add    %rcx,%rax
  817fbd:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  817fc1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fc8:	00 00 00 
  817fcb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817fce:	48 63 d2             	movslq %edx,%rdx
  817fd1:	48 c1 e2 05          	shl    $0x5,%rdx
  817fd5:	48 01 d0             	add    %rdx,%rax
  817fd8:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  817fdc:	66 85 c0             	test   %ax,%ax
  817fdf:	74 49                	je     81802a <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  817fe1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fe8:	00 00 00 
  817feb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817fee:	48 63 d2             	movslq %edx,%rdx
  817ff1:	48 c1 e2 05          	shl    $0x5,%rdx
  817ff5:	48 01 d0             	add    %rdx,%rax
  817ff8:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  817ffe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818001:	48 98                	cltq   
  818003:	48 c1 e0 05          	shl    $0x5,%rax
  818007:	48 89 c2             	mov    %rax,%rdx
  81800a:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818011:	00 00 00 
  818014:	48 01 d0             	add    %rdx,%rax
  818017:	48 83 c0 08          	add    $0x8,%rax
  81801b:	48 89 c7             	mov    %rax,%rdi
  81801e:	48 b8 a5 8a 81 00 00 	movabs $0x818aa5,%rax
  818025:	00 00 00 
  818028:	ff d0                	callq  *%rax
    }
}
  81802a:	c9                   	leaveq 
  81802b:	c3                   	retq   

000000000081802c <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  81802c:	55                   	push   %rbp
  81802d:	48 89 e5             	mov    %rsp,%rbp
  818030:	48 83 ec 30          	sub    $0x30,%rsp
  818034:	89 7d dc             	mov    %edi,-0x24(%rbp)
  818037:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  81803a:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818041:	00 00 00 
  818044:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818047:	48 63 d2             	movslq %edx,%rdx
  81804a:	48 c1 e2 05          	shl    $0x5,%rdx
  81804e:	48 01 d0             	add    %rdx,%rax
  818051:	8b 00                	mov    (%rax),%eax
  818053:	85 c0                	test   %eax,%eax
  818055:	74 35                	je     81808c <sys_arch_sem_wait+0x60>
  818057:	48 b9 00 2c 82 00 00 	movabs $0x822c00,%rcx
  81805e:	00 00 00 
  818061:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  818068:	00 00 00 
  81806b:	be ac 00 00 00       	mov    $0xac,%esi
  818070:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  818077:	00 00 00 
  81807a:	b8 00 00 00 00       	mov    $0x0,%eax
  81807f:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  818086:	00 00 00 
  818089:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  81808c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  818093:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81809a:	00 00 00 
  81809d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8180a0:	48 63 d2             	movslq %edx,%rdx
  8180a3:	48 c1 e2 05          	shl    $0x5,%rdx
  8180a7:	48 01 d0             	add    %rdx,%rax
  8180aa:	8b 40 04             	mov    0x4(%rax),%eax
  8180ad:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  8180b0:	e9 80 01 00 00       	jmpq   818235 <sys_arch_sem_wait+0x209>
	if (sems[sem].counter > 0) {
  8180b5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180bc:	00 00 00 
  8180bf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8180c2:	48 63 d2             	movslq %edx,%rdx
  8180c5:	48 c1 e2 05          	shl    $0x5,%rdx
  8180c9:	48 01 d0             	add    %rdx,%rax
  8180cc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8180d0:	66 85 c0             	test   %ax,%ax
  8180d3:	74 41                	je     818116 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  8180d5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180dc:	00 00 00 
  8180df:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8180e2:	48 63 d2             	movslq %edx,%rdx
  8180e5:	48 c1 e2 05          	shl    $0x5,%rdx
  8180e9:	48 01 d0             	add    %rdx,%rax
  8180ec:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8180f0:	8d 50 ff             	lea    -0x1(%rax),%edx
  8180f3:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180fa:	00 00 00 
  8180fd:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  818100:	48 63 c9             	movslq %ecx,%rcx
  818103:	48 c1 e1 05          	shl    $0x5,%rcx
  818107:	48 01 c8             	add    %rcx,%rax
  81810a:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  81810e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818111:	e9 3a 01 00 00       	jmpq   818250 <sys_arch_sem_wait+0x224>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  818116:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  81811a:	75 0a                	jne    818126 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  81811c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818121:	e9 2a 01 00 00       	jmpq   818250 <sys_arch_sem_wait+0x224>
	} else {
	    uint32_t a = sys_time_msec();
  818126:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  81812d:	00 00 00 
  818130:	ff d0                	callq  *%rax
  818132:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  818135:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818139:	74 0f                	je     81814a <sys_arch_sem_wait+0x11e>
  81813b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81813e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  818141:	29 c2                	sub    %eax,%edx
  818143:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818146:	01 d0                	add    %edx,%eax
  818148:	eb 05                	jmp    81814f <sys_arch_sem_wait+0x123>
  81814a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81814f:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  818152:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818159:	00 00 00 
  81815c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81815f:	48 63 d2             	movslq %edx,%rdx
  818162:	48 c1 e2 05          	shl    $0x5,%rdx
  818166:	48 01 d0             	add    %rdx,%rax
  818169:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  81816f:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818176:	00 00 00 
  818179:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81817c:	48 63 d2             	movslq %edx,%rdx
  81817f:	48 c1 e2 05          	shl    $0x5,%rdx
  818183:	48 01 d0             	add    %rdx,%rax
  818186:	8b 40 08             	mov    0x8(%rax),%eax
  818189:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  81818c:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  818193:	00 00 00 
  818196:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  818198:	8b 45 dc             	mov    -0x24(%rbp),%eax
  81819b:	48 98                	cltq   
  81819d:	48 c1 e0 05          	shl    $0x5,%rax
  8181a1:	48 89 c2             	mov    %rax,%rdx
  8181a4:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181ab:	00 00 00 
  8181ae:	48 01 d0             	add    %rdx,%rax
  8181b1:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8181b5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8181b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8181bb:	89 c6                	mov    %eax,%esi
  8181bd:	48 89 cf             	mov    %rcx,%rdi
  8181c0:	48 b8 f8 8a 81 00 00 	movabs $0x818af8,%rax
  8181c7:	00 00 00 
  8181ca:	ff d0                	callq  *%rax
	    lwip_core_lock();
  8181cc:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  8181d3:	00 00 00 
  8181d6:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  8181d8:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181df:	00 00 00 
  8181e2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8181e5:	48 63 d2             	movslq %edx,%rdx
  8181e8:	48 c1 e2 05          	shl    $0x5,%rdx
  8181ec:	48 01 d0             	add    %rdx,%rax
  8181ef:	8b 40 04             	mov    0x4(%rax),%eax
  8181f2:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  8181f5:	74 22                	je     818219 <sys_arch_sem_wait+0x1ed>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  8181f7:	48 bf 18 2c 82 00 00 	movabs $0x822c18,%rdi
  8181fe:	00 00 00 
  818201:	b8 00 00 00 00       	mov    $0x0,%eax
  818206:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  81820d:	00 00 00 
  818210:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  818212:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818217:	eb 37                	jmp    818250 <sys_arch_sem_wait+0x224>
	    }
	    uint32_t b = sys_time_msec();
  818219:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  818220:	00 00 00 
  818223:	ff d0                	callq  *%rax
  818225:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  818228:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81822b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  81822e:	29 c2                	sub    %eax,%edx
  818230:	89 d0                	mov    %edx,%eax
  818232:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  818235:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818239:	0f 84 76 fe ff ff    	je     8180b5 <sys_arch_sem_wait+0x89>
  81823f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818242:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  818245:	0f 82 6a fe ff ff    	jb     8180b5 <sys_arch_sem_wait+0x89>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  81824b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  818250:	c9                   	leaveq 
  818251:	c3                   	retq   

0000000000818252 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  818252:	55                   	push   %rbp
  818253:	48 89 e5             	mov    %rsp,%rbp
  818256:	48 83 ec 20          	sub    $0x20,%rsp
  81825a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81825d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818261:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  818264:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81826b:	00 00 00 
  81826e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818271:	48 63 d0             	movslq %eax,%rdx
  818274:	48 89 d0             	mov    %rdx,%rax
  818277:	48 c1 e0 03          	shl    $0x3,%rax
  81827b:	48 01 d0             	add    %rdx,%rax
  81827e:	48 c1 e0 02          	shl    $0x2,%rax
  818282:	48 01 d0             	add    %rdx,%rax
  818285:	48 c1 e0 03          	shl    $0x3,%rax
  818289:	48 01 c8             	add    %rcx,%rax
  81828c:	8b 00                	mov    (%rax),%eax
  81828e:	85 c0                	test   %eax,%eax
  818290:	74 35                	je     8182c7 <sys_arch_mbox_fetch+0x75>
  818292:	48 b9 91 2b 82 00 00 	movabs $0x822b91,%rcx
  818299:	00 00 00 
  81829c:	48 ba f9 2a 82 00 00 	movabs $0x822af9,%rdx
  8182a3:	00 00 00 
  8182a6:	be ce 00 00 00       	mov    $0xce,%esi
  8182ab:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8182b2:	00 00 00 
  8182b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8182ba:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8182c1:	00 00 00 
  8182c4:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  8182c7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8182ce:	00 00 00 
  8182d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8182d4:	48 63 d0             	movslq %eax,%rdx
  8182d7:	48 89 d0             	mov    %rdx,%rax
  8182da:	48 c1 e0 03          	shl    $0x3,%rax
  8182de:	48 01 d0             	add    %rdx,%rax
  8182e1:	48 c1 e0 02          	shl    $0x2,%rax
  8182e5:	48 01 d0             	add    %rdx,%rax
  8182e8:	48 c1 e0 03          	shl    $0x3,%rax
  8182ec:	48 01 c8             	add    %rcx,%rax
  8182ef:	48 05 10 01 00 00    	add    $0x110,%rax
  8182f5:	8b 00                	mov    (%rax),%eax
  8182f7:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8182fa:	89 d6                	mov    %edx,%esi
  8182fc:	89 c7                	mov    %eax,%edi
  8182fe:	48 b8 2c 80 81 00 00 	movabs $0x81802c,%rax
  818305:	00 00 00 
  818308:	ff d0                	callq  *%rax
  81830a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  81830d:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  818311:	75 08                	jne    81831b <sys_arch_mbox_fetch+0xc9>
	return waited;
  818313:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818316:	e9 ad 01 00 00       	jmpq   8184c8 <sys_arch_mbox_fetch+0x276>

    int slot = mboxes[mbox].head;
  81831b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818322:	00 00 00 
  818325:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818328:	48 63 d0             	movslq %eax,%rdx
  81832b:	48 89 d0             	mov    %rdx,%rax
  81832e:	48 c1 e0 03          	shl    $0x3,%rax
  818332:	48 01 d0             	add    %rdx,%rax
  818335:	48 c1 e0 02          	shl    $0x2,%rax
  818339:	48 01 d0             	add    %rdx,%rax
  81833c:	48 c1 e0 03          	shl    $0x3,%rax
  818340:	48 01 c8             	add    %rcx,%rax
  818343:	8b 40 04             	mov    0x4(%rax),%eax
  818346:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  818349:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  81834d:	75 2a                	jne    818379 <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  81834f:	48 ba 48 2c 82 00 00 	movabs $0x822c48,%rdx
  818356:	00 00 00 
  818359:	be d6 00 00 00       	mov    $0xd6,%esi
  81835e:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  818365:	00 00 00 
  818368:	b8 00 00 00 00       	mov    $0x0,%eax
  81836d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  818374:	00 00 00 
  818377:	ff d1                	callq  *%rcx
    if (msg)
  818379:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81837e:	74 39                	je     8183b9 <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  818380:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818387:	00 00 00 
  81838a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81838d:	48 63 f0             	movslq %eax,%rsi
  818390:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818393:	48 63 d0             	movslq %eax,%rdx
  818396:	48 89 d0             	mov    %rdx,%rax
  818399:	48 c1 e0 03          	shl    $0x3,%rax
  81839d:	48 01 d0             	add    %rdx,%rax
  8183a0:	48 c1 e0 02          	shl    $0x2,%rax
  8183a4:	48 01 d0             	add    %rdx,%rax
  8183a7:	48 01 f0             	add    %rsi,%rax
  8183aa:	48 83 c0 02          	add    $0x2,%rax
  8183ae:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  8183b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8183b6:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  8183b9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8183bc:	8d 50 01             	lea    0x1(%rax),%edx
  8183bf:	89 d0                	mov    %edx,%eax
  8183c1:	c1 f8 1f             	sar    $0x1f,%eax
  8183c4:	c1 e8 1b             	shr    $0x1b,%eax
  8183c7:	01 c2                	add    %eax,%edx
  8183c9:	83 e2 1f             	and    $0x1f,%edx
  8183cc:	29 c2                	sub    %eax,%edx
  8183ce:	89 d0                	mov    %edx,%eax
  8183d0:	89 c1                	mov    %eax,%ecx
  8183d2:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8183d9:	00 00 00 
  8183dc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8183df:	48 63 d0             	movslq %eax,%rdx
  8183e2:	48 89 d0             	mov    %rdx,%rax
  8183e5:	48 c1 e0 03          	shl    $0x3,%rax
  8183e9:	48 01 d0             	add    %rdx,%rax
  8183ec:	48 c1 e0 02          	shl    $0x2,%rax
  8183f0:	48 01 d0             	add    %rdx,%rax
  8183f3:	48 c1 e0 03          	shl    $0x3,%rax
  8183f7:	48 01 f0             	add    %rsi,%rax
  8183fa:	89 48 04             	mov    %ecx,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  8183fd:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818404:	00 00 00 
  818407:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81840a:	48 63 d0             	movslq %eax,%rdx
  81840d:	48 89 d0             	mov    %rdx,%rax
  818410:	48 c1 e0 03          	shl    $0x3,%rax
  818414:	48 01 d0             	add    %rdx,%rax
  818417:	48 c1 e0 02          	shl    $0x2,%rax
  81841b:	48 01 d0             	add    %rdx,%rax
  81841e:	48 c1 e0 03          	shl    $0x3,%rax
  818422:	48 01 c8             	add    %rcx,%rax
  818425:	8b 48 04             	mov    0x4(%rax),%ecx
  818428:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  81842f:	00 00 00 
  818432:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818435:	48 63 d0             	movslq %eax,%rdx
  818438:	48 89 d0             	mov    %rdx,%rax
  81843b:	48 c1 e0 03          	shl    $0x3,%rax
  81843f:	48 01 d0             	add    %rdx,%rax
  818442:	48 c1 e0 02          	shl    $0x2,%rax
  818446:	48 01 d0             	add    %rdx,%rax
  818449:	48 c1 e0 03          	shl    $0x3,%rax
  81844d:	48 01 f0             	add    %rsi,%rax
  818450:	8b 40 08             	mov    0x8(%rax),%eax
  818453:	39 c1                	cmp    %eax,%ecx
  818455:	75 2f                	jne    818486 <sys_arch_mbox_fetch+0x234>
	mboxes[mbox].head = -1;
  818457:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81845e:	00 00 00 
  818461:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818464:	48 63 d0             	movslq %eax,%rdx
  818467:	48 89 d0             	mov    %rdx,%rax
  81846a:	48 c1 e0 03          	shl    $0x3,%rax
  81846e:	48 01 d0             	add    %rdx,%rax
  818471:	48 c1 e0 02          	shl    $0x2,%rax
  818475:	48 01 d0             	add    %rdx,%rax
  818478:	48 c1 e0 03          	shl    $0x3,%rax
  81847c:	48 01 c8             	add    %rcx,%rax
  81847f:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  818486:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81848d:	00 00 00 
  818490:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818493:	48 63 d0             	movslq %eax,%rdx
  818496:	48 89 d0             	mov    %rdx,%rax
  818499:	48 c1 e0 03          	shl    $0x3,%rax
  81849d:	48 01 d0             	add    %rdx,%rax
  8184a0:	48 c1 e0 02          	shl    $0x2,%rax
  8184a4:	48 01 d0             	add    %rdx,%rax
  8184a7:	48 c1 e0 03          	shl    $0x3,%rax
  8184ab:	48 01 c8             	add    %rcx,%rax
  8184ae:	48 05 10 01 00 00    	add    $0x110,%rax
  8184b4:	8b 40 04             	mov    0x4(%rax),%eax
  8184b7:	89 c7                	mov    %eax,%edi
  8184b9:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  8184c0:	00 00 00 
  8184c3:	ff d0                	callq  *%rax
    return waited;
  8184c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8184c8:	c9                   	leaveq 
  8184c9:	c3                   	retq   

00000000008184ca <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  8184ca:	55                   	push   %rbp
  8184cb:	48 89 e5             	mov    %rsp,%rbp
  8184ce:	48 83 ec 10          	sub    $0x10,%rsp
  8184d2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8184d5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  8184d9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8184dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8184e0:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  8184e5:	48 89 ce             	mov    %rcx,%rsi
  8184e8:	89 c7                	mov    %eax,%edi
  8184ea:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  8184f1:	00 00 00 
  8184f4:	ff d0                	callq  *%rax
}
  8184f6:	c9                   	leaveq 
  8184f7:	c3                   	retq   

00000000008184f8 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  8184f8:	55                   	push   %rbp
  8184f9:	48 89 e5             	mov    %rsp,%rbp
  8184fc:	48 83 ec 20          	sub    $0x20,%rsp
  818500:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  818504:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818508:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  81850c:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  818513:	00 00 00 
  818516:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  818518:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81851c:	48 8b 00             	mov    (%rax),%rax
  81851f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818523:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  818527:	48 89 d7             	mov    %rdx,%rdi
  81852a:	ff d0                	callq  *%rax
    lwip_core_unlock();
  81852c:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  818533:	00 00 00 
  818536:	ff d0                	callq  *%rax
    free(lt);
  818538:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81853c:	48 89 c7             	mov    %rax,%rdi
  81853f:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  818546:	00 00 00 
  818549:	ff d0                	callq  *%rax
}
  81854b:	c9                   	leaveq 
  81854c:	c3                   	retq   

000000000081854d <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81854d:	55                   	push   %rbp
  81854e:	48 89 e5             	mov    %rsp,%rbp
  818551:	48 83 ec 30          	sub    $0x30,%rsp
  818555:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818559:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81855d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818561:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  818564:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  818568:	bf 10 00 00 00       	mov    $0x10,%edi
  81856d:	48 b8 d6 4c 80 00 00 	movabs $0x804cd6,%rax
  818574:	00 00 00 
  818577:	ff d0                	callq  *%rax
  818579:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  81857d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818582:	75 2a                	jne    8185ae <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  818584:	48 ba 70 2c 82 00 00 	movabs $0x822c70,%rdx
  81858b:	00 00 00 
  81858e:	be fd 00 00 00       	mov    $0xfd,%esi
  818593:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  81859a:	00 00 00 
  81859d:	b8 00 00 00 00       	mov    $0x0,%eax
  8185a2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8185a9:	00 00 00 
  8185ac:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  8185ae:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  8185b5:	7e 30                	jle    8185e7 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  8185b7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8185ba:	89 c1                	mov    %eax,%ecx
  8185bc:	48 ba 9e 2c 82 00 00 	movabs $0x822c9e,%rdx
  8185c3:	00 00 00 
  8185c6:	be 00 01 00 00       	mov    $0x100,%esi
  8185cb:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8185d2:	00 00 00 
  8185d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8185da:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  8185e1:	00 00 00 
  8185e4:	41 ff d0             	callq  *%r8

    lt->func = thread;
  8185e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8185eb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8185ef:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  8185f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8185f6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8185fa:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  8185fe:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818602:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  818606:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  81860a:	48 89 d1             	mov    %rdx,%rcx
  81860d:	48 ba f8 84 81 00 00 	movabs $0x8184f8,%rdx
  818614:	00 00 00 
  818617:	48 89 c7             	mov    %rax,%rdi
  81861a:	48 b8 6d 8d 81 00 00 	movabs $0x818d6d,%rax
  818621:	00 00 00 
  818624:	ff d0                	callq  *%rax
  818626:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  818629:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81862d:	79 3f                	jns    81866e <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  81862f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818632:	89 c7                	mov    %eax,%edi
  818634:	48 b8 f5 93 81 00 00 	movabs $0x8193f5,%rax
  81863b:	00 00 00 
  81863e:	ff d0                	callq  *%rax
  818640:	48 89 c1             	mov    %rax,%rcx
  818643:	48 ba b0 2c 82 00 00 	movabs $0x822cb0,%rdx
  81864a:	00 00 00 
  81864d:	be 09 01 00 00       	mov    $0x109,%esi
  818652:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  818659:	00 00 00 
  81865c:	b8 00 00 00 00       	mov    $0x0,%eax
  818661:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  818668:	00 00 00 
  81866b:	41 ff d0             	callq  *%r8

    return tid;
  81866e:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  818671:	c9                   	leaveq 
  818672:	c3                   	retq   

0000000000818673 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  818673:	55                   	push   %rbp
  818674:	48 89 e5             	mov    %rsp,%rbp
  818677:	48 83 ec 20          	sub    $0x20,%rsp
  81867b:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  81867e:	48 b8 7d 89 81 00 00 	movabs $0x81897d,%rax
  818685:	00 00 00 
  818688:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  81868a:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  81868d:	89 ca                	mov    %ecx,%edx
  81868f:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818694:	48 0f af c2          	imul   %rdx,%rax
  818698:	48 c1 e8 20          	shr    $0x20,%rax
  81869c:	89 c2                	mov    %eax,%edx
  81869e:	c1 ea 08             	shr    $0x8,%edx
  8186a1:	89 d0                	mov    %edx,%eax
  8186a3:	c1 e0 08             	shl    $0x8,%eax
  8186a6:	01 d0                	add    %edx,%eax
  8186a8:	29 c1                	sub    %eax,%ecx
  8186aa:	89 ca                	mov    %ecx,%edx
  8186ac:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8186b3:	00 00 00 
  8186b6:	89 d2                	mov    %edx,%edx
  8186b8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8186bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8186c0:	eb 60                	jmp    818722 <timeout_cleanup+0xaf>
	if (t->tid == tid) {
  8186c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186c6:	8b 00                	mov    (%rax),%eax
  8186c8:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8186cb:	75 49                	jne    818716 <timeout_cleanup+0xa3>
	    LIST_REMOVE(t, link);
  8186cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186d1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8186d5:	48 85 c0             	test   %rax,%rax
  8186d8:	74 14                	je     8186ee <timeout_cleanup+0x7b>
  8186da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186de:	48 8b 40 10          	mov    0x10(%rax),%rax
  8186e2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8186e6:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8186ea:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8186ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186f2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8186f6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8186fa:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8186fe:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  818701:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818705:	48 89 c7             	mov    %rax,%rdi
  818708:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  81870f:	00 00 00 
  818712:	ff d0                	callq  *%rax
	    goto done;
  818714:	eb 13                	jmp    818729 <timeout_cleanup+0xb6>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818716:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81871a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81871e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818722:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818727:	75 99                	jne    8186c2 <timeout_cleanup+0x4f>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  818729:	48 b8 83 89 81 00 00 	movabs $0x818983,%rax
  818730:	00 00 00 
  818733:	ff d0                	callq  *%rax
}
  818735:	c9                   	leaveq 
  818736:	c3                   	retq   

0000000000818737 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818737:	55                   	push   %rbp
  818738:	48 89 e5             	mov    %rsp,%rbp
  81873b:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  81873f:	48 b8 90 8a 81 00 00 	movabs $0x818a90,%rax
  818746:	00 00 00 
  818749:	ff d0                	callq  *%rax
  81874b:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  81874e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818751:	89 ca                	mov    %ecx,%edx
  818753:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818758:	48 0f af c2          	imul   %rdx,%rax
  81875c:	48 c1 e8 20          	shr    $0x20,%rax
  818760:	89 c2                	mov    %eax,%edx
  818762:	c1 ea 08             	shr    $0x8,%edx
  818765:	89 d0                	mov    %edx,%eax
  818767:	c1 e0 08             	shl    $0x8,%eax
  81876a:	01 d0                	add    %edx,%eax
  81876c:	29 c1                	sub    %eax,%ecx
  81876e:	89 ca                	mov    %ecx,%edx
  818770:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818777:	00 00 00 
  81877a:	89 d2                	mov    %edx,%edx
  81877c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818780:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818784:	eb 1c                	jmp    8187a2 <sys_arch_timeouts+0x6b>
	if (t->tid == tid)
  818786:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81878a:	8b 00                	mov    (%rax),%eax
  81878c:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  81878f:	75 05                	jne    818796 <sys_arch_timeouts+0x5f>
	    goto out;
  818791:	e9 dd 01 00 00       	jmpq   818973 <sys_arch_timeouts+0x23c>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818796:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81879a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81879e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8187a2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8187a7:	75 dd                	jne    818786 <sys_arch_timeouts+0x4f>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  8187a9:	bf 20 00 00 00       	mov    $0x20,%edi
  8187ae:	48 b8 d6 4c 80 00 00 	movabs $0x804cd6,%rax
  8187b5:	00 00 00 
  8187b8:	ff d0                	callq  *%rax
  8187ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  8187be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8187c3:	75 2a                	jne    8187ef <sys_arch_timeouts+0xb8>
	panic("sys_arch_timeouts: cannot malloc");
  8187c5:	48 ba e0 2c 82 00 00 	movabs $0x822ce0,%rdx
  8187cc:	00 00 00 
  8187cf:	be 2c 01 00 00       	mov    $0x12c,%esi
  8187d4:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  8187db:	00 00 00 
  8187de:	b8 00 00 00 00       	mov    $0x0,%eax
  8187e3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8187ea:	00 00 00 
  8187ed:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  8187ef:	48 bf 73 86 81 00 00 	movabs $0x818673,%rdi
  8187f6:	00 00 00 
  8187f9:	48 b8 26 8c 81 00 00 	movabs $0x818c26,%rax
  818800:	00 00 00 
  818803:	ff d0                	callq  *%rax
  818805:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  818808:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  81880c:	79 3f                	jns    81884d <sys_arch_timeouts+0x116>
	panic("thread_onhalt failed: %s", e2s(r));
  81880e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818811:	89 c7                	mov    %eax,%edi
  818813:	48 b8 f5 93 81 00 00 	movabs $0x8193f5,%rax
  81881a:	00 00 00 
  81881d:	ff d0                	callq  *%rax
  81881f:	48 89 c1             	mov    %rax,%rcx
  818822:	48 ba 01 2d 82 00 00 	movabs $0x822d01,%rdx
  818829:	00 00 00 
  81882c:	be 30 01 00 00       	mov    $0x130,%esi
  818831:	48 bf 0e 2b 82 00 00 	movabs $0x822b0e,%rdi
  818838:	00 00 00 
  81883b:	b8 00 00 00 00       	mov    $0x0,%eax
  818840:	49 b8 4e 11 80 00 00 	movabs $0x80114e,%r8
  818847:	00 00 00 
  81884a:	41 ff d0             	callq  *%r8

    t->tid = tid;
  81884d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818851:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818854:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818856:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81885a:	48 83 c0 08          	add    $0x8,%rax
  81885e:	ba 08 00 00 00       	mov    $0x8,%edx
  818863:	be 00 00 00 00       	mov    $0x0,%esi
  818868:	48 89 c7             	mov    %rax,%rdi
  81886b:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  818872:	00 00 00 
  818875:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  818877:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81887a:	89 ca                	mov    %ecx,%edx
  81887c:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818881:	48 0f af c2          	imul   %rdx,%rax
  818885:	48 c1 e8 20          	shr    $0x20,%rax
  818889:	89 c2                	mov    %eax,%edx
  81888b:	c1 ea 08             	shr    $0x8,%edx
  81888e:	89 d0                	mov    %edx,%eax
  818890:	c1 e0 08             	shl    $0x8,%eax
  818893:	01 d0                	add    %edx,%eax
  818895:	29 c1                	sub    %eax,%ecx
  818897:	89 ca                	mov    %ecx,%edx
  818899:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8188a0:	00 00 00 
  8188a3:	89 d2                	mov    %edx,%edx
  8188a5:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8188a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188ad:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8188b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188b5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8188b9:	48 85 c0             	test   %rax,%rax
  8188bc:	74 3e                	je     8188fc <sys_arch_timeouts+0x1c5>
  8188be:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8188c1:	89 ca                	mov    %ecx,%edx
  8188c3:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8188c8:	48 0f af c2          	imul   %rdx,%rax
  8188cc:	48 c1 e8 20          	shr    $0x20,%rax
  8188d0:	89 c2                	mov    %eax,%edx
  8188d2:	c1 ea 08             	shr    $0x8,%edx
  8188d5:	89 d0                	mov    %edx,%eax
  8188d7:	c1 e0 08             	shl    $0x8,%eax
  8188da:	01 d0                	add    %edx,%eax
  8188dc:	29 c1                	sub    %eax,%ecx
  8188de:	89 ca                	mov    %ecx,%edx
  8188e0:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8188e7:	00 00 00 
  8188ea:	89 d2                	mov    %edx,%edx
  8188ec:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8188f0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8188f4:	48 83 c2 10          	add    $0x10,%rdx
  8188f8:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8188fc:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8188ff:	89 ca                	mov    %ecx,%edx
  818901:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818906:	48 0f af c2          	imul   %rdx,%rax
  81890a:	48 c1 e8 20          	shr    $0x20,%rax
  81890e:	89 c2                	mov    %eax,%edx
  818910:	c1 ea 08             	shr    $0x8,%edx
  818913:	89 d0                	mov    %edx,%eax
  818915:	c1 e0 08             	shl    $0x8,%eax
  818918:	01 d0                	add    %edx,%eax
  81891a:	29 c1                	sub    %eax,%ecx
  81891c:	89 ca                	mov    %ecx,%edx
  81891e:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818925:	00 00 00 
  818928:	89 d2                	mov    %edx,%edx
  81892a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81892e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  818932:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818935:	89 ca                	mov    %ecx,%edx
  818937:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  81893c:	48 0f af c2          	imul   %rdx,%rax
  818940:	48 c1 e8 20          	shr    $0x20,%rax
  818944:	89 c2                	mov    %eax,%edx
  818946:	c1 ea 08             	shr    $0x8,%edx
  818949:	89 d0                	mov    %edx,%eax
  81894b:	c1 e0 08             	shl    $0x8,%eax
  81894e:	01 d0                	add    %edx,%eax
  818950:	29 c1                	sub    %eax,%ecx
  818952:	89 ca                	mov    %ecx,%edx
  818954:	89 d0                	mov    %edx,%eax
  818956:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81895d:	00 
  81895e:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818965:	00 00 00 
  818968:	48 01 c2             	add    %rax,%rdx
  81896b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81896f:	48 89 50 18          	mov    %rdx,0x18(%rax)

out:
    return &t->tmo;
  818973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818977:	48 83 c0 08          	add    $0x8,%rax
}
  81897b:	c9                   	leaveq 
  81897c:	c3                   	retq   

000000000081897d <lwip_core_lock>:

void
lwip_core_lock(void)
{
  81897d:	55                   	push   %rbp
  81897e:	48 89 e5             	mov    %rsp,%rbp
}
  818981:	5d                   	pop    %rbp
  818982:	c3                   	retq   

0000000000818983 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  818983:	55                   	push   %rbp
  818984:	48 89 e5             	mov    %rsp,%rbp
}
  818987:	5d                   	pop    %rbp
  818988:	c3                   	retq   

0000000000818989 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  818989:	55                   	push   %rbp
  81898a:	48 89 e5             	mov    %rsp,%rbp
  81898d:	48 83 ec 08          	sub    $0x8,%rsp
  818991:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  818995:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818999:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  8189a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189a4:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8189ab:	00 
}
  8189ac:	c9                   	leaveq 
  8189ad:	c3                   	retq   

00000000008189ae <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  8189ae:	55                   	push   %rbp
  8189af:	48 89 e5             	mov    %rsp,%rbp
  8189b2:	48 83 ec 10          	sub    $0x10,%rsp
  8189b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8189ba:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  8189be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8189c2:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8189c9:	00 00 00 00 
    if (!tq->tq_first) {
  8189cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189d1:	48 8b 00             	mov    (%rax),%rax
  8189d4:	48 85 c0             	test   %rax,%rax
  8189d7:	75 19                	jne    8189f2 <threadq_push+0x44>
	tq->tq_first = tc;
  8189d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189dd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8189e1:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  8189e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8189ec:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8189f0:	eb 1f                	jmp    818a11 <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  8189f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8189fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8189fe:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  818a05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a09:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818a0d:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818a11:	c9                   	leaveq 
  818a12:	c3                   	retq   

0000000000818a13 <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  818a13:	55                   	push   %rbp
  818a14:	48 89 e5             	mov    %rsp,%rbp
  818a17:	48 83 ec 18          	sub    $0x18,%rsp
  818a1b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818a1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a23:	48 8b 00             	mov    (%rax),%rax
  818a26:	48 85 c0             	test   %rax,%rax
  818a29:	75 07                	jne    818a32 <threadq_pop+0x1f>
	return 0;
  818a2b:	b8 00 00 00 00       	mov    $0x0,%eax
  818a30:	eb 30                	jmp    818a62 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818a32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a36:	48 8b 00             	mov    (%rax),%rax
  818a39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818a3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a41:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  818a48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a4c:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818a4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a53:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818a5a:	00 00 00 00 
    return tc;
  818a5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818a62:	c9                   	leaveq 
  818a63:	c3                   	retq   

0000000000818a64 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  818a64:	55                   	push   %rbp
  818a65:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818a68:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818a6f:	00 00 00 
  818a72:	48 b8 89 89 81 00 00 	movabs $0x818989,%rax
  818a79:	00 00 00 
  818a7c:	ff d0                	callq  *%rax
    max_tid = 0;
  818a7e:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818a85:	00 00 00 
  818a88:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  818a8e:	5d                   	pop    %rbp
  818a8f:	c3                   	retq   

0000000000818a90 <thread_id>:

uint32_t
thread_id(void) {
  818a90:	55                   	push   %rbp
  818a91:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  818a94:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818a9b:	00 00 00 
  818a9e:	48 8b 00             	mov    (%rax),%rax
  818aa1:	8b 00                	mov    (%rax),%eax
}
  818aa3:	5d                   	pop    %rbp
  818aa4:	c3                   	retq   

0000000000818aa5 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  818aa5:	55                   	push   %rbp
  818aa6:	48 89 e5             	mov    %rsp,%rbp
  818aa9:	48 83 ec 18          	sub    $0x18,%rsp
  818aad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  818ab1:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818ab8:	00 00 00 
  818abb:	48 8b 00             	mov    (%rax),%rax
  818abe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818ac2:	eb 2b                	jmp    818aef <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  818ac4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ac8:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818acf:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  818ad3:	75 0b                	jne    818ae0 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  818ad5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ad9:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818ae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ae4:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818aeb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818aef:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818af4:	75 ce                	jne    818ac4 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  818af6:	c9                   	leaveq 
  818af7:	c3                   	retq   

0000000000818af8 <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  818af8:	55                   	push   %rbp
  818af9:	48 89 e5             	mov    %rsp,%rbp
  818afc:	48 83 ec 20          	sub    $0x20,%rsp
  818b00:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818b04:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  818b07:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818b0a:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  818b11:	00 00 00 
  818b14:	ff d0                	callq  *%rax
  818b16:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818b19:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818b1c:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818b1f:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b26:	00 00 00 
  818b29:	48 8b 00             	mov    (%rax),%rax
  818b2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818b30:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  818b37:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b3e:	00 00 00 
  818b41:	48 8b 00             	mov    (%rax),%rax
  818b44:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818b4b:	eb 53                	jmp    818ba0 <thread_wait+0xa8>
	if (p < s)
  818b4d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818b50:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818b53:	73 02                	jae    818b57 <thread_wait+0x5f>
	    break;
  818b55:	eb 51                	jmp    818ba8 <thread_wait+0xb0>
	if (addr && *addr != val)
  818b57:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818b5c:	74 0d                	je     818b6b <thread_wait+0x73>
  818b5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818b62:	8b 00                	mov    (%rax),%eax
  818b64:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818b67:	74 02                	je     818b6b <thread_wait+0x73>
	    break;
  818b69:	eb 3d                	jmp    818ba8 <thread_wait+0xb0>
	if (cur_tc->tc_wakeup)
  818b6b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b72:	00 00 00 
  818b75:	48 8b 00             	mov    (%rax),%rax
  818b78:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818b7f:	84 c0                	test   %al,%al
  818b81:	74 02                	je     818b85 <thread_wait+0x8d>
	    break;
  818b83:	eb 23                	jmp    818ba8 <thread_wait+0xb0>

	thread_yield();
  818b85:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  818b8c:	00 00 00 
  818b8f:	ff d0                	callq  *%rax
	p = sys_time_msec();
  818b91:	48 b8 66 2b 80 00 00 	movabs $0x802b66,%rax
  818b98:	00 00 00 
  818b9b:	ff d0                	callq  *%rax
  818b9d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  818ba0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818ba3:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818ba6:	72 a5                	jb     818b4d <thread_wait+0x55>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  818ba8:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818baf:	00 00 00 
  818bb2:	48 8b 00             	mov    (%rax),%rax
  818bb5:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818bbc:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  818bc0:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818bc7:	00 00 00 
  818bca:	48 8b 00             	mov    (%rax),%rax
  818bcd:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  818bd4:	c9                   	leaveq 
  818bd5:	c3                   	retq   

0000000000818bd6 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818bd6:	55                   	push   %rbp
  818bd7:	48 89 e5             	mov    %rsp,%rbp
  818bda:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818bde:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818be5:	00 00 00 
  818be8:	48 8b 00             	mov    (%rax),%rax
  818beb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818bef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818bf6:	eb 22                	jmp    818c1a <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818bf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bfc:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818c03:	84 c0                	test   %al,%al
  818c05:	74 04                	je     818c0b <thread_wakeups_pending+0x35>
	    ++n;
  818c07:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818c0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c0f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818c16:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818c1a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818c1f:	75 d7                	jne    818bf8 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  818c21:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  818c24:	c9                   	leaveq 
  818c25:	c3                   	retq   

0000000000818c26 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818c26:	55                   	push   %rbp
  818c27:	48 89 e5             	mov    %rsp,%rbp
  818c2a:	48 83 ec 08          	sub    $0x8,%rsp
  818c2e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  818c32:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c39:	00 00 00 
  818c3c:	48 8b 00             	mov    (%rax),%rax
  818c3f:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818c45:	83 f8 03             	cmp    $0x3,%eax
  818c48:	7e 07                	jle    818c51 <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818c4a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818c4f:	eb 3d                	jmp    818c8e <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  818c51:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c58:	00 00 00 
  818c5b:	48 8b 08             	mov    (%rax),%rcx
  818c5e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c65:	00 00 00 
  818c68:	48 8b 00             	mov    (%rax),%rax
  818c6b:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  818c71:	8d 72 01             	lea    0x1(%rdx),%esi
  818c74:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818c7a:	48 63 c2             	movslq %edx,%rax
  818c7d:	48 8d 50 18          	lea    0x18(%rax),%rdx
  818c81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c85:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818c89:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818c8e:	c9                   	leaveq 
  818c8f:	c3                   	retq   

0000000000818c90 <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  818c90:	55                   	push   %rbp
  818c91:	48 89 e5             	mov    %rsp,%rbp
  818c94:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818c98:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818c9f:	00 00 00 
  818ca2:	8b 00                	mov    (%rax),%eax
  818ca4:	8d 48 01             	lea    0x1(%rax),%ecx
  818ca7:	48 ba 70 74 b5 00 00 	movabs $0xb57470,%rdx
  818cae:	00 00 00 
  818cb1:	89 0a                	mov    %ecx,(%rdx)
  818cb3:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818cb6:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818cbd:	00 00 00 
  818cc0:	8b 00                	mov    (%rax),%eax
  818cc2:	83 f8 ff             	cmp    $0xffffffff,%eax
  818cc5:	75 2a                	jne    818cf1 <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818cc7:	48 ba 1a 2d 82 00 00 	movabs $0x822d1a,%rdx
  818cce:	00 00 00 
  818cd1:	be 54 00 00 00       	mov    $0x54,%esi
  818cd6:	48 bf 38 2d 82 00 00 	movabs $0x822d38,%rdi
  818cdd:	00 00 00 
  818ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  818ce5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  818cec:	00 00 00 
  818cef:	ff d1                	callq  *%rcx
    return tid;
  818cf1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818cf4:	c9                   	leaveq 
  818cf5:	c3                   	retq   

0000000000818cf6 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818cf6:	55                   	push   %rbp
  818cf7:	48 89 e5             	mov    %rsp,%rbp
  818cfa:	48 83 ec 10          	sub    $0x10,%rsp
  818cfe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818d02:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818d06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d0a:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818d0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818d12:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818d17:	48 89 c6             	mov    %rax,%rsi
  818d1a:	48 89 cf             	mov    %rcx,%rdi
  818d1d:	48 b8 ce 1f 80 00 00 	movabs $0x801fce,%rax
  818d24:	00 00 00 
  818d27:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d2d:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  818d31:	c9                   	leaveq 
  818d32:	c3                   	retq   

0000000000818d33 <thread_entry>:

static void
thread_entry(void) {
  818d33:	55                   	push   %rbp
  818d34:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818d37:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d3e:	00 00 00 
  818d41:	48 8b 00             	mov    (%rax),%rax
  818d44:	48 8b 40 30          	mov    0x30(%rax),%rax
  818d48:	48 ba 78 74 b5 00 00 	movabs $0xb57478,%rdx
  818d4f:	00 00 00 
  818d52:	48 8b 12             	mov    (%rdx),%rdx
  818d55:	8b 52 38             	mov    0x38(%rdx),%edx
  818d58:	89 d2                	mov    %edx,%edx
  818d5a:	48 89 d7             	mov    %rdx,%rdi
  818d5d:	ff d0                	callq  *%rax
    thread_halt();
  818d5f:	48 b8 73 8f 81 00 00 	movabs $0x818f73,%rax
  818d66:	00 00 00 
  818d69:	ff d0                	callq  *%rax
}
  818d6b:	5d                   	pop    %rbp
  818d6c:	c3                   	retq   

0000000000818d6d <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818d6d:	55                   	push   %rbp
  818d6e:	48 89 e5             	mov    %rsp,%rbp
  818d71:	48 83 ec 30          	sub    $0x30,%rsp
  818d75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818d79:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818d7d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818d81:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  818d85:	bf f0 00 00 00       	mov    $0xf0,%edi
  818d8a:	48 b8 d6 4c 80 00 00 	movabs $0x804cd6,%rax
  818d91:	00 00 00 
  818d94:	ff d0                	callq  *%rax
  818d96:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  818d9a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818d9f:	75 0a                	jne    818dab <thread_create+0x3e>
	return -E_NO_MEM;
  818da1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818da6:	e9 4d 01 00 00       	jmpq   818ef8 <thread_create+0x18b>

    memset(tc, 0, sizeof(struct thread_context));
  818dab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818daf:	ba f0 00 00 00       	mov    $0xf0,%edx
  818db4:	be 00 00 00 00       	mov    $0x0,%esi
  818db9:	48 89 c7             	mov    %rax,%rdi
  818dbc:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  818dc3:	00 00 00 
  818dc6:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818dc8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818dcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818dd0:	48 89 d6             	mov    %rdx,%rsi
  818dd3:	48 89 c7             	mov    %rax,%rdi
  818dd6:	48 b8 f6 8c 81 00 00 	movabs $0x818cf6,%rax
  818ddd:	00 00 00 
  818de0:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  818de2:	48 b8 90 8c 81 00 00 	movabs $0x818c90,%rax
  818de9:	00 00 00 
  818dec:	ff d0                	callq  *%rax
  818dee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818df2:	89 02                	mov    %eax,(%rdx)

    tc->tc_stack_bottom = malloc(stack_size);
  818df4:	bf 00 10 00 00       	mov    $0x1000,%edi
  818df9:	48 b8 d6 4c 80 00 00 	movabs $0x804cd6,%rax
  818e00:	00 00 00 
  818e03:	ff d0                	callq  *%rax
  818e05:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818e09:	48 89 42 08          	mov    %rax,0x8(%rdx)
    if (!tc->tc_stack_bottom) {
  818e0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e11:	48 8b 40 08          	mov    0x8(%rax),%rax
  818e15:	48 85 c0             	test   %rax,%rax
  818e18:	75 1d                	jne    818e37 <thread_create+0xca>
	free(tc);
  818e1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e1e:	48 89 c7             	mov    %rax,%rdi
  818e21:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  818e28:	00 00 00 
  818e2b:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  818e2d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818e32:	e9 c1 00 00 00       	jmpq   818ef8 <thread_create+0x18b>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  818e37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  818e3f:	48 05 00 10 00 00    	add    $0x1000,%rax
  818e45:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  818e49:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  818e4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818e52:	ba 08 00 00 00       	mov    $0x8,%edx
  818e57:	be 00 00 00 00       	mov    $0x0,%esi
  818e5c:	48 89 c7             	mov    %rax,%rdi
  818e5f:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  818e66:	00 00 00 
  818e69:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  818e6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e6f:	48 83 c0 40          	add    $0x40,%rax
  818e73:	ba 70 00 00 00       	mov    $0x70,%edx
  818e78:	be 00 00 00 00       	mov    $0x0,%esi
  818e7d:	48 89 c7             	mov    %rax,%rdi
  818e80:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  818e87:	00 00 00 
  818e8a:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  818e8c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818e90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e94:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  818e98:	48 ba 33 8d 81 00 00 	movabs $0x818d33,%rdx
  818e9f:	00 00 00 
  818ea2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ea6:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  818eaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818eae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  818eb2:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818eb6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818eba:	89 c2                	mov    %eax,%edx
  818ebc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ec0:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818ec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ec7:	48 89 c6             	mov    %rax,%rsi
  818eca:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818ed1:	00 00 00 
  818ed4:	48 b8 ae 89 81 00 00 	movabs $0x8189ae,%rax
  818edb:	00 00 00 
  818ede:	ff d0                	callq  *%rax

    if (tid)
  818ee0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818ee5:	74 0c                	je     818ef3 <thread_create+0x186>
	*tid = tc->tc_tid;
  818ee7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818eeb:	8b 10                	mov    (%rax),%edx
  818eed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818ef1:	89 10                	mov    %edx,(%rax)
    return 0;
  818ef3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818ef8:	c9                   	leaveq 
  818ef9:	c3                   	retq   

0000000000818efa <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  818efa:	55                   	push   %rbp
  818efb:	48 89 e5             	mov    %rsp,%rbp
  818efe:	48 83 ec 20          	sub    $0x20,%rsp
  818f02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  818f06:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818f0b:	75 02                	jne    818f0f <thread_clean+0x15>
  818f0d:	eb 62                	jmp    818f71 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818f0f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  818f16:	eb 20                	jmp    818f38 <thread_clean+0x3e>
	tc->tc_onhalt[i](tc->tc_tid);
  818f18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818f1c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818f1f:	48 63 d2             	movslq %edx,%rdx
  818f22:	48 83 c2 18          	add    $0x18,%rdx
  818f26:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818f2a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818f2e:	8b 12                	mov    (%rdx),%edx
  818f30:	89 d7                	mov    %edx,%edi
  818f32:	ff d0                	callq  *%rax
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818f34:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  818f38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818f3c:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818f42:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  818f45:	7f d1                	jg     818f18 <thread_clean+0x1e>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  818f47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818f4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  818f4f:	48 89 c7             	mov    %rax,%rdi
  818f52:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  818f59:	00 00 00 
  818f5c:	ff d0                	callq  *%rax
    free(tc);
  818f5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818f62:	48 89 c7             	mov    %rax,%rdi
  818f65:	48 b8 54 50 80 00 00 	movabs $0x805054,%rax
  818f6c:	00 00 00 
  818f6f:	ff d0                	callq  *%rax
}
  818f71:	c9                   	leaveq 
  818f72:	c3                   	retq   

0000000000818f73 <thread_halt>:

void
thread_halt() {
  818f73:	55                   	push   %rbp
  818f74:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  818f77:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818f7e:	00 00 00 
  818f81:	48 b8 13 8a 81 00 00 	movabs $0x818a13,%rax
  818f88:	00 00 00 
  818f8b:	ff d0                	callq  *%rax
  818f8d:	48 89 c7             	mov    %rax,%rdi
  818f90:	48 b8 fa 8e 81 00 00 	movabs $0x818efa,%rax
  818f97:	00 00 00 
  818f9a:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  818f9c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818fa3:	00 00 00 
  818fa6:	48 8b 00             	mov    (%rax),%rax
  818fa9:	48 89 c6             	mov    %rax,%rsi
  818fac:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818fb3:	00 00 00 
  818fb6:	48 b8 ae 89 81 00 00 	movabs $0x8189ae,%rax
  818fbd:	00 00 00 
  818fc0:	ff d0                	callq  *%rax
    cur_tc = NULL;
  818fc2:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818fc9:	00 00 00 
  818fcc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  818fd3:	48 b8 ed 8f 81 00 00 	movabs $0x818fed,%rax
  818fda:	00 00 00 
  818fdd:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  818fdf:	48 b8 2b 11 80 00 00 	movabs $0x80112b,%rax
  818fe6:	00 00 00 
  818fe9:	ff d0                	callq  *%rax
}
  818feb:	5d                   	pop    %rbp
  818fec:	c3                   	retq   

0000000000818fed <thread_yield>:

void
thread_yield(void) {
  818fed:	55                   	push   %rbp
  818fee:	48 89 e5             	mov    %rsp,%rbp
  818ff1:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  818ff5:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818ffc:	00 00 00 
  818fff:	48 b8 13 8a 81 00 00 	movabs $0x818a13,%rax
  819006:	00 00 00 
  819009:	ff d0                	callq  *%rax
  81900b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  81900f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819014:	75 05                	jne    81901b <thread_yield+0x2e>
	return;
  819016:	e9 94 00 00 00       	jmpq   8190af <thread_yield+0xc2>

    if (cur_tc) {
  81901b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819022:	00 00 00 
  819025:	48 8b 00             	mov    (%rax),%rax
  819028:	48 85 c0             	test   %rax,%rax
  81902b:	74 4c                	je     819079 <thread_yield+0x8c>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  81902d:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819034:	00 00 00 
  819037:	48 8b 00             	mov    (%rax),%rax
  81903a:	48 83 c0 40          	add    $0x40,%rax
  81903e:	48 89 c7             	mov    %rax,%rdi
  819041:	48 b8 10 93 81 00 00 	movabs $0x819310,%rax
  819048:	00 00 00 
  81904b:	ff d0                	callq  *%rax
  81904d:	85 c0                	test   %eax,%eax
  81904f:	74 02                	je     819053 <thread_yield+0x66>
	    return;
  819051:	eb 5c                	jmp    8190af <thread_yield+0xc2>
	threadq_push(&thread_queue, cur_tc);
  819053:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81905a:	00 00 00 
  81905d:	48 8b 00             	mov    (%rax),%rax
  819060:	48 89 c6             	mov    %rax,%rsi
  819063:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  81906a:	00 00 00 
  81906d:	48 b8 ae 89 81 00 00 	movabs $0x8189ae,%rax
  819074:	00 00 00 
  819077:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  819079:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819080:	00 00 00 
  819083:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819087:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  81908a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819091:	00 00 00 
  819094:	48 8b 00             	mov    (%rax),%rax
  819097:	48 83 c0 40          	add    $0x40,%rax
  81909b:	be 01 00 00 00       	mov    $0x1,%esi
  8190a0:	48 89 c7             	mov    %rax,%rdi
  8190a3:	48 b8 60 93 81 00 00 	movabs $0x819360,%rax
  8190aa:	00 00 00 
  8190ad:	ff d0                	callq  *%rax
}
  8190af:	c9                   	leaveq 
  8190b0:	c3                   	retq   

00000000008190b1 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  8190b1:	55                   	push   %rbp
  8190b2:	48 89 e5             	mov    %rsp,%rbp
  8190b5:	48 83 ec 10          	sub    $0x10,%rsp
  8190b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  8190bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190c1:	48 83 c0 10          	add    $0x10,%rax
  8190c5:	48 89 c6             	mov    %rax,%rsi
  8190c8:	48 bf 53 2d 82 00 00 	movabs $0x822d53,%rdi
  8190cf:	00 00 00 
  8190d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8190d7:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8190de:	00 00 00 
  8190e1:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  8190e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190e7:	48 8b 40 40          	mov    0x40(%rax),%rax
  8190eb:	48 89 c6             	mov    %rax,%rsi
  8190ee:	48 bf 6f 2d 82 00 00 	movabs $0x822d6f,%rdi
  8190f5:	00 00 00 
  8190f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8190fd:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819104:	00 00 00 
  819107:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  819109:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81910d:	48 8b 40 48          	mov    0x48(%rax),%rax
  819111:	48 89 c6             	mov    %rax,%rsi
  819114:	48 bf 79 2d 82 00 00 	movabs $0x822d79,%rdi
  81911b:	00 00 00 
  81911e:	b8 00 00 00 00       	mov    $0x0,%eax
  819123:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  81912a:	00 00 00 
  81912d:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  81912f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819133:	48 8b 40 50          	mov    0x50(%rax),%rax
  819137:	48 89 c6             	mov    %rax,%rsi
  81913a:	48 bf 83 2d 82 00 00 	movabs $0x822d83,%rdi
  819141:	00 00 00 
  819144:	b8 00 00 00 00       	mov    $0x0,%eax
  819149:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819150:	00 00 00 
  819153:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  819155:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819159:	48 8b 40 58          	mov    0x58(%rax),%rax
  81915d:	48 89 c6             	mov    %rax,%rsi
  819160:	48 bf 8d 2d 82 00 00 	movabs $0x822d8d,%rdi
  819167:	00 00 00 
  81916a:	b8 00 00 00 00       	mov    $0x0,%eax
  81916f:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819176:	00 00 00 
  819179:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  81917b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81917f:	48 8b 40 60          	mov    0x60(%rax),%rax
  819183:	48 89 c6             	mov    %rax,%rsi
  819186:	48 bf 97 2d 82 00 00 	movabs $0x822d97,%rdi
  81918d:	00 00 00 
  819190:	b8 00 00 00 00       	mov    $0x0,%eax
  819195:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  81919c:	00 00 00 
  81919f:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  8191a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191a5:	48 8b 40 68          	mov    0x68(%rax),%rax
  8191a9:	48 89 c6             	mov    %rax,%rsi
  8191ac:	48 bf a1 2d 82 00 00 	movabs $0x822da1,%rdi
  8191b3:	00 00 00 
  8191b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8191bb:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8191c2:	00 00 00 
  8191c5:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  8191c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191cb:	48 8b 40 70          	mov    0x70(%rax),%rax
  8191cf:	48 89 c6             	mov    %rax,%rsi
  8191d2:	48 bf ab 2d 82 00 00 	movabs $0x822dab,%rdi
  8191d9:	00 00 00 
  8191dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8191e1:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8191e8:	00 00 00 
  8191eb:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  8191ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191f1:	48 8b 40 78          	mov    0x78(%rax),%rax
  8191f5:	48 89 c6             	mov    %rax,%rsi
  8191f8:	48 bf b5 2d 82 00 00 	movabs $0x822db5,%rdi
  8191ff:	00 00 00 
  819202:	b8 00 00 00 00       	mov    $0x0,%eax
  819207:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  81920e:	00 00 00 
  819211:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  819213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819217:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81921e:	48 89 c6             	mov    %rax,%rsi
  819221:	48 bf bf 2d 82 00 00 	movabs $0x822dbf,%rdi
  819228:	00 00 00 
  81922b:	b8 00 00 00 00       	mov    $0x0,%eax
  819230:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819237:	00 00 00 
  81923a:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  81923c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819240:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  819247:	48 89 c6             	mov    %rax,%rsi
  81924a:	48 bf c9 2d 82 00 00 	movabs $0x822dc9,%rdi
  819251:	00 00 00 
  819254:	b8 00 00 00 00       	mov    $0x0,%eax
  819259:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819260:	00 00 00 
  819263:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  819265:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819269:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  819270:	48 89 c6             	mov    %rax,%rsi
  819273:	48 bf d3 2d 82 00 00 	movabs $0x822dd3,%rdi
  81927a:	00 00 00 
  81927d:	b8 00 00 00 00       	mov    $0x0,%eax
  819282:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819289:	00 00 00 
  81928c:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  81928e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819292:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  819299:	48 89 c6             	mov    %rax,%rsi
  81929c:	48 bf dd 2d 82 00 00 	movabs $0x822ddd,%rdi
  8192a3:	00 00 00 
  8192a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8192ab:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8192b2:	00 00 00 
  8192b5:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  8192b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8192bb:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8192c2:	48 89 c6             	mov    %rax,%rsi
  8192c5:	48 bf e7 2d 82 00 00 	movabs $0x822de7,%rdi
  8192cc:	00 00 00 
  8192cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8192d4:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  8192db:	00 00 00 
  8192de:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  8192e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8192e4:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8192eb:	48 89 c6             	mov    %rax,%rsi
  8192ee:	48 bf f0 2d 82 00 00 	movabs $0x822df0,%rdi
  8192f5:	00 00 00 
  8192f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8192fd:	48 ba 87 13 80 00 00 	movabs $0x801387,%rdx
  819304:	00 00 00 
  819307:	ff d2                	callq  *%rdx
}
  819309:	c9                   	leaveq 
  81930a:	c3                   	retq   
  81930b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819310 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819310:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819313:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819317:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81931a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81931f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  819323:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  819327:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  81932b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  81932f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  819333:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  819337:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  81933b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  81933f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  819343:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  819347:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  81934b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  81934f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  819353:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81935a:	c3                   	retq   
  81935b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819360 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  819360:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  819363:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  819366:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  819369:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81936d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  819371:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  819375:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  819379:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  81937d:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  819381:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  819385:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  819389:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  81938d:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  819391:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  819395:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  819399:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  81939d:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  8193a0:	ff e1                	jmpq   *%rcx

00000000008193a2 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  8193a2:	55                   	push   %rbp
  8193a3:	48 89 e5             	mov    %rsp,%rbp
  8193a6:	48 83 ec 20          	sub    $0x20,%rsp
  8193aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  8193ae:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8193b5:	00 00 00 
  8193b8:	8b 00                	mov    (%rax),%eax
  8193ba:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  8193bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8193c0:	89 c7                	mov    %eax,%edi
  8193c2:	48 b8 f5 93 81 00 00 	movabs $0x8193f5,%rax
  8193c9:	00 00 00 
  8193cc:	ff d0                	callq  *%rax
  8193ce:	48 89 c2             	mov    %rax,%rdx
  8193d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8193d5:	48 89 c6             	mov    %rax,%rsi
  8193d8:	48 bf dd 32 82 00 00 	movabs $0x8232dd,%rdi
  8193df:	00 00 00 
  8193e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8193e7:	48 b9 87 13 80 00 00 	movabs $0x801387,%rcx
  8193ee:	00 00 00 
  8193f1:	ff d1                	callq  *%rcx
}
  8193f3:	c9                   	leaveq 
  8193f4:	c3                   	retq   

00000000008193f5 <e2s>:

const char *
e2s(int err) {
  8193f5:	55                   	push   %rbp
  8193f6:	48 89 e5             	mov    %rsp,%rbp
  8193f9:	48 83 ec 04          	sub    $0x4,%rsp
  8193fd:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  819400:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  819407:	00 00 00 
  81940a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81940d:	48 63 d2             	movslq %edx,%rdx
  819410:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819414:	c9                   	leaveq 
  819415:	c3                   	retq   

0000000000819416 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819416:	55                   	push   %rbp
  819417:	48 89 e5             	mov    %rsp,%rbp
  81941a:	48 83 ec 08          	sub    $0x8,%rsp
  81941e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  819422:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819426:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  81942a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81942e:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  819434:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819438:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  81943c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819440:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  819444:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819448:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  81944c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819450:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  819454:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819458:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  81945c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819460:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  819464:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819468:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  81946c:	c9                   	leaveq 
  81946d:	c3                   	retq   

000000000081946e <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  81946e:	55                   	push   %rbp
  81946f:	48 89 e5             	mov    %rsp,%rbp
  819472:	48 83 ec 40          	sub    $0x40,%rsp
  819476:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81947a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  81947e:	ba 07 00 00 00       	mov    $0x7,%edx
  819483:	be 00 00 00 10       	mov    $0x10000000,%esi
  819488:	bf 00 00 00 00       	mov    $0x0,%edi
  81948d:	48 b8 6b 28 80 00 00 	movabs $0x80286b,%rax
  819494:	00 00 00 
  819497:	ff d0                	callq  *%rax
  819499:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  81949c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8194a0:	79 2a                	jns    8194cc <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  8194a2:	48 ba e8 32 82 00 00 	movabs $0x8232e8,%rdx
  8194a9:	00 00 00 
  8194ac:	be 55 00 00 00       	mov    $0x55,%esi
  8194b1:	48 bf 0f 33 82 00 00 	movabs $0x82330f,%rdi
  8194b8:	00 00 00 
  8194bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8194c0:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8194c7:	00 00 00 
  8194ca:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  8194cc:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  8194d3:	10 

    struct jif *jif;
    jif = netif->state;
  8194d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8194d8:	48 8b 40 30          	mov    0x30(%rax),%rax
  8194dc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  8194e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8194e4:	48 83 c0 04          	add    $0x4,%rax
  8194e8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  8194ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8194f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8194f7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8194fb:	e9 a0 00 00 00       	jmpq   8195a0 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819500:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819504:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819508:	0f b7 d0             	movzwl %ax,%edx
  81950b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81950e:	01 d0                	add    %edx,%eax
  819510:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819515:	7e 3e                	jle    819555 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819517:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81951b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81951f:	0f b7 c0             	movzwl %ax,%eax
  819522:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819525:	41 89 d0             	mov    %edx,%r8d
  819528:	89 c1                	mov    %eax,%ecx
  81952a:	48 ba 28 33 82 00 00 	movabs $0x823328,%rdx
  819531:	00 00 00 
  819534:	be 64 00 00 00       	mov    $0x64,%esi
  819539:	48 bf 0f 33 82 00 00 	movabs $0x82330f,%rdi
  819540:	00 00 00 
  819543:	b8 00 00 00 00       	mov    $0x0,%eax
  819548:	49 b9 4e 11 80 00 00 	movabs $0x80114e,%r9
  81954f:	00 00 00 
  819552:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  819555:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819559:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81955d:	0f b7 d0             	movzwl %ax,%edx
  819560:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819564:	48 8b 40 08          	mov    0x8(%rax),%rax
  819568:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81956b:	48 63 f1             	movslq %ecx,%rsi
  81956e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  819572:	48 01 f1             	add    %rsi,%rcx
  819575:	48 89 c6             	mov    %rax,%rsi
  819578:	48 89 cf             	mov    %rcx,%rdi
  81957b:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  819582:	00 00 00 
  819585:	ff d0                	callq  *%rax
	txsize += q->len;
  819587:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81958b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81958f:	0f b7 c0             	movzwl %ax,%eax
  819592:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819595:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819599:	48 8b 00             	mov    (%rax),%rax
  81959c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8195a0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8195a5:	0f 85 55 ff ff ff    	jne    819500 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  8195ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8195af:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8195b2:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  8195b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195b8:	8b 40 08             	mov    0x8(%rax),%eax
  8195bb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8195bf:	b9 07 00 00 00       	mov    $0x7,%ecx
  8195c4:	be 0b 00 00 00       	mov    $0xb,%esi
  8195c9:	89 c7                	mov    %eax,%edi
  8195cb:	48 b8 44 33 80 00 00 	movabs $0x803344,%rax
  8195d2:	00 00 00 
  8195d5:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  8195d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8195db:	48 89 c6             	mov    %rax,%rsi
  8195de:	bf 00 00 00 00       	mov    $0x0,%edi
  8195e3:	48 b8 16 29 80 00 00 	movabs $0x802916,%rax
  8195ea:	00 00 00 
  8195ed:	ff d0                	callq  *%rax

    return ERR_OK;
  8195ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8195f4:	c9                   	leaveq 
  8195f5:	c3                   	retq   

00000000008195f6 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  8195f6:	55                   	push   %rbp
  8195f7:	48 89 e5             	mov    %rsp,%rbp
  8195fa:	48 83 ec 50          	sub    $0x50,%rsp
  8195fe:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  819602:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819606:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  81960a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81960e:	8b 00                	mov    (%rax),%eax
  819610:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819614:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  819618:	0f b7 c0             	movzwl %ax,%eax
  81961b:	ba 03 00 00 00       	mov    $0x3,%edx
  819620:	89 c6                	mov    %eax,%esi
  819622:	bf 03 00 00 00       	mov    $0x3,%edi
  819627:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81962e:	00 00 00 
  819631:	ff d0                	callq  *%rax
  819633:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819637:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81963c:	75 0a                	jne    819648 <low_level_input+0x52>
	return 0;
  81963e:	b8 00 00 00 00       	mov    $0x0,%eax
  819643:	e9 8a 00 00 00       	jmpq   8196d2 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  819648:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81964c:	48 83 c0 04          	add    $0x4,%rax
  819650:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  819654:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81965b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81965f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819663:	eb 62                	jmp    8196c7 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  819665:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819669:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81966d:	0f b7 c0             	movzwl %ax,%eax
  819670:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  819673:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819677:	2b 45 fc             	sub    -0x4(%rbp),%eax
  81967a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81967d:	7d 0a                	jge    819689 <low_level_input+0x93>
	    bytes = len - copied;
  81967f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819683:	2b 45 fc             	sub    -0x4(%rbp),%eax
  819686:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  819689:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81968c:	48 63 d0             	movslq %eax,%rdx
  81968f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819692:	48 63 c8             	movslq %eax,%rcx
  819695:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819699:	48 01 c1             	add    %rax,%rcx
  81969c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8196a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8196a4:	48 89 ce             	mov    %rcx,%rsi
  8196a7:	48 89 c7             	mov    %rax,%rdi
  8196aa:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8196b1:	00 00 00 
  8196b4:	ff d0                	callq  *%rax
	copied += bytes;
  8196b6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8196b9:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8196bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8196c0:	48 8b 00             	mov    (%rax),%rax
  8196c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8196c7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8196cc:	75 97                	jne    819665 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  8196ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8196d2:	c9                   	leaveq 
  8196d3:	c3                   	retq   

00000000008196d4 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  8196d4:	55                   	push   %rbp
  8196d5:	48 89 e5             	mov    %rsp,%rbp
  8196d8:	48 83 ec 20          	sub    $0x20,%rsp
  8196dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8196e0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8196e4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  8196e8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8196ec:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8196f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196f4:	48 89 ce             	mov    %rcx,%rsi
  8196f7:	48 89 c7             	mov    %rax,%rdi
  8196fa:	48 b8 34 69 81 00 00 	movabs $0x816934,%rax
  819701:	00 00 00 
  819704:	ff d0                	callq  *%rax
}
  819706:	c9                   	leaveq 
  819707:	c3                   	retq   

0000000000819708 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  819708:	55                   	push   %rbp
  819709:	48 89 e5             	mov    %rsp,%rbp
  81970c:	48 83 ec 30          	sub    $0x30,%rsp
  819710:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819714:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81971c:	48 8b 40 30          	mov    0x30(%rax),%rax
  819720:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  819724:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819728:	48 89 c7             	mov    %rax,%rdi
  81972b:	48 b8 f6 95 81 00 00 	movabs $0x8195f6,%rax
  819732:	00 00 00 
  819735:	ff d0                	callq  *%rax
  819737:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  81973b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819740:	75 05                	jne    819747 <jif_input+0x3f>
  819742:	e9 ba 00 00 00       	jmpq   819801 <jif_input+0xf9>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819747:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81974b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81974f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  819753:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819757:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81975b:	0f b7 c0             	movzwl %ax,%eax
  81975e:	89 c7                	mov    %eax,%edi
  819760:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  819767:	00 00 00 
  81976a:	ff d0                	callq  *%rax
  81976c:	0f b7 c0             	movzwl %ax,%eax
  81976f:	3d 00 08 00 00       	cmp    $0x800,%eax
  819774:	74 09                	je     81977f <jif_input+0x77>
  819776:	3d 06 08 00 00       	cmp    $0x806,%eax
  81977b:	74 4e                	je     8197cb <jif_input+0xc3>
  81977d:	eb 6f                	jmp    8197ee <jif_input+0xe6>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  81977f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819783:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819787:	48 89 d6             	mov    %rdx,%rsi
  81978a:	48 89 c7             	mov    %rax,%rdi
  81978d:	48 b8 58 65 81 00 00 	movabs $0x816558,%rax
  819794:	00 00 00 
  819797:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  819799:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81979d:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8197a2:	48 89 c7             	mov    %rax,%rdi
  8197a5:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  8197ac:	00 00 00 
  8197af:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  8197b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8197b5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8197b9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8197bd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8197c1:	48 89 ce             	mov    %rcx,%rsi
  8197c4:	48 89 d7             	mov    %rdx,%rdi
  8197c7:	ff d0                	callq  *%rax
	break;
  8197c9:	eb 36                	jmp    819801 <jif_input+0xf9>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  8197cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8197cf:	48 8b 08             	mov    (%rax),%rcx
  8197d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8197d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8197da:	48 89 ce             	mov    %rcx,%rsi
  8197dd:	48 89 c7             	mov    %rax,%rdi
  8197e0:	48 b8 ee 65 81 00 00 	movabs $0x8165ee,%rax
  8197e7:	00 00 00 
  8197ea:	ff d0                	callq  *%rax
	break;
  8197ec:	eb 13                	jmp    819801 <jif_input+0xf9>

    default:
	pbuf_free(p);
  8197ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8197f2:	48 89 c7             	mov    %rax,%rdi
  8197f5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8197fc:	00 00 00 
  8197ff:	ff d0                	callq  *%rax
    }
}
  819801:	c9                   	leaveq 
  819802:	c3                   	retq   

0000000000819803 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819803:	55                   	push   %rbp
  819804:	48 89 e5             	mov    %rsp,%rbp
  819807:	53                   	push   %rbx
  819808:	48 83 ec 38          	sub    $0x38,%rsp
  81980c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  819810:	bf 10 00 00 00       	mov    $0x10,%edi
  819815:	48 b8 75 c8 80 00 00 	movabs $0x80c875,%rax
  81981c:	00 00 00 
  81981f:	ff d0                	callq  *%rax
  819821:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (jif == NULL) {
  819825:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81982a:	75 0a                	jne    819836 <jif_init+0x33>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  81982c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819831:	e9 ce 00 00 00       	jmpq   819904 <jif_init+0x101>
    }

    output_envid = (envid_t *)netif->state;
  819836:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81983a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81983e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    netif->state = jif;
  819842:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819846:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81984a:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  81984e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819852:	48 bb d4 96 81 00 00 	movabs $0x8196d4,%rbx
  819859:	00 00 00 
  81985c:	48 89 58 20          	mov    %rbx,0x20(%rax)
    netif->linkoutput = low_level_output;
  819860:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819864:	48 b9 6e 94 81 00 00 	movabs $0x81946e,%rcx
  81986b:	00 00 00 
  81986e:	48 89 48 28          	mov    %rcx,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  819872:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819876:	48 83 c0 4b          	add    $0x4b,%rax
  81987a:	ba 02 00 00 00       	mov    $0x2,%edx
  81987f:	48 be 51 33 82 00 00 	movabs $0x823351,%rsi
  819886:	00 00 00 
  819889:	48 89 c7             	mov    %rax,%rdi
  81988c:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  819893:	00 00 00 
  819896:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  819898:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81989c:	48 8d 50 41          	lea    0x41(%rax),%rdx
  8198a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8198a4:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  8198a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8198ab:	8b 10                	mov    (%rax),%edx
  8198ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8198b1:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  8198b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198b8:	48 89 c7             	mov    %rax,%rdi
  8198bb:	48 b8 16 94 81 00 00 	movabs $0x819416,%rax
  8198c2:	00 00 00 
  8198c5:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  8198c7:	48 bf 54 33 82 00 00 	movabs $0x823354,%rdi
  8198ce:	00 00 00 
  8198d1:	48 b8 df 2a 81 00 00 	movabs $0x812adf,%rax
  8198d8:	00 00 00 
  8198db:	ff d0                	callq  *%rax
  8198dd:	89 45 dc             	mov    %eax,-0x24(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  8198e0:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
  8198e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8198ed:	48 89 ce             	mov    %rcx,%rsi
  8198f0:	48 89 c7             	mov    %rax,%rdi
  8198f3:	48 b8 c6 6a 81 00 00 	movabs $0x816ac6,%rax
  8198fa:	00 00 00 
  8198fd:	ff d0                	callq  *%rax

    return ERR_OK;
  8198ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819904:	48 83 c4 38          	add    $0x38,%rsp
  819908:	5b                   	pop    %rbx
  819909:	5d                   	pop    %rbp
  81990a:	c3                   	retq   

000000000081990b <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  81990b:	55                   	push   %rbp
  81990c:	48 89 e5             	mov    %rsp,%rbp
  81990f:	48 83 ec 40          	sub    $0x40,%rsp
  819913:	89 7d cc             	mov    %edi,-0x34(%rbp)
  819916:	89 f0                	mov    %esi,%eax
  819918:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  81991c:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  81991f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819923:	8b 45 cc             	mov    -0x34(%rbp),%eax
  819926:	48 89 d6             	mov    %rdx,%rsi
  819929:	89 c7                	mov    %eax,%edi
  81992b:	48 b8 8d af 81 00 00 	movabs $0x81af8d,%rax
  819932:	00 00 00 
  819935:	ff d0                	callq  *%rax
  819937:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  81993b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819940:	0f 84 62 01 00 00    	je     819aa8 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  819946:	48 b8 44 af 81 00 00 	movabs $0x81af44,%rax
  81994d:	00 00 00 
  819950:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  819954:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819958:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  81995b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81995f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  819963:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819967:	48 89 c7             	mov    %rax,%rdi
  81996a:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819971:	00 00 00 
  819974:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  819976:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81997a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81997e:	84 c0                	test   %al,%al
  819980:	0f 84 22 01 00 00    	je     819aa8 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  819986:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81998a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81998e:	48 85 c0             	test   %rax,%rax
  819991:	74 2a                	je     8199bd <netconn_new_with_proto_and_callback+0xb2>
  819993:	48 ba 60 33 82 00 00 	movabs $0x823360,%rdx
  81999a:	00 00 00 
  81999d:	be 52 00 00 00       	mov    $0x52,%esi
  8199a2:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  8199a9:	00 00 00 
  8199ac:	b8 00 00 00 00       	mov    $0x0,%eax
  8199b1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8199b8:	00 00 00 
  8199bb:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  8199bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8199c1:	8b 40 14             	mov    0x14(%rax),%eax
  8199c4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8199c7:	75 2a                	jne    8199f3 <netconn_new_with_proto_and_callback+0xe8>
  8199c9:	48 ba 98 33 82 00 00 	movabs $0x823398,%rdx
  8199d0:	00 00 00 
  8199d3:	be 53 00 00 00       	mov    $0x53,%esi
  8199d8:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  8199df:	00 00 00 
  8199e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8199e7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8199ee:	00 00 00 
  8199f1:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  8199f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8199f7:	8b 40 18             	mov    0x18(%rax),%eax
  8199fa:	83 f8 ff             	cmp    $0xffffffff,%eax
  8199fd:	75 2a                	jne    819a29 <netconn_new_with_proto_and_callback+0x11e>
  8199ff:	48 ba b1 33 82 00 00 	movabs $0x8233b1,%rdx
  819a06:	00 00 00 
  819a09:	be 54 00 00 00       	mov    $0x54,%esi
  819a0e:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819a15:	00 00 00 
  819a18:	b8 00 00 00 00       	mov    $0x0,%eax
  819a1d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819a24:	00 00 00 
  819a27:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819a29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a2d:	8b 40 1c             	mov    0x1c(%rax),%eax
  819a30:	83 f8 ff             	cmp    $0xffffffff,%eax
  819a33:	74 2a                	je     819a5f <netconn_new_with_proto_and_callback+0x154>
  819a35:	48 ba c8 33 82 00 00 	movabs $0x8233c8,%rdx
  819a3c:	00 00 00 
  819a3f:	be 55 00 00 00       	mov    $0x55,%esi
  819a44:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819a4b:	00 00 00 
  819a4e:	b8 00 00 00 00       	mov    $0x0,%eax
  819a53:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819a5a:	00 00 00 
  819a5d:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819a5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a63:	8b 40 14             	mov    0x14(%rax),%eax
  819a66:	89 c7                	mov    %eax,%edi
  819a68:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  819a6f:	00 00 00 
  819a72:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  819a74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a78:	8b 40 18             	mov    0x18(%rax),%eax
  819a7b:	89 c7                	mov    %eax,%edi
  819a7d:	48 b8 94 77 81 00 00 	movabs $0x817794,%rax
  819a84:	00 00 00 
  819a87:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819a89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a8d:	48 89 c6             	mov    %rax,%rsi
  819a90:	bf 07 00 00 00       	mov    $0x7,%edi
  819a95:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  819a9c:	00 00 00 
  819a9f:	ff d0                	callq  *%rax
      return NULL;
  819aa1:	b8 00 00 00 00       	mov    $0x0,%eax
  819aa6:	eb 04                	jmp    819aac <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819aa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819aac:	c9                   	leaveq 
  819aad:	c3                   	retq   

0000000000819aae <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  819aae:	55                   	push   %rbp
  819aaf:	48 89 e5             	mov    %rsp,%rbp
  819ab2:	48 83 ec 40          	sub    $0x40,%rsp
  819ab6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819aba:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819abf:	75 07                	jne    819ac8 <netconn_delete+0x1a>
    return ERR_OK;
  819ac1:	b8 00 00 00 00       	mov    $0x0,%eax
  819ac6:	eb 4d                	jmp    819b15 <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819ac8:	48 b8 57 b5 81 00 00 	movabs $0x81b557,%rax
  819acf:	00 00 00 
  819ad2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ad6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ada:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819ade:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819ae2:	48 89 c7             	mov    %rax,%rdi
  819ae5:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819aec:	00 00 00 
  819aef:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  819af1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819af5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819afc:	00 
  netconn_free(conn);
  819afd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b01:	48 89 c7             	mov    %rax,%rdi
  819b04:	48 b8 c1 b0 81 00 00 	movabs $0x81b0c1,%rax
  819b0b:	00 00 00 
  819b0e:	ff d0                	callq  *%rax

  return ERR_OK;
  819b10:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819b15:	c9                   	leaveq 
  819b16:	c3                   	retq   

0000000000819b17 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819b17:	55                   	push   %rbp
  819b18:	48 89 e5             	mov    %rsp,%rbp
  819b1b:	48 83 ec 10          	sub    $0x10,%rsp
  819b1f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  819b23:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819b28:	75 2a                	jne    819b54 <netconn_type+0x3d>
  819b2a:	48 ba e9 33 82 00 00 	movabs $0x8233e9,%rdx
  819b31:	00 00 00 
  819b34:	be 84 00 00 00       	mov    $0x84,%esi
  819b39:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819b40:	00 00 00 
  819b43:	b8 00 00 00 00       	mov    $0x0,%eax
  819b48:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819b4f:	00 00 00 
  819b52:	ff d1                	callq  *%rcx
  return conn->type;
  819b54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b58:	8b 00                	mov    (%rax),%eax
}
  819b5a:	c9                   	leaveq 
  819b5b:	c3                   	retq   

0000000000819b5c <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819b5c:	55                   	push   %rbp
  819b5d:	48 89 e5             	mov    %rsp,%rbp
  819b60:	48 83 ec 50          	sub    $0x50,%rsp
  819b64:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819b68:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819b6c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819b70:	89 c8                	mov    %ecx,%eax
  819b72:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  819b75:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819b7a:	75 2a                	jne    819ba6 <netconn_getaddr+0x4a>
  819b7c:	48 ba 04 34 82 00 00 	movabs $0x823404,%rdx
  819b83:	00 00 00 
  819b86:	be 98 00 00 00       	mov    $0x98,%esi
  819b8b:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819b92:	00 00 00 
  819b95:	b8 00 00 00 00       	mov    $0x0,%eax
  819b9a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819ba1:	00 00 00 
  819ba4:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819ba6:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  819bab:	75 2a                	jne    819bd7 <netconn_getaddr+0x7b>
  819bad:	48 ba 22 34 82 00 00 	movabs $0x823422,%rdx
  819bb4:	00 00 00 
  819bb7:	be 99 00 00 00       	mov    $0x99,%esi
  819bbc:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819bc3:	00 00 00 
  819bc6:	b8 00 00 00 00       	mov    $0x0,%eax
  819bcb:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819bd2:	00 00 00 
  819bd5:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819bd7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819bdc:	75 2a                	jne    819c08 <netconn_getaddr+0xac>
  819bde:	48 ba 40 34 82 00 00 	movabs $0x823440,%rdx
  819be5:	00 00 00 
  819be8:	be 9a 00 00 00       	mov    $0x9a,%esi
  819bed:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819bf4:	00 00 00 
  819bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  819bfc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819c03:	00 00 00 
  819c06:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819c08:	48 b8 ff c0 81 00 00 	movabs $0x81c0ff,%rax
  819c0f:	00 00 00 
  819c12:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819c16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c1a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819c1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819c22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  819c26:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819c2e:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  819c32:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  819c35:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819c39:	48 89 c7             	mov    %rax,%rdi
  819c3c:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819c43:	00 00 00 
  819c46:	ff d0                	callq  *%rax

  return conn->err;
  819c48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c4c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819c50:	c9                   	leaveq 
  819c51:	c3                   	retq   

0000000000819c52 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819c52:	55                   	push   %rbp
  819c53:	48 89 e5             	mov    %rsp,%rbp
  819c56:	48 83 ec 50          	sub    $0x50,%rsp
  819c5a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819c5e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819c62:	89 d0                	mov    %edx,%eax
  819c64:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819c68:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819c6d:	75 2a                	jne    819c99 <netconn_bind+0x47>
  819c6f:	48 ba 5e 34 82 00 00 	movabs $0x82345e,%rdx
  819c76:	00 00 00 
  819c79:	be b5 00 00 00       	mov    $0xb5,%esi
  819c7e:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819c85:	00 00 00 
  819c88:	b8 00 00 00 00       	mov    $0x0,%eax
  819c8d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819c94:	00 00 00 
  819c97:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819c99:	48 b8 95 b6 81 00 00 	movabs $0x81b695,%rax
  819ca0:	00 00 00 
  819ca3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ca7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819cab:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819caf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819cb3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819cb7:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819cbb:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819cbf:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819cc3:	48 89 c7             	mov    %rax,%rdi
  819cc6:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819ccd:	00 00 00 
  819cd0:	ff d0                	callq  *%rax
  return conn->err;
  819cd2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819cd6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819cda:	c9                   	leaveq 
  819cdb:	c3                   	retq   

0000000000819cdc <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819cdc:	55                   	push   %rbp
  819cdd:	48 89 e5             	mov    %rsp,%rbp
  819ce0:	48 83 ec 50          	sub    $0x50,%rsp
  819ce4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819ce8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819cec:	89 d0                	mov    %edx,%eax
  819cee:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819cf2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819cf7:	75 2a                	jne    819d23 <netconn_connect+0x47>
  819cf9:	48 ba 79 34 82 00 00 	movabs $0x823479,%rdx
  819d00:	00 00 00 
  819d03:	be cc 00 00 00       	mov    $0xcc,%esi
  819d08:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819d0f:	00 00 00 
  819d12:	b8 00 00 00 00       	mov    $0x0,%eax
  819d17:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819d1e:	00 00 00 
  819d21:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  819d23:	48 b8 40 b8 81 00 00 	movabs $0x81b840,%rax
  819d2a:	00 00 00 
  819d2d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819d31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d35:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819d39:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d3d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819d41:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819d45:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819d49:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819d4d:	48 89 c7             	mov    %rax,%rdi
  819d50:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819d57:	00 00 00 
  819d5a:	ff d0                	callq  *%rax
  return conn->err;
  819d5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d60:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819d64:	c9                   	leaveq 
  819d65:	c3                   	retq   

0000000000819d66 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819d66:	55                   	push   %rbp
  819d67:	48 89 e5             	mov    %rsp,%rbp
  819d6a:	48 83 ec 40          	sub    $0x40,%rsp
  819d6e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  819d72:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819d77:	75 2a                	jne    819da3 <netconn_disconnect+0x3d>
  819d79:	48 ba 98 34 82 00 00 	movabs $0x823498,%rdx
  819d80:	00 00 00 
  819d83:	be e2 00 00 00       	mov    $0xe2,%esi
  819d88:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819d8f:	00 00 00 
  819d92:	b8 00 00 00 00       	mov    $0x0,%eax
  819d97:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819d9e:	00 00 00 
  819da1:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  819da3:	48 b8 ad b9 81 00 00 	movabs $0x81b9ad,%rax
  819daa:	00 00 00 
  819dad:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819db1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819db5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819db9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819dbd:	48 89 c7             	mov    %rax,%rdi
  819dc0:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819dc7:	00 00 00 
  819dca:	ff d0                	callq  *%rax
  return conn->err;
  819dcc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dd0:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819dd4:	c9                   	leaveq 
  819dd5:	c3                   	retq   

0000000000819dd6 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  819dd6:	55                   	push   %rbp
  819dd7:	48 89 e5             	mov    %rsp,%rbp
  819dda:	48 83 ec 40          	sub    $0x40,%rsp
  819dde:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819de2:	89 f0                	mov    %esi,%eax
  819de4:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819de7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819dec:	75 2a                	jne    819e18 <netconn_listen_with_backlog+0x42>
  819dee:	48 ba b9 34 82 00 00 	movabs $0x8234b9,%rdx
  819df5:	00 00 00 
  819df8:	be fa 00 00 00       	mov    $0xfa,%esi
  819dfd:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819e04:	00 00 00 
  819e07:	b8 00 00 00 00       	mov    $0x0,%eax
  819e0c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819e13:	00 00 00 
  819e16:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  819e18:	48 b8 00 ba 81 00 00 	movabs $0x81ba00,%rax
  819e1f:	00 00 00 
  819e22:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819e26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e2a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  819e2e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819e32:	48 89 c7             	mov    %rax,%rdi
  819e35:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  819e3c:	00 00 00 
  819e3f:	ff d0                	callq  *%rax
  return conn->err;
  819e41:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e45:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819e49:	c9                   	leaveq 
  819e4a:	c3                   	retq   

0000000000819e4b <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  819e4b:	55                   	push   %rbp
  819e4c:	48 89 e5             	mov    %rsp,%rbp
  819e4f:	48 83 ec 20          	sub    $0x20,%rsp
  819e53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  819e57:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819e5c:	75 2a                	jne    819e88 <netconn_accept+0x3d>
  819e5e:	48 ba d6 34 82 00 00 	movabs $0x8234d6,%rdx
  819e65:	00 00 00 
  819e68:	be 10 01 00 00       	mov    $0x110,%esi
  819e6d:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819e74:	00 00 00 
  819e77:	b8 00 00 00 00       	mov    $0x0,%eax
  819e7c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819e83:	00 00 00 
  819e86:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  819e88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819e8c:	8b 40 1c             	mov    0x1c(%rax),%eax
  819e8f:	83 f8 ff             	cmp    $0xffffffff,%eax
  819e92:	75 2a                	jne    819ebe <netconn_accept+0x73>
  819e94:	48 ba f8 34 82 00 00 	movabs $0x8234f8,%rdx
  819e9b:	00 00 00 
  819e9e:	be 11 01 00 00       	mov    $0x111,%esi
  819ea3:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819eaa:	00 00 00 
  819ead:	b8 00 00 00 00       	mov    $0x0,%eax
  819eb2:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819eb9:	00 00 00 
  819ebc:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819ebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ec2:	8b 40 1c             	mov    0x1c(%rax),%eax
  819ec5:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819ec9:	ba 00 00 00 00       	mov    $0x0,%edx
  819ece:	48 89 ce             	mov    %rcx,%rsi
  819ed1:	89 c7                	mov    %eax,%edi
  819ed3:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  819eda:	00 00 00 
  819edd:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819edf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ee3:	48 8b 40 38          	mov    0x38(%rax),%rax
  819ee7:	48 85 c0             	test   %rax,%rax
  819eea:	74 1b                	je     819f07 <netconn_accept+0xbc>
  819eec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ef0:	48 8b 40 38          	mov    0x38(%rax),%rax
  819ef4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  819ef8:	ba 00 00 00 00       	mov    $0x0,%edx
  819efd:	be 01 00 00 00       	mov    $0x1,%esi
  819f02:	48 89 cf             	mov    %rcx,%rdi
  819f05:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  819f07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819f0b:	c9                   	leaveq 
  819f0c:	c3                   	retq   

0000000000819f0d <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  819f0d:	55                   	push   %rbp
  819f0e:	48 89 e5             	mov    %rsp,%rbp
  819f11:	48 83 ec 50          	sub    $0x50,%rsp
  819f15:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  819f19:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  819f20:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  819f21:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819f26:	75 2a                	jne    819f52 <netconn_recv+0x45>
  819f28:	48 ba 1b 35 82 00 00 	movabs $0x82351b,%rdx
  819f2f:	00 00 00 
  819f32:	be 3a 01 00 00       	mov    $0x13a,%esi
  819f37:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  819f3e:	00 00 00 
  819f41:	b8 00 00 00 00       	mov    $0x0,%eax
  819f46:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  819f4d:	00 00 00 
  819f50:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  819f52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f56:	8b 40 18             	mov    0x18(%rax),%eax
  819f59:	83 f8 ff             	cmp    $0xffffffff,%eax
  819f5c:	75 12                	jne    819f70 <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  819f5e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f62:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  819f66:	b8 00 00 00 00       	mov    $0x0,%eax
  819f6b:	e9 21 02 00 00       	jmpq   81a191 <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  819f70:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f74:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819f78:	3c fc                	cmp    $0xfc,%al
  819f7a:	7d 0a                	jge    819f86 <netconn_recv+0x79>
    return NULL;
  819f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  819f81:	e9 0b 02 00 00       	jmpq   81a191 <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  819f86:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f8a:	8b 00                	mov    (%rax),%eax
  819f8c:	83 f8 10             	cmp    $0x10,%eax
  819f8f:	0f 85 80 01 00 00    	jne    81a115 <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  819f95:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f99:	8b 40 04             	mov    0x4(%rax),%eax
  819f9c:	83 f8 02             	cmp    $0x2,%eax
  819f9f:	75 12                	jne    819fb3 <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  819fa1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819fa5:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  819fa9:	b8 00 00 00 00       	mov    $0x0,%eax
  819fae:	e9 de 01 00 00       	jmpq   81a191 <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  819fb3:	bf 06 00 00 00       	mov    $0x6,%edi
  819fb8:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  819fbf:	00 00 00 
  819fc2:	ff d0                	callq  *%rax
  819fc4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  819fc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fcc:	48 85 c0             	test   %rax,%rax
  819fcf:	75 12                	jne    819fe3 <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  819fd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819fd5:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  819fd9:	b8 00 00 00 00       	mov    $0x0,%eax
  819fde:	e9 ae 01 00 00       	jmpq   81a191 <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  819fe3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819fe7:	8b 40 18             	mov    0x18(%rax),%eax
  819fea:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  819fee:	ba 00 00 00 00       	mov    $0x0,%edx
  819ff3:	48 89 ce             	mov    %rcx,%rsi
  819ff6:	89 c7                	mov    %eax,%edi
  819ff8:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  819fff:	00 00 00 
  81a002:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  81a004:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a008:	48 85 c0             	test   %rax,%rax
  81a00b:	74 24                	je     81a031 <netconn_recv+0x124>
      len = p->tot_len;
  81a00d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a011:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a015:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  81a019:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a01d:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a021:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  81a025:	89 c2                	mov    %eax,%edx
  81a027:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a02b:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a02f:	eb 06                	jmp    81a037 <netconn_recv+0x12a>
    } else {
      len = 0;
  81a031:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  81a037:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a03b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a03f:	48 85 c0             	test   %rax,%rax
  81a042:	74 1a                	je     81a05e <netconn_recv+0x151>
  81a044:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a048:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a04c:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a050:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a054:	be 01 00 00 00       	mov    $0x1,%esi
  81a059:	48 89 cf             	mov    %rcx,%rdi
  81a05c:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  81a05e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a062:	48 85 c0             	test   %rax,%rax
  81a065:	75 36                	jne    81a09d <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  81a067:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a06b:	48 89 c6             	mov    %rax,%rsi
  81a06e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a073:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81a07a:	00 00 00 
  81a07d:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  81a07f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a083:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a087:	84 c0                	test   %al,%al
  81a089:	75 08                	jne    81a093 <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  81a08b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a08f:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  81a093:	b8 00 00 00 00       	mov    $0x0,%eax
  81a098:	e9 f4 00 00 00       	jmpq   81a191 <netconn_recv+0x284>
    }

    buf->p = p;
  81a09d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0a1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a0a5:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a0a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0ac:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a0b0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  81a0b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0b8:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  81a0be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0c2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81a0c9:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  81a0ca:	48 b8 39 bd 81 00 00 	movabs $0x81bd39,%rax
  81a0d1:	00 00 00 
  81a0d4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  81a0d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a0dc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  81a0e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0e4:	48 85 c0             	test   %rax,%rax
  81a0e7:	74 11                	je     81a0fa <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  81a0e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0ed:	48 8b 00             	mov    (%rax),%rax
  81a0f0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a0f4:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  81a0f8:	eb 06                	jmp    81a100 <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  81a0fa:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  81a100:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a104:	48 89 c7             	mov    %rax,%rdi
  81a107:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  81a10e:	00 00 00 
  81a111:	ff d0                	callq  *%rax
  81a113:	eb 78                	jmp    81a18d <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  81a115:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a119:	8b 40 18             	mov    0x18(%rax),%eax
  81a11c:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  81a120:	ba 00 00 00 00       	mov    $0x0,%edx
  81a125:	48 89 ce             	mov    %rcx,%rsi
  81a128:	89 c7                	mov    %eax,%edi
  81a12a:	48 b8 52 82 81 00 00 	movabs $0x818252,%rax
  81a131:	00 00 00 
  81a134:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  81a136:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a13a:	48 85 c0             	test   %rax,%rax
  81a13d:	74 4e                	je     81a18d <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  81a13f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a143:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a147:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a14b:	48 8b 00             	mov    (%rax),%rax
  81a14e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a152:	29 c2                	sub    %eax,%edx
  81a154:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a158:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  81a15c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a160:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a164:	48 85 c0             	test   %rax,%rax
  81a167:	74 24                	je     81a18d <netconn_recv+0x280>
  81a169:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a16d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a171:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a175:	48 8b 12             	mov    (%rdx),%rdx
  81a178:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a17c:	0f b7 d2             	movzwl %dx,%edx
  81a17f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a183:	be 01 00 00 00       	mov    $0x1,%esi
  81a188:	48 89 cf             	mov    %rcx,%rdi
  81a18b:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  81a18d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  81a191:	c9                   	leaveq 
  81a192:	c3                   	retq   

000000000081a193 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  81a193:	55                   	push   %rbp
  81a194:	48 89 e5             	mov    %rsp,%rbp
  81a197:	48 83 ec 20          	sub    $0x20,%rsp
  81a19b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81a19f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81a1a3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  81a1a7:	89 c8                	mov    %ecx,%eax
  81a1a9:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  81a1ad:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a1b2:	74 34                	je     81a1e8 <netconn_sendto+0x55>
    buf->addr = addr;
  81a1b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a1bc:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a1c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1c4:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  81a1c8:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  81a1cc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a1d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1d4:	48 89 d6             	mov    %rdx,%rsi
  81a1d7:	48 89 c7             	mov    %rax,%rdi
  81a1da:	48 b8 ef a1 81 00 00 	movabs $0x81a1ef,%rax
  81a1e1:	00 00 00 
  81a1e4:	ff d0                	callq  *%rax
  81a1e6:	eb 05                	jmp    81a1ed <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  81a1e8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  81a1ed:	c9                   	leaveq 
  81a1ee:	c3                   	retq   

000000000081a1ef <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  81a1ef:	55                   	push   %rbp
  81a1f0:	48 89 e5             	mov    %rsp,%rbp
  81a1f3:	48 83 ec 40          	sub    $0x40,%rsp
  81a1f7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a1fb:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a1ff:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a204:	75 2a                	jne    81a230 <netconn_send+0x41>
  81a206:	48 ba 36 35 82 00 00 	movabs $0x823536,%rdx
  81a20d:	00 00 00 
  81a210:	be b9 01 00 00       	mov    $0x1b9,%esi
  81a215:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  81a21c:	00 00 00 
  81a21f:	b8 00 00 00 00       	mov    $0x0,%eax
  81a224:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a22b:	00 00 00 
  81a22e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  81a230:	48 b8 aa bb 81 00 00 	movabs $0x81bbaa,%rax
  81a237:	00 00 00 
  81a23a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a23e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a242:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  81a246:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a24a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  81a24e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a252:	48 89 c7             	mov    %rax,%rdi
  81a255:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  81a25c:	00 00 00 
  81a25f:	ff d0                	callq  *%rax
  return conn->err;
  81a261:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a265:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a269:	c9                   	leaveq 
  81a26a:	c3                   	retq   

000000000081a26b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  81a26b:	55                   	push   %rbp
  81a26c:	48 89 e5             	mov    %rsp,%rbp
  81a26f:	48 83 ec 50          	sub    $0x50,%rsp
  81a273:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a277:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81a27b:	89 55 bc             	mov    %edx,-0x44(%rbp)
  81a27e:	89 c8                	mov    %ecx,%eax
  81a280:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a283:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a288:	75 2a                	jne    81a2b4 <netconn_write+0x49>
  81a28a:	48 ba 51 35 82 00 00 	movabs $0x823551,%rdx
  81a291:	00 00 00 
  81a294:	be d3 01 00 00       	mov    $0x1d3,%esi
  81a299:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  81a2a0:	00 00 00 
  81a2a3:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2a8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a2af:	00 00 00 
  81a2b2:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81a2b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a2b8:	8b 00                	mov    (%rax),%eax
  81a2ba:	83 f8 10             	cmp    $0x10,%eax
  81a2bd:	74 2a                	je     81a2e9 <netconn_write+0x7e>
  81a2bf:	48 ba 70 35 82 00 00 	movabs $0x823570,%rdx
  81a2c6:	00 00 00 
  81a2c9:	be d4 01 00 00       	mov    $0x1d4,%esi
  81a2ce:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  81a2d5:	00 00 00 
  81a2d8:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2dd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a2e4:	00 00 00 
  81a2e7:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a2e9:	48 b8 5e c0 81 00 00 	movabs $0x81c05e,%rax
  81a2f0:	00 00 00 
  81a2f3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a2f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a2fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a2ff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a303:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a307:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a30b:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a30e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a311:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a314:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a318:	48 89 c7             	mov    %rax,%rdi
  81a31b:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  81a322:	00 00 00 
  81a325:	ff d0                	callq  *%rax
  return conn->err;
  81a327:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a32b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a32f:	c9                   	leaveq 
  81a330:	c3                   	retq   

000000000081a331 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a331:	55                   	push   %rbp
  81a332:	48 89 e5             	mov    %rsp,%rbp
  81a335:	48 83 ec 40          	sub    $0x40,%rsp
  81a339:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a33d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a342:	75 2a                	jne    81a36e <netconn_close+0x3d>
  81a344:	48 ba 92 35 82 00 00 	movabs $0x823592,%rdx
  81a34b:	00 00 00 
  81a34e:	be ed 01 00 00       	mov    $0x1ed,%esi
  81a353:	48 bf 81 33 82 00 00 	movabs $0x823381,%rdi
  81a35a:	00 00 00 
  81a35d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a362:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a369:	00 00 00 
  81a36c:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a36e:	48 b8 83 c2 81 00 00 	movabs $0x81c283,%rax
  81a375:	00 00 00 
  81a378:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a37c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a380:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a384:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a388:	48 89 c7             	mov    %rax,%rdi
  81a38b:	48 b8 b1 8b 80 00 00 	movabs $0x808bb1,%rax
  81a392:	00 00 00 
  81a395:	ff d0                	callq  *%rax
  return conn->err;
  81a397:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a39b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a39f:	c9                   	leaveq 
  81a3a0:	c3                   	retq   

000000000081a3a1 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a3a1:	55                   	push   %rbp
  81a3a2:	48 89 e5             	mov    %rsp,%rbp
  81a3a5:	48 83 ec 40          	sub    $0x40,%rsp
  81a3a9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a3ad:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a3b1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a3b5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a3b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a3bd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a3c1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a3c6:	0f 84 74 01 00 00    	je     81a540 <recv_raw+0x19f>
  81a3cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a3d0:	8b 40 18             	mov    0x18(%rax),%eax
  81a3d3:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a3d6:	0f 84 64 01 00 00    	je     81a540 <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a3dc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3e0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a3e4:	0f b7 c0             	movzwl %ax,%eax
  81a3e7:	ba 00 00 00 00       	mov    $0x0,%edx
  81a3ec:	89 c6                	mov    %eax,%esi
  81a3ee:	bf 03 00 00 00       	mov    $0x3,%edi
  81a3f3:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81a3fa:	00 00 00 
  81a3fd:	ff d0                	callq  *%rax
  81a3ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a403:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a408:	74 39                	je     81a443 <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a40a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a40e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a412:	48 89 d6             	mov    %rdx,%rsi
  81a415:	48 89 c7             	mov    %rax,%rdi
  81a418:	48 b8 9e e0 80 00 00 	movabs $0x80e09e,%rax
  81a41f:	00 00 00 
  81a422:	ff d0                	callq  *%rax
  81a424:	84 c0                	test   %al,%al
  81a426:	74 1b                	je     81a443 <recv_raw+0xa2>
        pbuf_free(q);
  81a428:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a42c:	48 89 c7             	mov    %rax,%rdi
  81a42f:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81a436:	00 00 00 
  81a439:	ff d0                	callq  *%rax
        q = NULL;
  81a43b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a442:	00 
      }
    }

    if(q != NULL) {
  81a443:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a448:	0f 84 f2 00 00 00    	je     81a540 <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a44e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a453:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  81a45a:	00 00 00 
  81a45d:	ff d0                	callq  *%rax
  81a45f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a463:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a468:	75 1d                	jne    81a487 <recv_raw+0xe6>
        pbuf_free(q);
  81a46a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a46e:	48 89 c7             	mov    %rax,%rdi
  81a471:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81a478:	00 00 00 
  81a47b:	ff d0                	callq  *%rax
        return 0;
  81a47d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a482:	e9 be 00 00 00       	jmpq   81a545 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a48b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a48f:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a496:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a49a:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a49e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a4a6:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a4aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4ae:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a4b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a4b6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a4ba:	0f b6 d0             	movzbl %al,%edx
  81a4bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4c1:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a4c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4c9:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a4cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4d1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a4d5:	01 c2                	add    %eax,%edx
  81a4d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4db:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a4df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4e3:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a4e7:	48 85 c0             	test   %rax,%rax
  81a4ea:	74 21                	je     81a50d <recv_raw+0x16c>
  81a4ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4f0:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a4f4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a4f8:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a4fc:	0f b7 d2             	movzwl %dx,%edx
  81a4ff:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a503:	be 00 00 00 00       	mov    $0x0,%esi
  81a508:	48 89 cf             	mov    %rcx,%rdi
  81a50b:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a50d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a511:	8b 40 18             	mov    0x18(%rax),%eax
  81a514:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a518:	48 89 d6             	mov    %rdx,%rsi
  81a51b:	89 c7                	mov    %eax,%edi
  81a51d:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  81a524:	00 00 00 
  81a527:	ff d0                	callq  *%rax
  81a529:	84 c0                	test   %al,%al
  81a52b:	74 13                	je     81a540 <recv_raw+0x19f>
        netbuf_delete(buf);
  81a52d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a531:	48 89 c7             	mov    %rax,%rdi
  81a534:	48 b8 94 8d 80 00 00 	movabs $0x808d94,%rax
  81a53b:	00 00 00 
  81a53e:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a540:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a545:	c9                   	leaveq 
  81a546:	c3                   	retq   

000000000081a547 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a547:	55                   	push   %rbp
  81a548:	48 89 e5             	mov    %rsp,%rbp
  81a54b:	48 83 ec 40          	sub    $0x40,%rsp
  81a54f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a553:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a557:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a55b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a55f:	44 89 c0             	mov    %r8d,%eax
  81a562:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a566:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a56b:	75 2a                	jne    81a597 <recv_udp+0x50>
  81a56d:	48 ba b0 35 82 00 00 	movabs $0x8235b0,%rdx
  81a574:	00 00 00 
  81a577:	be 8e 00 00 00       	mov    $0x8e,%esi
  81a57c:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a583:	00 00 00 
  81a586:	b8 00 00 00 00       	mov    $0x0,%eax
  81a58b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a592:	00 00 00 
  81a595:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a597:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a59c:	75 2a                	jne    81a5c8 <recv_udp+0x81>
  81a59e:	48 ba f0 35 82 00 00 	movabs $0x8235f0,%rdx
  81a5a5:	00 00 00 
  81a5a8:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a5ad:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a5b4:	00 00 00 
  81a5b7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5bc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a5c3:	00 00 00 
  81a5c6:	ff d1                	callq  *%rcx
  conn = arg;
  81a5c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5cc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a5d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a5d8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a5dc:	74 2a                	je     81a608 <recv_udp+0xc1>
  81a5de:	48 ba 0f 36 82 00 00 	movabs $0x82360f,%rdx
  81a5e5:	00 00 00 
  81a5e8:	be 91 00 00 00       	mov    $0x91,%esi
  81a5ed:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a5f4:	00 00 00 
  81a5f7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5fc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a603:	00 00 00 
  81a606:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a608:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a60d:	74 0c                	je     81a61b <recv_udp+0xd4>
  81a60f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a613:	8b 40 18             	mov    0x18(%rax),%eax
  81a616:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a619:	75 18                	jne    81a633 <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a61b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a61f:	48 89 c7             	mov    %rax,%rdi
  81a622:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81a629:	00 00 00 
  81a62c:	ff d0                	callq  *%rax
    return;
  81a62e:	e9 df 00 00 00       	jmpq   81a712 <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a633:	bf 06 00 00 00       	mov    $0x6,%edi
  81a638:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  81a63f:	00 00 00 
  81a642:	ff d0                	callq  *%rax
  81a644:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a648:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a64d:	75 18                	jne    81a667 <recv_udp+0x120>
    pbuf_free(p);
  81a64f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a653:	48 89 c7             	mov    %rax,%rdi
  81a656:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81a65d:	00 00 00 
  81a660:	ff d0                	callq  *%rax
    return;
  81a662:	e9 ab 00 00 00       	jmpq   81a712 <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a667:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a66b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a66f:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a672:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a676:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a67a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a67e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a682:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a686:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a68a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a68e:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a692:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a69a:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a69e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a6a2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a6a6:	01 c2                	add    %eax,%edx
  81a6a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ac:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a6b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6b4:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a6b8:	48 85 c0             	test   %rax,%rax
  81a6bb:	74 21                	je     81a6de <recv_udp+0x197>
  81a6bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6c1:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a6c5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a6c9:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a6cd:	0f b7 d2             	movzwl %dx,%edx
  81a6d0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a6d4:	be 00 00 00 00       	mov    $0x0,%esi
  81a6d9:	48 89 cf             	mov    %rcx,%rdi
  81a6dc:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a6de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6e2:	8b 40 18             	mov    0x18(%rax),%eax
  81a6e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a6e9:	48 89 d6             	mov    %rdx,%rsi
  81a6ec:	89 c7                	mov    %eax,%edi
  81a6ee:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  81a6f5:	00 00 00 
  81a6f8:	ff d0                	callq  *%rax
  81a6fa:	84 c0                	test   %al,%al
  81a6fc:	74 14                	je     81a712 <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a6fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a702:	48 89 c7             	mov    %rax,%rdi
  81a705:	48 b8 94 8d 80 00 00 	movabs $0x808d94,%rax
  81a70c:	00 00 00 
  81a70f:	ff d0                	callq  *%rax
    return;
  81a711:	90                   	nop
  }
}
  81a712:	c9                   	leaveq 
  81a713:	c3                   	retq   

000000000081a714 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a714:	55                   	push   %rbp
  81a715:	48 89 e5             	mov    %rsp,%rbp
  81a718:	48 83 ec 30          	sub    $0x30,%rsp
  81a71c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a720:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a724:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a728:	89 c8                	mov    %ecx,%eax
  81a72a:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a72d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a732:	75 2a                	jne    81a75e <recv_tcp+0x4a>
  81a734:	48 ba 30 36 82 00 00 	movabs $0x823630,%rdx
  81a73b:	00 00 00 
  81a73e:	be c1 00 00 00       	mov    $0xc1,%esi
  81a743:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a74a:	00 00 00 
  81a74d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a752:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a759:	00 00 00 
  81a75c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a75e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a763:	75 2a                	jne    81a78f <recv_tcp+0x7b>
  81a765:	48 ba 58 36 82 00 00 	movabs $0x823658,%rdx
  81a76c:	00 00 00 
  81a76f:	be c2 00 00 00       	mov    $0xc2,%esi
  81a774:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a77b:	00 00 00 
  81a77e:	b8 00 00 00 00       	mov    $0x0,%eax
  81a783:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a78a:	00 00 00 
  81a78d:	ff d1                	callq  *%rcx
  conn = arg;
  81a78f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a793:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81a797:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a79b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a79f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a7a3:	74 2a                	je     81a7cf <recv_tcp+0xbb>
  81a7a5:	48 ba 77 36 82 00 00 	movabs $0x823677,%rdx
  81a7ac:	00 00 00 
  81a7af:	be c4 00 00 00       	mov    $0xc4,%esi
  81a7b4:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a7bb:	00 00 00 
  81a7be:	b8 00 00 00 00       	mov    $0x0,%eax
  81a7c3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a7ca:	00 00 00 
  81a7cd:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a7cf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a7d4:	74 0c                	je     81a7e2 <recv_tcp+0xce>
  81a7d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7da:	8b 40 18             	mov    0x18(%rax),%eax
  81a7dd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a7e0:	75 0a                	jne    81a7ec <recv_tcp+0xd8>
    return ERR_VAL;
  81a7e2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81a7e7:	e9 8f 00 00 00       	jmpq   81a87b <recv_tcp+0x167>
  }

  conn->err = err;
  81a7ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7f0:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81a7f4:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81a7f7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81a7fc:	74 24                	je     81a822 <recv_tcp+0x10e>
    len = p->tot_len;
  81a7fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a802:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a806:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81a80a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a80e:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a812:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81a816:	01 c2                	add    %eax,%edx
  81a818:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a81c:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a820:	eb 06                	jmp    81a828 <recv_tcp+0x114>
  } else {
    len = 0;
  81a822:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81a828:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a82c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a830:	48 85 c0             	test   %rax,%rax
  81a833:	74 1a                	je     81a84f <recv_tcp+0x13b>
  81a835:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a839:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a83d:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a841:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a845:	be 00 00 00 00       	mov    $0x0,%esi
  81a84a:	48 89 cf             	mov    %rcx,%rdi
  81a84d:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81a84f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a853:	8b 40 18             	mov    0x18(%rax),%eax
  81a856:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a85a:	48 89 d6             	mov    %rdx,%rsi
  81a85d:	89 c7                	mov    %eax,%edi
  81a85f:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  81a866:	00 00 00 
  81a869:	ff d0                	callq  *%rax
  81a86b:	84 c0                	test   %al,%al
  81a86d:	74 07                	je     81a876 <recv_tcp+0x162>
    return ERR_MEM;
  81a86f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a874:	eb 05                	jmp    81a87b <recv_tcp+0x167>
  }

  return ERR_OK;
  81a876:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a87b:	c9                   	leaveq 
  81a87c:	c3                   	retq   

000000000081a87d <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81a87d:	55                   	push   %rbp
  81a87e:	48 89 e5             	mov    %rsp,%rbp
  81a881:	48 83 ec 20          	sub    $0x20,%rsp
  81a885:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a889:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81a88d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a891:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a895:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a89a:	75 2a                	jne    81a8c6 <poll_tcp+0x49>
  81a89c:	48 ba 95 36 82 00 00 	movabs $0x823695,%rdx
  81a8a3:	00 00 00 
  81a8a6:	be eb 00 00 00       	mov    $0xeb,%esi
  81a8ab:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a8b2:	00 00 00 
  81a8b5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8ba:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a8c1:	00 00 00 
  81a8c4:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a8c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8ca:	8b 40 04             	mov    0x4(%rax),%eax
  81a8cd:	83 f8 01             	cmp    $0x1,%eax
  81a8d0:	75 15                	jne    81a8e7 <poll_tcp+0x6a>
    do_writemore(conn);
  81a8d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8d6:	48 89 c7             	mov    %rax,%rdi
  81a8d9:	48 b8 b3 bd 81 00 00 	movabs $0x81bdb3,%rax
  81a8e0:	00 00 00 
  81a8e3:	ff d0                	callq  *%rax
  81a8e5:	eb 1f                	jmp    81a906 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81a8e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8eb:	8b 40 04             	mov    0x4(%rax),%eax
  81a8ee:	83 f8 04             	cmp    $0x4,%eax
  81a8f1:	75 13                	jne    81a906 <poll_tcp+0x89>
    do_close_internal(conn);
  81a8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8f7:	48 89 c7             	mov    %rax,%rdi
  81a8fa:	48 b8 2b b2 81 00 00 	movabs $0x81b22b,%rax
  81a901:	00 00 00 
  81a904:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81a906:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a90b:	c9                   	leaveq 
  81a90c:	c3                   	retq   

000000000081a90d <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81a90d:	55                   	push   %rbp
  81a90e:	48 89 e5             	mov    %rsp,%rbp
  81a911:	48 83 ec 30          	sub    $0x30,%rsp
  81a915:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a919:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a91d:	89 d0                	mov    %edx,%eax
  81a91f:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81a923:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a927:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a92b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a930:	75 2a                	jne    81a95c <sent_tcp+0x4f>
  81a932:	48 ba 95 36 82 00 00 	movabs $0x823695,%rdx
  81a939:	00 00 00 
  81a93c:	be 03 01 00 00       	mov    $0x103,%esi
  81a941:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a948:	00 00 00 
  81a94b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a950:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a957:	00 00 00 
  81a95a:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a95c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a960:	8b 40 04             	mov    0x4(%rax),%eax
  81a963:	83 f8 01             	cmp    $0x1,%eax
  81a966:	75 4c                	jne    81a9b4 <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81a968:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a96c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a970:	48 85 c0             	test   %rax,%rax
  81a973:	75 2a                	jne    81a99f <sent_tcp+0x92>
  81a975:	48 ba a2 36 82 00 00 	movabs $0x8236a2,%rdx
  81a97c:	00 00 00 
  81a97f:	be 06 01 00 00       	mov    $0x106,%esi
  81a984:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81a98b:	00 00 00 
  81a98e:	b8 00 00 00 00       	mov    $0x0,%eax
  81a993:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81a99a:	00 00 00 
  81a99d:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81a99f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9a3:	48 89 c7             	mov    %rax,%rdi
  81a9a6:	48 b8 b3 bd 81 00 00 	movabs $0x81bdb3,%rax
  81a9ad:	00 00 00 
  81a9b0:	ff d0                	callq  *%rax
  81a9b2:	eb 1f                	jmp    81a9d3 <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81a9b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9b8:	8b 40 04             	mov    0x4(%rax),%eax
  81a9bb:	83 f8 04             	cmp    $0x4,%eax
  81a9be:	75 13                	jne    81a9d3 <sent_tcp+0xc6>
    do_close_internal(conn);
  81a9c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9c4:	48 89 c7             	mov    %rax,%rdi
  81a9c7:	48 b8 2b b2 81 00 00 	movabs $0x81b22b,%rax
  81a9ce:	00 00 00 
  81a9d1:	ff d0                	callq  *%rax
  }

  if (conn) {
  81a9d3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a9d8:	74 46                	je     81aa20 <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81a9da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9de:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a9e2:	48 85 c0             	test   %rax,%rax
  81a9e5:	74 39                	je     81aa20 <sent_tcp+0x113>
  81a9e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9eb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a9ef:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81a9f3:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81a9f7:	76 27                	jbe    81aa20 <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81a9f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9fd:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa01:	48 85 c0             	test   %rax,%rax
  81aa04:	74 1a                	je     81aa20 <sent_tcp+0x113>
  81aa06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa0a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa0e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81aa12:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81aa16:	be 02 00 00 00       	mov    $0x2,%esi
  81aa1b:	48 89 cf             	mov    %rcx,%rdi
  81aa1e:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  81aa20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81aa25:	c9                   	leaveq 
  81aa26:	c3                   	retq   

000000000081aa27 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81aa27:	55                   	push   %rbp
  81aa28:	48 89 e5             	mov    %rsp,%rbp
  81aa2b:	48 83 ec 20          	sub    $0x20,%rsp
  81aa2f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81aa33:	89 f0                	mov    %esi,%eax
  81aa35:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81aa38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa3c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81aa40:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81aa45:	75 2a                	jne    81aa71 <err_tcp+0x4a>
  81aa47:	48 ba 95 36 82 00 00 	movabs $0x823695,%rdx
  81aa4e:	00 00 00 
  81aa51:	be 22 01 00 00       	mov    $0x122,%esi
  81aa56:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81aa5d:	00 00 00 
  81aa60:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa65:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81aa6c:	00 00 00 
  81aa6f:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81aa71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa75:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81aa7c:	00 

  conn->err = err;
  81aa7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa81:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81aa85:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81aa88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa8c:	8b 40 18             	mov    0x18(%rax),%eax
  81aa8f:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aa92:	74 42                	je     81aad6 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81aa94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa98:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa9c:	48 85 c0             	test   %rax,%rax
  81aa9f:	74 1b                	je     81aabc <err_tcp+0x95>
  81aaa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aaa5:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aaa9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81aaad:	ba 00 00 00 00       	mov    $0x0,%edx
  81aab2:	be 00 00 00 00       	mov    $0x0,%esi
  81aab7:	48 89 cf             	mov    %rcx,%rdi
  81aaba:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81aabc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aac0:	8b 40 18             	mov    0x18(%rax),%eax
  81aac3:	be 00 00 00 00       	mov    $0x0,%esi
  81aac8:	89 c7                	mov    %eax,%edi
  81aaca:	48 b8 e3 79 81 00 00 	movabs $0x8179e3,%rax
  81aad1:	00 00 00 
  81aad4:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81aad6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aada:	8b 40 14             	mov    0x14(%rax),%eax
  81aadd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aae0:	74 2c                	je     81ab0e <err_tcp+0xe7>
  81aae2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aae6:	8b 40 04             	mov    0x4(%rax),%eax
  81aae9:	83 f8 03             	cmp    $0x3,%eax
  81aaec:	75 20                	jne    81ab0e <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81aaee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aaf2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81aaf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aafd:	8b 40 14             	mov    0x14(%rax),%eax
  81ab00:	89 c7                	mov    %eax,%edi
  81ab02:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81ab09:	00 00 00 
  81ab0c:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81ab0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab12:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ab15:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ab18:	74 42                	je     81ab5c <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ab1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab1e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab22:	48 85 c0             	test   %rax,%rax
  81ab25:	74 1b                	je     81ab42 <err_tcp+0x11b>
  81ab27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab2b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab2f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ab33:	ba 00 00 00 00       	mov    $0x0,%edx
  81ab38:	be 00 00 00 00       	mov    $0x0,%esi
  81ab3d:	48 89 cf             	mov    %rcx,%rdi
  81ab40:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81ab42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab46:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ab49:	be 00 00 00 00       	mov    $0x0,%esi
  81ab4e:	89 c7                	mov    %eax,%edi
  81ab50:	48 b8 e3 79 81 00 00 	movabs $0x8179e3,%rax
  81ab57:	00 00 00 
  81ab5a:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81ab5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab60:	8b 40 04             	mov    0x4(%rax),%eax
  81ab63:	83 f8 01             	cmp    $0x1,%eax
  81ab66:	74 0c                	je     81ab74 <err_tcp+0x14d>
  81ab68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab6c:	8b 40 04             	mov    0x4(%rax),%eax
  81ab6f:	83 f8 04             	cmp    $0x4,%eax
  81ab72:	75 20                	jne    81ab94 <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81ab74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab78:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81ab7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab83:	8b 40 14             	mov    0x14(%rax),%eax
  81ab86:	89 c7                	mov    %eax,%edi
  81ab88:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81ab8f:	00 00 00 
  81ab92:	ff d0                	callq  *%rax
  }
}
  81ab94:	c9                   	leaveq 
  81ab95:	c3                   	retq   

000000000081ab96 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81ab96:	55                   	push   %rbp
  81ab97:	48 89 e5             	mov    %rsp,%rbp
  81ab9a:	48 83 ec 20          	sub    $0x20,%rsp
  81ab9e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81aba2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aba6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81abaa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81abae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81abb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abb6:	48 89 d6             	mov    %rdx,%rsi
  81abb9:	48 89 c7             	mov    %rax,%rdi
  81abbc:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  81abc3:	00 00 00 
  81abc6:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81abc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abcc:	48 be 14 a7 81 00 00 	movabs $0x81a714,%rsi
  81abd3:	00 00 00 
  81abd6:	48 89 c7             	mov    %rax,%rdi
  81abd9:	48 b8 d4 07 81 00 00 	movabs $0x8107d4,%rax
  81abe0:	00 00 00 
  81abe3:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81abe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abe9:	48 be 0d a9 81 00 00 	movabs $0x81a90d,%rsi
  81abf0:	00 00 00 
  81abf3:	48 89 c7             	mov    %rax,%rdi
  81abf6:	48 b8 f5 07 81 00 00 	movabs $0x8107f5,%rax
  81abfd:	00 00 00 
  81ac00:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81ac02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac06:	ba 04 00 00 00       	mov    $0x4,%edx
  81ac0b:	48 be 7d a8 81 00 00 	movabs $0x81a87d,%rsi
  81ac12:	00 00 00 
  81ac15:	48 89 c7             	mov    %rax,%rdi
  81ac18:	48 b8 55 08 81 00 00 	movabs $0x810855,%rax
  81ac1f:	00 00 00 
  81ac22:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81ac24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac28:	48 be 27 aa 81 00 00 	movabs $0x81aa27,%rsi
  81ac2f:	00 00 00 
  81ac32:	48 89 c7             	mov    %rax,%rdi
  81ac35:	48 b8 16 08 81 00 00 	movabs $0x810816,%rax
  81ac3c:	00 00 00 
  81ac3f:	ff d0                	callq  *%rax
}
  81ac41:	c9                   	leaveq 
  81ac42:	c3                   	retq   

000000000081ac43 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81ac43:	55                   	push   %rbp
  81ac44:	48 89 e5             	mov    %rsp,%rbp
  81ac47:	48 83 ec 30          	sub    $0x30,%rsp
  81ac4b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ac4f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ac53:	89 d0                	mov    %edx,%eax
  81ac55:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81ac58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81ac60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac64:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ac67:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ac6a:	75 2a                	jne    81ac96 <accept_function+0x53>
  81ac6c:	48 ba b8 36 82 00 00 	movabs $0x8236b8,%rdx
  81ac73:	00 00 00 
  81ac76:	be 65 01 00 00       	mov    $0x165,%esi
  81ac7b:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81ac82:	00 00 00 
  81ac85:	b8 00 00 00 00       	mov    $0x0,%eax
  81ac8a:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81ac91:	00 00 00 
  81ac94:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81ac96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac9a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81ac9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aca2:	8b 00                	mov    (%rax),%eax
  81aca4:	48 89 d6             	mov    %rdx,%rsi
  81aca7:	89 c7                	mov    %eax,%edi
  81aca9:	48 b8 8d af 81 00 00 	movabs $0x81af8d,%rax
  81acb0:	00 00 00 
  81acb3:	ff d0                	callq  *%rax
  81acb5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81acb9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81acbe:	75 0a                	jne    81acca <accept_function+0x87>
    return ERR_MEM;
  81acc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81acc5:	e9 9d 00 00 00       	jmpq   81ad67 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81acca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81acce:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81acd2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81acd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81acda:	48 89 c7             	mov    %rax,%rdi
  81acdd:	48 b8 96 ab 81 00 00 	movabs $0x81ab96,%rax
  81ace4:	00 00 00 
  81ace7:	ff d0                	callq  *%rax
  newconn->err = err;
  81ace9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aced:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81acf1:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81acf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acf8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81acfc:	48 85 c0             	test   %rax,%rax
  81acff:	74 1b                	je     81ad1c <accept_function+0xd9>
  81ad01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad05:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ad09:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ad0d:	ba 00 00 00 00       	mov    $0x0,%edx
  81ad12:	be 00 00 00 00       	mov    $0x0,%esi
  81ad17:	48 89 cf             	mov    %rcx,%rdi
  81ad1a:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81ad1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad20:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ad23:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81ad27:	48 89 d6             	mov    %rdx,%rsi
  81ad2a:	89 c7                	mov    %eax,%edi
  81ad2c:	48 b8 45 7a 81 00 00 	movabs $0x817a45,%rax
  81ad33:	00 00 00 
  81ad36:	ff d0                	callq  *%rax
  81ad38:	84 c0                	test   %al,%al
  81ad3a:	74 26                	je     81ad62 <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81ad3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ad40:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ad47:	00 
    netconn_free(newconn);
  81ad48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ad4c:	48 89 c7             	mov    %rax,%rdi
  81ad4f:	48 b8 c1 b0 81 00 00 	movabs $0x81b0c1,%rax
  81ad56:	00 00 00 
  81ad59:	ff d0                	callq  *%rax
    return ERR_MEM;
  81ad5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ad60:	eb 05                	jmp    81ad67 <accept_function+0x124>
  }
  return ERR_OK;
  81ad62:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ad67:	c9                   	leaveq 
  81ad68:	c3                   	retq   

000000000081ad69 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81ad69:	55                   	push   %rbp
  81ad6a:	48 89 e5             	mov    %rsp,%rbp
  81ad6d:	53                   	push   %rbx
  81ad6e:	48 83 ec 18          	sub    $0x18,%rsp
  81ad72:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81ad76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad7a:	48 8b 00             	mov    (%rax),%rax
  81ad7d:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81ad81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad85:	48 8b 00             	mov    (%rax),%rax
  81ad88:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ad8c:	48 85 c0             	test   %rax,%rax
  81ad8f:	74 2a                	je     81adbb <pcb_new+0x52>
  81ad91:	48 ba e8 36 82 00 00 	movabs $0x8236e8,%rdx
  81ad98:	00 00 00 
  81ad9b:	be 8a 01 00 00       	mov    $0x18a,%esi
  81ada0:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81ada7:	00 00 00 
  81adaa:	b8 00 00 00 00       	mov    $0x0,%eax
  81adaf:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81adb6:	00 00 00 
  81adb9:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81adbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adbf:	48 8b 00             	mov    (%rax),%rax
  81adc2:	8b 00                	mov    (%rax),%eax
  81adc4:	25 f0 00 00 00       	and    $0xf0,%eax
  81adc9:	83 f8 20             	cmp    $0x20,%eax
  81adcc:	0f 84 87 00 00 00    	je     81ae59 <pcb_new+0xf0>
  81add2:	83 f8 40             	cmp    $0x40,%eax
  81add5:	74 0e                	je     81ade5 <pcb_new+0x7c>
  81add7:	83 f8 10             	cmp    $0x10,%eax
  81adda:	0f 84 fa 00 00 00    	je     81aeda <pcb_new+0x171>
  81ade0:	e9 41 01 00 00       	jmpq   81af26 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81ade5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ade9:	48 8b 18             	mov    (%rax),%rbx
  81adec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adf0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81adf4:	0f b6 c0             	movzbl %al,%eax
  81adf7:	89 c7                	mov    %eax,%edi
  81adf9:	48 b8 3f 00 82 00 00 	movabs $0x82003f,%rax
  81ae00:	00 00 00 
  81ae03:	ff d0                	callq  *%rax
  81ae05:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81ae09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae0d:	48 8b 00             	mov    (%rax),%rax
  81ae10:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae14:	48 85 c0             	test   %rax,%rax
  81ae17:	75 10                	jne    81ae29 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81ae19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae1d:	48 8b 00             	mov    (%rax),%rax
  81ae20:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ae24:	e9 09 01 00 00       	jmpq   81af32 <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81ae29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae2d:	48 8b 10             	mov    (%rax),%rdx
  81ae30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae34:	48 8b 00             	mov    (%rax),%rax
  81ae37:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae3b:	48 be a1 a3 81 00 00 	movabs $0x81a3a1,%rsi
  81ae42:	00 00 00 
  81ae45:	48 89 c7             	mov    %rax,%rdi
  81ae48:	48 b8 8f fd 81 00 00 	movabs $0x81fd8f,%rax
  81ae4f:	00 00 00 
  81ae52:	ff d0                	callq  *%rax
     break;
  81ae54:	e9 d9 00 00 00       	jmpq   81af32 <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81ae59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae5d:	48 8b 18             	mov    (%rax),%rbx
  81ae60:	48 b8 25 58 81 00 00 	movabs $0x815825,%rax
  81ae67:	00 00 00 
  81ae6a:	ff d0                	callq  *%rax
  81ae6c:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81ae70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae74:	48 8b 00             	mov    (%rax),%rax
  81ae77:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae7b:	48 85 c0             	test   %rax,%rax
  81ae7e:	75 10                	jne    81ae90 <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81ae80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae84:	48 8b 00             	mov    (%rax),%rax
  81ae87:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ae8b:	e9 a2 00 00 00       	jmpq   81af32 <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81ae90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae94:	48 8b 00             	mov    (%rax),%rax
  81ae97:	8b 00                	mov    (%rax),%eax
  81ae99:	83 f8 22             	cmp    $0x22,%eax
  81ae9c:	75 0f                	jne    81aead <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81ae9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aea2:	48 8b 00             	mov    (%rax),%rax
  81aea5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aea9:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81aead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aeb1:	48 8b 10             	mov    (%rax),%rdx
  81aeb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aeb8:	48 8b 00             	mov    (%rax),%rax
  81aebb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aebf:	48 be 47 a5 81 00 00 	movabs $0x81a547,%rsi
  81aec6:	00 00 00 
  81aec9:	48 89 c7             	mov    %rax,%rdi
  81aecc:	48 b8 4d 57 81 00 00 	movabs $0x81574d,%rax
  81aed3:	00 00 00 
  81aed6:	ff d0                	callq  *%rax
     break;
  81aed8:	eb 58                	jmp    81af32 <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81aeda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aede:	48 8b 18             	mov    (%rax),%rbx
  81aee1:	48 b8 9f 07 81 00 00 	movabs $0x81079f,%rax
  81aee8:	00 00 00 
  81aeeb:	ff d0                	callq  *%rax
  81aeed:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81aef1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aef5:	48 8b 00             	mov    (%rax),%rax
  81aef8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aefc:	48 85 c0             	test   %rax,%rax
  81aeff:	75 0d                	jne    81af0e <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81af01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af05:	48 8b 00             	mov    (%rax),%rax
  81af08:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81af0c:	eb 24                	jmp    81af32 <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81af0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af12:	48 8b 00             	mov    (%rax),%rax
  81af15:	48 89 c7             	mov    %rax,%rdi
  81af18:	48 b8 96 ab 81 00 00 	movabs $0x81ab96,%rax
  81af1f:	00 00 00 
  81af22:	ff d0                	callq  *%rax
     break;
  81af24:	eb 0c                	jmp    81af32 <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81af26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af2a:	48 8b 00             	mov    (%rax),%rax
  81af2d:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81af31:	90                   	nop
   }

  return msg->conn->err;
  81af32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af36:	48 8b 00             	mov    (%rax),%rax
  81af39:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81af3d:	48 83 c4 18          	add    $0x18,%rsp
  81af41:	5b                   	pop    %rbx
  81af42:	5d                   	pop    %rbp
  81af43:	c3                   	retq   

000000000081af44 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81af44:	55                   	push   %rbp
  81af45:	48 89 e5             	mov    %rsp,%rbp
  81af48:	48 83 ec 10          	sub    $0x10,%rsp
  81af4c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81af50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af54:	48 8b 00             	mov    (%rax),%rax
  81af57:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af5b:	48 85 c0             	test   %rax,%rax
  81af5e:	75 13                	jne    81af73 <do_newconn+0x2f>
     pcb_new(msg);
  81af60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af64:	48 89 c7             	mov    %rax,%rdi
  81af67:	48 b8 69 ad 81 00 00 	movabs $0x81ad69,%rax
  81af6e:	00 00 00 
  81af71:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81af73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af77:	48 8b 00             	mov    (%rax),%rax
  81af7a:	8b 40 14             	mov    0x14(%rax),%eax
  81af7d:	89 c7                	mov    %eax,%edi
  81af7f:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81af86:	00 00 00 
  81af89:	ff d0                	callq  *%rax
}
  81af8b:	c9                   	leaveq 
  81af8c:	c3                   	retq   

000000000081af8d <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81af8d:	55                   	push   %rbp
  81af8e:	48 89 e5             	mov    %rsp,%rbp
  81af91:	48 83 ec 20          	sub    $0x20,%rsp
  81af95:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81af98:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81af9c:	bf 07 00 00 00       	mov    $0x7,%edi
  81afa1:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  81afa8:	00 00 00 
  81afab:	ff d0                	callq  *%rax
  81afad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81afb1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81afb6:	75 0a                	jne    81afc2 <netconn_alloc+0x35>
    return NULL;
  81afb8:	b8 00 00 00 00       	mov    $0x0,%eax
  81afbd:	e9 fd 00 00 00       	jmpq   81b0bf <netconn_alloc+0x132>
  }

  conn->err = ERR_OK;
  81afc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81afc6:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81afca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81afce:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81afd1:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81afd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81afd7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81afde:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81afdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81afe6:	bf 00 00 00 00       	mov    $0x0,%edi
  81afeb:	48 b8 ab 7c 81 00 00 	movabs $0x817cab,%rax
  81aff2:	00 00 00 
  81aff5:	ff d0                	callq  *%rax
  81aff7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81affb:	89 42 14             	mov    %eax,0x14(%rdx)
  81affe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b002:	8b 40 14             	mov    0x14(%rax),%eax
  81b005:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b008:	75 22                	jne    81b02c <netconn_alloc+0x9f>
    memp_free(MEMP_NETCONN, conn);
  81b00a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b00e:	48 89 c6             	mov    %rax,%rsi
  81b011:	bf 07 00 00 00       	mov    $0x7,%edi
  81b016:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81b01d:	00 00 00 
  81b020:	ff d0                	callq  *%rax
    return NULL;
  81b022:	b8 00 00 00 00       	mov    $0x0,%eax
  81b027:	e9 93 00 00 00       	jmpq   81b0bf <netconn_alloc+0x132>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81b02c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81b02f:	89 c7                	mov    %eax,%edi
  81b031:	48 b8 b4 75 81 00 00 	movabs $0x8175b4,%rax
  81b038:	00 00 00 
  81b03b:	ff d0                	callq  *%rax
  81b03d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b041:	89 42 18             	mov    %eax,0x18(%rdx)
  81b044:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b048:	8b 40 18             	mov    0x18(%rax),%eax
  81b04b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b04e:	75 34                	jne    81b084 <netconn_alloc+0xf7>
    sys_sem_free(conn->op_completed);
  81b050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b054:	8b 40 14             	mov    0x14(%rax),%eax
  81b057:	89 c7                	mov    %eax,%edi
  81b059:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  81b060:	00 00 00 
  81b063:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81b065:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b069:	48 89 c6             	mov    %rax,%rsi
  81b06c:	bf 07 00 00 00       	mov    $0x7,%edi
  81b071:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81b078:	00 00 00 
  81b07b:	ff d0                	callq  *%rax
    return NULL;
  81b07d:	b8 00 00 00 00       	mov    $0x0,%eax
  81b082:	eb 3b                	jmp    81b0bf <netconn_alloc+0x132>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81b084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b088:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81b08f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b093:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81b09a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b09e:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81b0a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0a9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81b0ad:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81b0b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0b5:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81b0bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81b0bf:	c9                   	leaveq 
  81b0c0:	c3                   	retq   

000000000081b0c1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81b0c1:	55                   	push   %rbp
  81b0c2:	48 89 e5             	mov    %rsp,%rbp
  81b0c5:	48 83 ec 20          	sub    $0x20,%rsp
  81b0c9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81b0cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0d1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0d5:	48 85 c0             	test   %rax,%rax
  81b0d8:	74 2a                	je     81b104 <netconn_free+0x43>
  81b0da:	48 ba 08 37 82 00 00 	movabs $0x823708,%rdx
  81b0e1:	00 00 00 
  81b0e4:	be 26 02 00 00       	mov    $0x226,%esi
  81b0e9:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b0f0:	00 00 00 
  81b0f3:	b8 00 00 00 00       	mov    $0x0,%eax
  81b0f8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b0ff:	00 00 00 
  81b102:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81b104:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b108:	8b 40 18             	mov    0x18(%rax),%eax
  81b10b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b10e:	74 7f                	je     81b18f <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b110:	eb 3c                	jmp    81b14e <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81b112:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b116:	8b 00                	mov    (%rax),%eax
  81b118:	83 f8 10             	cmp    $0x10,%eax
  81b11b:	75 1e                	jne    81b13b <netconn_free+0x7a>
        if(mem != NULL) {
  81b11d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b121:	48 85 c0             	test   %rax,%rax
  81b124:	74 28                	je     81b14e <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81b126:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b12a:	48 89 c7             	mov    %rax,%rdi
  81b12d:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81b134:	00 00 00 
  81b137:	ff d0                	callq  *%rax
  81b139:	eb 13                	jmp    81b14e <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81b13b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b13f:	48 89 c7             	mov    %rax,%rdi
  81b142:	48 b8 94 8d 80 00 00 	movabs $0x808d94,%rax
  81b149:	00 00 00 
  81b14c:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b14e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b152:	8b 40 18             	mov    0x18(%rax),%eax
  81b155:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b159:	48 89 d6             	mov    %rdx,%rsi
  81b15c:	89 c7                	mov    %eax,%edi
  81b15e:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  81b165:	00 00 00 
  81b168:	ff d0                	callq  *%rax
  81b16a:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b16d:	75 a3                	jne    81b112 <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81b16f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b173:	8b 40 18             	mov    0x18(%rax),%eax
  81b176:	89 c7                	mov    %eax,%edi
  81b178:	48 b8 94 77 81 00 00 	movabs $0x817794,%rax
  81b17f:	00 00 00 
  81b182:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81b184:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b188:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81b18f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b193:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b196:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b199:	74 56                	je     81b1f1 <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b19b:	eb 13                	jmp    81b1b0 <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81b19d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1a1:	48 89 c7             	mov    %rax,%rdi
  81b1a4:	48 b8 ae 9a 81 00 00 	movabs $0x819aae,%rax
  81b1ab:	00 00 00 
  81b1ae:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b1b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1b4:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b1b7:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b1bb:	48 89 d6             	mov    %rdx,%rsi
  81b1be:	89 c7                	mov    %eax,%edi
  81b1c0:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  81b1c7:	00 00 00 
  81b1ca:	ff d0                	callq  *%rax
  81b1cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b1cf:	75 cc                	jne    81b19d <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81b1d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1d5:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b1d8:	89 c7                	mov    %eax,%edi
  81b1da:	48 b8 94 77 81 00 00 	movabs $0x817794,%rax
  81b1e1:	00 00 00 
  81b1e4:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81b1e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1ea:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81b1f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1f5:	8b 40 14             	mov    0x14(%rax),%eax
  81b1f8:	89 c7                	mov    %eax,%edi
  81b1fa:	48 b8 a9 7d 81 00 00 	movabs $0x817da9,%rax
  81b201:	00 00 00 
  81b204:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81b206:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b20a:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81b211:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b215:	48 89 c6             	mov    %rax,%rsi
  81b218:	bf 07 00 00 00       	mov    $0x7,%edi
  81b21d:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81b224:	00 00 00 
  81b227:	ff d0                	callq  *%rax
}
  81b229:	c9                   	leaveq 
  81b22a:	c3                   	retq   

000000000081b22b <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81b22b:	55                   	push   %rbp
  81b22c:	48 89 e5             	mov    %rsp,%rbp
  81b22f:	48 83 ec 20          	sub    $0x20,%rsp
  81b233:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81b237:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b23c:	75 2a                	jne    81b268 <do_close_internal+0x3d>
  81b23e:	48 ba 36 37 82 00 00 	movabs $0x823736,%rdx
  81b245:	00 00 00 
  81b248:	be 53 02 00 00       	mov    $0x253,%esi
  81b24d:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b254:	00 00 00 
  81b257:	b8 00 00 00 00       	mov    $0x0,%eax
  81b25c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b263:	00 00 00 
  81b266:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81b268:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b26c:	8b 00                	mov    (%rax),%eax
  81b26e:	83 f8 10             	cmp    $0x10,%eax
  81b271:	74 2a                	je     81b29d <do_close_internal+0x72>
  81b273:	48 ba 43 37 82 00 00 	movabs $0x823743,%rdx
  81b27a:	00 00 00 
  81b27d:	be 54 02 00 00       	mov    $0x254,%esi
  81b282:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b289:	00 00 00 
  81b28c:	b8 00 00 00 00       	mov    $0x0,%eax
  81b291:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b298:	00 00 00 
  81b29b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81b29d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2a1:	8b 40 04             	mov    0x4(%rax),%eax
  81b2a4:	83 f8 04             	cmp    $0x4,%eax
  81b2a7:	74 2a                	je     81b2d3 <do_close_internal+0xa8>
  81b2a9:	48 ba 68 37 82 00 00 	movabs $0x823768,%rdx
  81b2b0:	00 00 00 
  81b2b3:	be 55 02 00 00       	mov    $0x255,%esi
  81b2b8:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b2bf:	00 00 00 
  81b2c2:	b8 00 00 00 00       	mov    $0x0,%eax
  81b2c7:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b2ce:	00 00 00 
  81b2d1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81b2d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2db:	48 85 c0             	test   %rax,%rax
  81b2de:	75 2a                	jne    81b30a <do_close_internal+0xdf>
  81b2e0:	48 ba 8c 37 82 00 00 	movabs $0x82378c,%rdx
  81b2e7:	00 00 00 
  81b2ea:	be 56 02 00 00       	mov    $0x256,%esi
  81b2ef:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b2f6:	00 00 00 
  81b2f9:	b8 00 00 00 00       	mov    $0x0,%eax
  81b2fe:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b305:	00 00 00 
  81b308:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b30a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b30e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b312:	be 00 00 00 00       	mov    $0x0,%esi
  81b317:	48 89 c7             	mov    %rax,%rdi
  81b31a:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  81b321:	00 00 00 
  81b324:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b326:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b32a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b32e:	8b 40 18             	mov    0x18(%rax),%eax
  81b331:	83 f8 01             	cmp    $0x1,%eax
  81b334:	75 21                	jne    81b357 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b336:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b33a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b33e:	be 00 00 00 00       	mov    $0x0,%esi
  81b343:	48 89 c7             	mov    %rax,%rdi
  81b346:	48 b8 37 08 81 00 00 	movabs $0x810837,%rax
  81b34d:	00 00 00 
  81b350:	ff d0                	callq  *%rax
  81b352:	e9 91 00 00 00       	jmpq   81b3e8 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b357:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b35b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b35f:	be 00 00 00 00       	mov    $0x0,%esi
  81b364:	48 89 c7             	mov    %rax,%rdi
  81b367:	48 b8 d4 07 81 00 00 	movabs $0x8107d4,%rax
  81b36e:	00 00 00 
  81b371:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b373:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b377:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b37b:	be 00 00 00 00       	mov    $0x0,%esi
  81b380:	48 89 c7             	mov    %rax,%rdi
  81b383:	48 b8 37 08 81 00 00 	movabs $0x810837,%rax
  81b38a:	00 00 00 
  81b38d:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b38f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b393:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b397:	be 00 00 00 00       	mov    $0x0,%esi
  81b39c:	48 89 c7             	mov    %rax,%rdi
  81b39f:	48 b8 f5 07 81 00 00 	movabs $0x8107f5,%rax
  81b3a6:	00 00 00 
  81b3a9:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b3ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3af:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3b3:	ba 04 00 00 00       	mov    $0x4,%edx
  81b3b8:	be 00 00 00 00       	mov    $0x0,%esi
  81b3bd:	48 89 c7             	mov    %rax,%rdi
  81b3c0:	48 b8 55 08 81 00 00 	movabs $0x810855,%rax
  81b3c7:	00 00 00 
  81b3ca:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b3cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3d4:	be 00 00 00 00       	mov    $0x0,%esi
  81b3d9:	48 89 c7             	mov    %rax,%rdi
  81b3dc:	48 b8 16 08 81 00 00 	movabs $0x810816,%rax
  81b3e3:	00 00 00 
  81b3e6:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b3e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3f0:	48 89 c7             	mov    %rax,%rdi
  81b3f3:	48 b8 58 eb 80 00 00 	movabs $0x80eb58,%rax
  81b3fa:	00 00 00 
  81b3fd:	ff d0                	callq  *%rax
  81b3ff:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b402:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b406:	0f 85 89 00 00 00    	jne    81b495 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b40c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b410:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b417:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b41b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b422:	00 
    conn->err = ERR_OK;
  81b423:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b427:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b42b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b42f:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b433:	48 85 c0             	test   %rax,%rax
  81b436:	74 1b                	je     81b453 <do_close_internal+0x228>
  81b438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b43c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b440:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b444:	ba 00 00 00 00       	mov    $0x0,%edx
  81b449:	be 00 00 00 00       	mov    $0x0,%esi
  81b44e:	48 89 cf             	mov    %rcx,%rdi
  81b451:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b453:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b457:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b45b:	48 85 c0             	test   %rax,%rax
  81b45e:	74 1b                	je     81b47b <do_close_internal+0x250>
  81b460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b464:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b468:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b46c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b471:	be 02 00 00 00       	mov    $0x2,%esi
  81b476:	48 89 cf             	mov    %rcx,%rdi
  81b479:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b47b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b47f:	8b 40 14             	mov    0x14(%rax),%eax
  81b482:	89 c7                	mov    %eax,%edi
  81b484:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b48b:	00 00 00 
  81b48e:	ff d0                	callq  *%rax
  81b490:	e9 c0 00 00 00       	jmpq   81b555 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b495:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b499:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b49d:	8b 40 18             	mov    0x18(%rax),%eax
  81b4a0:	83 f8 01             	cmp    $0x1,%eax
  81b4a3:	75 2a                	jne    81b4cf <do_close_internal+0x2a4>
  81b4a5:	48 ba a0 37 82 00 00 	movabs $0x8237a0,%rdx
  81b4ac:	00 00 00 
  81b4af:	be 75 02 00 00       	mov    $0x275,%esi
  81b4b4:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81b4bb:	00 00 00 
  81b4be:	b8 00 00 00 00       	mov    $0x0,%eax
  81b4c3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81b4ca:	00 00 00 
  81b4cd:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b4cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4d7:	48 be 0d a9 81 00 00 	movabs $0x81a90d,%rsi
  81b4de:	00 00 00 
  81b4e1:	48 89 c7             	mov    %rax,%rdi
  81b4e4:	48 b8 f5 07 81 00 00 	movabs $0x8107f5,%rax
  81b4eb:	00 00 00 
  81b4ee:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b4f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4f8:	ba 04 00 00 00       	mov    $0x4,%edx
  81b4fd:	48 be 7d a8 81 00 00 	movabs $0x81a87d,%rsi
  81b504:	00 00 00 
  81b507:	48 89 c7             	mov    %rax,%rdi
  81b50a:	48 b8 55 08 81 00 00 	movabs $0x810855,%rax
  81b511:	00 00 00 
  81b514:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b516:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b51a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b51e:	48 be 27 aa 81 00 00 	movabs $0x81aa27,%rsi
  81b525:	00 00 00 
  81b528:	48 89 c7             	mov    %rax,%rdi
  81b52b:	48 b8 16 08 81 00 00 	movabs $0x810816,%rax
  81b532:	00 00 00 
  81b535:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b53b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b53f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b543:	48 89 d6             	mov    %rdx,%rsi
  81b546:	48 89 c7             	mov    %rax,%rdi
  81b549:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  81b550:	00 00 00 
  81b553:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b555:	c9                   	leaveq 
  81b556:	c3                   	retq   

000000000081b557 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b557:	55                   	push   %rbp
  81b558:	48 89 e5             	mov    %rsp,%rbp
  81b55b:	48 83 ec 10          	sub    $0x10,%rsp
  81b55f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b563:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b567:	48 8b 00             	mov    (%rax),%rax
  81b56a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b56e:	48 85 c0             	test   %rax,%rax
  81b571:	0f 84 93 00 00 00    	je     81b60a <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b577:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b57b:	48 8b 00             	mov    (%rax),%rax
  81b57e:	8b 00                	mov    (%rax),%eax
  81b580:	25 f0 00 00 00       	and    $0xf0,%eax
  81b585:	83 f8 20             	cmp    $0x20,%eax
  81b588:	74 28                	je     81b5b2 <do_delconn+0x5b>
  81b58a:	83 f8 40             	cmp    $0x40,%eax
  81b58d:	74 07                	je     81b596 <do_delconn+0x3f>
  81b58f:	83 f8 10             	cmp    $0x10,%eax
  81b592:	74 4d                	je     81b5e1 <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81b594:	eb 74                	jmp    81b60a <do_delconn+0xb3>
{
  if (msg->conn->pcb.tcp != NULL) {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b596:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b59a:	48 8b 00             	mov    (%rax),%rax
  81b59d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5a1:	48 89 c7             	mov    %rax,%rdi
  81b5a4:	48 b8 95 ff 81 00 00 	movabs $0x81ff95,%rax
  81b5ab:	00 00 00 
  81b5ae:	ff d0                	callq  *%rax
      break;
  81b5b0:	eb 58                	jmp    81b60a <do_delconn+0xb3>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b5b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5b6:	48 8b 00             	mov    (%rax),%rax
  81b5b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5bd:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b5c4:	00 
      udp_remove(msg->conn->pcb.udp);
  81b5c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5c9:	48 8b 00             	mov    (%rax),%rax
  81b5cc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5d0:	48 89 c7             	mov    %rax,%rdi
  81b5d3:	48 b8 7b 57 81 00 00 	movabs $0x81577b,%rax
  81b5da:	00 00 00 
  81b5dd:	ff d0                	callq  *%rax
      break;
  81b5df:	eb 29                	jmp    81b60a <do_delconn+0xb3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b5e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5e5:	48 8b 00             	mov    (%rax),%rax
  81b5e8:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b5ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5f3:	48 8b 00             	mov    (%rax),%rax
  81b5f6:	48 89 c7             	mov    %rax,%rdi
  81b5f9:	48 b8 2b b2 81 00 00 	movabs $0x81b22b,%rax
  81b600:	00 00 00 
  81b603:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b605:	e9 89 00 00 00       	jmpq   81b693 <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b60a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b60e:	48 8b 00             	mov    (%rax),%rax
  81b611:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b615:	48 85 c0             	test   %rax,%rax
  81b618:	74 21                	je     81b63b <do_delconn+0xe4>
  81b61a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b61e:	48 8b 00             	mov    (%rax),%rax
  81b621:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b625:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b629:	48 8b 0a             	mov    (%rdx),%rcx
  81b62c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b631:	be 00 00 00 00       	mov    $0x0,%esi
  81b636:	48 89 cf             	mov    %rcx,%rdi
  81b639:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b63b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b63f:	48 8b 00             	mov    (%rax),%rax
  81b642:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b646:	48 85 c0             	test   %rax,%rax
  81b649:	74 21                	je     81b66c <do_delconn+0x115>
  81b64b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b64f:	48 8b 00             	mov    (%rax),%rax
  81b652:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b656:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b65a:	48 8b 0a             	mov    (%rdx),%rcx
  81b65d:	ba 00 00 00 00       	mov    $0x0,%edx
  81b662:	be 02 00 00 00       	mov    $0x2,%esi
  81b667:	48 89 cf             	mov    %rcx,%rdi
  81b66a:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b66c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b670:	48 8b 00             	mov    (%rax),%rax
  81b673:	8b 40 14             	mov    0x14(%rax),%eax
  81b676:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b679:	74 18                	je     81b693 <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81b67b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b67f:	48 8b 00             	mov    (%rax),%rax
  81b682:	8b 40 14             	mov    0x14(%rax),%eax
  81b685:	89 c7                	mov    %eax,%edi
  81b687:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b68e:	00 00 00 
  81b691:	ff d0                	callq  *%rax
  }
}
  81b693:	c9                   	leaveq 
  81b694:	c3                   	retq   

000000000081b695 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b695:	55                   	push   %rbp
  81b696:	48 89 e5             	mov    %rsp,%rbp
  81b699:	53                   	push   %rbx
  81b69a:	48 83 ec 18          	sub    $0x18,%rsp
  81b69e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b6a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6a6:	48 8b 00             	mov    (%rax),%rax
  81b6a9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b6ad:	3c fc                	cmp    $0xfc,%al
  81b6af:	0f 8c eb 00 00 00    	jl     81b7a0 <do_bind+0x10b>
    if (msg->conn->pcb.tcp != NULL) {
  81b6b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6b9:	48 8b 00             	mov    (%rax),%rax
  81b6bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6c0:	48 85 c0             	test   %rax,%rax
  81b6c3:	0f 84 cc 00 00 00    	je     81b795 <do_bind+0x100>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b6c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6cd:	48 8b 00             	mov    (%rax),%rax
  81b6d0:	8b 00                	mov    (%rax),%eax
  81b6d2:	25 f0 00 00 00       	and    $0xf0,%eax
  81b6d7:	83 f8 20             	cmp    $0x20,%eax
  81b6da:	74 40                	je     81b71c <do_bind+0x87>
  81b6dc:	83 f8 40             	cmp    $0x40,%eax
  81b6df:	74 0a                	je     81b6eb <do_bind+0x56>
  81b6e1:	83 f8 10             	cmp    $0x10,%eax
  81b6e4:	74 72                	je     81b758 <do_bind+0xc3>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81b6e6:	e9 a8 00 00 00       	jmpq   81b793 <do_bind+0xfe>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b6eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6ef:	48 8b 18             	mov    (%rax),%rbx
  81b6f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6f6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b6fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6fe:	48 8b 00             	mov    (%rax),%rax
  81b701:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b705:	48 89 d6             	mov    %rdx,%rsi
  81b708:	48 89 c7             	mov    %rax,%rdi
  81b70b:	48 b8 2c fd 81 00 00 	movabs $0x81fd2c,%rax
  81b712:	00 00 00 
  81b715:	ff d0                	callq  *%rax
  81b717:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b71a:	eb 77                	jmp    81b793 <do_bind+0xfe>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b71c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b720:	48 8b 18             	mov    (%rax),%rbx
  81b723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b727:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b72b:	0f b7 d0             	movzwl %ax,%edx
  81b72e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b732:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b736:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b73a:	48 8b 00             	mov    (%rax),%rax
  81b73d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b741:	48 89 ce             	mov    %rcx,%rsi
  81b744:	48 89 c7             	mov    %rax,%rdi
  81b747:	48 b8 c9 54 81 00 00 	movabs $0x8154c9,%rax
  81b74e:	00 00 00 
  81b751:	ff d0                	callq  *%rax
  81b753:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b756:	eb 3b                	jmp    81b793 <do_bind+0xfe>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b758:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b75c:	48 8b 18             	mov    (%rax),%rbx
  81b75f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b763:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b767:	0f b7 d0             	movzwl %ax,%edx
  81b76a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b76e:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b776:	48 8b 00             	mov    (%rax),%rax
  81b779:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b77d:	48 89 ce             	mov    %rcx,%rsi
  81b780:	48 89 c7             	mov    %rax,%rdi
  81b783:	48 b8 a7 ef 80 00 00 	movabs $0x80efa7,%rax
  81b78a:	00 00 00 
  81b78d:	ff d0                	callq  *%rax
  81b78f:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b792:	90                   	nop
  81b793:	eb 0b                	jmp    81b7a0 <do_bind+0x10b>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81b795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b799:	48 8b 00             	mov    (%rax),%rax
  81b79c:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b7a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7a4:	48 8b 00             	mov    (%rax),%rax
  81b7a7:	8b 40 14             	mov    0x14(%rax),%eax
  81b7aa:	89 c7                	mov    %eax,%edi
  81b7ac:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b7b3:	00 00 00 
  81b7b6:	ff d0                	callq  *%rax
}
  81b7b8:	48 83 c4 18          	add    $0x18,%rsp
  81b7bc:	5b                   	pop    %rbx
  81b7bd:	5d                   	pop    %rbp
  81b7be:	c3                   	retq   

000000000081b7bf <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81b7bf:	55                   	push   %rbp
  81b7c0:	48 89 e5             	mov    %rsp,%rbp
  81b7c3:	48 83 ec 30          	sub    $0x30,%rsp
  81b7c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81b7cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81b7cf:	89 d0                	mov    %edx,%eax
  81b7d1:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81b7d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81b7dc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b7e1:	75 07                	jne    81b7ea <do_connected+0x2b>
    return ERR_VAL;
  81b7e3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81b7e8:	eb 54                	jmp    81b83e <do_connected+0x7f>
  }

  conn->err = err;
  81b7ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7ee:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81b7f2:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81b7f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7f9:	8b 00                	mov    (%rax),%eax
  81b7fb:	83 f8 10             	cmp    $0x10,%eax
  81b7fe:	75 19                	jne    81b819 <do_connected+0x5a>
  81b800:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81b804:	75 13                	jne    81b819 <do_connected+0x5a>
    setup_tcp(conn);
  81b806:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b80a:	48 89 c7             	mov    %rax,%rdi
  81b80d:	48 b8 96 ab 81 00 00 	movabs $0x81ab96,%rax
  81b814:	00 00 00 
  81b817:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81b819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b81d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81b824:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b828:	8b 40 14             	mov    0x14(%rax),%eax
  81b82b:	89 c7                	mov    %eax,%edi
  81b82d:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b834:	00 00 00 
  81b837:	ff d0                	callq  *%rax
  return ERR_OK;
  81b839:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b83e:	c9                   	leaveq 
  81b83f:	c3                   	retq   

000000000081b840 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81b840:	55                   	push   %rbp
  81b841:	48 89 e5             	mov    %rsp,%rbp
  81b844:	53                   	push   %rbx
  81b845:	48 83 ec 18          	sub    $0x18,%rsp
  81b849:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81b84d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b851:	48 8b 00             	mov    (%rax),%rax
  81b854:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b858:	48 85 c0             	test   %rax,%rax
  81b85b:	75 1d                	jne    81b87a <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81b85d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b861:	48 8b 00             	mov    (%rax),%rax
  81b864:	8b 40 14             	mov    0x14(%rax),%eax
  81b867:	89 c7                	mov    %eax,%edi
  81b869:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b870:	00 00 00 
  81b873:	ff d0                	callq  *%rax
    return;
  81b875:	e9 2c 01 00 00       	jmpq   81b9a6 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b87a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b87e:	48 8b 00             	mov    (%rax),%rax
  81b881:	8b 00                	mov    (%rax),%eax
  81b883:	25 f0 00 00 00       	and    $0xf0,%eax
  81b888:	83 f8 20             	cmp    $0x20,%eax
  81b88b:	74 5f                	je     81b8ec <do_connect+0xac>
  81b88d:	83 f8 40             	cmp    $0x40,%eax
  81b890:	74 0e                	je     81b8a0 <do_connect+0x60>
  81b892:	83 f8 10             	cmp    $0x10,%eax
  81b895:	0f 84 a5 00 00 00    	je     81b940 <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81b89b:	e9 06 01 00 00       	jmpq   81b9a6 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b8a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8a4:	48 8b 18             	mov    (%rax),%rbx
  81b8a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8ab:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b8af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8b3:	48 8b 00             	mov    (%rax),%rax
  81b8b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8ba:	48 89 d6             	mov    %rdx,%rsi
  81b8bd:	48 89 c7             	mov    %rax,%rdi
  81b8c0:	48 b8 5d fd 81 00 00 	movabs $0x81fd5d,%rax
  81b8c7:	00 00 00 
  81b8ca:	ff d0                	callq  *%rax
  81b8cc:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b8cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8d3:	48 8b 00             	mov    (%rax),%rax
  81b8d6:	8b 40 14             	mov    0x14(%rax),%eax
  81b8d9:	89 c7                	mov    %eax,%edi
  81b8db:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b8e2:	00 00 00 
  81b8e5:	ff d0                	callq  *%rax
    break;
  81b8e7:	e9 ba 00 00 00       	jmpq   81b9a6 <do_connect+0x166>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b8ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8f0:	48 8b 18             	mov    (%rax),%rbx
  81b8f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8f7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b8fb:	0f b7 d0             	movzwl %ax,%edx
  81b8fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b902:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b906:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b90a:	48 8b 00             	mov    (%rax),%rax
  81b90d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b911:	48 89 ce             	mov    %rcx,%rsi
  81b914:	48 89 c7             	mov    %rax,%rdi
  81b917:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  81b91e:	00 00 00 
  81b921:	ff d0                	callq  *%rax
  81b923:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b926:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b92a:	48 8b 00             	mov    (%rax),%rax
  81b92d:	8b 40 14             	mov    0x14(%rax),%eax
  81b930:	89 c7                	mov    %eax,%edi
  81b932:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b939:	00 00 00 
  81b93c:	ff d0                	callq  *%rax
    break;
  81b93e:	eb 66                	jmp    81b9a6 <do_connect+0x166>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81b940:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b944:	48 8b 00             	mov    (%rax),%rax
  81b947:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81b94e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b952:	48 8b 00             	mov    (%rax),%rax
  81b955:	48 89 c7             	mov    %rax,%rdi
  81b958:	48 b8 96 ab 81 00 00 	movabs $0x81ab96,%rax
  81b95f:	00 00 00 
  81b962:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81b964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b968:	48 8b 18             	mov    (%rax),%rbx
  81b96b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b96f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b973:	0f b7 d0             	movzwl %ax,%edx
  81b976:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b97a:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81b97e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b982:	48 8b 00             	mov    (%rax),%rax
  81b985:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b989:	48 b9 bf b7 81 00 00 	movabs $0x81b7bf,%rcx
  81b990:	00 00 00 
  81b993:	48 89 c7             	mov    %rax,%rdi
  81b996:	48 b8 e1 f6 80 00 00 	movabs $0x80f6e1,%rax
  81b99d:	00 00 00 
  81b9a0:	ff d0                	callq  *%rax
  81b9a2:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81b9a5:	90                   	nop
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  81b9a6:	48 83 c4 18          	add    $0x18,%rsp
  81b9aa:	5b                   	pop    %rbx
  81b9ab:	5d                   	pop    %rbp
  81b9ac:	c3                   	retq   

000000000081b9ad <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81b9ad:	55                   	push   %rbp
  81b9ae:	48 89 e5             	mov    %rsp,%rbp
  81b9b1:	48 83 ec 10          	sub    $0x10,%rsp
  81b9b5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81b9b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b9bd:	48 8b 00             	mov    (%rax),%rax
  81b9c0:	8b 00                	mov    (%rax),%eax
  81b9c2:	25 f0 00 00 00       	and    $0xf0,%eax
  81b9c7:	83 f8 20             	cmp    $0x20,%eax
  81b9ca:	75 1a                	jne    81b9e6 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81b9cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b9d0:	48 8b 00             	mov    (%rax),%rax
  81b9d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9d7:	48 89 c7             	mov    %rax,%rdi
  81b9da:	48 b8 0e 57 81 00 00 	movabs $0x81570e,%rax
  81b9e1:	00 00 00 
  81b9e4:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81b9e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b9ea:	48 8b 00             	mov    (%rax),%rax
  81b9ed:	8b 40 14             	mov    0x14(%rax),%eax
  81b9f0:	89 c7                	mov    %eax,%edi
  81b9f2:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81b9f9:	00 00 00 
  81b9fc:	ff d0                	callq  *%rax
}
  81b9fe:	c9                   	leaveq 
  81b9ff:	c3                   	retq   

000000000081ba00 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81ba00:	55                   	push   %rbp
  81ba01:	48 89 e5             	mov    %rsp,%rbp
  81ba04:	53                   	push   %rbx
  81ba05:	48 83 ec 28          	sub    $0x28,%rsp
  81ba09:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81ba0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba11:	48 8b 00             	mov    (%rax),%rax
  81ba14:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81ba18:	3c fc                	cmp    $0xfc,%al
  81ba1a:	0f 8c 6b 01 00 00    	jl     81bb8b <do_listen+0x18b>
    if (msg->conn->pcb.tcp != NULL) {
  81ba20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba24:	48 8b 00             	mov    (%rax),%rax
  81ba27:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba2b:	48 85 c0             	test   %rax,%rax
  81ba2e:	0f 84 57 01 00 00    	je     81bb8b <do_listen+0x18b>
      if (msg->conn->type == NETCONN_TCP) {
  81ba34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba38:	48 8b 00             	mov    (%rax),%rax
  81ba3b:	8b 00                	mov    (%rax),%eax
  81ba3d:	83 f8 10             	cmp    $0x10,%eax
  81ba40:	0f 85 45 01 00 00    	jne    81bb8b <do_listen+0x18b>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81ba46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba4a:	48 8b 00             	mov    (%rax),%rax
  81ba4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba51:	8b 40 18             	mov    0x18(%rax),%eax
  81ba54:	85 c0                	test   %eax,%eax
  81ba56:	0f 85 24 01 00 00    	jne    81bb80 <do_listen+0x180>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81ba5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba60:	48 8b 00             	mov    (%rax),%rax
  81ba63:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba67:	be ff 00 00 00       	mov    $0xff,%esi
  81ba6c:	48 89 c7             	mov    %rax,%rdi
  81ba6f:	48 b8 28 f2 80 00 00 	movabs $0x80f228,%rax
  81ba76:	00 00 00 
  81ba79:	ff d0                	callq  *%rax
  81ba7b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81ba7f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81ba84:	75 10                	jne    81ba96 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81ba86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba8a:	48 8b 00             	mov    (%rax),%rax
  81ba8d:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81ba91:	e9 e8 00 00 00       	jmpq   81bb7e <do_listen+0x17e>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81ba96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba9a:	48 8b 00             	mov    (%rax),%rax
  81ba9d:	8b 40 18             	mov    0x18(%rax),%eax
  81baa0:	83 f8 ff             	cmp    $0xffffffff,%eax
  81baa3:	74 26                	je     81bacb <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81baa5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81baa9:	48 8b 00             	mov    (%rax),%rax
  81baac:	8b 40 18             	mov    0x18(%rax),%eax
  81baaf:	89 c7                	mov    %eax,%edi
  81bab1:	48 b8 94 77 81 00 00 	movabs $0x817794,%rax
  81bab8:	00 00 00 
  81babb:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81babd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bac1:	48 8b 00             	mov    (%rax),%rax
  81bac4:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81bacb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bacf:	48 8b 00             	mov    (%rax),%rax
  81bad2:	8b 40 1c             	mov    0x1c(%rax),%eax
  81bad5:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bad8:	75 2e                	jne    81bb08 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81bada:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bade:	48 8b 18             	mov    (%rax),%rbx
  81bae1:	bf 00 00 00 00       	mov    $0x0,%edi
  81bae6:	48 b8 b4 75 81 00 00 	movabs $0x8175b4,%rax
  81baed:	00 00 00 
  81baf0:	ff d0                	callq  *%rax
  81baf2:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81baf5:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81baf8:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bafb:	75 0b                	jne    81bb08 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81bafd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb01:	48 8b 00             	mov    (%rax),%rax
  81bb04:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81bb08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb0c:	48 8b 00             	mov    (%rax),%rax
  81bb0f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bb13:	84 c0                	test   %al,%al
  81bb15:	75 67                	jne    81bb7e <do_listen+0x17e>
              msg->conn->state = NETCONN_LISTEN;
  81bb17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb1b:	48 8b 00             	mov    (%rax),%rax
  81bb1e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81bb25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb29:	48 8b 00             	mov    (%rax),%rax
  81bb2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81bb30:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81bb34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb38:	48 8b 10             	mov    (%rax),%rdx
  81bb3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb3f:	48 8b 00             	mov    (%rax),%rax
  81bb42:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb46:	48 89 d6             	mov    %rdx,%rsi
  81bb49:	48 89 c7             	mov    %rax,%rdi
  81bb4c:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  81bb53:	00 00 00 
  81bb56:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81bb58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb5c:	48 8b 00             	mov    (%rax),%rax
  81bb5f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb63:	48 be 43 ac 81 00 00 	movabs $0x81ac43,%rsi
  81bb6a:	00 00 00 
  81bb6d:	48 89 c7             	mov    %rax,%rdi
  81bb70:	48 b8 37 08 81 00 00 	movabs $0x810837,%rax
  81bb77:	00 00 00 
  81bb7a:	ff d0                	callq  *%rax
  81bb7c:	eb 0d                	jmp    81bb8b <do_listen+0x18b>
  81bb7e:	eb 0b                	jmp    81bb8b <do_listen+0x18b>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81bb80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb84:	48 8b 00             	mov    (%rax),%rax
  81bb87:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81bb8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb8f:	48 8b 00             	mov    (%rax),%rax
  81bb92:	8b 40 14             	mov    0x14(%rax),%eax
  81bb95:	89 c7                	mov    %eax,%edi
  81bb97:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81bb9e:	00 00 00 
  81bba1:	ff d0                	callq  *%rax
}
  81bba3:	48 83 c4 28          	add    $0x28,%rsp
  81bba7:	5b                   	pop    %rbx
  81bba8:	5d                   	pop    %rbp
  81bba9:	c3                   	retq   

000000000081bbaa <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81bbaa:	55                   	push   %rbp
  81bbab:	48 89 e5             	mov    %rsp,%rbp
  81bbae:	53                   	push   %rbx
  81bbaf:	48 83 ec 18          	sub    $0x18,%rsp
  81bbb3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bbb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbbb:	48 8b 00             	mov    (%rax),%rax
  81bbbe:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bbc2:	3c fc                	cmp    $0xfc,%al
  81bbc4:	0f 8c 50 01 00 00    	jl     81bd1a <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81bbca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbce:	48 8b 00             	mov    (%rax),%rax
  81bbd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bbd5:	48 85 c0             	test   %rax,%rax
  81bbd8:	0f 84 3c 01 00 00    	je     81bd1a <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bbde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbe2:	48 8b 00             	mov    (%rax),%rax
  81bbe5:	8b 00                	mov    (%rax),%eax
  81bbe7:	25 f0 00 00 00       	and    $0xf0,%eax
  81bbec:	83 f8 20             	cmp    $0x20,%eax
  81bbef:	0f 84 95 00 00 00    	je     81bc8a <do_send+0xe0>
  81bbf5:	83 f8 40             	cmp    $0x40,%eax
  81bbf8:	74 05                	je     81bbff <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81bbfa:	e9 1b 01 00 00       	jmpq   81bd1a <do_send+0x170>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81bbff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc07:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bc0b:	48 85 c0             	test   %rax,%rax
  81bc0e:	75 37                	jne    81bc47 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81bc10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc14:	48 8b 18             	mov    (%rax),%rbx
  81bc17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc1f:	48 8b 10             	mov    (%rax),%rdx
  81bc22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc26:	48 8b 00             	mov    (%rax),%rax
  81bc29:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc2d:	48 89 d6             	mov    %rdx,%rsi
  81bc30:	48 89 c7             	mov    %rax,%rdi
  81bc33:	48 b8 61 ff 81 00 00 	movabs $0x81ff61,%rax
  81bc3a:	00 00 00 
  81bc3d:	ff d0                	callq  *%rax
  81bc3f:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81bc42:	e9 d3 00 00 00       	jmpq   81bd1a <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81bc47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc4b:	48 8b 18             	mov    (%rax),%rbx
  81bc4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc52:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc56:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bc5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc5e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc62:	48 8b 08             	mov    (%rax),%rcx
  81bc65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc69:	48 8b 00             	mov    (%rax),%rax
  81bc6c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc70:	48 89 ce             	mov    %rcx,%rsi
  81bc73:	48 89 c7             	mov    %rax,%rdi
  81bc76:	48 b8 bd fd 81 00 00 	movabs $0x81fdbd,%rax
  81bc7d:	00 00 00 
  81bc80:	ff d0                	callq  *%rax
  81bc82:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bc85:	e9 90 00 00 00       	jmpq   81bd1a <do_send+0x170>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81bc8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc8e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc92:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bc96:	48 85 c0             	test   %rax,%rax
  81bc99:	75 34                	jne    81bccf <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81bc9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc9f:	48 8b 18             	mov    (%rax),%rbx
  81bca2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bca6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcaa:	48 8b 10             	mov    (%rax),%rdx
  81bcad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcb1:	48 8b 00             	mov    (%rax),%rax
  81bcb4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcb8:	48 89 d6             	mov    %rdx,%rsi
  81bcbb:	48 89 c7             	mov    %rax,%rdi
  81bcbe:	48 b8 70 51 81 00 00 	movabs $0x815170,%rax
  81bcc5:	00 00 00 
  81bcc8:	ff d0                	callq  *%rax
  81bcca:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81bccd:	eb 4a                	jmp    81bd19 <do_send+0x16f>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81bccf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcd3:	48 8b 18             	mov    (%rax),%rbx
  81bcd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcda:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcde:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81bce2:	0f b7 c8             	movzwl %ax,%ecx
  81bce5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bce9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bced:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bcf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcf5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcf9:	48 8b 30             	mov    (%rax),%rsi
  81bcfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd00:	48 8b 00             	mov    (%rax),%rax
  81bd03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd07:	48 89 c7             	mov    %rax,%rdi
  81bd0a:	48 b8 b1 51 81 00 00 	movabs $0x8151b1,%rax
  81bd11:	00 00 00 
  81bd14:	ff d0                	callq  *%rax
  81bd16:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bd19:	90                   	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81bd1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd1e:	48 8b 00             	mov    (%rax),%rax
  81bd21:	8b 40 14             	mov    0x14(%rax),%eax
  81bd24:	89 c7                	mov    %eax,%edi
  81bd26:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81bd2d:	00 00 00 
  81bd30:	ff d0                	callq  *%rax
}
  81bd32:	48 83 c4 18          	add    $0x18,%rsp
  81bd36:	5b                   	pop    %rbx
  81bd37:	5d                   	pop    %rbp
  81bd38:	c3                   	retq   

000000000081bd39 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81bd39:	55                   	push   %rbp
  81bd3a:	48 89 e5             	mov    %rsp,%rbp
  81bd3d:	48 83 ec 10          	sub    $0x10,%rsp
  81bd41:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bd45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd49:	48 8b 00             	mov    (%rax),%rax
  81bd4c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bd50:	3c fc                	cmp    $0xfc,%al
  81bd52:	7c 45                	jl     81bd99 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81bd54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd58:	48 8b 00             	mov    (%rax),%rax
  81bd5b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd5f:	48 85 c0             	test   %rax,%rax
  81bd62:	74 35                	je     81bd99 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81bd64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd68:	48 8b 00             	mov    (%rax),%rax
  81bd6b:	8b 00                	mov    (%rax),%eax
  81bd6d:	83 f8 10             	cmp    $0x10,%eax
  81bd70:	75 27                	jne    81bd99 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81bd72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd76:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81bd7a:	0f b7 d0             	movzwl %ax,%edx
  81bd7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd81:	48 8b 00             	mov    (%rax),%rax
  81bd84:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd88:	89 d6                	mov    %edx,%esi
  81bd8a:	48 89 c7             	mov    %rax,%rdi
  81bd8d:	48 b8 71 f4 80 00 00 	movabs $0x80f471,%rax
  81bd94:	00 00 00 
  81bd97:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81bd99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd9d:	48 8b 00             	mov    (%rax),%rax
  81bda0:	8b 40 14             	mov    0x14(%rax),%eax
  81bda3:	89 c7                	mov    %eax,%edi
  81bda5:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81bdac:	00 00 00 
  81bdaf:	ff d0                	callq  *%rax
}
  81bdb1:	c9                   	leaveq 
  81bdb2:	c3                   	retq   

000000000081bdb3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81bdb3:	55                   	push   %rbp
  81bdb4:	48 89 e5             	mov    %rsp,%rbp
  81bdb7:	48 83 ec 30          	sub    $0x30,%rsp
  81bdbb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81bdbf:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81bdc3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdc7:	8b 40 04             	mov    0x4(%rax),%eax
  81bdca:	83 f8 01             	cmp    $0x1,%eax
  81bdcd:	74 2a                	je     81bdf9 <do_writemore+0x46>
  81bdcf:	48 ba c3 37 82 00 00 	movabs $0x8237c3,%rdx
  81bdd6:	00 00 00 
  81bdd9:	be b8 03 00 00       	mov    $0x3b8,%esi
  81bdde:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81bde5:	00 00 00 
  81bde8:	b8 00 00 00 00       	mov    $0x0,%eax
  81bded:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81bdf4:	00 00 00 
  81bdf7:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81bdf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdfd:	48 8b 40 28          	mov    0x28(%rax),%rax
  81be01:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81be05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be09:	8b 40 30             	mov    0x30(%rax),%eax
  81be0c:	48 98                	cltq   
  81be0e:	48 01 d0             	add    %rdx,%rax
  81be11:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81be15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be19:	48 8b 40 28          	mov    0x28(%rax),%rax
  81be1d:	8b 50 10             	mov    0x10(%rax),%edx
  81be20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be24:	8b 40 30             	mov    0x30(%rax),%eax
  81be27:	29 c2                	sub    %eax,%edx
  81be29:	89 d0                	mov    %edx,%eax
  81be2b:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81be30:	7e 08                	jle    81be3a <do_writemore+0x87>
    len = 0xffff;
  81be32:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81be38:	eb 1c                	jmp    81be56 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81be3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be3e:	48 8b 40 28          	mov    0x28(%rax),%rax
  81be42:	8b 40 10             	mov    0x10(%rax),%eax
  81be45:	89 c2                	mov    %eax,%edx
  81be47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be4b:	8b 40 30             	mov    0x30(%rax),%eax
  81be4e:	29 c2                	sub    %eax,%edx
  81be50:	89 d0                	mov    %edx,%eax
  81be52:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81be56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be5e:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81be62:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81be66:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81be6a:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81be6e:	73 08                	jae    81be78 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81be70:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81be74:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81be78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be7c:	48 8b 40 28          	mov    0x28(%rax),%rax
  81be80:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81be84:	0f b6 c8             	movzbl %al,%ecx
  81be87:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81be8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be93:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81be97:	48 89 c7             	mov    %rax,%rdi
  81be9a:	48 b8 d2 2f 81 00 00 	movabs $0x812fd2,%rax
  81bea1:	00 00 00 
  81bea4:	ff d0                	callq  *%rax
  81bea6:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81bea9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bead:	8b 50 30             	mov    0x30(%rax),%edx
  81beb0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81beb4:	01 c2                	add    %eax,%edx
  81beb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81beba:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bebe:	8b 40 10             	mov    0x10(%rax),%eax
  81bec1:	39 c2                	cmp    %eax,%edx
  81bec3:	7e 2a                	jle    81beef <do_writemore+0x13c>
  81bec5:	48 ba e0 37 82 00 00 	movabs $0x8237e0,%rdx
  81becc:	00 00 00 
  81becf:	be cd 03 00 00       	mov    $0x3cd,%esi
  81bed4:	48 bf d2 35 82 00 00 	movabs $0x8235d2,%rdi
  81bedb:	00 00 00 
  81bede:	b8 00 00 00 00       	mov    $0x0,%eax
  81bee3:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81beea:	00 00 00 
  81beed:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81beef:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bef3:	0f 85 07 01 00 00    	jne    81c000 <do_writemore+0x24d>
    conn->write_offset += len;
  81bef9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81befd:	8b 50 30             	mov    0x30(%rax),%edx
  81bf00:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bf04:	01 c2                	add    %eax,%edx
  81bf06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf0a:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81bf0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf11:	8b 50 30             	mov    0x30(%rax),%edx
  81bf14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf18:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bf1c:	8b 40 10             	mov    0x10(%rax),%eax
  81bf1f:	39 c2                	cmp    %eax,%edx
  81bf21:	75 1b                	jne    81bf3e <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81bf23:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81bf27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf2b:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81bf32:	00 
      conn->write_offset = 0;
  81bf33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf37:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81bf3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf42:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf46:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81bf4d:	48 85 c0             	test   %rax,%rax
  81bf50:	74 41                	je     81bf93 <do_writemore+0x1e0>
  81bf52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf56:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf5a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81bf5e:	0f b6 c0             	movzbl %al,%eax
  81bf61:	83 e0 40             	and    $0x40,%eax
  81bf64:	85 c0                	test   %eax,%eax
  81bf66:	75 2b                	jne    81bf93 <do_writemore+0x1e0>
  81bf68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf6c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf70:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bf77:	48 85 c0             	test   %rax,%rax
  81bf7a:	74 30                	je     81bfac <do_writemore+0x1f9>
  81bf7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf80:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf84:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bf8b:	48 8b 00             	mov    (%rax),%rax
  81bf8e:	48 85 c0             	test   %rax,%rax
  81bf91:	74 19                	je     81bfac <do_writemore+0x1f9>
  81bf93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf97:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf9b:	48 89 c7             	mov    %rax,%rdi
  81bf9e:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81bfa5:	00 00 00 
  81bfa8:	ff d0                	callq  *%rax
  81bfaa:	eb 05                	jmp    81bfb1 <do_writemore+0x1fe>
  81bfac:	b8 00 00 00 00       	mov    $0x0,%eax
  81bfb1:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81bfb4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfb8:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bfbc:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81bfbf:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bfc3:	75 6c                	jne    81c031 <do_writemore+0x27e>
  81bfc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfc9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfcd:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bfd1:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81bfd5:	77 5a                	ja     81c031 <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81bfd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfdb:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bfdf:	48 85 c0             	test   %rax,%rax
  81bfe2:	74 4d                	je     81c031 <do_writemore+0x27e>
  81bfe4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfe8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bfec:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bff0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81bff4:	be 03 00 00 00       	mov    $0x3,%esi
  81bff9:	48 89 cf             	mov    %rcx,%rdi
  81bffc:	ff d0                	callq  *%rax
  81bffe:	eb 31                	jmp    81c031 <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81c000:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81c004:	75 1c                	jne    81c022 <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81c006:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c00a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c00e:	48 89 c7             	mov    %rax,%rdi
  81c011:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81c018:	00 00 00 
  81c01b:	ff d0                	callq  *%rax
  81c01d:	88 45 ed             	mov    %al,-0x13(%rbp)
  81c020:	eb 0f                	jmp    81c031 <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81c022:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c026:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c02a:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81c02d:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81c031:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81c035:	74 20                	je     81c057 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81c037:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c03b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81c042:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c046:	8b 40 14             	mov    0x14(%rax),%eax
  81c049:	89 c7                	mov    %eax,%edi
  81c04b:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81c052:	00 00 00 
  81c055:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81c057:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81c05c:	c9                   	leaveq 
  81c05d:	c3                   	retq   

000000000081c05e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81c05e:	55                   	push   %rbp
  81c05f:	48 89 e5             	mov    %rsp,%rbp
  81c062:	48 83 ec 10          	sub    $0x10,%rsp
  81c066:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81c06a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c06e:	48 8b 00             	mov    (%rax),%rax
  81c071:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81c075:	3c fc                	cmp    $0xfc,%al
  81c077:	7c 6c                	jl     81c0e5 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c079:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c07d:	48 8b 00             	mov    (%rax),%rax
  81c080:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c084:	48 85 c0             	test   %rax,%rax
  81c087:	74 51                	je     81c0da <do_write+0x7c>
  81c089:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c08d:	48 8b 00             	mov    (%rax),%rax
  81c090:	8b 00                	mov    (%rax),%eax
  81c092:	83 f8 10             	cmp    $0x10,%eax
  81c095:	75 43                	jne    81c0da <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81c097:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c09b:	48 8b 00             	mov    (%rax),%rax
  81c09e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81c0a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0a9:	48 8b 00             	mov    (%rax),%rax
  81c0ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c0b0:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81c0b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0b8:	48 8b 00             	mov    (%rax),%rax
  81c0bb:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81c0c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0c6:	48 8b 00             	mov    (%rax),%rax
  81c0c9:	48 89 c7             	mov    %rax,%rdi
  81c0cc:	48 b8 b3 bd 81 00 00 	movabs $0x81bdb3,%rax
  81c0d3:	00 00 00 
  81c0d6:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81c0d8:	eb 23                	jmp    81c0fd <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81c0da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0de:	48 8b 00             	mov    (%rax),%rax
  81c0e1:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81c0e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0e9:	48 8b 00             	mov    (%rax),%rax
  81c0ec:	8b 40 14             	mov    0x14(%rax),%eax
  81c0ef:	89 c7                	mov    %eax,%edi
  81c0f1:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81c0f8:	00 00 00 
  81c0fb:	ff d0                	callq  *%rax
}
  81c0fd:	c9                   	leaveq 
  81c0fe:	c3                   	retq   

000000000081c0ff <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81c0ff:	55                   	push   %rbp
  81c100:	48 89 e5             	mov    %rsp,%rbp
  81c103:	48 83 ec 10          	sub    $0x10,%rsp
  81c107:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81c10b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c10f:	48 8b 00             	mov    (%rax),%rax
  81c112:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c116:	48 85 c0             	test   %rax,%rax
  81c119:	0f 84 3f 01 00 00    	je     81c25e <do_getaddr+0x15f>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81c11f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c123:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c127:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c12b:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c12f:	84 d2                	test   %dl,%dl
  81c131:	74 11                	je     81c144 <do_getaddr+0x45>
  81c133:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c137:	48 8b 12             	mov    (%rdx),%rdx
  81c13a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c13e:	8b 12                	mov    (%rdx),%edx
  81c140:	89 10                	mov    %edx,(%rax)
  81c142:	eb 10                	jmp    81c154 <do_getaddr+0x55>
  81c144:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c148:	48 8b 12             	mov    (%rdx),%rdx
  81c14b:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c14f:	8b 52 04             	mov    0x4(%rdx),%edx
  81c152:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81c154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c158:	48 8b 00             	mov    (%rax),%rax
  81c15b:	8b 00                	mov    (%rax),%eax
  81c15d:	25 f0 00 00 00       	and    $0xf0,%eax
  81c162:	83 f8 20             	cmp    $0x20,%eax
  81c165:	74 51                	je     81c1b8 <do_getaddr+0xb9>
  81c167:	83 f8 40             	cmp    $0x40,%eax
  81c16a:	74 0e                	je     81c17a <do_getaddr+0x7b>
  81c16c:	83 f8 10             	cmp    $0x10,%eax
  81c16f:	0f 84 af 00 00 00    	je     81c224 <do_getaddr+0x125>
  81c175:	e9 ef 00 00 00       	jmpq   81c269 <do_getaddr+0x16a>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81c17a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c17e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c182:	84 c0                	test   %al,%al
  81c184:	74 22                	je     81c1a8 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81c186:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c18a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c18e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c192:	48 8b 12             	mov    (%rdx),%rdx
  81c195:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c199:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c19d:	0f b6 d2             	movzbl %dl,%edx
  81c1a0:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81c1a3:	e9 b4 00 00 00       	jmpq   81c25c <do_getaddr+0x15d>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81c1a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1ac:	48 8b 00             	mov    (%rax),%rax
  81c1af:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81c1b3:	e9 a4 00 00 00       	jmpq   81c25c <do_getaddr+0x15d>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81c1b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1bc:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c1c0:	84 c0                	test   %al,%al
  81c1c2:	74 1c                	je     81c1e0 <do_getaddr+0xe1>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81c1c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1c8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c1cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c1d0:	48 8b 12             	mov    (%rdx),%rdx
  81c1d3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c1d7:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81c1db:	66 89 10             	mov    %dx,(%rax)
  81c1de:	eb 42                	jmp    81c222 <do_getaddr+0x123>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81c1e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1e4:	48 8b 00             	mov    (%rax),%rax
  81c1e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c1eb:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c1ef:	0f b6 c0             	movzbl %al,%eax
  81c1f2:	83 e0 04             	and    $0x4,%eax
  81c1f5:	85 c0                	test   %eax,%eax
  81c1f7:	75 0d                	jne    81c206 <do_getaddr+0x107>
          msg->conn->err = ERR_CONN;
  81c1f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1fd:	48 8b 00             	mov    (%rax),%rax
  81c200:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  81c204:	eb 1c                	jmp    81c222 <do_getaddr+0x123>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81c206:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c20a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c20e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c212:	48 8b 12             	mov    (%rdx),%rdx
  81c215:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c219:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81c21d:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81c220:	eb 3a                	jmp    81c25c <do_getaddr+0x15d>
  81c222:	eb 38                	jmp    81c25c <do_getaddr+0x15d>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81c224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c228:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c22c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c230:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c234:	84 c0                	test   %al,%al
  81c236:	74 11                	je     81c249 <do_getaddr+0x14a>
  81c238:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c23c:	48 8b 00             	mov    (%rax),%rax
  81c23f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c243:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81c247:	eb 0f                	jmp    81c258 <do_getaddr+0x159>
  81c249:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c24d:	48 8b 00             	mov    (%rax),%rax
  81c250:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c254:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81c258:	66 89 02             	mov    %ax,(%rdx)
      break;
  81c25b:	90                   	nop
  81c25c:	eb 0b                	jmp    81c269 <do_getaddr+0x16a>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81c25e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c262:	48 8b 00             	mov    (%rax),%rax
  81c265:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81c269:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c26d:	48 8b 00             	mov    (%rax),%rax
  81c270:	8b 40 14             	mov    0x14(%rax),%eax
  81c273:	89 c7                	mov    %eax,%edi
  81c275:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81c27c:	00 00 00 
  81c27f:	ff d0                	callq  *%rax
}
  81c281:	c9                   	leaveq 
  81c282:	c3                   	retq   

000000000081c283 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81c283:	55                   	push   %rbp
  81c284:	48 89 e5             	mov    %rsp,%rbp
  81c287:	48 83 ec 10          	sub    $0x10,%rsp
  81c28b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c28f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c293:	48 8b 00             	mov    (%rax),%rax
  81c296:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c29a:	48 85 c0             	test   %rax,%rax
  81c29d:	74 34                	je     81c2d3 <do_close+0x50>
  81c29f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2a3:	48 8b 00             	mov    (%rax),%rax
  81c2a6:	8b 00                	mov    (%rax),%eax
  81c2a8:	83 f8 10             	cmp    $0x10,%eax
  81c2ab:	75 26                	jne    81c2d3 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81c2ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2b1:	48 8b 00             	mov    (%rax),%rax
  81c2b4:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81c2bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2bf:	48 8b 00             	mov    (%rax),%rax
  81c2c2:	48 89 c7             	mov    %rax,%rdi
  81c2c5:	48 b8 2b b2 81 00 00 	movabs $0x81b22b,%rax
  81c2cc:	00 00 00 
  81c2cf:	ff d0                	callq  *%rax
  81c2d1:	eb 23                	jmp    81c2f6 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c2d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2d7:	48 8b 00             	mov    (%rax),%rax
  81c2da:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c2de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2e2:	48 8b 00             	mov    (%rax),%rax
  81c2e5:	8b 40 14             	mov    0x14(%rax),%eax
  81c2e8:	89 c7                	mov    %eax,%edi
  81c2ea:	48 b8 2b 7f 81 00 00 	movabs $0x817f2b,%rax
  81c2f1:	00 00 00 
  81c2f4:	ff d0                	callq  *%rax
  }
}
  81c2f6:	c9                   	leaveq 
  81c2f7:	c3                   	retq   

000000000081c2f8 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c2f8:	55                   	push   %rbp
  81c2f9:	48 89 e5             	mov    %rsp,%rbp
  81c2fc:	53                   	push   %rbx
  81c2fd:	48 83 ec 38          	sub    $0x38,%rsp
  81c301:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c305:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c309:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c30d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c311:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c318:	00 00 00 
  81c31b:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c31e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c322:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c326:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c32d:	00 00 00 
  81c330:	48 8b 00             	mov    (%rax),%rax
  81c333:	0f b7 00             	movzwl (%rax),%eax
  81c336:	0f b7 c0             	movzwl %ax,%eax
  81c339:	89 c7                	mov    %eax,%edi
  81c33b:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c342:	00 00 00 
  81c345:	ff d0                	callq  *%rax
  81c347:	66 c1 e8 08          	shr    $0x8,%ax
  81c34b:	0f b7 c0             	movzwl %ax,%eax
  81c34e:	83 e0 0f             	and    $0xf,%eax
  81c351:	c1 e0 02             	shl    $0x2,%eax
  81c354:	48 98                	cltq   
  81c356:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c35a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c361:	00 00 00 
  81c364:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c367:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c36e:	00 00 00 
  81c371:	48 8b 00             	mov    (%rax),%rax
  81c374:	0f b7 00             	movzwl (%rax),%eax
  81c377:	0f b7 c0             	movzwl %ax,%eax
  81c37a:	89 c7                	mov    %eax,%edi
  81c37c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c383:	00 00 00 
  81c386:	ff d0                	callq  *%rax
  81c388:	66 c1 e8 08          	shr    $0x8,%ax
  81c38c:	83 e0 0f             	and    $0xf,%eax
  81c38f:	c1 e0 02             	shl    $0x2,%eax
  81c392:	f7 d8                	neg    %eax
  81c394:	0f bf d0             	movswl %ax,%edx
  81c397:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c39b:	89 d6                	mov    %edx,%esi
  81c39d:	48 89 c7             	mov    %rax,%rdi
  81c3a0:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81c3a7:	00 00 00 
  81c3aa:	ff d0                	callq  *%rax
  81c3ac:	84 c0                	test   %al,%al
  81c3ae:	75 0e                	jne    81c3be <tcp_input+0xc6>
  81c3b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c3b4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c3b8:	66 83 f8 13          	cmp    $0x13,%ax
  81c3bc:	77 18                	ja     81c3d6 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c3be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c3c2:	48 89 c7             	mov    %rax,%rdi
  81c3c5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81c3cc:	00 00 00 
  81c3cf:	ff d0                	callq  *%rax
    return;
  81c3d1:	e9 eb 0b 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c3d6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c3dd:	00 00 00 
  81c3e0:	48 8b 00             	mov    (%rax),%rax
  81c3e3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c3e7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c3eb:	48 89 c6             	mov    %rax,%rsi
  81c3ee:	48 89 d7             	mov    %rdx,%rdi
  81c3f1:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  81c3f8:	00 00 00 
  81c3fb:	ff d0                	callq  *%rax
  81c3fd:	84 c0                	test   %al,%al
  81c3ff:	75 38                	jne    81c439 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c401:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c408:	00 00 00 
  81c40b:	48 8b 00             	mov    (%rax),%rax
  81c40e:	8b 58 10             	mov    0x10(%rax),%ebx
  81c411:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c416:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81c41d:	00 00 00 
  81c420:	ff d0                	callq  *%rax
  81c422:	21 c3                	and    %eax,%ebx
  81c424:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c429:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81c430:	00 00 00 
  81c433:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c435:	39 c3                	cmp    %eax,%ebx
  81c437:	75 18                	jne    81c451 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c439:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c43d:	48 89 c7             	mov    %rax,%rdi
  81c440:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81c447:	00 00 00 
  81c44a:	ff d0                	callq  *%rax
    return;
  81c44c:	e9 70 0b 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c451:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c455:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c459:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c45c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c463:	00 00 00 
  81c466:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c469:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c46d:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c474:	00 00 00 
  81c477:	48 8b 00             	mov    (%rax),%rax
  81c47a:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c47e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c482:	41 89 c8             	mov    %ecx,%r8d
  81c485:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c48a:	48 89 c7             	mov    %rax,%rdi
  81c48d:	48 b8 aa 26 81 00 00 	movabs $0x8126aa,%rax
  81c494:	00 00 00 
  81c497:	ff d0                	callq  *%rax
  81c499:	66 85 c0             	test   %ax,%ax
  81c49c:	74 18                	je     81c4b6 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c49e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4a2:	48 89 c7             	mov    %rax,%rdi
  81c4a5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81c4ac:	00 00 00 
  81c4af:	ff d0                	callq  *%rax
    return;
  81c4b1:	e9 0b 0b 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c4b6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c4bd:	00 00 00 
  81c4c0:	48 8b 00             	mov    (%rax),%rax
  81c4c3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c4c7:	0f b7 c0             	movzwl %ax,%eax
  81c4ca:	89 c7                	mov    %eax,%edi
  81c4cc:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c4d3:	00 00 00 
  81c4d6:	ff d0                	callq  *%rax
  81c4d8:	66 c1 e8 0c          	shr    $0xc,%ax
  81c4dc:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c4df:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c4e3:	b8 00 00 00 00       	mov    $0x0,%eax
  81c4e8:	29 d0                	sub    %edx,%eax
  81c4ea:	c1 e0 02             	shl    $0x2,%eax
  81c4ed:	0f bf d0             	movswl %ax,%edx
  81c4f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4f4:	89 d6                	mov    %edx,%esi
  81c4f6:	48 89 c7             	mov    %rax,%rdi
  81c4f9:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81c500:	00 00 00 
  81c503:	ff d0                	callq  *%rax
  81c505:	84 c0                	test   %al,%al
  81c507:	74 18                	je     81c521 <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c509:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c50d:	48 89 c7             	mov    %rax,%rdi
  81c510:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81c517:	00 00 00 
  81c51a:	ff d0                	callq  *%rax
    return;
  81c51c:	e9 a0 0a 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c521:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c528:	00 00 00 
  81c52b:	48 8b 18             	mov    (%rax),%rbx
  81c52e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c535:	00 00 00 
  81c538:	48 8b 00             	mov    (%rax),%rax
  81c53b:	0f b7 00             	movzwl (%rax),%eax
  81c53e:	0f b7 c0             	movzwl %ax,%eax
  81c541:	89 c7                	mov    %eax,%edi
  81c543:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c54a:	00 00 00 
  81c54d:	ff d0                	callq  *%rax
  81c54f:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c552:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c559:	00 00 00 
  81c55c:	48 8b 18             	mov    (%rax),%rbx
  81c55f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c566:	00 00 00 
  81c569:	48 8b 00             	mov    (%rax),%rax
  81c56c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c570:	0f b7 c0             	movzwl %ax,%eax
  81c573:	89 c7                	mov    %eax,%edi
  81c575:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c57c:	00 00 00 
  81c57f:	ff d0                	callq  *%rax
  81c581:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c585:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c58c:	00 00 00 
  81c58f:	48 8b 18             	mov    (%rax),%rbx
  81c592:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c599:	00 00 00 
  81c59c:	48 8b 00             	mov    (%rax),%rax
  81c59f:	8b 40 04             	mov    0x4(%rax),%eax
  81c5a2:	89 c7                	mov    %eax,%edi
  81c5a4:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81c5ab:	00 00 00 
  81c5ae:	ff d0                	callq  *%rax
  81c5b0:	89 43 04             	mov    %eax,0x4(%rbx)
  81c5b3:	8b 53 04             	mov    0x4(%rbx),%edx
  81c5b6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c5bd:	00 00 00 
  81c5c0:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c5c2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c5c9:	00 00 00 
  81c5cc:	48 8b 18             	mov    (%rax),%rbx
  81c5cf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c5d6:	00 00 00 
  81c5d9:	48 8b 00             	mov    (%rax),%rax
  81c5dc:	8b 40 08             	mov    0x8(%rax),%eax
  81c5df:	89 c7                	mov    %eax,%edi
  81c5e1:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81c5e8:	00 00 00 
  81c5eb:	ff d0                	callq  *%rax
  81c5ed:	89 43 08             	mov    %eax,0x8(%rbx)
  81c5f0:	8b 53 08             	mov    0x8(%rbx),%edx
  81c5f3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c5fa:	00 00 00 
  81c5fd:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c5ff:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c606:	00 00 00 
  81c609:	48 8b 18             	mov    (%rax),%rbx
  81c60c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c613:	00 00 00 
  81c616:	48 8b 00             	mov    (%rax),%rax
  81c619:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c61d:	0f b7 c0             	movzwl %ax,%eax
  81c620:	89 c7                	mov    %eax,%edi
  81c622:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c629:	00 00 00 
  81c62c:	ff d0                	callq  *%rax
  81c62e:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c632:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c639:	00 00 00 
  81c63c:	48 8b 00             	mov    (%rax),%rax
  81c63f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c643:	0f b7 c0             	movzwl %ax,%eax
  81c646:	89 c7                	mov    %eax,%edi
  81c648:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81c64f:	00 00 00 
  81c652:	ff d0                	callq  *%rax
  81c654:	83 e0 3f             	and    $0x3f,%eax
  81c657:	89 c2                	mov    %eax,%edx
  81c659:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c660:	00 00 00 
  81c663:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c665:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c669:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c66d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c674:	00 00 00 
  81c677:	0f b6 00             	movzbl (%rax),%eax
  81c67a:	0f b6 c0             	movzbl %al,%eax
  81c67d:	83 e0 01             	and    $0x1,%eax
  81c680:	85 c0                	test   %eax,%eax
  81c682:	75 17                	jne    81c69b <tcp_input+0x3a3>
  81c684:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c68b:	00 00 00 
  81c68e:	0f b6 00             	movzbl (%rax),%eax
  81c691:	0f b6 c0             	movzbl %al,%eax
  81c694:	83 e0 02             	and    $0x2,%eax
  81c697:	85 c0                	test   %eax,%eax
  81c699:	74 07                	je     81c6a2 <tcp_input+0x3aa>
  81c69b:	b8 01 00 00 00       	mov    $0x1,%eax
  81c6a0:	eb 05                	jmp    81c6a7 <tcp_input+0x3af>
  81c6a2:	b8 00 00 00 00       	mov    $0x0,%eax
  81c6a7:	01 c2                	add    %eax,%edx
  81c6a9:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c6b0:	00 00 00 
  81c6b3:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c6b6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c6bd:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c6be:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c6c5:	00 00 00 
  81c6c8:	48 8b 00             	mov    (%rax),%rax
  81c6cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c6cf:	e9 e4 01 00 00       	jmpq   81c8b8 <tcp_input+0x5c0>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c6d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6d8:	8b 40 18             	mov    0x18(%rax),%eax
  81c6db:	85 c0                	test   %eax,%eax
  81c6dd:	75 2a                	jne    81c709 <tcp_input+0x411>
  81c6df:	48 ba 00 38 82 00 00 	movabs $0x823800,%rdx
  81c6e6:	00 00 00 
  81c6e9:	be b5 00 00 00       	mov    $0xb5,%esi
  81c6ee:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c6f5:	00 00 00 
  81c6f8:	b8 00 00 00 00       	mov    $0x0,%eax
  81c6fd:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c704:	00 00 00 
  81c707:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c709:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c70d:	8b 40 18             	mov    0x18(%rax),%eax
  81c710:	83 f8 0a             	cmp    $0xa,%eax
  81c713:	75 2a                	jne    81c73f <tcp_input+0x447>
  81c715:	48 ba 40 38 82 00 00 	movabs $0x823840,%rdx
  81c71c:	00 00 00 
  81c71f:	be b6 00 00 00       	mov    $0xb6,%esi
  81c724:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c72b:	00 00 00 
  81c72e:	b8 00 00 00 00       	mov    $0x0,%eax
  81c733:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c73a:	00 00 00 
  81c73d:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c73f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c743:	8b 40 18             	mov    0x18(%rax),%eax
  81c746:	83 f8 01             	cmp    $0x1,%eax
  81c749:	75 2a                	jne    81c775 <tcp_input+0x47d>
  81c74b:	48 ba 70 38 82 00 00 	movabs $0x823870,%rdx
  81c752:	00 00 00 
  81c755:	be b7 00 00 00       	mov    $0xb7,%esi
  81c75a:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c761:	00 00 00 
  81c764:	b8 00 00 00 00       	mov    $0x0,%eax
  81c769:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c770:	00 00 00 
  81c773:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81c775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c779:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c77d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c784:	00 00 00 
  81c787:	48 8b 00             	mov    (%rax),%rax
  81c78a:	0f b7 00             	movzwl (%rax),%eax
  81c78d:	66 39 c2             	cmp    %ax,%dx
  81c790:	0f 85 0e 01 00 00    	jne    81c8a4 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
  81c796:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c79a:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c79e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7a5:	00 00 00 
  81c7a8:	48 8b 00             	mov    (%rax),%rax
  81c7ab:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81c7af:	66 39 c2             	cmp    %ax,%dx
  81c7b2:	0f 85 ec 00 00 00    	jne    81c8a4 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c7b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7bc:	8b 50 04             	mov    0x4(%rax),%edx
  81c7bf:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c7c6:	00 00 00 
  81c7c9:	48 8b 00             	mov    (%rax),%rax
  81c7cc:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81c7cf:	39 c2                	cmp    %eax,%edx
  81c7d1:	0f 85 cd 00 00 00    	jne    81c8a4 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c7d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7db:	8b 10                	mov    (%rax),%edx
  81c7dd:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c7e4:	00 00 00 
  81c7e7:	48 8b 00             	mov    (%rax),%rax
  81c7ea:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c7ed:	39 c2                	cmp    %eax,%edx
  81c7ef:	0f 85 af 00 00 00    	jne    81c8a4 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81c7f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7f9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c7fd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c801:	75 2a                	jne    81c82d <tcp_input+0x535>
  81c803:	48 ba 98 38 82 00 00 	movabs $0x823898,%rdx
  81c80a:	00 00 00 
  81c80d:	be c0 00 00 00       	mov    $0xc0,%esi
  81c812:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c819:	00 00 00 
  81c81c:	b8 00 00 00 00       	mov    $0x0,%eax
  81c821:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c828:	00 00 00 
  81c82b:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81c82d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c832:	74 36                	je     81c86a <tcp_input+0x572>
        prev->next = pcb->next;
  81c834:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c838:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c83c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c840:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81c844:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c84b:	00 00 00 
  81c84e:	48 8b 10             	mov    (%rax),%rdx
  81c851:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c855:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81c859:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c860:	00 00 00 
  81c863:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c867:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81c86a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c86e:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c872:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c876:	75 2a                	jne    81c8a2 <tcp_input+0x5aa>
  81c878:	48 ba c8 38 82 00 00 	movabs $0x8238c8,%rdx
  81c87f:	00 00 00 
  81c882:	be c6 00 00 00       	mov    $0xc6,%esi
  81c887:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c88e:	00 00 00 
  81c891:	b8 00 00 00 00       	mov    $0x0,%eax
  81c896:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c89d:	00 00 00 
  81c8a0:	ff d1                	callq  *%rcx
      break;
  81c8a2:	eb 1f                	jmp    81c8c3 <tcp_input+0x5cb>
    }
    prev = pcb;
  81c8a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8a8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c8ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8b0:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c8b4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c8b8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c8bd:	0f 85 11 fe ff ff    	jne    81c6d4 <tcp_input+0x3dc>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81c8c3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c8c8:	0f 85 f2 01 00 00    	jne    81cac0 <tcp_input+0x7c8>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c8ce:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81c8d5:	00 00 00 
  81c8d8:	48 8b 00             	mov    (%rax),%rax
  81c8db:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c8df:	e9 dd 00 00 00       	jmpq   81c9c1 <tcp_input+0x6c9>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81c8e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8e8:	8b 40 18             	mov    0x18(%rax),%eax
  81c8eb:	83 f8 0a             	cmp    $0xa,%eax
  81c8ee:	74 2a                	je     81c91a <tcp_input+0x622>
  81c8f0:	48 ba f8 38 82 00 00 	movabs $0x8238f8,%rdx
  81c8f7:	00 00 00 
  81c8fa:	be d0 00 00 00       	mov    $0xd0,%esi
  81c8ff:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81c906:	00 00 00 
  81c909:	b8 00 00 00 00       	mov    $0x0,%eax
  81c90e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81c915:	00 00 00 
  81c918:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81c91a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c91e:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c922:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c929:	00 00 00 
  81c92c:	48 8b 00             	mov    (%rax),%rax
  81c92f:	0f b7 00             	movzwl (%rax),%eax
  81c932:	66 39 c2             	cmp    %ax,%dx
  81c935:	75 7e                	jne    81c9b5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
  81c937:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c93b:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c93f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c946:	00 00 00 
  81c949:	48 8b 00             	mov    (%rax),%rax
  81c94c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81c950:	66 39 c2             	cmp    %ax,%dx
  81c953:	75 60                	jne    81c9b5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c955:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c959:	8b 50 04             	mov    0x4(%rax),%edx
  81c95c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c963:	00 00 00 
  81c966:	48 8b 00             	mov    (%rax),%rax
  81c969:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81c96c:	39 c2                	cmp    %eax,%edx
  81c96e:	75 45                	jne    81c9b5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c970:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c974:	8b 10                	mov    (%rax),%edx
  81c976:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c97d:	00 00 00 
  81c980:	48 8b 00             	mov    (%rax),%rax
  81c983:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c986:	39 c2                	cmp    %eax,%edx
  81c988:	75 2b                	jne    81c9b5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81c98a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c98e:	48 89 c7             	mov    %rax,%rdi
  81c991:	48 b8 c7 d2 81 00 00 	movabs $0x81d2c7,%rax
  81c998:	00 00 00 
  81c99b:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c99d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c9a1:	48 89 c7             	mov    %rax,%rdi
  81c9a4:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81c9ab:	00 00 00 
  81c9ae:	ff d0                	callq  *%rax
        return;
  81c9b0:	e9 0c 06 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c9b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9b9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c9bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c9c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c9c6:	0f 85 18 ff ff ff    	jne    81c8e4 <tcp_input+0x5ec>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81c9cc:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c9d3:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c9d4:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c9db:	00 00 00 
  81c9de:	48 8b 00             	mov    (%rax),%rax
  81c9e1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c9e5:	e9 cb 00 00 00       	jmpq   81cab5 <tcp_input+0x7bd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c9ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c9ee:	48 85 c0             	test   %rax,%rax
  81c9f1:	74 28                	je     81ca1b <tcp_input+0x723>
  81c9f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c9f7:	8b 00                	mov    (%rax),%eax
  81c9f9:	85 c0                	test   %eax,%eax
  81c9fb:	74 1e                	je     81ca1b <tcp_input+0x723>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c9fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ca01:	8b 10                	mov    (%rax),%edx
  81ca03:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ca0a:	00 00 00 
  81ca0d:	48 8b 00             	mov    (%rax),%rax
  81ca10:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81ca13:	39 c2                	cmp    %eax,%edx
  81ca15:	0f 85 86 00 00 00    	jne    81caa1 <tcp_input+0x7a9>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81ca1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ca1f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81ca23:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca2a:	00 00 00 
  81ca2d:	48 8b 00             	mov    (%rax),%rax
  81ca30:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81ca34:	66 39 c2             	cmp    %ax,%dx
  81ca37:	75 68                	jne    81caa1 <tcp_input+0x7a9>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81ca39:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81ca3e:	74 36                	je     81ca76 <tcp_input+0x77e>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81ca40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ca44:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ca48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ca4c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81ca50:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81ca57:	00 00 00 
  81ca5a:	48 8b 10             	mov    (%rax),%rdx
  81ca5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ca61:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81ca65:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81ca6c:	00 00 00 
  81ca6f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ca73:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81ca76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ca7a:	48 89 c7             	mov    %rax,%rdi
  81ca7d:	48 b8 c8 cf 81 00 00 	movabs $0x81cfc8,%rax
  81ca84:	00 00 00 
  81ca87:	ff d0                	callq  *%rax
        pbuf_free(p);
  81ca89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ca8d:	48 89 c7             	mov    %rax,%rdi
  81ca90:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81ca97:	00 00 00 
  81ca9a:	ff d0                	callq  *%rax
        return;
  81ca9c:	e9 20 05 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
      }
      prev = (struct tcp_pcb *)lpcb;
  81caa1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81caa5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81caa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81caad:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cab1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cab5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81caba:	0f 85 2a ff ff ff    	jne    81c9ea <tcp_input+0x6f2>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81cac0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cac5:	0f 84 2b 04 00 00    	je     81cef6 <tcp_input+0xbfe>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81cacb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cad2:	00 00 00 
  81cad5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81cadc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cae0:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81cae4:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81caeb:	00 00 00 
  81caee:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81caf2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81caf6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81cafa:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cb01:	00 00 00 
  81cb04:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81cb08:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cb0f:	00 00 00 
  81cb12:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81cb16:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81cb1a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cb21:	00 00 00 
  81cb24:	48 8b 10             	mov    (%rax),%rdx
  81cb27:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cb2e:	00 00 00 
  81cb31:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81cb35:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cb3c:	00 00 00 
  81cb3f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81cb46:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cb4d:	00 00 00 
  81cb50:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81cb53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb57:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cb5e:	48 85 c0             	test   %rax,%rax
  81cb61:	0f 84 9b 00 00 00    	je     81cc02 <tcp_input+0x90a>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81cb67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb6b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cb72:	48 85 c0             	test   %rax,%rax
  81cb75:	74 2e                	je     81cba5 <tcp_input+0x8ad>
  81cb77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb7b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cb82:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cb86:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81cb8d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cb91:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81cb95:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cb99:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cb9e:	ff d0                	callq  *%rax
  81cba0:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cba3:	eb 2e                	jmp    81cbd3 <tcp_input+0x8db>
  81cba5:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81cba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbad:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cbb4:	48 85 c0             	test   %rax,%rax
  81cbb7:	74 1a                	je     81cbd3 <tcp_input+0x8db>
  81cbb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbbd:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cbc4:	48 89 c7             	mov    %rax,%rdi
  81cbc7:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81cbce:	00 00 00 
  81cbd1:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81cbd3:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cbd7:	75 11                	jne    81cbea <tcp_input+0x8f2>
        pcb->refused_data = NULL;
  81cbd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbdd:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81cbe4:	00 00 00 00 
  81cbe8:	eb 18                	jmp    81cc02 <tcp_input+0x90a>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81cbea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cbee:	48 89 c7             	mov    %rax,%rdi
  81cbf1:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81cbf8:	00 00 00 
  81cbfb:	ff d0                	callq  *%rax
        return;
  81cbfd:	e9 bf 03 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
      }
    }

    tcp_input_pcb = pcb;
  81cc02:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cc09:	00 00 00 
  81cc0c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cc10:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81cc13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc17:	48 89 c7             	mov    %rax,%rdi
  81cc1a:	48 b8 73 d3 81 00 00 	movabs $0x81d373,%rax
  81cc21:	00 00 00 
  81cc24:	ff d0                	callq  *%rax
  81cc26:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81cc29:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cc30:	00 00 00 
  81cc33:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81cc3a:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81cc3e:	0f 84 67 02 00 00    	je     81ceab <tcp_input+0xbb3>
      if (recv_flags & TF_RESET) {
  81cc44:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cc4b:	00 00 00 
  81cc4e:	0f b6 00             	movzbl (%rax),%eax
  81cc51:	0f b6 c0             	movzbl %al,%eax
  81cc54:	83 e0 08             	and    $0x8,%eax
  81cc57:	85 c0                	test   %eax,%eax
  81cc59:	74 67                	je     81ccc2 <tcp_input+0x9ca>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81cc5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc5f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cc66:	48 85 c0             	test   %rax,%rax
  81cc69:	74 1d                	je     81cc88 <tcp_input+0x990>
  81cc6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc6f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cc76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cc7a:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81cc7e:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81cc83:	48 89 d7             	mov    %rdx,%rdi
  81cc86:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cc88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc8c:	48 89 c6             	mov    %rax,%rsi
  81cc8f:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cc96:	00 00 00 
  81cc99:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  81cca0:	00 00 00 
  81cca3:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cca5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cca9:	48 89 c6             	mov    %rax,%rsi
  81ccac:	bf 02 00 00 00       	mov    $0x2,%edi
  81ccb1:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81ccb8:	00 00 00 
  81ccbb:	ff d0                	callq  *%rax
  81ccbd:	e9 e9 01 00 00       	jmpq   81ceab <tcp_input+0xbb3>
      } else if (recv_flags & TF_CLOSED) {
  81ccc2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ccc9:	00 00 00 
  81cccc:	0f b6 00             	movzbl (%rax),%eax
  81cccf:	0f b6 c0             	movzbl %al,%eax
  81ccd2:	83 e0 10             	and    $0x10,%eax
  81ccd5:	85 c0                	test   %eax,%eax
  81ccd7:	74 3a                	je     81cd13 <tcp_input+0xa1b>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81ccd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccdd:	48 89 c6             	mov    %rax,%rsi
  81cce0:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cce7:	00 00 00 
  81ccea:	48 b8 88 09 81 00 00 	movabs $0x810988,%rax
  81ccf1:	00 00 00 
  81ccf4:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81ccf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccfa:	48 89 c6             	mov    %rax,%rsi
  81ccfd:	bf 02 00 00 00       	mov    $0x2,%edi
  81cd02:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81cd09:	00 00 00 
  81cd0c:	ff d0                	callq  *%rax
  81cd0e:	e9 98 01 00 00       	jmpq   81ceab <tcp_input+0xbb3>
      } else {
        err = ERR_OK;
  81cd13:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81cd17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd1b:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81cd1f:	66 85 c0             	test   %ax,%ax
  81cd22:	74 3a                	je     81cd5e <tcp_input+0xa66>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81cd24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd28:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cd2f:	48 85 c0             	test   %rax,%rax
  81cd32:	74 2a                	je     81cd5e <tcp_input+0xa66>
  81cd34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd38:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cd3f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cd43:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81cd47:	0f b7 d2             	movzwl %dx,%edx
  81cd4a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cd4e:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81cd52:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cd56:	48 89 cf             	mov    %rcx,%rdi
  81cd59:	ff d0                	callq  *%rax
  81cd5b:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81cd5e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cd65:	00 00 00 
  81cd68:	48 8b 00             	mov    (%rax),%rax
  81cd6b:	48 85 c0             	test   %rax,%rax
  81cd6e:	0f 84 cb 00 00 00    	je     81ce3f <tcp_input+0xb47>
          if(flags & TCP_PSH) {
  81cd74:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cd7b:	00 00 00 
  81cd7e:	0f b6 00             	movzbl (%rax),%eax
  81cd81:	0f b6 c0             	movzbl %al,%eax
  81cd84:	83 e0 08             	and    $0x8,%eax
  81cd87:	85 c0                	test   %eax,%eax
  81cd89:	74 24                	je     81cdaf <tcp_input+0xab7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81cd8b:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cd92:	00 00 00 
  81cd95:	48 8b 00             	mov    (%rax),%rax
  81cd98:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cd9f:	00 00 00 
  81cda2:	48 8b 12             	mov    (%rdx),%rdx
  81cda5:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81cda9:	83 ca 01             	or     $0x1,%edx
  81cdac:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81cdaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdb3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cdba:	48 85 c0             	test   %rax,%rax
  81cdbd:	74 30                	je     81cdef <tcp_input+0xaf7>
  81cdbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdc3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cdca:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cdd1:	00 00 00 
  81cdd4:	48 8b 12             	mov    (%rdx),%rdx
  81cdd7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cddb:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81cddf:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cde3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cde8:	ff d0                	callq  *%rax
  81cdea:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cded:	eb 32                	jmp    81ce21 <tcp_input+0xb29>
  81cdef:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81cdf3:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cdfa:	00 00 00 
  81cdfd:	48 8b 00             	mov    (%rax),%rax
  81ce00:	48 85 c0             	test   %rax,%rax
  81ce03:	74 1c                	je     81ce21 <tcp_input+0xb29>
  81ce05:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ce0c:	00 00 00 
  81ce0f:	48 8b 00             	mov    (%rax),%rax
  81ce12:	48 89 c7             	mov    %rax,%rdi
  81ce15:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81ce1c:	00 00 00 
  81ce1f:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81ce21:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81ce25:	74 18                	je     81ce3f <tcp_input+0xb47>
            pcb->refused_data = recv_data;
  81ce27:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ce2e:	00 00 00 
  81ce31:	48 8b 10             	mov    (%rax),%rdx
  81ce34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce38:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81ce3f:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ce46:	00 00 00 
  81ce49:	0f b6 00             	movzbl (%rax),%eax
  81ce4c:	0f b6 c0             	movzbl %al,%eax
  81ce4f:	83 e0 20             	and    $0x20,%eax
  81ce52:	85 c0                	test   %eax,%eax
  81ce54:	74 3c                	je     81ce92 <tcp_input+0xb9a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81ce56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce5a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce61:	48 85 c0             	test   %rax,%rax
  81ce64:	74 28                	je     81ce8e <tcp_input+0xb96>
  81ce66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce6a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce71:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ce75:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81ce79:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ce7d:	b9 00 00 00 00       	mov    $0x0,%ecx
  81ce82:	ba 00 00 00 00       	mov    $0x0,%edx
  81ce87:	ff d0                	callq  *%rax
  81ce89:	88 45 d7             	mov    %al,-0x29(%rbp)
  81ce8c:	eb 04                	jmp    81ce92 <tcp_input+0xb9a>
  81ce8e:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81ce92:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81ce96:	75 13                	jne    81ceab <tcp_input+0xbb3>
          tcp_output(pcb);
  81ce98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce9c:	48 89 c7             	mov    %rax,%rdi
  81ce9f:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81cea6:	00 00 00 
  81cea9:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81ceab:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ceb2:	00 00 00 
  81ceb5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ceb9:	48 85 c0             	test   %rax,%rax
  81cebc:	0f 84 ff 00 00 00    	je     81cfc1 <tcp_input+0xcc9>
    {
      pbuf_free(inseg.p);
  81cec2:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cec9:	00 00 00 
  81cecc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ced0:	48 89 c7             	mov    %rax,%rdi
  81ced3:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81ceda:	00 00 00 
  81cedd:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81cedf:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cee6:	00 00 00 
  81cee9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81cef0:	00 
  81cef1:	e9 cb 00 00 00       	jmpq   81cfc1 <tcp_input+0xcc9>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81cef6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cefd:	00 00 00 
  81cf00:	48 8b 00             	mov    (%rax),%rax
  81cf03:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81cf07:	0f b7 c0             	movzwl %ax,%eax
  81cf0a:	89 c7                	mov    %eax,%edi
  81cf0c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81cf13:	00 00 00 
  81cf16:	ff d0                	callq  *%rax
  81cf18:	0f b7 c0             	movzwl %ax,%eax
  81cf1b:	83 e0 04             	and    $0x4,%eax
  81cf1e:	85 c0                	test   %eax,%eax
  81cf20:	0f 85 88 00 00 00    	jne    81cfae <tcp_input+0xcb6>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cf26:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cf2d:	00 00 00 
  81cf30:	48 8b 00             	mov    (%rax),%rax
  81cf33:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cf36:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cf3a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cf41:	00 00 00 
  81cf44:	48 8b 00             	mov    (%rax),%rax
  81cf47:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cf4b:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81cf4e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cf55:	00 00 00 
  81cf58:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cf5b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81cf5f:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cf66:	00 00 00 
  81cf69:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cf6c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cf70:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81cf77:	00 00 00 
  81cf7a:	0f b7 00             	movzwl (%rax),%eax
  81cf7d:	0f b7 f0             	movzwl %ax,%esi
  81cf80:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cf87:	00 00 00 
  81cf8a:	8b 00                	mov    (%rax),%eax
  81cf8c:	01 c6                	add    %eax,%esi
  81cf8e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81cf95:	00 00 00 
  81cf98:	8b 00                	mov    (%rax),%eax
  81cf9a:	45 89 c1             	mov    %r8d,%r9d
  81cf9d:	41 89 f8             	mov    %edi,%r8d
  81cfa0:	89 c7                	mov    %eax,%edi
  81cfa2:	48 b8 27 44 81 00 00 	movabs $0x814427,%rax
  81cfa9:	00 00 00 
  81cfac:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81cfae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cfb2:	48 89 c7             	mov    %rax,%rdi
  81cfb5:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81cfbc:	00 00 00 
  81cfbf:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81cfc1:	48 83 c4 38          	add    $0x38,%rsp
  81cfc5:	5b                   	pop    %rbx
  81cfc6:	5d                   	pop    %rbp
  81cfc7:	c3                   	retq   

000000000081cfc8 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81cfc8:	55                   	push   %rbp
  81cfc9:	48 89 e5             	mov    %rsp,%rbp
  81cfcc:	48 83 ec 20          	sub    $0x20,%rsp
  81cfd0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81cfd4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cfdb:	00 00 00 
  81cfde:	0f b6 00             	movzbl (%rax),%eax
  81cfe1:	0f b6 c0             	movzbl %al,%eax
  81cfe4:	83 e0 10             	and    $0x10,%eax
  81cfe7:	85 c0                	test   %eax,%eax
  81cfe9:	0f 84 90 00 00 00    	je     81d07f <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cfef:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cff6:	00 00 00 
  81cff9:	48 8b 00             	mov    (%rax),%rax
  81cffc:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cfff:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d003:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d00a:	00 00 00 
  81d00d:	48 8b 00             	mov    (%rax),%rax
  81d010:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d014:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81d017:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d01e:	00 00 00 
  81d021:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d024:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81d028:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d02f:	00 00 00 
  81d032:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d035:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d039:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d040:	00 00 00 
  81d043:	0f b7 00             	movzwl (%rax),%eax
  81d046:	0f b7 f0             	movzwl %ax,%esi
  81d049:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d050:	00 00 00 
  81d053:	8b 00                	mov    (%rax),%eax
  81d055:	01 c6                	add    %eax,%esi
  81d057:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d05e:	00 00 00 
  81d061:	8b 00                	mov    (%rax),%eax
  81d063:	83 c0 01             	add    $0x1,%eax
  81d066:	45 89 c1             	mov    %r8d,%r9d
  81d069:	41 89 f8             	mov    %edi,%r8d
  81d06c:	89 c7                	mov    %eax,%edi
  81d06e:	48 b8 27 44 81 00 00 	movabs $0x814427,%rax
  81d075:	00 00 00 
  81d078:	ff d0                	callq  *%rax
  81d07a:	e9 41 02 00 00       	jmpq   81d2c0 <tcp_listen_input+0x2f8>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81d07f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d086:	00 00 00 
  81d089:	0f b6 00             	movzbl (%rax),%eax
  81d08c:	0f b6 c0             	movzbl %al,%eax
  81d08f:	83 e0 02             	and    $0x2,%eax
  81d092:	85 c0                	test   %eax,%eax
  81d094:	0f 84 26 02 00 00    	je     81d2c0 <tcp_listen_input+0x2f8>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81d09a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d09e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81d0a2:	0f b6 c0             	movzbl %al,%eax
  81d0a5:	89 c7                	mov    %eax,%edi
  81d0a7:	48 b8 f3 05 81 00 00 	movabs $0x8105f3,%rax
  81d0ae:	00 00 00 
  81d0b1:	ff d0                	callq  *%rax
  81d0b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81d0b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81d0bc:	75 0a                	jne    81d0c8 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81d0be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81d0c3:	e9 fd 01 00 00       	jmpq   81d2c5 <tcp_listen_input+0x2fd>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81d0c8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d0cf:	00 00 00 
  81d0d2:	48 8b 00             	mov    (%rax),%rax
  81d0d5:	48 83 c0 10          	add    $0x10,%rax
  81d0d9:	48 85 c0             	test   %rax,%rax
  81d0dc:	74 12                	je     81d0f0 <tcp_listen_input+0x128>
  81d0de:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d0e5:	00 00 00 
  81d0e8:	48 8b 00             	mov    (%rax),%rax
  81d0eb:	8b 40 10             	mov    0x10(%rax),%eax
  81d0ee:	eb 05                	jmp    81d0f5 <tcp_listen_input+0x12d>
  81d0f0:	b8 00 00 00 00       	mov    $0x0,%eax
  81d0f5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d0f9:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81d0fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0ff:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81d103:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d107:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81d10b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d112:	00 00 00 
  81d115:	48 8b 00             	mov    (%rax),%rax
  81d118:	48 83 c0 0c          	add    $0xc,%rax
  81d11c:	48 85 c0             	test   %rax,%rax
  81d11f:	74 12                	je     81d133 <tcp_listen_input+0x16b>
  81d121:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d128:	00 00 00 
  81d12b:	48 8b 00             	mov    (%rax),%rax
  81d12e:	8b 40 0c             	mov    0xc(%rax),%eax
  81d131:	eb 05                	jmp    81d138 <tcp_listen_input+0x170>
  81d133:	b8 00 00 00 00       	mov    $0x0,%eax
  81d138:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d13c:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81d13f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d146:	00 00 00 
  81d149:	48 8b 00             	mov    (%rax),%rax
  81d14c:	0f b7 10             	movzwl (%rax),%edx
  81d14f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d153:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81d157:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d15b:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81d162:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d169:	00 00 00 
  81d16c:	8b 00                	mov    (%rax),%eax
  81d16e:	8d 50 01             	lea    0x1(%rax),%edx
  81d171:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d175:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81d178:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d17f:	00 00 00 
  81d182:	48 8b 00             	mov    (%rax),%rax
  81d185:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d189:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d18d:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81d191:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d195:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81d199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d19d:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81d1a1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d1a8:	00 00 00 
  81d1ab:	8b 00                	mov    (%rax),%eax
  81d1ad:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d1b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d1b4:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81d1b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1bb:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81d1bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d1c3:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81d1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1cb:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81d1cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d1d3:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81d1da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1de:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81d1e2:	66 25 99 01          	and    $0x199,%ax
  81d1e6:	89 c2                	mov    %eax,%edx
  81d1e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d1ec:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81d1f0:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d1f7:	00 00 00 
  81d1fa:	48 8b 10             	mov    (%rax),%rdx
  81d1fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d201:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d205:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d20c:	00 00 00 
  81d20f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d213:	48 89 10             	mov    %rdx,(%rax)
  81d216:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  81d21d:	00 00 00 
  81d220:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81d222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d226:	48 89 c7             	mov    %rax,%rdi
  81d229:	48 b8 a9 fa 81 00 00 	movabs $0x81faa9,%rax
  81d230:	00 00 00 
  81d233:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81d235:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d239:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d23d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d241:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d245:	0f b7 c0             	movzwl %ax,%eax
  81d248:	48 89 d6             	mov    %rdx,%rsi
  81d24b:	89 c7                	mov    %eax,%edi
  81d24d:	48 b8 bd 0b 81 00 00 	movabs $0x810bbd,%rax
  81d254:	00 00 00 
  81d257:	ff d0                	callq  *%rax
  81d259:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d25d:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81d261:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81d266:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  81d26d:	00 00 00 
  81d270:	ff d0                	callq  *%rax
  81d272:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81d275:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81d279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d27d:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  81d284:	49 89 d1             	mov    %rdx,%r9
  81d287:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81d28d:	b9 12 00 00 00       	mov    $0x12,%ecx
  81d292:	ba 00 00 00 00       	mov    $0x0,%edx
  81d297:	be 00 00 00 00       	mov    $0x0,%esi
  81d29c:	48 89 c7             	mov    %rax,%rdi
  81d29f:	48 b8 66 30 81 00 00 	movabs $0x813066,%rax
  81d2a6:	00 00 00 
  81d2a9:	ff d0                	callq  *%rax
    return tcp_output(npcb);
  81d2ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2af:	48 89 c7             	mov    %rax,%rdi
  81d2b2:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81d2b9:	00 00 00 
  81d2bc:	ff d0                	callq  *%rax
  81d2be:	eb 05                	jmp    81d2c5 <tcp_listen_input+0x2fd>
  }
  return ERR_OK;
  81d2c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d2c5:	c9                   	leaveq 
  81d2c6:	c3                   	retq   

000000000081d2c7 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d2c7:	55                   	push   %rbp
  81d2c8:	48 89 e5             	mov    %rsp,%rbp
  81d2cb:	48 83 ec 10          	sub    $0x10,%rsp
  81d2cf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d2d3:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d2da:	00 00 00 
  81d2dd:	0f b7 00             	movzwl (%rax),%eax
  81d2e0:	0f b7 d0             	movzwl %ax,%edx
  81d2e3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d2ea:	00 00 00 
  81d2ed:	8b 00                	mov    (%rax),%eax
  81d2ef:	01 c2                	add    %eax,%edx
  81d2f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2f5:	8b 40 30             	mov    0x30(%rax),%eax
  81d2f8:	29 c2                	sub    %eax,%edx
  81d2fa:	89 d0                	mov    %edx,%eax
  81d2fc:	85 c0                	test   %eax,%eax
  81d2fe:	7e 25                	jle    81d325 <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81d300:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d307:	00 00 00 
  81d30a:	0f b7 00             	movzwl (%rax),%eax
  81d30d:	0f b7 d0             	movzwl %ax,%edx
  81d310:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d317:	00 00 00 
  81d31a:	8b 00                	mov    (%rax),%eax
  81d31c:	01 c2                	add    %eax,%edx
  81d31e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d322:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d325:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d32c:	00 00 00 
  81d32f:	0f b7 00             	movzwl (%rax),%eax
  81d332:	66 85 c0             	test   %ax,%ax
  81d335:	74 27                	je     81d35e <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81d337:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d33b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d33f:	83 c8 02             	or     $0x2,%eax
  81d342:	89 c2                	mov    %eax,%edx
  81d344:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d348:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d34b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d34f:	48 89 c7             	mov    %rax,%rdi
  81d352:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81d359:	00 00 00 
  81d35c:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d35e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d362:	48 89 c7             	mov    %rax,%rdi
  81d365:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81d36c:	00 00 00 
  81d36f:	ff d0                	callq  *%rax
}
  81d371:	c9                   	leaveq 
  81d372:	c3                   	retq   

000000000081d373 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d373:	55                   	push   %rbp
  81d374:	48 89 e5             	mov    %rsp,%rbp
  81d377:	48 83 ec 30          	sub    $0x30,%rsp
  81d37b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d37f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d383:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d387:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d38e:	00 00 00 
  81d391:	0f b6 00             	movzbl (%rax),%eax
  81d394:	0f b6 c0             	movzbl %al,%eax
  81d397:	83 e0 04             	and    $0x4,%eax
  81d39a:	85 c0                	test   %eax,%eax
  81d39c:	0f 84 e0 00 00 00    	je     81d482 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d3a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3a6:	8b 40 18             	mov    0x18(%rax),%eax
  81d3a9:	83 f8 02             	cmp    $0x2,%eax
  81d3ac:	75 1d                	jne    81d3cb <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d3ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3b2:	8b 50 60             	mov    0x60(%rax),%edx
  81d3b5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d3bc:	00 00 00 
  81d3bf:	8b 00                	mov    (%rax),%eax
  81d3c1:	39 c2                	cmp    %eax,%edx
  81d3c3:	75 4d                	jne    81d412 <tcp_process+0x9f>
        acceptable = 1;
  81d3c5:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d3c9:	eb 47                	jmp    81d412 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d3cb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d3d2:	00 00 00 
  81d3d5:	8b 10                	mov    (%rax),%edx
  81d3d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3db:	8b 40 30             	mov    0x30(%rax),%eax
  81d3de:	29 c2                	sub    %eax,%edx
  81d3e0:	89 d0                	mov    %edx,%eax
  81d3e2:	85 c0                	test   %eax,%eax
  81d3e4:	78 2c                	js     81d412 <tcp_process+0x9f>
  81d3e6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d3ed:	00 00 00 
  81d3f0:	8b 10                	mov    (%rax),%edx
  81d3f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3f6:	8b 48 30             	mov    0x30(%rax),%ecx
  81d3f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3fd:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d401:	0f b7 c0             	movzwl %ax,%eax
  81d404:	01 c8                	add    %ecx,%eax
  81d406:	29 c2                	sub    %eax,%edx
  81d408:	89 d0                	mov    %edx,%eax
  81d40a:	85 c0                	test   %eax,%eax
  81d40c:	7f 04                	jg     81d412 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d40e:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d412:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d416:	74 60                	je     81d478 <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d418:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d41c:	8b 40 18             	mov    0x18(%rax),%eax
  81d41f:	85 c0                	test   %eax,%eax
  81d421:	75 2a                	jne    81d44d <tcp_process+0xda>
  81d423:	48 ba 28 39 82 00 00 	movabs $0x823928,%rdx
  81d42a:	00 00 00 
  81d42d:	be 09 02 00 00       	mov    $0x209,%esi
  81d432:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81d439:	00 00 00 
  81d43c:	b8 00 00 00 00       	mov    $0x0,%eax
  81d441:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81d448:	00 00 00 
  81d44b:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d44d:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d454:	00 00 00 
  81d457:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d45a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d45e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d462:	83 e0 fe             	and    $0xfffffffe,%eax
  81d465:	89 c2                	mov    %eax,%edx
  81d467:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d46b:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d46e:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d473:	e9 c7 0b 00 00       	jmpq   81e03f <tcp_process+0xccc>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d478:	b8 00 00 00 00       	mov    $0x0,%eax
  81d47d:	e9 bd 0b 00 00       	jmpq   81e03f <tcp_process+0xccc>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d482:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d489:	00 00 00 
  81d48c:	8b 10                	mov    (%rax),%edx
  81d48e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d492:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d495:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d499:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d4a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4a4:	8b 40 18             	mov    0x18(%rax),%eax
  81d4a7:	83 f8 09             	cmp    $0x9,%eax
  81d4aa:	0f 87 89 0b 00 00    	ja     81e039 <tcp_process+0xcc6>
  81d4b0:	89 c0                	mov    %eax,%eax
  81d4b2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d4b9:	00 
  81d4ba:	48 b8 78 39 82 00 00 	movabs $0x823978,%rax
  81d4c1:	00 00 00 
  81d4c4:	48 01 d0             	add    %rdx,%rax
  81d4c7:	48 8b 00             	mov    (%rax),%rax
  81d4ca:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d4cc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d4d3:	00 00 00 
  81d4d6:	0f b6 00             	movzbl (%rax),%eax
  81d4d9:	0f b6 c0             	movzbl %al,%eax
  81d4dc:	83 e0 10             	and    $0x10,%eax
  81d4df:	85 c0                	test   %eax,%eax
  81d4e1:	0f 84 58 02 00 00    	je     81d73f <tcp_process+0x3cc>
  81d4e7:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d4ee:	00 00 00 
  81d4f1:	0f b6 00             	movzbl (%rax),%eax
  81d4f4:	0f b6 c0             	movzbl %al,%eax
  81d4f7:	83 e0 02             	and    $0x2,%eax
  81d4fa:	85 c0                	test   %eax,%eax
  81d4fc:	0f 84 3d 02 00 00    	je     81d73f <tcp_process+0x3cc>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d502:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d506:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d50d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d511:	8b 40 04             	mov    0x4(%rax),%eax
  81d514:	89 c7                	mov    %eax,%edi
  81d516:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81d51d:	00 00 00 
  81d520:	ff d0                	callq  *%rax
  81d522:	8d 50 01             	lea    0x1(%rax),%edx
  81d525:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d52c:	00 00 00 
  81d52f:	8b 00                	mov    (%rax),%eax
  81d531:	39 c2                	cmp    %eax,%edx
  81d533:	0f 85 06 02 00 00    	jne    81d73f <tcp_process+0x3cc>
      pcb->snd_buf++;
  81d539:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d53d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d541:	8d 50 01             	lea    0x1(%rax),%edx
  81d544:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d548:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d54c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d553:	00 00 00 
  81d556:	8b 00                	mov    (%rax),%eax
  81d558:	8d 50 01             	lea    0x1(%rax),%edx
  81d55b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d55f:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d562:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d569:	00 00 00 
  81d56c:	8b 10                	mov    (%rax),%edx
  81d56e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d572:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d575:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d57c:	00 00 00 
  81d57f:	48 8b 00             	mov    (%rax),%rax
  81d582:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d586:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d58a:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d58e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d595:	00 00 00 
  81d598:	8b 00                	mov    (%rax),%eax
  81d59a:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d59d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5a1:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d5a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5a8:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d5af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5b3:	48 89 c7             	mov    %rax,%rdi
  81d5b6:	48 b8 a9 fa 81 00 00 	movabs $0x81faa9,%rax
  81d5bd:	00 00 00 
  81d5c0:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d5c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5c6:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d5ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5ce:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d5d2:	0f b7 c0             	movzwl %ax,%eax
  81d5d5:	48 89 d6             	mov    %rdx,%rsi
  81d5d8:	89 c7                	mov    %eax,%edi
  81d5da:	48 b8 bd 0b 81 00 00 	movabs $0x810bbd,%rax
  81d5e1:	00 00 00 
  81d5e4:	ff d0                	callq  *%rax
  81d5e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d5ea:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d5ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5f2:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d5f6:	89 d0                	mov    %edx,%eax
  81d5f8:	c1 e0 02             	shl    $0x2,%eax
  81d5fb:	01 d0                	add    %edx,%eax
  81d5fd:	01 c0                	add    %eax,%eax
  81d5ff:	89 c2                	mov    %eax,%edx
  81d601:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d605:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d609:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d60d:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d611:	66 83 f8 01          	cmp    $0x1,%ax
  81d615:	75 0c                	jne    81d623 <tcp_process+0x2b0>
  81d617:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d61b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d61f:	01 c0                	add    %eax,%eax
  81d621:	eb 08                	jmp    81d62b <tcp_process+0x2b8>
  81d623:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d627:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d62b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d62f:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d633:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d637:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d63b:	66 85 c0             	test   %ax,%ax
  81d63e:	75 2a                	jne    81d66a <tcp_process+0x2f7>
  81d640:	48 ba 48 39 82 00 00 	movabs $0x823948,%rdx
  81d647:	00 00 00 
  81d64a:	be 35 02 00 00       	mov    $0x235,%esi
  81d64f:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81d656:	00 00 00 
  81d659:	b8 00 00 00 00       	mov    $0x0,%eax
  81d65e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81d665:	00 00 00 
  81d668:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d66a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d66e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d672:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d675:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d679:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d67d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d681:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d688:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d68c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d690:	48 8b 10             	mov    (%rax),%rdx
  81d693:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d697:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d69e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6a2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d6a9:	48 85 c0             	test   %rax,%rax
  81d6ac:	75 0c                	jne    81d6ba <tcp_process+0x347>
        pcb->rtime = -1;
  81d6ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6b2:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d6b8:	eb 12                	jmp    81d6cc <tcp_process+0x359>
      else {
        pcb->rtime = 0;
  81d6ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6be:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d6c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6c8:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d6cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d6d0:	48 89 c7             	mov    %rax,%rdi
  81d6d3:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81d6da:	00 00 00 
  81d6dd:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d6df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6e3:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d6ea:	48 85 c0             	test   %rax,%rax
  81d6ed:	74 24                	je     81d713 <tcp_process+0x3a0>
  81d6ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6f3:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d6fa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d6fe:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d702:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d706:	ba 00 00 00 00       	mov    $0x0,%edx
  81d70b:	48 89 cf             	mov    %rcx,%rdi
  81d70e:	ff d0                	callq  *%rax
  81d710:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d713:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d717:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d71b:	83 c8 02             	or     $0x2,%eax
  81d71e:	89 c2                	mov    %eax,%edx
  81d720:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d724:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d727:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d72b:	48 89 c7             	mov    %rax,%rdi
  81d72e:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81d735:	00 00 00 
  81d738:	ff d0                	callq  *%rax
  81d73a:	e9 a8 00 00 00       	jmpq   81d7e7 <tcp_process+0x474>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d73f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d746:	00 00 00 
  81d749:	0f b6 00             	movzbl (%rax),%eax
  81d74c:	0f b6 c0             	movzbl %al,%eax
  81d74f:	83 e0 10             	and    $0x10,%eax
  81d752:	85 c0                	test   %eax,%eax
  81d754:	0f 84 8d 00 00 00    	je     81d7e7 <tcp_process+0x474>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d75a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d761:	00 00 00 
  81d764:	48 8b 00             	mov    (%rax),%rax
  81d767:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d76a:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81d76e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d775:	00 00 00 
  81d778:	48 8b 00             	mov    (%rax),%rax
  81d77b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d77f:	0f b7 f8             	movzwl %ax,%edi
  81d782:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d789:	00 00 00 
  81d78c:	48 8b 00             	mov    (%rax),%rax
  81d78f:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d793:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d79a:	00 00 00 
  81d79d:	48 8b 00             	mov    (%rax),%rax
  81d7a0:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d7a4:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d7ab:	00 00 00 
  81d7ae:	0f b7 00             	movzwl (%rax),%eax
  81d7b1:	0f b7 f0             	movzwl %ax,%esi
  81d7b4:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d7bb:	00 00 00 
  81d7be:	8b 00                	mov    (%rax),%eax
  81d7c0:	01 c6                	add    %eax,%esi
  81d7c2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d7c9:	00 00 00 
  81d7cc:	8b 00                	mov    (%rax),%eax
  81d7ce:	45 89 c1             	mov    %r8d,%r9d
  81d7d1:	41 89 f8             	mov    %edi,%r8d
  81d7d4:	89 c7                	mov    %eax,%edi
  81d7d6:	48 b8 27 44 81 00 00 	movabs $0x814427,%rax
  81d7dd:	00 00 00 
  81d7e0:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d7e2:	e9 53 08 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  81d7e7:	e9 4e 08 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d7ec:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d7f3:	00 00 00 
  81d7f6:	0f b6 00             	movzbl (%rax),%eax
  81d7f9:	0f b6 c0             	movzbl %al,%eax
  81d7fc:	83 e0 10             	and    $0x10,%eax
  81d7ff:	85 c0                	test   %eax,%eax
  81d801:	0f 84 23 02 00 00    	je     81da2a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
  81d807:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d80e:	00 00 00 
  81d811:	0f b6 00             	movzbl (%rax),%eax
  81d814:	0f b6 c0             	movzbl %al,%eax
  81d817:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d81a:	85 c0                	test   %eax,%eax
  81d81c:	0f 85 08 02 00 00    	jne    81da2a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d822:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d829:	00 00 00 
  81d82c:	8b 10                	mov    (%rax),%edx
  81d82e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d832:	8b 40 54             	mov    0x54(%rax),%eax
  81d835:	29 c2                	sub    %eax,%edx
  81d837:	89 d0                	mov    %edx,%eax
  81d839:	83 e8 01             	sub    $0x1,%eax
  81d83c:	85 c0                	test   %eax,%eax
  81d83e:	0f 88 59 01 00 00    	js     81d99d <tcp_process+0x62a>
  81d844:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d84b:	00 00 00 
  81d84e:	8b 10                	mov    (%rax),%edx
  81d850:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d854:	8b 40 60             	mov    0x60(%rax),%eax
  81d857:	29 c2                	sub    %eax,%edx
  81d859:	89 d0                	mov    %edx,%eax
  81d85b:	85 c0                	test   %eax,%eax
  81d85d:	0f 8f 3a 01 00 00    	jg     81d99d <tcp_process+0x62a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81d863:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d867:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81d86e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d872:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d879:	48 85 c0             	test   %rax,%rax
  81d87c:	75 2a                	jne    81d8a8 <tcp_process+0x535>
  81d87e:	48 ba 5e 39 82 00 00 	movabs $0x82395e,%rdx
  81d885:	00 00 00 
  81d888:	be 5b 02 00 00       	mov    $0x25b,%esi
  81d88d:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81d894:	00 00 00 
  81d897:	b8 00 00 00 00       	mov    $0x0,%eax
  81d89c:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81d8a3:	00 00 00 
  81d8a6:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81d8a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8ac:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d8b3:	48 85 c0             	test   %rax,%rax
  81d8b6:	74 24                	je     81d8dc <tcp_process+0x569>
  81d8b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8bc:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d8c3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d8c7:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d8cb:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d8cf:	ba 00 00 00 00       	mov    $0x0,%edx
  81d8d4:	48 89 cf             	mov    %rcx,%rdi
  81d8d7:	ff d0                	callq  *%rax
  81d8d9:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81d8dc:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81d8e0:	74 1d                	je     81d8ff <tcp_process+0x58c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81d8e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8e6:	48 89 c7             	mov    %rax,%rdi
  81d8e9:	48 b8 de ed 80 00 00 	movabs $0x80edde,%rax
  81d8f0:	00 00 00 
  81d8f3:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81d8f5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81d8fa:	e9 40 07 00 00       	jmpq   81e03f <tcp_process+0xccc>
        }
        old_cwnd = pcb->cwnd;
  81d8ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d903:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d907:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81d90b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d90f:	48 89 c7             	mov    %rax,%rdi
  81d912:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81d919:	00 00 00 
  81d91c:	ff d0                	callq  *%rax
  81d91e:	88 45 ed             	mov    %al,-0x13(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d921:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  81d926:	75 0c                	jne    81d934 <tcp_process+0x5c1>
  81d928:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d92c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d930:	01 c0                	add    %eax,%eax
  81d932:	eb 08                	jmp    81d93c <tcp_process+0x5c9>
  81d934:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d938:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d93c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d940:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81d944:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d94b:	00 00 00 
  81d94e:	0f b6 00             	movzbl (%rax),%eax
  81d951:	0f b6 c0             	movzbl %al,%eax
  81d954:	83 e0 01             	and    $0x1,%eax
  81d957:	85 c0                	test   %eax,%eax
  81d959:	74 3d                	je     81d998 <tcp_process+0x625>
  81d95b:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d95f:	74 37                	je     81d998 <tcp_process+0x625>
          tcp_ack_now(pcb);
  81d961:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d965:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d969:	83 c8 02             	or     $0x2,%eax
  81d96c:	89 c2                	mov    %eax,%edx
  81d96e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d972:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d975:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d979:	48 89 c7             	mov    %rax,%rdi
  81d97c:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81d983:	00 00 00 
  81d986:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81d988:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d98c:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d993:	e9 92 00 00 00       	jmpq   81da2a <tcp_process+0x6b7>
  81d998:	e9 8d 00 00 00       	jmpq   81da2a <tcp_process+0x6b7>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81d99d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d9a4:	00 00 00 
  81d9a7:	48 8b 00             	mov    (%rax),%rax
  81d9aa:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d9ad:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81d9b1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d9b8:	00 00 00 
  81d9bb:	48 8b 00             	mov    (%rax),%rax
  81d9be:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d9c2:	0f b7 f8             	movzwl %ax,%edi
  81d9c5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d9cc:	00 00 00 
  81d9cf:	48 8b 00             	mov    (%rax),%rax
  81d9d2:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d9d6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d9dd:	00 00 00 
  81d9e0:	48 8b 00             	mov    (%rax),%rax
  81d9e3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d9e7:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d9ee:	00 00 00 
  81d9f1:	0f b7 00             	movzwl (%rax),%eax
  81d9f4:	0f b7 f0             	movzwl %ax,%esi
  81d9f7:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d9fe:	00 00 00 
  81da01:	8b 00                	mov    (%rax),%eax
  81da03:	01 c6                	add    %eax,%esi
  81da05:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81da0c:	00 00 00 
  81da0f:	8b 00                	mov    (%rax),%eax
  81da11:	45 89 c1             	mov    %r8d,%r9d
  81da14:	41 89 f8             	mov    %edi,%r8d
  81da17:	89 c7                	mov    %eax,%edi
  81da19:	48 b8 27 44 81 00 00 	movabs $0x814427,%rax
  81da20:	00 00 00 
  81da23:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81da25:	e9 10 06 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  81da2a:	e9 0b 06 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81da2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da33:	48 89 c7             	mov    %rax,%rdi
  81da36:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81da3d:	00 00 00 
  81da40:	ff d0                	callq  *%rax
  81da42:	88 45 ed             	mov    %al,-0x13(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81da45:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81da4c:	00 00 00 
  81da4f:	0f b6 00             	movzbl (%rax),%eax
  81da52:	0f b6 c0             	movzbl %al,%eax
  81da55:	83 e0 01             	and    $0x1,%eax
  81da58:	85 c0                	test   %eax,%eax
  81da5a:	74 3d                	je     81da99 <tcp_process+0x726>
  81da5c:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81da60:	74 37                	je     81da99 <tcp_process+0x726>
      tcp_ack_now(pcb);
  81da62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da66:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da6a:	83 c8 02             	or     $0x2,%eax
  81da6d:	89 c2                	mov    %eax,%edx
  81da6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da73:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da7a:	48 89 c7             	mov    %rax,%rdi
  81da7d:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81da84:	00 00 00 
  81da87:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81da89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da8d:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81da94:	e9 a1 05 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  81da99:	e9 9c 05 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81da9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daa2:	48 89 c7             	mov    %rax,%rdi
  81daa5:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81daac:	00 00 00 
  81daaf:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dab1:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dab8:	00 00 00 
  81dabb:	0f b6 00             	movzbl (%rax),%eax
  81dabe:	0f b6 c0             	movzbl %al,%eax
  81dac1:	83 e0 01             	and    $0x1,%eax
  81dac4:	85 c0                	test   %eax,%eax
  81dac6:	0f 84 b9 01 00 00    	je     81dc85 <tcp_process+0x912>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dacc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dad3:	00 00 00 
  81dad6:	0f b6 00             	movzbl (%rax),%eax
  81dad9:	0f b6 c0             	movzbl %al,%eax
  81dadc:	83 e0 10             	and    $0x10,%eax
  81dadf:	85 c0                	test   %eax,%eax
  81dae1:	0f 84 6a 01 00 00    	je     81dc51 <tcp_process+0x8de>
  81dae7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daeb:	8b 50 60             	mov    0x60(%rax),%edx
  81daee:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81daf5:	00 00 00 
  81daf8:	8b 00                	mov    (%rax),%eax
  81dafa:	39 c2                	cmp    %eax,%edx
  81dafc:	0f 85 4f 01 00 00    	jne    81dc51 <tcp_process+0x8de>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81db02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db06:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81db0a:	83 c8 02             	or     $0x2,%eax
  81db0d:	89 c2                	mov    %eax,%edx
  81db0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db13:	88 50 2c             	mov    %dl,0x2c(%rax)
  81db16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db1a:	48 89 c7             	mov    %rax,%rdi
  81db1d:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81db24:	00 00 00 
  81db27:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81db29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db2d:	48 89 c7             	mov    %rax,%rdi
  81db30:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  81db37:	00 00 00 
  81db3a:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81db3c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db43:	00 00 00 
  81db46:	48 8b 00             	mov    (%rax),%rax
  81db49:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81db4d:	75 23                	jne    81db72 <tcp_process+0x7ff>
  81db4f:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db56:	00 00 00 
  81db59:	48 8b 00             	mov    (%rax),%rax
  81db5c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81db60:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db67:	00 00 00 
  81db6a:	48 89 10             	mov    %rdx,(%rax)
  81db6d:	e9 94 00 00 00       	jmpq   81dc06 <tcp_process+0x893>
  81db72:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db79:	00 00 00 
  81db7c:	48 8b 10             	mov    (%rax),%rdx
  81db7f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db86:	00 00 00 
  81db89:	48 89 10             	mov    %rdx,(%rax)
  81db8c:	eb 66                	jmp    81dbf4 <tcp_process+0x881>
  81db8e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db95:	00 00 00 
  81db98:	48 8b 00             	mov    (%rax),%rax
  81db9b:	48 8b 40 10          	mov    0x10(%rax),%rax
  81db9f:	48 85 c0             	test   %rax,%rax
  81dba2:	74 32                	je     81dbd6 <tcp_process+0x863>
  81dba4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbab:	00 00 00 
  81dbae:	48 8b 00             	mov    (%rax),%rax
  81dbb1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dbb5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dbb9:	75 1b                	jne    81dbd6 <tcp_process+0x863>
  81dbbb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbc2:	00 00 00 
  81dbc5:	48 8b 00             	mov    (%rax),%rax
  81dbc8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dbcc:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dbd0:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dbd4:	eb 30                	jmp    81dc06 <tcp_process+0x893>
  81dbd6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbdd:	00 00 00 
  81dbe0:	48 8b 00             	mov    (%rax),%rax
  81dbe3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dbe7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbee:	00 00 00 
  81dbf1:	48 89 10             	mov    %rdx,(%rax)
  81dbf4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbfb:	00 00 00 
  81dbfe:	48 8b 00             	mov    (%rax),%rax
  81dc01:	48 85 c0             	test   %rax,%rax
  81dc04:	75 88                	jne    81db8e <tcp_process+0x81b>
  81dc06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc0a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dc11:	00 
        pcb->state = TIME_WAIT;
  81dc12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc16:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81dc1d:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dc24:	00 00 00 
  81dc27:	48 8b 10             	mov    (%rax),%rdx
  81dc2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc2e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dc32:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dc39:	00 00 00 
  81dc3c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dc40:	48 89 10             	mov    %rdx,(%rax)
  81dc43:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  81dc4a:	00 00 00 
  81dc4d:	ff d0                	callq  *%rax
  81dc4f:	eb 72                	jmp    81dcc3 <tcp_process+0x950>
      } else {
        tcp_ack_now(pcb);
  81dc51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc55:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dc59:	83 c8 02             	or     $0x2,%eax
  81dc5c:	89 c2                	mov    %eax,%edx
  81dc5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc62:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc69:	48 89 c7             	mov    %rax,%rdi
  81dc6c:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81dc73:	00 00 00 
  81dc76:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81dc78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc7c:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
  81dc83:	eb 3e                	jmp    81dcc3 <tcp_process+0x950>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dc85:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dc8c:	00 00 00 
  81dc8f:	0f b6 00             	movzbl (%rax),%eax
  81dc92:	0f b6 c0             	movzbl %al,%eax
  81dc95:	83 e0 10             	and    $0x10,%eax
  81dc98:	85 c0                	test   %eax,%eax
  81dc9a:	74 27                	je     81dcc3 <tcp_process+0x950>
  81dc9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dca0:	8b 50 60             	mov    0x60(%rax),%edx
  81dca3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dcaa:	00 00 00 
  81dcad:	8b 00                	mov    (%rax),%eax
  81dcaf:	39 c2                	cmp    %eax,%edx
  81dcb1:	75 10                	jne    81dcc3 <tcp_process+0x950>
      pcb->state = FIN_WAIT_2;
  81dcb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcb7:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81dcbe:	e9 77 03 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  81dcc3:	e9 72 03 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81dcc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dccc:	48 89 c7             	mov    %rax,%rdi
  81dccf:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81dcd6:	00 00 00 
  81dcd9:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dcdb:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dce2:	00 00 00 
  81dce5:	0f b6 00             	movzbl (%rax),%eax
  81dce8:	0f b6 c0             	movzbl %al,%eax
  81dceb:	83 e0 01             	and    $0x1,%eax
  81dcee:	85 c0                	test   %eax,%eax
  81dcf0:	0f 84 52 01 00 00    	je     81de48 <tcp_process+0xad5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81dcf6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcfa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dcfe:	83 c8 02             	or     $0x2,%eax
  81dd01:	89 c2                	mov    %eax,%edx
  81dd03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd07:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dd0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd0e:	48 89 c7             	mov    %rax,%rdi
  81dd11:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81dd18:	00 00 00 
  81dd1b:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81dd1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd21:	48 89 c7             	mov    %rax,%rdi
  81dd24:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  81dd2b:	00 00 00 
  81dd2e:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81dd30:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dd37:	00 00 00 
  81dd3a:	48 8b 00             	mov    (%rax),%rax
  81dd3d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dd41:	75 23                	jne    81dd66 <tcp_process+0x9f3>
  81dd43:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dd4a:	00 00 00 
  81dd4d:	48 8b 00             	mov    (%rax),%rax
  81dd50:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dd54:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dd5b:	00 00 00 
  81dd5e:	48 89 10             	mov    %rdx,(%rax)
  81dd61:	e9 94 00 00 00       	jmpq   81ddfa <tcp_process+0xa87>
  81dd66:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dd6d:	00 00 00 
  81dd70:	48 8b 10             	mov    (%rax),%rdx
  81dd73:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd7a:	00 00 00 
  81dd7d:	48 89 10             	mov    %rdx,(%rax)
  81dd80:	eb 66                	jmp    81dde8 <tcp_process+0xa75>
  81dd82:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd89:	00 00 00 
  81dd8c:	48 8b 00             	mov    (%rax),%rax
  81dd8f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dd93:	48 85 c0             	test   %rax,%rax
  81dd96:	74 32                	je     81ddca <tcp_process+0xa57>
  81dd98:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd9f:	00 00 00 
  81dda2:	48 8b 00             	mov    (%rax),%rax
  81dda5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dda9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81ddad:	75 1b                	jne    81ddca <tcp_process+0xa57>
  81ddaf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81ddb6:	00 00 00 
  81ddb9:	48 8b 00             	mov    (%rax),%rax
  81ddbc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ddc0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81ddc4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81ddc8:	eb 30                	jmp    81ddfa <tcp_process+0xa87>
  81ddca:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81ddd1:	00 00 00 
  81ddd4:	48 8b 00             	mov    (%rax),%rax
  81ddd7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dddb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dde2:	00 00 00 
  81dde5:	48 89 10             	mov    %rdx,(%rax)
  81dde8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81ddef:	00 00 00 
  81ddf2:	48 8b 00             	mov    (%rax),%rax
  81ddf5:	48 85 c0             	test   %rax,%rax
  81ddf8:	75 88                	jne    81dd82 <tcp_process+0xa0f>
  81ddfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ddfe:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81de05:	00 
      pcb->state = TIME_WAIT;
  81de06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de0a:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81de11:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81de18:	00 00 00 
  81de1b:	48 8b 10             	mov    (%rax),%rdx
  81de1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de22:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81de26:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81de2d:	00 00 00 
  81de30:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81de34:	48 89 10             	mov    %rdx,(%rax)
  81de37:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  81de3e:	00 00 00 
  81de41:	ff d0                	callq  *%rax
    }
    break;
  81de43:	e9 f2 01 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  81de48:	e9 ed 01 00 00       	jmpq   81e03a <tcp_process+0xcc7>
  case CLOSING:
    tcp_receive(pcb);
  81de4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de51:	48 89 c7             	mov    %rax,%rdi
  81de54:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81de5b:	00 00 00 
  81de5e:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81de60:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81de67:	00 00 00 
  81de6a:	0f b6 00             	movzbl (%rax),%eax
  81de6d:	0f b6 c0             	movzbl %al,%eax
  81de70:	83 e0 10             	and    $0x10,%eax
  81de73:	85 c0                	test   %eax,%eax
  81de75:	0f 84 6a 01 00 00    	je     81dfe5 <tcp_process+0xc72>
  81de7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de7f:	8b 50 60             	mov    0x60(%rax),%edx
  81de82:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81de89:	00 00 00 
  81de8c:	8b 00                	mov    (%rax),%eax
  81de8e:	39 c2                	cmp    %eax,%edx
  81de90:	0f 85 4f 01 00 00    	jne    81dfe5 <tcp_process+0xc72>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81de96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de9a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81de9e:	83 c8 02             	or     $0x2,%eax
  81dea1:	89 c2                	mov    %eax,%edx
  81dea3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dea7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81deaa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81deae:	48 89 c7             	mov    %rax,%rdi
  81deb1:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81deb8:	00 00 00 
  81debb:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81debd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dec1:	48 89 c7             	mov    %rax,%rdi
  81dec4:	48 b8 86 08 81 00 00 	movabs $0x810886,%rax
  81decb:	00 00 00 
  81dece:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81ded0:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81ded7:	00 00 00 
  81deda:	48 8b 00             	mov    (%rax),%rax
  81dedd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dee1:	75 23                	jne    81df06 <tcp_process+0xb93>
  81dee3:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81deea:	00 00 00 
  81deed:	48 8b 00             	mov    (%rax),%rax
  81def0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81def4:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81defb:	00 00 00 
  81defe:	48 89 10             	mov    %rdx,(%rax)
  81df01:	e9 94 00 00 00       	jmpq   81df9a <tcp_process+0xc27>
  81df06:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81df0d:	00 00 00 
  81df10:	48 8b 10             	mov    (%rax),%rdx
  81df13:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df1a:	00 00 00 
  81df1d:	48 89 10             	mov    %rdx,(%rax)
  81df20:	eb 66                	jmp    81df88 <tcp_process+0xc15>
  81df22:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df29:	00 00 00 
  81df2c:	48 8b 00             	mov    (%rax),%rax
  81df2f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81df33:	48 85 c0             	test   %rax,%rax
  81df36:	74 32                	je     81df6a <tcp_process+0xbf7>
  81df38:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df3f:	00 00 00 
  81df42:	48 8b 00             	mov    (%rax),%rax
  81df45:	48 8b 40 10          	mov    0x10(%rax),%rax
  81df49:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81df4d:	75 1b                	jne    81df6a <tcp_process+0xbf7>
  81df4f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df56:	00 00 00 
  81df59:	48 8b 00             	mov    (%rax),%rax
  81df5c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81df60:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81df64:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81df68:	eb 30                	jmp    81df9a <tcp_process+0xc27>
  81df6a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df71:	00 00 00 
  81df74:	48 8b 00             	mov    (%rax),%rax
  81df77:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81df7b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df82:	00 00 00 
  81df85:	48 89 10             	mov    %rdx,(%rax)
  81df88:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df8f:	00 00 00 
  81df92:	48 8b 00             	mov    (%rax),%rax
  81df95:	48 85 c0             	test   %rax,%rax
  81df98:	75 88                	jne    81df22 <tcp_process+0xbaf>
  81df9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df9e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dfa5:	00 
      pcb->state = TIME_WAIT;
  81dfa6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfaa:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81dfb1:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dfb8:	00 00 00 
  81dfbb:	48 8b 10             	mov    (%rax),%rdx
  81dfbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfc2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dfc6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dfcd:	00 00 00 
  81dfd0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dfd4:	48 89 10             	mov    %rdx,(%rax)
  81dfd7:	48 b8 d0 85 80 00 00 	movabs $0x8085d0,%rax
  81dfde:	00 00 00 
  81dfe1:	ff d0                	callq  *%rax
    }
    break;
  81dfe3:	eb 55                	jmp    81e03a <tcp_process+0xcc7>
  81dfe5:	eb 53                	jmp    81e03a <tcp_process+0xcc7>
  case LAST_ACK:
    tcp_receive(pcb);
  81dfe7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfeb:	48 89 c7             	mov    %rax,%rdi
  81dfee:	48 b8 41 e0 81 00 00 	movabs $0x81e041,%rax
  81dff5:	00 00 00 
  81dff8:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dffa:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e001:	00 00 00 
  81e004:	0f b6 00             	movzbl (%rax),%eax
  81e007:	0f b6 c0             	movzbl %al,%eax
  81e00a:	83 e0 10             	and    $0x10,%eax
  81e00d:	85 c0                	test   %eax,%eax
  81e00f:	74 26                	je     81e037 <tcp_process+0xcc4>
  81e011:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e015:	8b 50 60             	mov    0x60(%rax),%edx
  81e018:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e01f:	00 00 00 
  81e022:	8b 00                	mov    (%rax),%eax
  81e024:	39 c2                	cmp    %eax,%edx
  81e026:	75 0f                	jne    81e037 <tcp_process+0xcc4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81e028:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81e02f:	00 00 00 
  81e032:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81e035:	eb 03                	jmp    81e03a <tcp_process+0xcc7>
  81e037:	eb 01                	jmp    81e03a <tcp_process+0xcc7>
  default:
    break;
  81e039:	90                   	nop
  }
  return ERR_OK;
  81e03a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81e03f:	c9                   	leaveq 
  81e040:	c3                   	retq   

000000000081e041 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81e041:	55                   	push   %rbp
  81e042:	48 89 e5             	mov    %rsp,%rbp
  81e045:	41 55                	push   %r13
  81e047:	41 54                	push   %r12
  81e049:	53                   	push   %rbx
  81e04a:	48 83 ec 58          	sub    $0x58,%rsp
  81e04e:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81e052:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81e056:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e05d:	00 00 00 
  81e060:	0f b6 00             	movzbl (%rax),%eax
  81e063:	0f b6 c0             	movzbl %al,%eax
  81e066:	83 e0 10             	and    $0x10,%eax
  81e069:	85 c0                	test   %eax,%eax
  81e06b:	0f 84 80 09 00 00    	je     81e9f1 <tcp_receive+0x9b0>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81e071:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e075:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e079:	0f b7 d0             	movzwl %ax,%edx
  81e07c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e080:	8b 40 6c             	mov    0x6c(%rax),%eax
  81e083:	01 d0                	add    %edx,%eax
  81e085:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e088:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e08c:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e08f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e096:	00 00 00 
  81e099:	8b 00                	mov    (%rax),%eax
  81e09b:	29 c2                	sub    %eax,%edx
  81e09d:	89 d0                	mov    %edx,%eax
  81e09f:	85 c0                	test   %eax,%eax
  81e0a1:	78 6b                	js     81e10e <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e0a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0a7:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e0aa:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e0b1:	00 00 00 
  81e0b4:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e0b6:	39 c2                	cmp    %eax,%edx
  81e0b8:	75 1b                	jne    81e0d5 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e0ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0be:	8b 50 70             	mov    0x70(%rax),%edx
  81e0c1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e0c8:	00 00 00 
  81e0cb:	8b 00                	mov    (%rax),%eax
  81e0cd:	29 c2                	sub    %eax,%edx
  81e0cf:	89 d0                	mov    %edx,%eax
  81e0d1:	85 c0                	test   %eax,%eax
  81e0d3:	78 39                	js     81e10e <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e0d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0d9:	8b 50 70             	mov    0x70(%rax),%edx
  81e0dc:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e0e3:	00 00 00 
  81e0e6:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e0e8:	39 c2                	cmp    %eax,%edx
  81e0ea:	0f 85 84 00 00 00    	jne    81e174 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e0f0:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e0f7:	00 00 00 
  81e0fa:	48 8b 00             	mov    (%rax),%rax
  81e0fd:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e101:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e105:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e109:	66 39 c2             	cmp    %ax,%dx
  81e10c:	76 66                	jbe    81e174 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81e10e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e115:	00 00 00 
  81e118:	48 8b 00             	mov    (%rax),%rax
  81e11b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e11f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e123:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81e127:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e12e:	00 00 00 
  81e131:	8b 10                	mov    (%rax),%edx
  81e133:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e137:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81e13a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e141:	00 00 00 
  81e144:	8b 10                	mov    (%rax),%edx
  81e146:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e14a:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81e14d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e151:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e155:	66 85 c0             	test   %ax,%ax
  81e158:	74 1a                	je     81e174 <tcp_receive+0x133>
  81e15a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e15e:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81e165:	84 c0                	test   %al,%al
  81e167:	74 0b                	je     81e174 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81e169:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e16d:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81e174:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e178:	8b 50 54             	mov    0x54(%rax),%edx
  81e17b:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e182:	00 00 00 
  81e185:	8b 00                	mov    (%rax),%eax
  81e187:	39 c2                	cmp    %eax,%edx
  81e189:	0f 85 72 01 00 00    	jne    81e301 <tcp_receive+0x2c0>
      pcb->acked = 0;
  81e18f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e193:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81e199:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e19d:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e1a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1a4:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e1a8:	0f b7 c0             	movzwl %ax,%eax
  81e1ab:	01 d0                	add    %edx,%eax
  81e1ad:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81e1b0:	0f 85 15 05 00 00    	jne    81e6cb <tcp_receive+0x68a>
        ++pcb->dupacks;
  81e1b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1ba:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e1be:	8d 50 01             	lea    0x1(%rax),%edx
  81e1c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1c5:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81e1c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1cc:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e1d0:	3c 02                	cmp    $0x2,%al
  81e1d2:	0f 86 f3 04 00 00    	jbe    81e6cb <tcp_receive+0x68a>
  81e1d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1dc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e1e3:	48 85 c0             	test   %rax,%rax
  81e1e6:	0f 84 df 04 00 00    	je     81e6cb <tcp_receive+0x68a>
          if (!(pcb->flags & TF_INFR)) {
  81e1ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1f0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e1f4:	0f b6 c0             	movzbl %al,%eax
  81e1f7:	83 e0 04             	and    $0x4,%eax
  81e1fa:	85 c0                	test   %eax,%eax
  81e1fc:	0f 85 bd 00 00 00    	jne    81e2bf <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81e202:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e206:	48 89 c7             	mov    %rax,%rdi
  81e209:	48 b8 0a 47 81 00 00 	movabs $0x81470a,%rax
  81e210:	00 00 00 
  81e213:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81e215:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e219:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e21d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e221:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e225:	66 39 c2             	cmp    %ax,%dx
  81e228:	76 17                	jbe    81e241 <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81e22a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e22e:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e232:	66 d1 e8             	shr    %ax
  81e235:	89 c2                	mov    %eax,%edx
  81e237:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e23b:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81e23f:	eb 15                	jmp    81e256 <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81e241:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e245:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e249:	66 d1 e8             	shr    %ax
  81e24c:	89 c2                	mov    %eax,%edx
  81e24e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e252:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81e256:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e25a:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e25e:	0f b7 d0             	movzwl %ax,%edx
  81e261:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e265:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e269:	0f b7 c0             	movzwl %ax,%eax
  81e26c:	01 c0                	add    %eax,%eax
  81e26e:	39 c2                	cmp    %eax,%edx
  81e270:	7d 13                	jge    81e285 <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81e272:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e276:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e27a:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81e27d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e281:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81e285:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e289:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e28d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e291:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e295:	89 d0                	mov    %edx,%eax
  81e297:	01 c0                	add    %eax,%eax
  81e299:	01 d0                	add    %edx,%eax
  81e29b:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e29e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2a2:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e2a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2aa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e2ae:	83 c8 04             	or     $0x4,%eax
  81e2b1:	89 c2                	mov    %eax,%edx
  81e2b3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2b7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e2ba:	e9 0c 04 00 00       	jmpq   81e6cb <tcp_receive+0x68a>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e2bf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2c3:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e2c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2cb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e2cf:	01 c2                	add    %eax,%edx
  81e2d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2d5:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e2d9:	66 39 c2             	cmp    %ax,%dx
  81e2dc:	0f 86 e9 03 00 00    	jbe    81e6cb <tcp_receive+0x68a>
              pcb->cwnd += pcb->mss;
  81e2e2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2e6:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e2ea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2ee:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e2f2:	01 c2                	add    %eax,%edx
  81e2f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2f8:	66 89 50 5a          	mov    %dx,0x5a(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e2fc:	e9 17 05 00 00       	jmpq   81e818 <tcp_receive+0x7d7>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e301:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e308:	00 00 00 
  81e30b:	8b 10                	mov    (%rax),%edx
  81e30d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e311:	8b 40 54             	mov    0x54(%rax),%eax
  81e314:	29 c2                	sub    %eax,%edx
  81e316:	89 d0                	mov    %edx,%eax
  81e318:	83 e8 01             	sub    $0x1,%eax
  81e31b:	85 c0                	test   %eax,%eax
  81e31d:	0f 88 99 03 00 00    	js     81e6bc <tcp_receive+0x67b>
  81e323:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e32a:	00 00 00 
  81e32d:	8b 10                	mov    (%rax),%edx
  81e32f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e333:	8b 40 64             	mov    0x64(%rax),%eax
  81e336:	29 c2                	sub    %eax,%edx
  81e338:	89 d0                	mov    %edx,%eax
  81e33a:	85 c0                	test   %eax,%eax
  81e33c:	0f 8f 7a 03 00 00    	jg     81e6bc <tcp_receive+0x67b>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e342:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e346:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e34a:	0f b6 c0             	movzbl %al,%eax
  81e34d:	83 e0 04             	and    $0x4,%eax
  81e350:	85 c0                	test   %eax,%eax
  81e352:	74 24                	je     81e378 <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81e354:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e358:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e35c:	83 e0 fb             	and    $0xfffffffb,%eax
  81e35f:	89 c2                	mov    %eax,%edx
  81e361:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e365:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e368:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e36c:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e370:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e374:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e378:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e37c:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e380:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e384:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e388:	66 c1 f8 03          	sar    $0x3,%ax
  81e38c:	89 c2                	mov    %eax,%edx
  81e38e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e392:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e396:	01 d0                	add    %edx,%eax
  81e398:	89 c2                	mov    %eax,%edx
  81e39a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e39e:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e3a2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e3a9:	00 00 00 
  81e3ac:	8b 00                	mov    (%rax),%eax
  81e3ae:	89 c2                	mov    %eax,%edx
  81e3b0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3b4:	8b 40 54             	mov    0x54(%rax),%eax
  81e3b7:	29 c2                	sub    %eax,%edx
  81e3b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3bd:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e3c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3c5:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e3c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3cd:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e3d1:	01 c2                	add    %eax,%edx
  81e3d3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3d7:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e3db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3df:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e3e3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e3ea:	00 00 00 
  81e3ed:	8b 10                	mov    (%rax),%edx
  81e3ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3f3:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e3f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3fa:	8b 40 18             	mov    0x18(%rax),%eax
  81e3fd:	83 f8 03             	cmp    $0x3,%eax
  81e400:	0f 86 a1 00 00 00    	jbe    81e4a7 <tcp_receive+0x466>
        if (pcb->cwnd < pcb->ssthresh) {
  81e406:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e40a:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e40e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e412:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e416:	66 39 c2             	cmp    %ax,%dx
  81e419:	73 3b                	jae    81e456 <tcp_receive+0x415>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e41b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e41f:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e423:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e427:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e42b:	01 c2                	add    %eax,%edx
  81e42d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e431:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e435:	66 39 c2             	cmp    %ax,%dx
  81e438:	76 6d                	jbe    81e4a7 <tcp_receive+0x466>
            pcb->cwnd += pcb->mss;
  81e43a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e43e:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e442:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e446:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e44a:	01 c2                	add    %eax,%edx
  81e44c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e450:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e454:	eb 51                	jmp    81e4a7 <tcp_receive+0x466>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e456:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e45a:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e45e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e462:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e466:	0f b7 d0             	movzwl %ax,%edx
  81e469:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e46d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e471:	0f b7 c0             	movzwl %ax,%eax
  81e474:	0f af c2             	imul   %edx,%eax
  81e477:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e47b:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e47f:	0f b7 f2             	movzwl %dx,%esi
  81e482:	99                   	cltd   
  81e483:	f7 fe                	idiv   %esi
  81e485:	01 c8                	add    %ecx,%eax
  81e487:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e48b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e48f:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e493:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e497:	73 0e                	jae    81e4a7 <tcp_receive+0x466>
            pcb->cwnd = new_cwnd;
  81e499:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e49d:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e4a1:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e4a5:	eb 00                	jmp    81e4a7 <tcp_receive+0x466>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e4a7:	e9 11 01 00 00       	jmpq   81e5bd <tcp_receive+0x57c>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e4ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4b0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e4b7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e4bb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4bf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e4c6:	48 8b 10             	mov    (%rax),%rdx
  81e4c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4cd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e4d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4d8:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e4dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e4e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e4e4:	48 89 c7             	mov    %rax,%rdi
  81e4e7:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81e4ee:	00 00 00 
  81e4f1:	ff d0                	callq  *%rax
  81e4f3:	0f b6 c0             	movzbl %al,%eax
  81e4f6:	66 39 c3             	cmp    %ax,%bx
  81e4f9:	73 2a                	jae    81e525 <tcp_receive+0x4e4>
  81e4fb:	48 ba c8 39 82 00 00 	movabs $0x8239c8,%rdx
  81e502:	00 00 00 
  81e505:	be 55 03 00 00       	mov    $0x355,%esi
  81e50a:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81e511:	00 00 00 
  81e514:	b8 00 00 00 00       	mov    $0x0,%eax
  81e519:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81e520:	00 00 00 
  81e523:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e525:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e529:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e52d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e531:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e535:	48 89 c7             	mov    %rax,%rdi
  81e538:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81e53f:	00 00 00 
  81e542:	ff d0                	callq  *%rax
  81e544:	0f b6 c0             	movzbl %al,%eax
  81e547:	29 c3                	sub    %eax,%ebx
  81e549:	89 da                	mov    %ebx,%edx
  81e54b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e54f:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e553:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e557:	48 89 c7             	mov    %rax,%rdi
  81e55a:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81e561:	00 00 00 
  81e564:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e566:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e56a:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e56e:	66 85 c0             	test   %ax,%ax
  81e571:	74 4a                	je     81e5bd <tcp_receive+0x57c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e573:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e577:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e57e:	48 85 c0             	test   %rax,%rax
  81e581:	75 3a                	jne    81e5bd <tcp_receive+0x57c>
  81e583:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e587:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e58e:	48 85 c0             	test   %rax,%rax
  81e591:	75 2a                	jne    81e5bd <tcp_receive+0x57c>
  81e593:	48 ba f0 39 82 00 00 	movabs $0x8239f0,%rdx
  81e59a:	00 00 00 
  81e59d:	be 5c 03 00 00       	mov    $0x35c,%esi
  81e5a2:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81e5a9:	00 00 00 
  81e5ac:	b8 00 00 00 00       	mov    $0x0,%eax
  81e5b1:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81e5b8:	00 00 00 
  81e5bb:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e5bd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5c1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e5c8:	48 85 c0             	test   %rax,%rax
  81e5cb:	0f 84 bb 00 00 00    	je     81e68c <tcp_receive+0x64b>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e5d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5d5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e5dc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e5e0:	8b 40 04             	mov    0x4(%rax),%eax
  81e5e3:	89 c7                	mov    %eax,%edi
  81e5e5:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81e5ec:	00 00 00 
  81e5ef:	ff d0                	callq  *%rax
  81e5f1:	89 c3                	mov    %eax,%ebx
  81e5f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5f7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e5fe:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e602:	44 0f b7 e0          	movzwl %ax,%r12d
  81e606:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e60a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e611:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e615:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e619:	0f b7 c0             	movzwl %ax,%eax
  81e61c:	89 c7                	mov    %eax,%edi
  81e61e:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81e625:	00 00 00 
  81e628:	ff d0                	callq  *%rax
  81e62a:	0f b7 c0             	movzwl %ax,%eax
  81e62d:	83 e0 01             	and    $0x1,%eax
  81e630:	85 c0                	test   %eax,%eax
  81e632:	75 2e                	jne    81e662 <tcp_receive+0x621>
  81e634:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e638:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e63f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e643:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e647:	0f b7 c0             	movzwl %ax,%eax
  81e64a:	89 c7                	mov    %eax,%edi
  81e64c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81e653:	00 00 00 
  81e656:	ff d0                	callq  *%rax
  81e658:	0f b7 c0             	movzwl %ax,%eax
  81e65b:	83 e0 02             	and    $0x2,%eax
  81e65e:	85 c0                	test   %eax,%eax
  81e660:	74 07                	je     81e669 <tcp_receive+0x628>
  81e662:	b8 01 00 00 00       	mov    $0x1,%eax
  81e667:	eb 05                	jmp    81e66e <tcp_receive+0x62d>
  81e669:	b8 00 00 00 00       	mov    $0x0,%eax
  81e66e:	44 01 e0             	add    %r12d,%eax
  81e671:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e674:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e67b:	00 00 00 
  81e67e:	8b 00                	mov    (%rax),%eax
  81e680:	29 c2                	sub    %eax,%edx
  81e682:	89 d0                	mov    %edx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e684:	85 c0                	test   %eax,%eax
  81e686:	0f 8e 20 fe ff ff    	jle    81e4ac <tcp_receive+0x46b>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e68c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e690:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e697:	48 85 c0             	test   %rax,%rax
  81e69a:	75 0c                	jne    81e6a8 <tcp_receive+0x667>
        pcb->rtime = -1;
  81e69c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a0:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e6a6:	eb 0a                	jmp    81e6b2 <tcp_receive+0x671>
      else
        pcb->rtime = 0;
  81e6a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6ac:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e6b2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6b6:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81e6ba:	eb 0f                	jmp    81e6cb <tcp_receive+0x68a>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e6bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6c0:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e6c6:	e9 4d 01 00 00       	jmpq   81e818 <tcp_receive+0x7d7>
  81e6cb:	e9 48 01 00 00       	jmpq   81e818 <tcp_receive+0x7d7>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e6d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6d4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e6db:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e6df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6e3:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e6ea:	48 8b 10             	mov    (%rax),%rdx
  81e6ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f1:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e6f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6fc:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e700:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e704:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e708:	48 89 c7             	mov    %rax,%rdi
  81e70b:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81e712:	00 00 00 
  81e715:	ff d0                	callq  *%rax
  81e717:	0f b6 c0             	movzbl %al,%eax
  81e71a:	66 39 c3             	cmp    %ax,%bx
  81e71d:	73 2a                	jae    81e749 <tcp_receive+0x708>
  81e71f:	48 ba c8 39 82 00 00 	movabs $0x8239c8,%rdx
  81e726:	00 00 00 
  81e729:	be 7f 03 00 00       	mov    $0x37f,%esi
  81e72e:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81e735:	00 00 00 
  81e738:	b8 00 00 00 00       	mov    $0x0,%eax
  81e73d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81e744:	00 00 00 
  81e747:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e749:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e74d:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e751:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e755:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e759:	48 89 c7             	mov    %rax,%rdi
  81e75c:	48 b8 d4 dd 80 00 00 	movabs $0x80ddd4,%rax
  81e763:	00 00 00 
  81e766:	ff d0                	callq  *%rax
  81e768:	0f b6 c0             	movzbl %al,%eax
  81e76b:	29 c3                	sub    %eax,%ebx
  81e76d:	89 da                	mov    %ebx,%edx
  81e76f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e773:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81e777:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e77b:	48 89 c7             	mov    %rax,%rdi
  81e77e:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81e785:	00 00 00 
  81e788:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81e78a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e78e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e792:	66 85 c0             	test   %ax,%ax
  81e795:	74 4a                	je     81e7e1 <tcp_receive+0x7a0>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81e797:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e79b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e7a2:	48 85 c0             	test   %rax,%rax
  81e7a5:	75 3a                	jne    81e7e1 <tcp_receive+0x7a0>
  81e7a7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7ab:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e7b2:	48 85 c0             	test   %rax,%rax
  81e7b5:	75 2a                	jne    81e7e1 <tcp_receive+0x7a0>
  81e7b7:	48 ba f0 39 82 00 00 	movabs $0x8239f0,%rdx
  81e7be:	00 00 00 
  81e7c1:	be 85 03 00 00       	mov    $0x385,%esi
  81e7c6:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81e7cd:	00 00 00 
  81e7d0:	b8 00 00 00 00       	mov    $0x0,%eax
  81e7d5:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81e7dc:	00 00 00 
  81e7df:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81e7e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7e5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e7ec:	48 85 c0             	test   %rax,%rax
  81e7ef:	74 27                	je     81e818 <tcp_receive+0x7d7>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81e7f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7f5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e7fc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e800:	8b 40 04             	mov    0x4(%rax),%eax
  81e803:	89 c7                	mov    %eax,%edi
  81e805:	48 b8 33 2f 81 00 00 	movabs $0x812f33,%rax
  81e80c:	00 00 00 
  81e80f:	ff d0                	callq  *%rax
  81e811:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e815:	89 42 60             	mov    %eax,0x60(%rdx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e818:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e81c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e823:	48 85 c0             	test   %rax,%rax
  81e826:	0f 84 d8 00 00 00    	je     81e904 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e82c:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e833:	00 00 00 
  81e836:	44 8b 20             	mov    (%rax),%r12d
  81e839:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e83d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e844:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e848:	8b 40 04             	mov    0x4(%rax),%eax
  81e84b:	89 c7                	mov    %eax,%edi
  81e84d:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  81e854:	00 00 00 
  81e857:	ff d0                	callq  *%rax
  81e859:	89 c3                	mov    %eax,%ebx
  81e85b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e85f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e866:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e86a:	44 0f b7 e8          	movzwl %ax,%r13d
  81e86e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e872:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e879:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e87d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e881:	0f b7 c0             	movzwl %ax,%eax
  81e884:	89 c7                	mov    %eax,%edi
  81e886:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81e88d:	00 00 00 
  81e890:	ff d0                	callq  *%rax
  81e892:	0f b7 c0             	movzwl %ax,%eax
  81e895:	83 e0 01             	and    $0x1,%eax
  81e898:	85 c0                	test   %eax,%eax
  81e89a:	75 2e                	jne    81e8ca <tcp_receive+0x889>
  81e89c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8a0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e8a7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e8ab:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e8af:	0f b7 c0             	movzwl %ax,%eax
  81e8b2:	89 c7                	mov    %eax,%edi
  81e8b4:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81e8bb:	00 00 00 
  81e8be:	ff d0                	callq  *%rax
  81e8c0:	0f b7 c0             	movzwl %ax,%eax
  81e8c3:	83 e0 02             	and    $0x2,%eax
  81e8c6:	85 c0                	test   %eax,%eax
  81e8c8:	74 07                	je     81e8d1 <tcp_receive+0x890>
  81e8ca:	b8 01 00 00 00       	mov    $0x1,%eax
  81e8cf:	eb 05                	jmp    81e8d6 <tcp_receive+0x895>
  81e8d1:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8d6:	44 01 e8             	add    %r13d,%eax
  81e8d9:	01 d8                	add    %ebx,%eax
  81e8db:	41 29 c4             	sub    %eax,%r12d
  81e8de:	44 89 e0             	mov    %r12d,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e8e1:	85 c0                	test   %eax,%eax
  81e8e3:	78 1f                	js     81e904 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e8e5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e8ec:	00 00 00 
  81e8ef:	8b 10                	mov    (%rax),%edx
  81e8f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8f5:	8b 40 64             	mov    0x64(%rax),%eax
  81e8f8:	29 c2                	sub    %eax,%edx
  81e8fa:	89 d0                	mov    %edx,%eax
  81e8fc:	85 c0                	test   %eax,%eax
  81e8fe:	0f 8e cc fd ff ff    	jle    81e6d0 <tcp_receive+0x68f>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81e904:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e908:	8b 40 44             	mov    0x44(%rax),%eax
  81e90b:	85 c0                	test   %eax,%eax
  81e90d:	0f 84 de 00 00 00    	je     81e9f1 <tcp_receive+0x9b0>
  81e913:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e917:	8b 50 48             	mov    0x48(%rax),%edx
  81e91a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e921:	00 00 00 
  81e924:	8b 00                	mov    (%rax),%eax
  81e926:	29 c2                	sub    %eax,%edx
  81e928:	89 d0                	mov    %edx,%eax
  81e92a:	85 c0                	test   %eax,%eax
  81e92c:	0f 89 bf 00 00 00    	jns    81e9f1 <tcp_receive+0x9b0>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81e932:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81e939:	00 00 00 
  81e93c:	8b 00                	mov    (%rax),%eax
  81e93e:	89 c2                	mov    %eax,%edx
  81e940:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e944:	8b 40 44             	mov    0x44(%rax),%eax
  81e947:	29 c2                	sub    %eax,%edx
  81e949:	89 d0                	mov    %edx,%eax
  81e94b:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81e94f:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e953:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e957:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e95b:	66 c1 f8 03          	sar    $0x3,%ax
  81e95f:	29 c2                	sub    %eax,%edx
  81e961:	89 d0                	mov    %edx,%eax
  81e963:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81e967:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e96b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e96f:	89 c2                	mov    %eax,%edx
  81e971:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e975:	01 d0                	add    %edx,%eax
  81e977:	89 c2                	mov    %eax,%edx
  81e979:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e97d:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81e981:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81e986:	79 0a                	jns    81e992 <tcp_receive+0x951>
        m = -m;
  81e988:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e98c:	f7 d8                	neg    %eax
  81e98e:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81e992:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e996:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e99a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e99e:	66 c1 f8 02          	sar    $0x2,%ax
  81e9a2:	29 c2                	sub    %eax,%edx
  81e9a4:	89 d0                	mov    %edx,%eax
  81e9a6:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81e9aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9ae:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e9b2:	89 c2                	mov    %eax,%edx
  81e9b4:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e9b8:	01 d0                	add    %edx,%eax
  81e9ba:	89 c2                	mov    %eax,%edx
  81e9bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9c0:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e9c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9c8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e9cc:	66 c1 f8 03          	sar    $0x3,%ax
  81e9d0:	89 c2                	mov    %eax,%edx
  81e9d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9d6:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e9da:	01 d0                	add    %edx,%eax
  81e9dc:	89 c2                	mov    %eax,%edx
  81e9de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9e2:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81e9e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9ea:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81e9f1:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81e9f8:	00 00 00 
  81e9fb:	0f b7 00             	movzwl (%rax),%eax
  81e9fe:	66 85 c0             	test   %ax,%ax
  81ea01:	0f 84 26 10 00 00    	je     81fa2d <tcp_receive+0x19ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81ea07:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea0b:	8b 50 30             	mov    0x30(%rax),%edx
  81ea0e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ea15:	00 00 00 
  81ea18:	8b 00                	mov    (%rax),%eax
  81ea1a:	29 c2                	sub    %eax,%edx
  81ea1c:	89 d0                	mov    %edx,%eax
  81ea1e:	83 e8 01             	sub    $0x1,%eax
  81ea21:	85 c0                	test   %eax,%eax
  81ea23:	0f 88 af 02 00 00    	js     81ecd8 <tcp_receive+0xc97>
  81ea29:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea2d:	8b 50 30             	mov    0x30(%rax),%edx
  81ea30:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ea37:	00 00 00 
  81ea3a:	0f b7 00             	movzwl (%rax),%eax
  81ea3d:	0f b7 c8             	movzwl %ax,%ecx
  81ea40:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ea47:	00 00 00 
  81ea4a:	8b 00                	mov    (%rax),%eax
  81ea4c:	01 c8                	add    %ecx,%eax
  81ea4e:	29 c2                	sub    %eax,%edx
  81ea50:	89 d0                	mov    %edx,%eax
  81ea52:	83 c0 01             	add    $0x1,%eax
  81ea55:	85 c0                	test   %eax,%eax
  81ea57:	0f 8f 7b 02 00 00    	jg     81ecd8 <tcp_receive+0xc97>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81ea5d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea61:	8b 50 30             	mov    0x30(%rax),%edx
  81ea64:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ea6b:	00 00 00 
  81ea6e:	8b 00                	mov    (%rax),%eax
  81ea70:	29 c2                	sub    %eax,%edx
  81ea72:	89 d0                	mov    %edx,%eax
  81ea74:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81ea77:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea7e:	00 00 00 
  81ea81:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea85:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81ea89:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea90:	00 00 00 
  81ea93:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea97:	48 85 c0             	test   %rax,%rax
  81ea9a:	75 2a                	jne    81eac6 <tcp_receive+0xa85>
  81ea9c:	48 ba 10 3a 82 00 00 	movabs $0x823a10,%rdx
  81eaa3:	00 00 00 
  81eaa6:	be e5 03 00 00       	mov    $0x3e5,%esi
  81eaab:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81eab2:	00 00 00 
  81eab5:	b8 00 00 00 00       	mov    $0x0,%eax
  81eaba:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81eac1:	00 00 00 
  81eac4:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81eac6:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81eacd:	7e 2a                	jle    81eaf9 <tcp_receive+0xab8>
  81eacf:	48 ba 20 3a 82 00 00 	movabs $0x823a20,%rdx
  81ead6:	00 00 00 
  81ead9:	be e6 03 00 00       	mov    $0x3e6,%esi
  81eade:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81eae5:	00 00 00 
  81eae8:	b8 00 00 00 00       	mov    $0x0,%eax
  81eaed:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81eaf4:	00 00 00 
  81eaf7:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81eaf9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eb00:	00 00 00 
  81eb03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eb07:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81eb0b:	0f b7 c0             	movzwl %ax,%eax
  81eb0e:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81eb11:	0f 8d ed 00 00 00    	jge    81ec04 <tcp_receive+0xbc3>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81eb17:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eb1e:	00 00 00 
  81eb21:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eb25:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81eb29:	0f b7 c0             	movzwl %ax,%eax
  81eb2c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81eb2f:	7d 2a                	jge    81eb5b <tcp_receive+0xb1a>
  81eb31:	48 ba 2f 3a 82 00 00 	movabs $0x823a2f,%rdx
  81eb38:	00 00 00 
  81eb3b:	be e8 03 00 00       	mov    $0x3e8,%esi
  81eb40:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81eb47:	00 00 00 
  81eb4a:	b8 00 00 00 00       	mov    $0x0,%eax
  81eb4f:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81eb56:	00 00 00 
  81eb59:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81eb5b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eb62:	00 00 00 
  81eb65:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eb69:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81eb6d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81eb70:	29 c2                	sub    %eax,%edx
  81eb72:	89 d0                	mov    %edx,%eax
  81eb74:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81eb78:	eb 2f                	jmp    81eba9 <tcp_receive+0xb68>
          off -= p->len;
  81eb7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eb7e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81eb82:	0f b7 c0             	movzwl %ax,%eax
  81eb85:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81eb88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eb8c:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81eb90:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81eb94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eb98:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81eb9e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eba2:	48 8b 00             	mov    (%rax),%rax
  81eba5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81eba9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ebad:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ebb1:	0f b7 c0             	movzwl %ax,%eax
  81ebb4:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ebb7:	7c c1                	jl     81eb7a <tcp_receive+0xb39>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81ebb9:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ebbc:	f7 d8                	neg    %eax
  81ebbe:	0f bf d0             	movswl %ax,%edx
  81ebc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ebc5:	89 d6                	mov    %edx,%esi
  81ebc7:	48 89 c7             	mov    %rax,%rdi
  81ebca:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81ebd1:	00 00 00 
  81ebd4:	ff d0                	callq  *%rax
  81ebd6:	84 c0                	test   %al,%al
  81ebd8:	74 7f                	je     81ec59 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ebda:	48 ba 3f 3a 82 00 00 	movabs $0x823a3f,%rdx
  81ebe1:	00 00 00 
  81ebe4:	be f5 03 00 00       	mov    $0x3f5,%esi
  81ebe9:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81ebf0:	00 00 00 
  81ebf3:	b8 00 00 00 00       	mov    $0x0,%eax
  81ebf8:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81ebff:	00 00 00 
  81ec02:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81ec04:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ec07:	f7 d8                	neg    %eax
  81ec09:	0f bf d0             	movswl %ax,%edx
  81ec0c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec13:	00 00 00 
  81ec16:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec1a:	89 d6                	mov    %edx,%esi
  81ec1c:	48 89 c7             	mov    %rax,%rdi
  81ec1f:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81ec26:	00 00 00 
  81ec29:	ff d0                	callq  *%rax
  81ec2b:	84 c0                	test   %al,%al
  81ec2d:	74 2a                	je     81ec59 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ec2f:	48 ba 3f 3a 82 00 00 	movabs $0x823a3f,%rdx
  81ec36:	00 00 00 
  81ec39:	be fa 03 00 00       	mov    $0x3fa,%esi
  81ec3e:	48 bf 27 38 82 00 00 	movabs $0x823827,%rdi
  81ec45:	00 00 00 
  81ec48:	b8 00 00 00 00       	mov    $0x0,%eax
  81ec4d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81ec54:	00 00 00 
  81ec57:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81ec59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ec5d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ec61:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec68:	00 00 00 
  81ec6b:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81ec6f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec76:	00 00 00 
  81ec79:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81ec7d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ec84:	00 00 00 
  81ec87:	8b 00                	mov    (%rax),%eax
  81ec89:	89 c1                	mov    %eax,%ecx
  81ec8b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec8f:	8b 40 30             	mov    0x30(%rax),%eax
  81ec92:	29 c1                	sub    %eax,%ecx
  81ec94:	89 c8                	mov    %ecx,%eax
  81ec96:	01 c2                	add    %eax,%edx
  81ec98:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec9f:	00 00 00 
  81eca2:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81eca6:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ecad:	00 00 00 
  81ecb0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ecb4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81ecb8:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81ecbb:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81ecc2:	00 00 00 
  81ecc5:	89 0a                	mov    %ecx,(%rdx)
  81ecc7:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81ecce:	00 00 00 
  81ecd1:	8b 12                	mov    (%rdx),%edx
  81ecd3:	89 50 04             	mov    %edx,0x4(%rax)
  81ecd6:	eb 42                	jmp    81ed1a <tcp_receive+0xcd9>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81ecd8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ecdf:	00 00 00 
  81ece2:	8b 10                	mov    (%rax),%edx
  81ece4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ece8:	8b 40 30             	mov    0x30(%rax),%eax
  81eceb:	29 c2                	sub    %eax,%edx
  81eced:	89 d0                	mov    %edx,%eax
  81ecef:	85 c0                	test   %eax,%eax
  81ecf1:	79 27                	jns    81ed1a <tcp_receive+0xcd9>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81ecf3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecf7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ecfb:	83 c8 02             	or     $0x2,%eax
  81ecfe:	89 c2                	mov    %eax,%edx
  81ed00:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed04:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ed07:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed0b:	48 89 c7             	mov    %rax,%rdi
  81ed0e:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81ed15:	00 00 00 
  81ed18:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81ed1a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed21:	00 00 00 
  81ed24:	8b 10                	mov    (%rax),%edx
  81ed26:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed2a:	8b 40 30             	mov    0x30(%rax),%eax
  81ed2d:	29 c2                	sub    %eax,%edx
  81ed2f:	89 d0                	mov    %edx,%eax
  81ed31:	85 c0                	test   %eax,%eax
  81ed33:	0f 88 c9 0c 00 00    	js     81fa02 <tcp_receive+0x19c1>
  81ed39:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed40:	00 00 00 
  81ed43:	8b 10                	mov    (%rax),%edx
  81ed45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed49:	8b 48 30             	mov    0x30(%rax),%ecx
  81ed4c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed50:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81ed54:	0f b7 c0             	movzwl %ax,%eax
  81ed57:	01 c8                	add    %ecx,%eax
  81ed59:	29 c2                	sub    %eax,%edx
  81ed5b:	89 d0                	mov    %edx,%eax
  81ed5d:	83 c0 01             	add    $0x1,%eax
  81ed60:	85 c0                	test   %eax,%eax
  81ed62:	0f 8f 9a 0c 00 00    	jg     81fa02 <tcp_receive+0x19c1>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81ed68:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed6c:	8b 50 30             	mov    0x30(%rax),%edx
  81ed6f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed76:	00 00 00 
  81ed79:	8b 00                	mov    (%rax),%eax
  81ed7b:	39 c2                	cmp    %eax,%edx
  81ed7d:	0f 85 42 07 00 00    	jne    81f4c5 <tcp_receive+0x1484>
        accepted_inseq = 1; 
  81ed83:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81ed87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed8b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ed92:	48 85 c0             	test   %rax,%rax
  81ed95:	0f 84 4c 01 00 00    	je     81eee7 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81ed9b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed9f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eda6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81edaa:	8b 50 04             	mov    0x4(%rax),%edx
  81edad:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edb4:	00 00 00 
  81edb7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81edbb:	0f b7 c8             	movzwl %ax,%ecx
  81edbe:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81edc5:	00 00 00 
  81edc8:	8b 00                	mov    (%rax),%eax
  81edca:	01 c8                	add    %ecx,%eax
  81edcc:	29 c2                	sub    %eax,%edx
  81edce:	89 d0                	mov    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81edd0:	85 c0                	test   %eax,%eax
  81edd2:	0f 8f 0f 01 00 00    	jg     81eee7 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81edd8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eddc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ede3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ede7:	66 85 c0             	test   %ax,%ax
  81edea:	74 65                	je     81ee51 <tcp_receive+0xe10>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81edec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edf0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81edf7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81edfb:	8b 40 04             	mov    0x4(%rax),%eax
  81edfe:	89 c2                	mov    %eax,%edx
  81ee00:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ee07:	00 00 00 
  81ee0a:	8b 00                	mov    (%rax),%eax
  81ee0c:	29 c2                	sub    %eax,%edx
  81ee0e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee15:	00 00 00 
  81ee18:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81ee1c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee23:	00 00 00 
  81ee26:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ee2a:	0f b7 d0             	movzwl %ax,%edx
  81ee2d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee34:	00 00 00 
  81ee37:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee3b:	89 d6                	mov    %edx,%esi
  81ee3d:	48 89 c7             	mov    %rax,%rdi
  81ee40:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81ee47:	00 00 00 
  81ee4a:	ff d0                	callq  *%rax
  81ee4c:	e9 96 00 00 00       	jmpq   81eee7 <tcp_receive+0xea6>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ee51:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee58:	00 00 00 
  81ee5b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee5f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee63:	0f b7 c0             	movzwl %ax,%eax
  81ee66:	89 c7                	mov    %eax,%edi
  81ee68:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81ee6f:	00 00 00 
  81ee72:	ff d0                	callq  *%rax
  81ee74:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81ee77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee7b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ee82:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee86:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee8a:	0f b7 c0             	movzwl %ax,%eax
  81ee8d:	89 c7                	mov    %eax,%edi
  81ee8f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81ee96:	00 00 00 
  81ee99:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ee9b:	0f b7 c0             	movzwl %ax,%eax
  81ee9e:	31 d8                	xor    %ebx,%eax
  81eea0:	83 e0 03             	and    $0x3,%eax
  81eea3:	85 c0                	test   %eax,%eax
  81eea5:	75 40                	jne    81eee7 <tcp_receive+0xea6>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81eea7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eeab:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eeb2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81eeb6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eeba:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eec1:	48 8b 10             	mov    (%rax),%rdx
  81eec4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eec8:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81eecf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81eed3:	48 89 c6             	mov    %rax,%rsi
  81eed6:	bf 04 00 00 00       	mov    $0x4,%edi
  81eedb:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  81eee2:	00 00 00 
  81eee5:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81eee7:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eeee:	00 00 00 
  81eef1:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81eef5:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eefc:	00 00 00 
  81eeff:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef03:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef07:	0f b7 c0             	movzwl %ax,%eax
  81ef0a:	89 c7                	mov    %eax,%edi
  81ef0c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81ef13:	00 00 00 
  81ef16:	ff d0                	callq  *%rax
  81ef18:	0f b7 c0             	movzwl %ax,%eax
  81ef1b:	83 e0 01             	and    $0x1,%eax
  81ef1e:	85 c0                	test   %eax,%eax
  81ef20:	75 2d                	jne    81ef4f <tcp_receive+0xf0e>
  81ef22:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef29:	00 00 00 
  81ef2c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef30:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef34:	0f b7 c0             	movzwl %ax,%eax
  81ef37:	89 c7                	mov    %eax,%edi
  81ef39:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81ef40:	00 00 00 
  81ef43:	ff d0                	callq  *%rax
  81ef45:	0f b7 c0             	movzwl %ax,%eax
  81ef48:	83 e0 02             	and    $0x2,%eax
  81ef4b:	85 c0                	test   %eax,%eax
  81ef4d:	74 07                	je     81ef56 <tcp_receive+0xf15>
  81ef4f:	b8 01 00 00 00       	mov    $0x1,%eax
  81ef54:	eb 05                	jmp    81ef5b <tcp_receive+0xf1a>
  81ef56:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef5b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81ef5e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ef65:	00 00 00 
  81ef68:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81ef6b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef6f:	8b 40 18             	mov    0x18(%rax),%eax
  81ef72:	83 f8 07             	cmp    $0x7,%eax
  81ef75:	74 20                	je     81ef97 <tcp_receive+0xf56>
          pcb->rcv_nxt += tcplen;
  81ef77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef7b:	8b 50 30             	mov    0x30(%rax),%edx
  81ef7e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ef85:	00 00 00 
  81ef88:	0f b7 00             	movzwl (%rax),%eax
  81ef8b:	0f b7 c0             	movzwl %ax,%eax
  81ef8e:	01 c2                	add    %eax,%edx
  81ef90:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef94:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81ef97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef9b:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81ef9f:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81efa6:	00 00 00 
  81efa9:	0f b7 00             	movzwl (%rax),%eax
  81efac:	66 39 c2             	cmp    %ax,%dx
  81efaf:	73 0c                	jae    81efbd <tcp_receive+0xf7c>
          pcb->rcv_wnd = 0;
  81efb1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efb5:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81efbb:	eb 1f                	jmp    81efdc <tcp_receive+0xf9b>
        } else {
          pcb->rcv_wnd -= tcplen;
  81efbd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efc1:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81efc5:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81efcc:	00 00 00 
  81efcf:	0f b7 00             	movzwl (%rax),%eax
  81efd2:	29 c2                	sub    %eax,%edx
  81efd4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efd8:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81efdc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efe0:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81efe4:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81efeb:	00 00 00 
  81efee:	0f b7 00             	movzwl (%rax),%eax
  81eff1:	66 39 c2             	cmp    %ax,%dx
  81eff4:	73 0c                	jae    81f002 <tcp_receive+0xfc1>
          pcb->rcv_ann_wnd = 0;
  81eff6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81effa:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f000:	eb 1f                	jmp    81f021 <tcp_receive+0xfe0>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81f002:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f006:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f00a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f011:	00 00 00 
  81f014:	0f b7 00             	movzwl (%rax),%eax
  81f017:	29 c2                	sub    %eax,%edx
  81f019:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f01d:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81f021:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f028:	00 00 00 
  81f02b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f02f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f033:	66 85 c0             	test   %ax,%ax
  81f036:	74 2d                	je     81f065 <tcp_receive+0x1024>
          recv_data = inseg.p;
  81f038:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f03f:	00 00 00 
  81f042:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f046:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f04d:	00 00 00 
  81f050:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81f053:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f05a:	00 00 00 
  81f05d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f064:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81f065:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f06c:	00 00 00 
  81f06f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f073:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f077:	0f b7 c0             	movzwl %ax,%eax
  81f07a:	89 c7                	mov    %eax,%edi
  81f07c:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f083:	00 00 00 
  81f086:	ff d0                	callq  *%rax
  81f088:	0f b7 c0             	movzwl %ax,%eax
  81f08b:	83 e0 01             	and    $0x1,%eax
  81f08e:	85 c0                	test   %eax,%eax
  81f090:	74 12                	je     81f0a4 <tcp_receive+0x1063>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81f092:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f099:	00 00 00 
  81f09c:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f09f:	e9 85 03 00 00       	jmpq   81f429 <tcp_receive+0x13e8>
  81f0a4:	e9 80 03 00 00       	jmpq   81f429 <tcp_receive+0x13e8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81f0a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0ad:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0b4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81f0b8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0bc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0c3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0c7:	8b 50 04             	mov    0x4(%rax),%edx
  81f0ca:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f0d1:	00 00 00 
  81f0d4:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81f0d6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0da:	8b 58 30             	mov    0x30(%rax),%ebx
  81f0dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0e1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f0e5:	44 0f b7 e0          	movzwl %ax,%r12d
  81f0e9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0ed:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0f1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f0f5:	0f b7 c0             	movzwl %ax,%eax
  81f0f8:	89 c7                	mov    %eax,%edi
  81f0fa:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f101:	00 00 00 
  81f104:	ff d0                	callq  *%rax
  81f106:	0f b7 c0             	movzwl %ax,%eax
  81f109:	83 e0 01             	and    $0x1,%eax
  81f10c:	85 c0                	test   %eax,%eax
  81f10e:	75 27                	jne    81f137 <tcp_receive+0x10f6>
  81f110:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f114:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f118:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f11c:	0f b7 c0             	movzwl %ax,%eax
  81f11f:	89 c7                	mov    %eax,%edi
  81f121:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f128:	00 00 00 
  81f12b:	ff d0                	callq  *%rax
  81f12d:	0f b7 c0             	movzwl %ax,%eax
  81f130:	83 e0 02             	and    $0x2,%eax
  81f133:	85 c0                	test   %eax,%eax
  81f135:	74 07                	je     81f13e <tcp_receive+0x10fd>
  81f137:	b8 01 00 00 00       	mov    $0x1,%eax
  81f13c:	eb 05                	jmp    81f143 <tcp_receive+0x1102>
  81f13e:	b8 00 00 00 00       	mov    $0x0,%eax
  81f143:	44 01 e0             	add    %r12d,%eax
  81f146:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f149:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f14d:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81f150:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f154:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f158:	0f b7 d8             	movzwl %ax,%ebx
  81f15b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f15f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f163:	44 0f b7 e0          	movzwl %ax,%r12d
  81f167:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f16b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f16f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f173:	0f b7 c0             	movzwl %ax,%eax
  81f176:	89 c7                	mov    %eax,%edi
  81f178:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f17f:	00 00 00 
  81f182:	ff d0                	callq  *%rax
  81f184:	0f b7 c0             	movzwl %ax,%eax
  81f187:	83 e0 01             	and    $0x1,%eax
  81f18a:	85 c0                	test   %eax,%eax
  81f18c:	75 27                	jne    81f1b5 <tcp_receive+0x1174>
  81f18e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f192:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f196:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f19a:	0f b7 c0             	movzwl %ax,%eax
  81f19d:	89 c7                	mov    %eax,%edi
  81f19f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f1a6:	00 00 00 
  81f1a9:	ff d0                	callq  *%rax
  81f1ab:	0f b7 c0             	movzwl %ax,%eax
  81f1ae:	83 e0 02             	and    $0x2,%eax
  81f1b1:	85 c0                	test   %eax,%eax
  81f1b3:	74 07                	je     81f1bc <tcp_receive+0x117b>
  81f1b5:	b8 01 00 00 00       	mov    $0x1,%eax
  81f1ba:	eb 05                	jmp    81f1c1 <tcp_receive+0x1180>
  81f1bc:	b8 00 00 00 00       	mov    $0x0,%eax
  81f1c1:	44 01 e0             	add    %r12d,%eax
  81f1c4:	39 c3                	cmp    %eax,%ebx
  81f1c6:	7d 0c                	jge    81f1d4 <tcp_receive+0x1193>
            pcb->rcv_wnd = 0;
  81f1c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1cc:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f1d2:	eb 7a                	jmp    81f24e <tcp_receive+0x120d>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81f1d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1d8:	0f b7 58 34          	movzwl 0x34(%rax),%ebx
  81f1dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1e0:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f1e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1e9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1ed:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f1f1:	0f b7 c0             	movzwl %ax,%eax
  81f1f4:	89 c7                	mov    %eax,%edi
  81f1f6:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f1fd:	00 00 00 
  81f200:	ff d0                	callq  *%rax
  81f202:	0f b7 c0             	movzwl %ax,%eax
  81f205:	83 e0 01             	and    $0x1,%eax
  81f208:	85 c0                	test   %eax,%eax
  81f20a:	75 27                	jne    81f233 <tcp_receive+0x11f2>
  81f20c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f210:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f214:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f218:	0f b7 c0             	movzwl %ax,%eax
  81f21b:	89 c7                	mov    %eax,%edi
  81f21d:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f224:	00 00 00 
  81f227:	ff d0                	callq  *%rax
  81f229:	0f b7 c0             	movzwl %ax,%eax
  81f22c:	83 e0 02             	and    $0x2,%eax
  81f22f:	85 c0                	test   %eax,%eax
  81f231:	74 07                	je     81f23a <tcp_receive+0x11f9>
  81f233:	b8 01 00 00 00       	mov    $0x1,%eax
  81f238:	eb 05                	jmp    81f23f <tcp_receive+0x11fe>
  81f23a:	b8 00 00 00 00       	mov    $0x0,%eax
  81f23f:	44 01 e0             	add    %r12d,%eax
  81f242:	29 c3                	sub    %eax,%ebx
  81f244:	89 da                	mov    %ebx,%edx
  81f246:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f24a:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81f24e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f252:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f256:	0f b7 d8             	movzwl %ax,%ebx
  81f259:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f25d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f261:	44 0f b7 e0          	movzwl %ax,%r12d
  81f265:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f269:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f26d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f271:	0f b7 c0             	movzwl %ax,%eax
  81f274:	89 c7                	mov    %eax,%edi
  81f276:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f27d:	00 00 00 
  81f280:	ff d0                	callq  *%rax
  81f282:	0f b7 c0             	movzwl %ax,%eax
  81f285:	83 e0 01             	and    $0x1,%eax
  81f288:	85 c0                	test   %eax,%eax
  81f28a:	75 27                	jne    81f2b3 <tcp_receive+0x1272>
  81f28c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f290:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f294:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f298:	0f b7 c0             	movzwl %ax,%eax
  81f29b:	89 c7                	mov    %eax,%edi
  81f29d:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f2a4:	00 00 00 
  81f2a7:	ff d0                	callq  *%rax
  81f2a9:	0f b7 c0             	movzwl %ax,%eax
  81f2ac:	83 e0 02             	and    $0x2,%eax
  81f2af:	85 c0                	test   %eax,%eax
  81f2b1:	74 07                	je     81f2ba <tcp_receive+0x1279>
  81f2b3:	b8 01 00 00 00       	mov    $0x1,%eax
  81f2b8:	eb 05                	jmp    81f2bf <tcp_receive+0x127e>
  81f2ba:	b8 00 00 00 00       	mov    $0x0,%eax
  81f2bf:	44 01 e0             	add    %r12d,%eax
  81f2c2:	39 c3                	cmp    %eax,%ebx
  81f2c4:	7d 0c                	jge    81f2d2 <tcp_receive+0x1291>
            pcb->rcv_ann_wnd = 0;
  81f2c6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2ca:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f2d0:	eb 7a                	jmp    81f34c <tcp_receive+0x130b>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f2d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2d6:	0f b7 58 36          	movzwl 0x36(%rax),%ebx
  81f2da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f2de:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f2e3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f2e7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f2eb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f2ef:	0f b7 c0             	movzwl %ax,%eax
  81f2f2:	89 c7                	mov    %eax,%edi
  81f2f4:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f2fb:	00 00 00 
  81f2fe:	ff d0                	callq  *%rax
  81f300:	0f b7 c0             	movzwl %ax,%eax
  81f303:	83 e0 01             	and    $0x1,%eax
  81f306:	85 c0                	test   %eax,%eax
  81f308:	75 27                	jne    81f331 <tcp_receive+0x12f0>
  81f30a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f30e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f312:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f316:	0f b7 c0             	movzwl %ax,%eax
  81f319:	89 c7                	mov    %eax,%edi
  81f31b:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f322:	00 00 00 
  81f325:	ff d0                	callq  *%rax
  81f327:	0f b7 c0             	movzwl %ax,%eax
  81f32a:	83 e0 02             	and    $0x2,%eax
  81f32d:	85 c0                	test   %eax,%eax
  81f32f:	74 07                	je     81f338 <tcp_receive+0x12f7>
  81f331:	b8 01 00 00 00       	mov    $0x1,%eax
  81f336:	eb 05                	jmp    81f33d <tcp_receive+0x12fc>
  81f338:	b8 00 00 00 00       	mov    $0x0,%eax
  81f33d:	44 01 e0             	add    %r12d,%eax
  81f340:	29 c3                	sub    %eax,%ebx
  81f342:	89 da                	mov    %ebx,%edx
  81f344:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f348:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f34c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f350:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f354:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f358:	66 85 c0             	test   %ax,%ax
  81f35b:	74 5c                	je     81f3b9 <tcp_receive+0x1378>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f35d:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f364:	00 00 00 
  81f367:	48 8b 00             	mov    (%rax),%rax
  81f36a:	48 85 c0             	test   %rax,%rax
  81f36d:	74 29                	je     81f398 <tcp_receive+0x1357>
              pbuf_cat(recv_data, cseg->p);
  81f36f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f373:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f377:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f37e:	00 00 00 
  81f381:	48 8b 00             	mov    (%rax),%rax
  81f384:	48 89 d6             	mov    %rdx,%rsi
  81f387:	48 89 c7             	mov    %rax,%rdi
  81f38a:	48 b8 2a de 80 00 00 	movabs $0x80de2a,%rax
  81f391:	00 00 00 
  81f394:	ff d0                	callq  *%rax
  81f396:	eb 15                	jmp    81f3ad <tcp_receive+0x136c>
            } else {
              recv_data = cseg->p;
  81f398:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f39c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f3a0:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f3a7:	00 00 00 
  81f3aa:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f3ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3b1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f3b8:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f3b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3bd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3c1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f3c5:	0f b7 c0             	movzwl %ax,%eax
  81f3c8:	89 c7                	mov    %eax,%edi
  81f3ca:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81f3d1:	00 00 00 
  81f3d4:	ff d0                	callq  *%rax
  81f3d6:	0f b7 c0             	movzwl %ax,%eax
  81f3d9:	83 e0 01             	and    $0x1,%eax
  81f3dc:	85 c0                	test   %eax,%eax
  81f3de:	74 24                	je     81f404 <tcp_receive+0x13c3>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f3e0:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f3e7:	00 00 00 
  81f3ea:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f3ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3f1:	8b 40 18             	mov    0x18(%rax),%eax
  81f3f4:	83 f8 04             	cmp    $0x4,%eax
  81f3f7:	75 0b                	jne    81f404 <tcp_receive+0x13c3>
              pcb->state = CLOSE_WAIT;
  81f3f9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3fd:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f404:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f408:	48 8b 10             	mov    (%rax),%rdx
  81f40b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f40f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f416:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f41a:	48 89 c7             	mov    %rax,%rdi
  81f41d:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81f424:	00 00 00 
  81f427:	ff d0                	callq  *%rax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f429:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f42d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f434:	48 85 c0             	test   %rax,%rax
  81f437:	74 21                	je     81f45a <tcp_receive+0x1419>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f439:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f43d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f444:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f448:	8b 50 04             	mov    0x4(%rax),%edx
  81f44b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f44f:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f452:	39 c2                	cmp    %eax,%edx
  81f454:	0f 84 4f fc ff ff    	je     81f0a9 <tcp_receive+0x1068>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f45a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f45e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f462:	0f b6 c0             	movzbl %al,%eax
  81f465:	83 e0 01             	and    $0x1,%eax
  81f468:	85 c0                	test   %eax,%eax
  81f46a:	74 40                	je     81f4ac <tcp_receive+0x146b>
  81f46c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f470:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f474:	83 e0 fe             	and    $0xfffffffe,%eax
  81f477:	89 c2                	mov    %eax,%edx
  81f479:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f47d:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f480:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f484:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f488:	83 c8 02             	or     $0x2,%eax
  81f48b:	89 c2                	mov    %eax,%edx
  81f48d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f491:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f494:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f498:	48 89 c7             	mov    %rax,%rdi
  81f49b:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81f4a2:	00 00 00 
  81f4a5:	ff d0                	callq  *%rax
  81f4a7:	e9 54 05 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
  81f4ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4b0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f4b4:	83 c8 01             	or     $0x1,%eax
  81f4b7:	89 c2                	mov    %eax,%edx
  81f4b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4bd:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f4c0:	e9 66 05 00 00       	jmpq   81fa2b <tcp_receive+0x19ea>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f4c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4c9:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f4cd:	83 c8 02             	or     $0x2,%eax
  81f4d0:	89 c2                	mov    %eax,%edx
  81f4d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4d6:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f4d9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4dd:	48 89 c7             	mov    %rax,%rdi
  81f4e0:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81f4e7:	00 00 00 
  81f4ea:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f4ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4f0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f4f7:	48 85 c0             	test   %rax,%rax
  81f4fa:	75 26                	jne    81f522 <tcp_receive+0x14e1>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f4fc:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f503:	00 00 00 
  81f506:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81f50d:	00 00 00 
  81f510:	ff d0                	callq  *%rax
  81f512:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81f516:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
  81f51d:	e9 de 04 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f522:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f529:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f52a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f52e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f535:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f539:	e9 b7 04 00 00       	jmpq   81f9f5 <tcp_receive+0x19b4>
            if (seqno == next->tcphdr->seqno) {
  81f53e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f542:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f546:	8b 50 04             	mov    0x4(%rax),%edx
  81f549:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f550:	00 00 00 
  81f553:	8b 00                	mov    (%rax),%eax
  81f555:	39 c2                	cmp    %eax,%edx
  81f557:	0f 85 25 01 00 00    	jne    81f682 <tcp_receive+0x1641>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f55d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f564:	00 00 00 
  81f567:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f56b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f56f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f573:	66 39 c2             	cmp    %ax,%dx
  81f576:	0f 86 01 01 00 00    	jbe    81f67d <tcp_receive+0x163c>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f57c:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f583:	00 00 00 
  81f586:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81f58d:	00 00 00 
  81f590:	ff d0                	callq  *%rax
  81f592:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f596:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f59b:	0f 84 d7 00 00 00    	je     81f678 <tcp_receive+0x1637>
                  cseg->next = next->next;
  81f5a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5a5:	48 8b 10             	mov    (%rax),%rdx
  81f5a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f5ac:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f5af:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f5b4:	74 0d                	je     81f5c3 <tcp_receive+0x1582>
                    prev->next = cseg;
  81f5b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f5ba:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f5be:	48 89 10             	mov    %rdx,(%rax)
  81f5c1:	eb 0f                	jmp    81f5d2 <tcp_receive+0x1591>
                  } else {
                    pcb->ooseq = cseg;
  81f5c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5c7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f5cb:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f5d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5d6:	48 89 c7             	mov    %rax,%rdi
  81f5d9:	48 b8 5b 03 81 00 00 	movabs $0x81035b,%rax
  81f5e0:	00 00 00 
  81f5e3:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f5e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f5e9:	48 8b 00             	mov    (%rax),%rax
  81f5ec:	48 85 c0             	test   %rax,%rax
  81f5ef:	0f 84 83 00 00 00    	je     81f678 <tcp_receive+0x1637>
                    next = cseg->next;
  81f5f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f5f9:	48 8b 00             	mov    (%rax),%rax
  81f5fc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f600:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f604:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f608:	0f b7 d0             	movzwl %ax,%edx
  81f60b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f612:	00 00 00 
  81f615:	8b 00                	mov    (%rax),%eax
  81f617:	01 c2                	add    %eax,%edx
  81f619:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f61d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f621:	8b 40 04             	mov    0x4(%rax),%eax
  81f624:	29 c2                	sub    %eax,%edx
  81f626:	89 d0                	mov    %edx,%eax
  81f628:	85 c0                	test   %eax,%eax
  81f62a:	7e 4c                	jle    81f678 <tcp_receive+0x1637>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f62c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f630:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f634:	8b 40 04             	mov    0x4(%rax),%eax
  81f637:	89 c2                	mov    %eax,%edx
  81f639:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f640:	00 00 00 
  81f643:	8b 00                	mov    (%rax),%eax
  81f645:	29 c2                	sub    %eax,%edx
  81f647:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f64b:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f64f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f653:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f657:	0f b7 d0             	movzwl %ax,%edx
  81f65a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f65e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f662:	89 d6                	mov    %edx,%esi
  81f664:	48 89 c7             	mov    %rax,%rdi
  81f667:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81f66e:	00 00 00 
  81f671:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f673:	e9 88 03 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
  81f678:	e9 83 03 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81f67d:	e9 7e 03 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
              }
            } else {
              if (prev == NULL) {
  81f682:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f687:	0f 85 f3 00 00 00    	jne    81f780 <tcp_receive+0x173f>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f68d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f694:	00 00 00 
  81f697:	8b 10                	mov    (%rax),%edx
  81f699:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f69d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6a1:	8b 40 04             	mov    0x4(%rax),%eax
  81f6a4:	29 c2                	sub    %eax,%edx
  81f6a6:	89 d0                	mov    %edx,%eax
  81f6a8:	85 c0                	test   %eax,%eax
  81f6aa:	0f 89 5f 02 00 00    	jns    81f90f <tcp_receive+0x18ce>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f6b0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f6b7:	00 00 00 
  81f6ba:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f6be:	0f b7 d0             	movzwl %ax,%edx
  81f6c1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f6c8:	00 00 00 
  81f6cb:	8b 00                	mov    (%rax),%eax
  81f6cd:	01 c2                	add    %eax,%edx
  81f6cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6d3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6d7:	8b 40 04             	mov    0x4(%rax),%eax
  81f6da:	29 c2                	sub    %eax,%edx
  81f6dc:	89 d0                	mov    %edx,%eax
  81f6de:	85 c0                	test   %eax,%eax
  81f6e0:	7e 59                	jle    81f73b <tcp_receive+0x16fa>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f6e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6e6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6ea:	8b 40 04             	mov    0x4(%rax),%eax
  81f6ed:	89 c2                	mov    %eax,%edx
  81f6ef:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f6f6:	00 00 00 
  81f6f9:	8b 00                	mov    (%rax),%eax
  81f6fb:	29 c2                	sub    %eax,%edx
  81f6fd:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f704:	00 00 00 
  81f707:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f70b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f712:	00 00 00 
  81f715:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f719:	0f b7 d0             	movzwl %ax,%edx
  81f71c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f723:	00 00 00 
  81f726:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f72a:	89 d6                	mov    %edx,%esi
  81f72c:	48 89 c7             	mov    %rax,%rdi
  81f72f:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81f736:	00 00 00 
  81f739:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f73b:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f742:	00 00 00 
  81f745:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81f74c:	00 00 00 
  81f74f:	ff d0                	callq  *%rax
  81f751:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81f755:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f75a:	74 1f                	je     81f77b <tcp_receive+0x173a>
                    cseg->next = next;
  81f75c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f760:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f764:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81f767:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f76b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f76f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81f776:	e9 85 02 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
  81f77b:	e9 80 02 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81f780:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f787:	00 00 00 
  81f78a:	8b 10                	mov    (%rax),%edx
  81f78c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f790:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f794:	8b 40 04             	mov    0x4(%rax),%eax
  81f797:	29 c2                	sub    %eax,%edx
  81f799:	89 d0                	mov    %edx,%eax
  81f79b:	83 e8 01             	sub    $0x1,%eax
  81f79e:	85 c0                	test   %eax,%eax
  81f7a0:	0f 88 69 01 00 00    	js     81f90f <tcp_receive+0x18ce>
  81f7a6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f7ad:	00 00 00 
  81f7b0:	8b 10                	mov    (%rax),%edx
  81f7b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7b6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f7ba:	8b 40 04             	mov    0x4(%rax),%eax
  81f7bd:	29 c2                	sub    %eax,%edx
  81f7bf:	89 d0                	mov    %edx,%eax
  81f7c1:	83 c0 01             	add    $0x1,%eax
  81f7c4:	85 c0                	test   %eax,%eax
  81f7c6:	0f 8f 43 01 00 00    	jg     81f90f <tcp_receive+0x18ce>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f7cc:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f7d3:	00 00 00 
  81f7d6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f7da:	0f b7 d0             	movzwl %ax,%edx
  81f7dd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f7e4:	00 00 00 
  81f7e7:	8b 00                	mov    (%rax),%eax
  81f7e9:	01 c2                	add    %eax,%edx
  81f7eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7ef:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f7f3:	8b 40 04             	mov    0x4(%rax),%eax
  81f7f6:	29 c2                	sub    %eax,%edx
  81f7f8:	89 d0                	mov    %edx,%eax
  81f7fa:	85 c0                	test   %eax,%eax
  81f7fc:	7e 59                	jle    81f857 <tcp_receive+0x1816>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f7fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f802:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f806:	8b 40 04             	mov    0x4(%rax),%eax
  81f809:	89 c2                	mov    %eax,%edx
  81f80b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f812:	00 00 00 
  81f815:	8b 00                	mov    (%rax),%eax
  81f817:	29 c2                	sub    %eax,%edx
  81f819:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f820:	00 00 00 
  81f823:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81f827:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f82e:	00 00 00 
  81f831:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f835:	0f b7 d0             	movzwl %ax,%edx
  81f838:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f83f:	00 00 00 
  81f842:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f846:	89 d6                	mov    %edx,%esi
  81f848:	48 89 c7             	mov    %rax,%rdi
  81f84b:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81f852:	00 00 00 
  81f855:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81f857:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f85e:	00 00 00 
  81f861:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81f868:	00 00 00 
  81f86b:	ff d0                	callq  *%rax
  81f86d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f871:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f876:	0f 84 8e 00 00 00    	je     81f90a <tcp_receive+0x18c9>
                  cseg->next = next;
  81f87c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f880:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f884:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81f887:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f88b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f88f:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81f892:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f896:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f89a:	8b 50 04             	mov    0x4(%rax),%edx
  81f89d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8a1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f8a5:	0f b7 c0             	movzwl %ax,%eax
  81f8a8:	01 c2                	add    %eax,%edx
  81f8aa:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8b1:	00 00 00 
  81f8b4:	8b 00                	mov    (%rax),%eax
  81f8b6:	29 c2                	sub    %eax,%edx
  81f8b8:	89 d0                	mov    %edx,%eax
  81f8ba:	85 c0                	test   %eax,%eax
  81f8bc:	7e 4c                	jle    81f90a <tcp_receive+0x18c9>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81f8be:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8c5:	00 00 00 
  81f8c8:	8b 00                	mov    (%rax),%eax
  81f8ca:	89 c2                	mov    %eax,%edx
  81f8cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8d0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f8d4:	8b 40 04             	mov    0x4(%rax),%eax
  81f8d7:	29 c2                	sub    %eax,%edx
  81f8d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8dd:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81f8e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8e5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f8e9:	0f b7 d0             	movzwl %ax,%edx
  81f8ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f8f4:	89 d6                	mov    %edx,%esi
  81f8f6:	48 89 c7             	mov    %rax,%rdi
  81f8f9:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81f900:	00 00 00 
  81f903:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f905:	e9 f6 00 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
  81f90a:	e9 f1 00 00 00       	jmpq   81fa00 <tcp_receive+0x19bf>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f90f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f913:	48 8b 00             	mov    (%rax),%rax
  81f916:	48 85 c0             	test   %rax,%rax
  81f919:	0f 85 c3 00 00 00    	jne    81f9e2 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81f91f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f926:	00 00 00 
  81f929:	8b 10                	mov    (%rax),%edx
  81f92b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f92f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f933:	8b 40 04             	mov    0x4(%rax),%eax
  81f936:	29 c2                	sub    %eax,%edx
  81f938:	89 d0                	mov    %edx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f93a:	85 c0                	test   %eax,%eax
  81f93c:	0f 8e a0 00 00 00    	jle    81f9e2 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81f942:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f949:	00 00 00 
  81f94c:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81f953:	00 00 00 
  81f956:	ff d0                	callq  *%rax
  81f958:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f95c:	48 89 02             	mov    %rax,(%rdx)
                if (next->next != NULL) {
  81f95f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f963:	48 8b 00             	mov    (%rax),%rax
  81f966:	48 85 c0             	test   %rax,%rax
  81f969:	74 75                	je     81f9e0 <tcp_receive+0x199f>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81f96b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f96f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f973:	8b 50 04             	mov    0x4(%rax),%edx
  81f976:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f97a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f97e:	0f b7 c0             	movzwl %ax,%eax
  81f981:	01 c2                	add    %eax,%edx
  81f983:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f98a:	00 00 00 
  81f98d:	8b 00                	mov    (%rax),%eax
  81f98f:	29 c2                	sub    %eax,%edx
  81f991:	89 d0                	mov    %edx,%eax
  81f993:	85 c0                	test   %eax,%eax
  81f995:	7e 49                	jle    81f9e0 <tcp_receive+0x199f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81f997:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f99e:	00 00 00 
  81f9a1:	8b 00                	mov    (%rax),%eax
  81f9a3:	89 c2                	mov    %eax,%edx
  81f9a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9a9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f9ad:	8b 40 04             	mov    0x4(%rax),%eax
  81f9b0:	29 c2                	sub    %eax,%edx
  81f9b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9b6:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81f9ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9be:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f9c2:	0f b7 d0             	movzwl %ax,%edx
  81f9c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9c9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f9cd:	89 d6                	mov    %edx,%esi
  81f9cf:	48 89 c7             	mov    %rax,%rdi
  81f9d2:	48 b8 15 d8 80 00 00 	movabs $0x80d815,%rax
  81f9d9:	00 00 00 
  81f9dc:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f9de:	eb 20                	jmp    81fa00 <tcp_receive+0x19bf>
  81f9e0:	eb 1e                	jmp    81fa00 <tcp_receive+0x19bf>
              }
            }
            prev = next;
  81f9e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9e6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f9ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9ee:	48 8b 00             	mov    (%rax),%rax
  81f9f1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f9f5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81f9fa:	0f 85 3e fb ff ff    	jne    81f53e <tcp_receive+0x14fd>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fa00:	eb 29                	jmp    81fa2b <tcp_receive+0x19ea>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81fa02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa06:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fa0a:	83 c8 02             	or     $0x2,%eax
  81fa0d:	89 c2                	mov    %eax,%edx
  81fa0f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa13:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fa16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa1a:	48 89 c7             	mov    %rax,%rdi
  81fa1d:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81fa24:	00 00 00 
  81fa27:	ff d0                	callq  *%rax
  81fa29:	eb 6f                	jmp    81fa9a <tcp_receive+0x1a59>
  81fa2b:	eb 6d                	jmp    81fa9a <tcp_receive+0x1a59>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81fa2d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa34:	00 00 00 
  81fa37:	8b 10                	mov    (%rax),%edx
  81fa39:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa3d:	8b 40 30             	mov    0x30(%rax),%eax
  81fa40:	29 c2                	sub    %eax,%edx
  81fa42:	89 d0                	mov    %edx,%eax
  81fa44:	85 c0                	test   %eax,%eax
  81fa46:	78 2b                	js     81fa73 <tcp_receive+0x1a32>
  81fa48:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa4f:	00 00 00 
  81fa52:	8b 10                	mov    (%rax),%edx
  81fa54:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa58:	8b 48 30             	mov    0x30(%rax),%ecx
  81fa5b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa5f:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81fa63:	0f b7 c0             	movzwl %ax,%eax
  81fa66:	01 c8                	add    %ecx,%eax
  81fa68:	29 c2                	sub    %eax,%edx
  81fa6a:	89 d0                	mov    %edx,%eax
  81fa6c:	83 c0 01             	add    $0x1,%eax
  81fa6f:	85 c0                	test   %eax,%eax
  81fa71:	7e 27                	jle    81fa9a <tcp_receive+0x1a59>
      tcp_ack_now(pcb);
  81fa73:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa77:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fa7b:	83 c8 02             	or     $0x2,%eax
  81fa7e:	89 c2                	mov    %eax,%edx
  81fa80:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa84:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fa87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa8b:	48 89 c7             	mov    %rax,%rdi
  81fa8e:	48 b8 1c 3b 81 00 00 	movabs $0x813b1c,%rax
  81fa95:	00 00 00 
  81fa98:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81fa9a:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81fa9e:	48 83 c4 58          	add    $0x58,%rsp
  81faa2:	5b                   	pop    %rbx
  81faa3:	41 5c                	pop    %r12
  81faa5:	41 5d                	pop    %r13
  81faa7:	5d                   	pop    %rbp
  81faa8:	c3                   	retq   

000000000081faa9 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81faa9:	55                   	push   %rbp
  81faaa:	48 89 e5             	mov    %rsp,%rbp
  81faad:	53                   	push   %rbx
  81faae:	48 83 ec 38          	sub    $0x38,%rsp
  81fab2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81fab6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fabd:	00 00 00 
  81fac0:	48 8b 00             	mov    (%rax),%rax
  81fac3:	48 83 c0 14          	add    $0x14,%rax
  81fac7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81facb:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fad2:	00 00 00 
  81fad5:	48 8b 00             	mov    (%rax),%rax
  81fad8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fadc:	0f b7 c0             	movzwl %ax,%eax
  81fadf:	89 c7                	mov    %eax,%edi
  81fae1:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81fae8:	00 00 00 
  81faeb:	ff d0                	callq  *%rax
  81faed:	66 c1 e8 0c          	shr    $0xc,%ax
  81faf1:	66 83 f8 05          	cmp    $0x5,%ax
  81faf5:	0f 86 11 01 00 00    	jbe    81fc0c <tcp_parseopt+0x163>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fafb:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81faff:	e9 cd 00 00 00       	jmpq   81fbd1 <tcp_parseopt+0x128>
      opt = opts[c];
  81fb04:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81fb08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fb0c:	48 01 d0             	add    %rdx,%rax
  81fb0f:	0f b6 00             	movzbl (%rax),%eax
  81fb12:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81fb15:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81fb19:	75 05                	jne    81fb20 <tcp_parseopt+0x77>
        /* End of options. */
        break;
  81fb1b:	e9 ec 00 00 00       	jmpq   81fc0c <tcp_parseopt+0x163>
      } else if (opt == 0x01) {
  81fb20:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81fb24:	75 09                	jne    81fb2f <tcp_parseopt+0x86>
        ++c;
  81fb26:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81fb2a:	e9 a2 00 00 00       	jmpq   81fbd1 <tcp_parseopt+0x128>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fb2f:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81fb33:	75 6f                	jne    81fba4 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
  81fb35:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fb39:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fb3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fb41:	48 01 d0             	add    %rdx,%rax
  81fb44:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fb47:	3c 04                	cmp    $0x4,%al
  81fb49:	75 59                	jne    81fba4 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81fb4b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fb4f:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81fb53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fb57:	48 01 d0             	add    %rdx,%rax
  81fb5a:	0f b6 00             	movzbl (%rax),%eax
  81fb5d:	0f b6 c0             	movzbl %al,%eax
  81fb60:	c1 e0 08             	shl    $0x8,%eax
  81fb63:	89 c2                	mov    %eax,%edx
  81fb65:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fb69:	48 8d 48 03          	lea    0x3(%rax),%rcx
  81fb6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fb71:	48 01 c8             	add    %rcx,%rax
  81fb74:	0f b6 00             	movzbl (%rax),%eax
  81fb77:	0f b6 c0             	movzbl %al,%eax
  81fb7a:	09 d0                	or     %edx,%eax
  81fb7c:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81fb80:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81fb86:	77 0d                	ja     81fb95 <tcp_parseopt+0xec>
  81fb88:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81fb8d:	74 06                	je     81fb95 <tcp_parseopt+0xec>
  81fb8f:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81fb93:	eb 05                	jmp    81fb9a <tcp_parseopt+0xf1>
  81fb95:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81fb9a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fb9e:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81fba2:	eb 68                	jmp    81fc0c <tcp_parseopt+0x163>
      } else {
        if (opts[c + 1] == 0) {
  81fba4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fba8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fbac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fbb0:	48 01 d0             	add    %rdx,%rax
  81fbb3:	0f b6 00             	movzbl (%rax),%eax
  81fbb6:	84 c0                	test   %al,%al
  81fbb8:	75 02                	jne    81fbbc <tcp_parseopt+0x113>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81fbba:	eb 50                	jmp    81fc0c <tcp_parseopt+0x163>
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81fbbc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fbc0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fbc4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fbc8:	48 01 d0             	add    %rdx,%rax
  81fbcb:	0f b6 00             	movzbl (%rax),%eax
  81fbce:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fbd1:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81fbd5:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fbdc:	00 00 00 
  81fbdf:	48 8b 00             	mov    (%rax),%rax
  81fbe2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fbe6:	0f b7 c0             	movzwl %ax,%eax
  81fbe9:	89 c7                	mov    %eax,%edi
  81fbeb:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81fbf2:	00 00 00 
  81fbf5:	ff d0                	callq  *%rax
  81fbf7:	66 c1 e8 0c          	shr    $0xc,%ax
  81fbfb:	0f b7 c0             	movzwl %ax,%eax
  81fbfe:	83 e8 05             	sub    $0x5,%eax
  81fc01:	c1 e0 02             	shl    $0x2,%eax
  81fc04:	39 c3                	cmp    %eax,%ebx
  81fc06:	0f 8c f8 fe ff ff    	jl     81fb04 <tcp_parseopt+0x5b>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81fc0c:	48 83 c4 38          	add    $0x38,%rsp
  81fc10:	5b                   	pop    %rbx
  81fc11:	5d                   	pop    %rbp
  81fc12:	c3                   	retq   

000000000081fc13 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81fc13:	55                   	push   %rbp
  81fc14:	48 89 e5             	mov    %rsp,%rbp
  81fc17:	48 83 ec 40          	sub    $0x40,%rsp
  81fc1b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81fc1f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81fc23:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81fc27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fc2b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fc2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81fc33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fc37:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81fc3b:	0f b7 c0             	movzwl %ax,%eax
  81fc3e:	89 c7                	mov    %eax,%edi
  81fc40:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  81fc47:	00 00 00 
  81fc4a:	ff d0                	callq  *%rax
  81fc4c:	66 25 ff 00          	and    $0xff,%ax
  81fc50:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81fc54:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81fc5b:	00 
  pcb = raw_pcbs;
  81fc5c:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fc63:	00 00 00 
  81fc66:	48 8b 00             	mov    (%rax),%rax
  81fc69:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fc6d:	e9 a3 00 00 00       	jmpq   81fd15 <raw_input+0x102>
    if (pcb->protocol == proto) {
  81fc72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc76:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fc7a:	0f b6 d0             	movzbl %al,%edx
  81fc7d:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81fc81:	39 c2                	cmp    %eax,%edx
  81fc83:	75 7c                	jne    81fd01 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81fc85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc89:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc8d:	48 85 c0             	test   %rax,%rax
  81fc90:	74 6f                	je     81fd01 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81fc92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc96:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc9a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81fc9e:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81fca2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fca6:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  81fcaa:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fcae:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fcb2:	ff d0                	callq  *%rax
  81fcb4:	84 c0                	test   %al,%al
  81fcb6:	74 49                	je     81fd01 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  81fcb8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81fcbf:	00 
          eaten = 1;
  81fcc0:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81fcc4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fcc9:	74 36                	je     81fd01 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81fccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fccf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fcd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fcd7:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81fcdb:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fce2:	00 00 00 
  81fce5:	48 8b 10             	mov    (%rax),%rdx
  81fce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fcec:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81fcf0:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fcf7:	00 00 00 
  81fcfa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fcfe:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81fd01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd05:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81fd09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd0d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fd11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fd15:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81fd19:	75 0b                	jne    81fd26 <raw_input+0x113>
  81fd1b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fd20:	0f 85 4c ff ff ff    	jne    81fc72 <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81fd26:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81fd2a:	c9                   	leaveq 
  81fd2b:	c3                   	retq   

000000000081fd2c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fd2c:	55                   	push   %rbp
  81fd2d:	48 89 e5             	mov    %rsp,%rbp
  81fd30:	48 83 ec 10          	sub    $0x10,%rsp
  81fd34:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fd38:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81fd3c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fd41:	74 08                	je     81fd4b <raw_bind+0x1f>
  81fd43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd47:	8b 00                	mov    (%rax),%eax
  81fd49:	eb 05                	jmp    81fd50 <raw_bind+0x24>
  81fd4b:	b8 00 00 00 00       	mov    $0x0,%eax
  81fd50:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fd54:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81fd56:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fd5b:	c9                   	leaveq 
  81fd5c:	c3                   	retq   

000000000081fd5d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fd5d:	55                   	push   %rbp
  81fd5e:	48 89 e5             	mov    %rsp,%rbp
  81fd61:	48 83 ec 10          	sub    $0x10,%rsp
  81fd65:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fd69:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81fd6d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fd72:	74 08                	je     81fd7c <raw_connect+0x1f>
  81fd74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd78:	8b 00                	mov    (%rax),%eax
  81fd7a:	eb 05                	jmp    81fd81 <raw_connect+0x24>
  81fd7c:	b8 00 00 00 00       	mov    $0x0,%eax
  81fd81:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fd85:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81fd88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fd8d:	c9                   	leaveq 
  81fd8e:	c3                   	retq   

000000000081fd8f <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81fd8f:	55                   	push   %rbp
  81fd90:	48 89 e5             	mov    %rsp,%rbp
  81fd93:	48 83 ec 18          	sub    $0x18,%rsp
  81fd97:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fd9b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81fd9f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81fda3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fda7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81fdab:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81fdaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81fdb7:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81fdbb:	c9                   	leaveq 
  81fdbc:	c3                   	retq   

000000000081fdbd <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81fdbd:	55                   	push   %rbp
  81fdbe:	48 89 e5             	mov    %rsp,%rbp
  81fdc1:	48 83 ec 40          	sub    $0x40,%rsp
  81fdc5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fdc9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81fdcd:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81fdd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fdd5:	be 14 00 00 00       	mov    $0x14,%esi
  81fdda:	48 89 c7             	mov    %rax,%rdi
  81fddd:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81fde4:	00 00 00 
  81fde7:	ff d0                	callq  *%rax
  81fde9:	84 c0                	test   %al,%al
  81fdeb:	74 4c                	je     81fe39 <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81fded:	ba 00 00 00 00       	mov    $0x0,%edx
  81fdf2:	be 00 00 00 00       	mov    $0x0,%esi
  81fdf7:	bf 01 00 00 00       	mov    $0x1,%edi
  81fdfc:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  81fe03:	00 00 00 
  81fe06:	ff d0                	callq  *%rax
  81fe08:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81fe0c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fe11:	75 0a                	jne    81fe1d <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81fe13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81fe18:	e9 42 01 00 00       	jmpq   81ff5f <raw_sendto+0x1a2>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81fe1d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81fe21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fe25:	48 89 d6             	mov    %rdx,%rsi
  81fe28:	48 89 c7             	mov    %rax,%rdi
  81fe2b:	48 b8 49 df 80 00 00 	movabs $0x80df49,%rax
  81fe32:	00 00 00 
  81fe35:	ff d0                	callq  *%rax
  81fe37:	eb 4e                	jmp    81fe87 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81fe39:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fe3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81fe41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fe45:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81fe4a:	48 89 c7             	mov    %rax,%rdi
  81fe4d:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  81fe54:	00 00 00 
  81fe57:	ff d0                	callq  *%rax
  81fe59:	84 c0                	test   %al,%al
  81fe5b:	74 2a                	je     81fe87 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81fe5d:	48 ba 58 3a 82 00 00 	movabs $0x823a58,%rdx
  81fe64:	00 00 00 
  81fe67:	be e3 00 00 00       	mov    $0xe3,%esi
  81fe6c:	48 bf 7e 3a 82 00 00 	movabs $0x823a7e,%rdi
  81fe73:	00 00 00 
  81fe76:	b8 00 00 00 00       	mov    $0x0,%eax
  81fe7b:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  81fe82:	00 00 00 
  81fe85:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81fe87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fe8b:	48 89 c7             	mov    %rax,%rdi
  81fe8e:	48 b8 bd 0c 81 00 00 	movabs $0x810cbd,%rax
  81fe95:	00 00 00 
  81fe98:	ff d0                	callq  *%rax
  81fe9a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81fe9e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81fea3:	75 27                	jne    81fecc <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81fea5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fea9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fead:	74 13                	je     81fec2 <raw_sendto+0x105>
      pbuf_free(q);
  81feaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81feb3:	48 89 c7             	mov    %rax,%rdi
  81feb6:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81febd:	00 00 00 
  81fec0:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81fec2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81fec7:	e9 93 00 00 00       	jmpq   81ff5f <raw_sendto+0x1a2>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81fecc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fed0:	48 85 c0             	test   %rax,%rax
  81fed3:	74 0a                	je     81fedf <raw_sendto+0x122>
  81fed5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fed9:	8b 00                	mov    (%rax),%eax
  81fedb:	85 c0                	test   %eax,%eax
  81fedd:	75 0e                	jne    81feed <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81fedf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fee3:	48 83 c0 08          	add    $0x8,%rax
  81fee7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81feeb:	eb 08                	jmp    81fef5 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81feed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fef1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81fef5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fef9:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fefd:	44 0f b6 c8          	movzbl %al,%r9d
  81ff01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ff05:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81ff09:	44 0f b6 c0          	movzbl %al,%r8d
  81ff0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ff11:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81ff15:	0f b6 c8             	movzbl %al,%ecx
  81ff18:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81ff1c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81ff20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ff24:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  81ff28:	48 89 3c 24          	mov    %rdi,(%rsp)
  81ff2c:	48 89 c7             	mov    %rax,%rdi
  81ff2f:	48 b8 f2 11 81 00 00 	movabs $0x8111f2,%rax
  81ff36:	00 00 00 
  81ff39:	ff d0                	callq  *%rax
  81ff3b:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81ff3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ff42:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81ff46:	74 13                	je     81ff5b <raw_sendto+0x19e>
    /* free the header */
    pbuf_free(q);
  81ff48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ff4c:	48 89 c7             	mov    %rax,%rdi
  81ff4f:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  81ff56:	00 00 00 
  81ff59:	ff d0                	callq  *%rax
  }
  return err;
  81ff5b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  81ff5f:	c9                   	leaveq 
  81ff60:	c3                   	retq   

000000000081ff61 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  81ff61:	55                   	push   %rbp
  81ff62:	48 89 e5             	mov    %rsp,%rbp
  81ff65:	48 83 ec 10          	sub    $0x10,%rsp
  81ff69:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81ff6d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81ff71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ff75:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81ff79:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81ff7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ff81:	48 89 ce             	mov    %rcx,%rsi
  81ff84:	48 89 c7             	mov    %rax,%rdi
  81ff87:	48 b8 bd fd 81 00 00 	movabs $0x81fdbd,%rax
  81ff8e:	00 00 00 
  81ff91:	ff d0                	callq  *%rax
}
  81ff93:	c9                   	leaveq 
  81ff94:	c3                   	retq   

000000000081ff95 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81ff95:	55                   	push   %rbp
  81ff96:	48 89 e5             	mov    %rsp,%rbp
  81ff99:	48 83 ec 20          	sub    $0x20,%rsp
  81ff9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  81ffa1:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffa8:	00 00 00 
  81ffab:	48 8b 00             	mov    (%rax),%rax
  81ffae:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81ffb2:	75 20                	jne    81ffd4 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81ffb4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffbb:	00 00 00 
  81ffbe:	48 8b 00             	mov    (%rax),%rax
  81ffc1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ffc5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffcc:	00 00 00 
  81ffcf:	48 89 10             	mov    %rdx,(%rax)
  81ffd2:	eb 51                	jmp    820025 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81ffd4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffdb:	00 00 00 
  81ffde:	48 8b 00             	mov    (%rax),%rax
  81ffe1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81ffe5:	eb 37                	jmp    82001e <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81ffe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffeb:	48 8b 40 10          	mov    0x10(%rax),%rax
  81ffef:	48 85 c0             	test   %rax,%rax
  81fff2:	74 1e                	je     820012 <raw_remove+0x7d>
  81fff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fff8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fffc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  820000:	75 10                	jne    820012 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  820002:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820006:	48 8b 50 10          	mov    0x10(%rax),%rdx
  82000a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82000e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  820012:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820016:	48 8b 40 10          	mov    0x10(%rax),%rax
  82001a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  82001e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820023:	75 c2                	jne    81ffe7 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  820025:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820029:	48 89 c6             	mov    %rax,%rsi
  82002c:	bf 00 00 00 00       	mov    $0x0,%edi
  820031:	48 b8 de cd 80 00 00 	movabs $0x80cdde,%rax
  820038:	00 00 00 
  82003b:	ff d0                	callq  *%rax
}
  82003d:	c9                   	leaveq 
  82003e:	c3                   	retq   

000000000082003f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  82003f:	55                   	push   %rbp
  820040:	48 89 e5             	mov    %rsp,%rbp
  820043:	48 83 ec 20          	sub    $0x20,%rsp
  820047:	89 f8                	mov    %edi,%eax
  820049:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  82004c:	bf 00 00 00 00       	mov    $0x0,%edi
  820051:	48 b8 33 cd 80 00 00 	movabs $0x80cd33,%rax
  820058:	00 00 00 
  82005b:	ff d0                	callq  *%rax
  82005d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  820061:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820066:	74 56                	je     8200be <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  820068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82006c:	ba 30 00 00 00       	mov    $0x30,%edx
  820071:	be 00 00 00 00       	mov    $0x0,%esi
  820076:	48 89 c7             	mov    %rax,%rdi
  820079:	48 b8 d5 21 80 00 00 	movabs $0x8021d5,%rax
  820080:	00 00 00 
  820083:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  820085:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820089:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  82008d:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  820090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820094:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  820098:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82009f:	00 00 00 
  8200a2:	48 8b 10             	mov    (%rax),%rdx
  8200a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8200a9:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  8200ad:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8200b4:	00 00 00 
  8200b7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8200bb:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  8200be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8200c2:	c9                   	leaveq 
  8200c3:	c3                   	retq   

00000000008200c4 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  8200c4:	55                   	push   %rbp
  8200c5:	48 89 e5             	mov    %rsp,%rbp
  8200c8:	53                   	push   %rbx
  8200c9:	48 83 ec 58          	sub    $0x58,%rsp
  8200cd:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8200d1:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  8200d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8200d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8200dd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  8200e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8200e5:	0f b7 00             	movzwl (%rax),%eax
  8200e8:	0f b7 c0             	movzwl %ax,%eax
  8200eb:	89 c7                	mov    %eax,%edi
  8200ed:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8200f4:	00 00 00 
  8200f7:	ff d0                	callq  *%rax
  8200f9:	66 c1 e8 08          	shr    $0x8,%ax
  8200fd:	83 e0 0f             	and    $0xf,%eax
  820100:	c1 e0 02             	shl    $0x2,%eax
  820103:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  820107:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82010b:	f7 d8                	neg    %eax
  82010d:	0f bf d0             	movswl %ax,%edx
  820110:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820114:	89 d6                	mov    %edx,%esi
  820116:	48 89 c7             	mov    %rax,%rdi
  820119:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  820120:	00 00 00 
  820123:	ff d0                	callq  *%rax
  820125:	84 c0                	test   %al,%al
  820127:	75 0e                	jne    820137 <icmp_input+0x73>
  820129:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82012d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820131:	66 83 f8 03          	cmp    $0x3,%ax
  820135:	77 05                	ja     82013c <icmp_input+0x78>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  820137:	e9 90 04 00 00       	jmpq   8205cc <icmp_input+0x508>
  }

  type = *((u8_t *)p->payload);
  82013c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820140:	48 8b 40 08          	mov    0x8(%rax),%rax
  820144:	0f b6 00             	movzbl (%rax),%eax
  820147:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  82014a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82014e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820152:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  820156:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  820159:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  82015d:	83 f8 08             	cmp    $0x8,%eax
  820160:	74 05                	je     820167 <icmp_input+0xa3>
  820162:	e9 50 04 00 00       	jmpq   8205b7 <icmp_input+0x4f3>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  820167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82016b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  82016f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  820173:	48 89 c6             	mov    %rax,%rsi
  820176:	48 89 d7             	mov    %rdx,%rdi
  820179:	48 b8 20 0c 81 00 00 	movabs $0x810c20,%rax
  820180:	00 00 00 
  820183:	ff d0                	callq  *%rax
  820185:	84 c0                	test   %al,%al
  820187:	75 2f                	jne    8201b8 <icmp_input+0xf4>
  820189:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82018d:	8b 58 10             	mov    0x10(%rax),%ebx
  820190:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  820195:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  82019c:	00 00 00 
  82019f:	ff d0                	callq  *%rax
  8201a1:	21 c3                	and    %eax,%ebx
  8201a3:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8201a8:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8201af:	00 00 00 
  8201b2:	ff d0                	callq  *%rax
  8201b4:	39 c3                	cmp    %eax,%ebx
  8201b6:	75 18                	jne    8201d0 <icmp_input+0x10c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  8201b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201bc:	48 89 c7             	mov    %rax,%rdi
  8201bf:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8201c6:	00 00 00 
  8201c9:	ff d0                	callq  *%rax
      return;
  8201cb:	e9 10 04 00 00       	jmpq   8205e0 <icmp_input+0x51c>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8201d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201d4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8201d8:	66 83 f8 07          	cmp    $0x7,%ax
  8201dc:	77 05                	ja     8201e3 <icmp_input+0x11f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  8201de:	e9 e9 03 00 00       	jmpq   8205cc <icmp_input+0x508>
    }
    if (inet_chksum_pbuf(p) != 0) {
  8201e3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201e7:	48 89 c7             	mov    %rax,%rdi
  8201ea:	48 b8 0f 2a 81 00 00 	movabs $0x812a0f,%rax
  8201f1:	00 00 00 
  8201f4:	ff d0                	callq  *%rax
  8201f6:	66 85 c0             	test   %ax,%ax
  8201f9:	74 18                	je     820213 <icmp_input+0x14f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  8201fb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201ff:	48 89 c7             	mov    %rax,%rdi
  820202:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  820209:	00 00 00 
  82020c:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  82020e:	e9 cd 03 00 00       	jmpq   8205e0 <icmp_input+0x51c>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  820213:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820217:	be 22 00 00 00       	mov    $0x22,%esi
  82021c:	48 89 c7             	mov    %rax,%rdi
  82021f:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  820226:	00 00 00 
  820229:	ff d0                	callq  *%rax
  82022b:	84 c0                	test   %al,%al
  82022d:	0f 84 8f 01 00 00    	je     8203c2 <icmp_input+0x2fe>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820233:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820237:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82023b:	89 d6                	mov    %edx,%esi
  82023d:	48 89 c7             	mov    %rax,%rdi
  820240:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  820247:	00 00 00 
  82024a:	ff d0                	callq  *%rax
  82024c:	84 c0                	test   %al,%al
  82024e:	74 2a                	je     82027a <icmp_input+0x1b6>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  820250:	48 ba 98 3a 82 00 00 	movabs $0x823a98,%rdx
  820257:	00 00 00 
  82025a:	be 7b 00 00 00       	mov    $0x7b,%esi
  82025f:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  820266:	00 00 00 
  820269:	b8 00 00 00 00       	mov    $0x0,%eax
  82026e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820275:	00 00 00 
  820278:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  82027a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82027e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820282:	0f b7 c0             	movzwl %ax,%eax
  820285:	ba 00 00 00 00       	mov    $0x0,%edx
  82028a:	89 c6                	mov    %eax,%esi
  82028c:	bf 02 00 00 00       	mov    $0x2,%edi
  820291:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  820298:	00 00 00 
  82029b:	ff d0                	callq  *%rax
  82029d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  8202a1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8202a6:	75 1a                	jne    8202c2 <icmp_input+0x1fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  8202a8:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  8202a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8202ad:	48 89 c7             	mov    %rax,%rdi
  8202b0:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8202b7:	00 00 00 
  8202ba:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8202bc:	90                   	nop
  8202bd:	e9 1e 03 00 00       	jmpq   8205e0 <icmp_input+0x51c>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  8202c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8202c6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8202ca:	0f b7 c0             	movzwl %ax,%eax
  8202cd:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  8202d2:	48 83 c2 08          	add    $0x8,%rdx
  8202d6:	48 39 d0             	cmp    %rdx,%rax
  8202d9:	73 2a                	jae    820305 <icmp_input+0x241>
  8202db:	48 ba e8 3a 82 00 00 	movabs $0x823ae8,%rdx
  8202e2:	00 00 00 
  8202e5:	be 85 00 00 00       	mov    $0x85,%esi
  8202ea:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  8202f1:	00 00 00 
  8202f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8202f9:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820300:	00 00 00 
  820303:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  820305:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  820309:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82030d:	48 89 d6             	mov    %rdx,%rsi
  820310:	48 89 c7             	mov    %rax,%rdi
  820313:	48 b8 9e e0 80 00 00 	movabs $0x80e09e,%rax
  82031a:	00 00 00 
  82031d:	ff d0                	callq  *%rax
  82031f:	84 c0                	test   %al,%al
  820321:	74 2a                	je     82034d <icmp_input+0x289>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  820323:	48 ba 20 3b 82 00 00 	movabs $0x823b20,%rdx
  82032a:	00 00 00 
  82032d:	be 88 00 00 00       	mov    $0x88,%esi
  820332:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  820339:	00 00 00 
  82033c:	b8 00 00 00 00       	mov    $0x0,%eax
  820341:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820348:	00 00 00 
  82034b:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82034d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820351:	48 8b 40 08          	mov    0x8(%rax),%rax
  820355:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  820359:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82035d:	f7 d8                	neg    %eax
  82035f:	0f bf d0             	movswl %ax,%edx
  820362:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820366:	89 d6                	mov    %edx,%esi
  820368:	48 89 c7             	mov    %rax,%rdi
  82036b:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  820372:	00 00 00 
  820375:	ff d0                	callq  *%rax
  820377:	84 c0                	test   %al,%al
  820379:	74 2a                	je     8203a5 <icmp_input+0x2e1>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82037b:	48 ba 48 3b 82 00 00 	movabs $0x823b48,%rdx
  820382:	00 00 00 
  820385:	be 8e 00 00 00       	mov    $0x8e,%esi
  82038a:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  820391:	00 00 00 
  820394:	b8 00 00 00 00       	mov    $0x0,%eax
  820399:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8203a0:	00 00 00 
  8203a3:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  8203a5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203a9:	48 89 c7             	mov    %rax,%rdi
  8203ac:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8203b3:	00 00 00 
  8203b6:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  8203b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8203bc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8203c0:	eb 46                	jmp    820408 <icmp_input+0x344>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  8203c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203c6:	be de ff ff ff       	mov    $0xffffffde,%esi
  8203cb:	48 89 c7             	mov    %rax,%rdi
  8203ce:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  8203d5:	00 00 00 
  8203d8:	ff d0                	callq  *%rax
  8203da:	84 c0                	test   %al,%al
  8203dc:	74 2a                	je     820408 <icmp_input+0x344>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8203de:	48 ba 48 3b 82 00 00 	movabs $0x823b48,%rdx
  8203e5:	00 00 00 
  8203e8:	be 98 00 00 00       	mov    $0x98,%esi
  8203ed:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  8203f4:	00 00 00 
  8203f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8203fc:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820403:	00 00 00 
  820406:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  820408:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82040c:	48 8b 40 08          	mov    0x8(%rax),%rax
  820410:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  820414:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820418:	8b 40 0c             	mov    0xc(%rax),%eax
  82041b:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  82041e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820422:	8b 50 10             	mov    0x10(%rax),%edx
  820425:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820429:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  82042c:	8b 55 c0             	mov    -0x40(%rbp),%edx
  82042f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820433:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820436:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82043a:	0f b7 00             	movzwl (%rax),%eax
  82043d:	0f b7 c0             	movzwl %ax,%eax
  820440:	89 c7                	mov    %eax,%edi
  820442:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  820449:	00 00 00 
  82044c:	ff d0                	callq  *%rax
  82044e:	0f b7 c0             	movzwl %ax,%eax
  820451:	0f b6 c0             	movzbl %al,%eax
  820454:	89 c7                	mov    %eax,%edi
  820456:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  82045d:	00 00 00 
  820460:	ff d0                	callq  *%rax
  820462:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  820466:	66 89 02             	mov    %ax,(%rdx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  820469:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82046d:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820471:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820476:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  82047d:	00 00 00 
  820480:	ff d0                	callq  *%rax
  820482:	66 39 c3             	cmp    %ax,%bx
  820485:	72 28                	jb     8204af <icmp_input+0x3eb>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  820487:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82048b:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  82048f:	bf 00 08 00 00       	mov    $0x800,%edi
  820494:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  82049b:	00 00 00 
  82049e:	ff d0                	callq  *%rax
  8204a0:	01 d8                	add    %ebx,%eax
  8204a2:	8d 50 01             	lea    0x1(%rax),%edx
  8204a5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8204a9:	66 89 50 02          	mov    %dx,0x2(%rax)
  8204ad:	eb 24                	jmp    8204d3 <icmp_input+0x40f>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  8204af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8204b3:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  8204b7:	bf 00 08 00 00       	mov    $0x800,%edi
  8204bc:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8204c3:	00 00 00 
  8204c6:	ff d0                	callq  *%rax
  8204c8:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  8204cb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8204cf:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8204d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204d7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8204db:	0f b7 c0             	movzwl %ax,%eax
  8204de:	89 c7                	mov    %eax,%edi
  8204e0:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8204e7:	00 00 00 
  8204ea:	ff d0                	callq  *%rax
  8204ec:	66 0d 00 ff          	or     $0xff00,%ax
  8204f0:	0f b7 c0             	movzwl %ax,%eax
  8204f3:	89 c7                	mov    %eax,%edi
  8204f5:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8204fc:	00 00 00 
  8204ff:	ff d0                	callq  *%rax
  820501:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820505:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  820509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82050d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  820513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820517:	be 14 00 00 00       	mov    $0x14,%esi
  82051c:	48 89 c7             	mov    %rax,%rdi
  82051f:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  820526:	00 00 00 
  820529:	ff d0                	callq  *%rax
  82052b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82052f:	66 89 42 0a          	mov    %ax,0xa(%rdx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  820533:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820537:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82053b:	89 d6                	mov    %edx,%esi
  82053d:	48 89 c7             	mov    %rax,%rdi
  820540:	48 b8 5e da 80 00 00 	movabs $0x80da5e,%rax
  820547:	00 00 00 
  82054a:	ff d0                	callq  *%rax
  82054c:	84 c0                	test   %al,%al
  82054e:	74 2a                	je     82057a <icmp_input+0x4b6>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820550:	48 ba 80 3b 82 00 00 	movabs $0x823b80,%rdx
  820557:	00 00 00 
  82055a:	be b9 00 00 00       	mov    $0xb9,%esi
  82055f:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  820566:	00 00 00 
  820569:	b8 00 00 00 00       	mov    $0x0,%eax
  82056e:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820575:	00 00 00 
  820578:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  82057a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82057e:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  820582:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820586:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  82058a:	48 89 14 24          	mov    %rdx,(%rsp)
  82058e:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820594:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  82059a:	b9 ff 00 00 00       	mov    $0xff,%ecx
  82059f:	ba 00 00 00 00       	mov    $0x0,%edx
  8205a4:	48 89 c7             	mov    %rax,%rdi
  8205a7:	48 b8 f2 11 81 00 00 	movabs $0x8111f2,%rax
  8205ae:	00 00 00 
  8205b1:	ff d0                	callq  *%rax
  8205b3:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  8205b6:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  8205b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8205bb:	48 89 c7             	mov    %rax,%rdi
  8205be:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8205c5:	00 00 00 
  8205c8:	ff d0                	callq  *%rax
  return;
  8205ca:	eb 14                	jmp    8205e0 <icmp_input+0x51c>
lenerr:
  pbuf_free(p);
  8205cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8205d0:	48 89 c7             	mov    %rax,%rdi
  8205d3:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  8205da:	00 00 00 
  8205dd:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8205df:	90                   	nop
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  8205e0:	48 83 c4 58          	add    $0x58,%rsp
  8205e4:	5b                   	pop    %rbx
  8205e5:	5d                   	pop    %rbp
  8205e6:	c3                   	retq   

00000000008205e7 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8205e7:	55                   	push   %rbp
  8205e8:	48 89 e5             	mov    %rsp,%rbp
  8205eb:	48 83 ec 30          	sub    $0x30,%rsp
  8205ef:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8205f3:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8205f6:	ba 00 00 00 00       	mov    $0x0,%edx
  8205fb:	be 24 00 00 00       	mov    $0x24,%esi
  820600:	bf 01 00 00 00       	mov    $0x1,%edi
  820605:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  82060c:	00 00 00 
  82060f:	ff d0                	callq  *%rax
  820611:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820615:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  82061a:	75 05                	jne    820621 <icmp_dest_unreach+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82061c:	e9 60 01 00 00       	jmpq   820781 <icmp_dest_unreach+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820621:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820625:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820629:	66 83 f8 23          	cmp    $0x23,%ax
  82062d:	77 2a                	ja     820659 <icmp_dest_unreach+0x72>
  82062f:	48 ba a8 3b 82 00 00 	movabs $0x823ba8,%rdx
  820636:	00 00 00 
  820639:	be ef 00 00 00       	mov    $0xef,%esi
  82063e:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  820645:	00 00 00 
  820648:	b8 00 00 00 00       	mov    $0x0,%eax
  82064d:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  820654:	00 00 00 
  820657:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820659:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82065d:	48 8b 40 08          	mov    0x8(%rax),%rax
  820661:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  820665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820669:	48 8b 40 08          	mov    0x8(%rax),%rax
  82066d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  820671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820675:	0f b7 00             	movzwl (%rax),%eax
  820678:	0f b7 c0             	movzwl %ax,%eax
  82067b:	89 c7                	mov    %eax,%edi
  82067d:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  820684:	00 00 00 
  820687:	ff d0                	callq  *%rax
  820689:	0f b6 c0             	movzbl %al,%eax
  82068c:	80 cc 03             	or     $0x3,%ah
  82068f:	0f b7 c0             	movzwl %ax,%eax
  820692:	89 c7                	mov    %eax,%edi
  820694:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  82069b:	00 00 00 
  82069e:	ff d0                	callq  *%rax
  8206a0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8206a4:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(idur, t);
  8206a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8206ab:	0f b7 00             	movzwl (%rax),%eax
  8206ae:	0f b7 c0             	movzwl %ax,%eax
  8206b1:	89 c7                	mov    %eax,%edi
  8206b3:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  8206ba:	00 00 00 
  8206bd:	ff d0                	callq  *%rax
  8206bf:	b0 00                	mov    $0x0,%al
  8206c1:	89 c2                	mov    %eax,%edx
  8206c3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8206c6:	09 d0                	or     %edx,%eax
  8206c8:	0f b7 c0             	movzwl %ax,%eax
  8206cb:	89 c7                	mov    %eax,%edi
  8206cd:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  8206d4:	00 00 00 
  8206d7:	ff d0                	callq  *%rax
  8206d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8206dd:	66 89 02             	mov    %ax,(%rdx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8206e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8206e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8206e8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8206ec:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8206f0:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8206f4:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8206f9:	48 89 c6             	mov    %rax,%rsi
  8206fc:	48 89 cf             	mov    %rcx,%rdi
  8206ff:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  820706:	00 00 00 
  820709:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  82070b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82070f:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820715:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820719:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  82071d:	0f b7 d0             	movzwl %ax,%edx
  820720:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820724:	89 d6                	mov    %edx,%esi
  820726:	48 89 c7             	mov    %rax,%rdi
  820729:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  820730:	00 00 00 
  820733:	ff d0                	callq  *%rax
  820735:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820739:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  82073d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820741:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820749:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82074f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820755:	b9 ff 00 00 00       	mov    $0xff,%ecx
  82075a:	be 00 00 00 00       	mov    $0x0,%esi
  82075f:	48 89 c7             	mov    %rax,%rdi
  820762:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  820769:	00 00 00 
  82076c:	ff d0                	callq  *%rax
  pbuf_free(q);
  82076e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820772:	48 89 c7             	mov    %rax,%rdi
  820775:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  82077c:	00 00 00 
  82077f:	ff d0                	callq  *%rax
}
  820781:	c9                   	leaveq 
  820782:	c3                   	retq   

0000000000820783 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820783:	55                   	push   %rbp
  820784:	48 89 e5             	mov    %rsp,%rbp
  820787:	48 83 ec 30          	sub    $0x30,%rsp
  82078b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  82078f:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820792:	ba 00 00 00 00       	mov    $0x0,%edx
  820797:	be 24 00 00 00       	mov    $0x24,%esi
  82079c:	bf 01 00 00 00       	mov    $0x1,%edi
  8207a1:	48 b8 40 d3 80 00 00 	movabs $0x80d340,%rax
  8207a8:	00 00 00 
  8207ab:	ff d0                	callq  *%rax
  8207ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  8207b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8207b6:	75 05                	jne    8207bd <icmp_time_exceeded+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  8207b8:	e9 60 01 00 00       	jmpq   82091d <icmp_time_exceeded+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8207bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8207c1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8207c5:	66 83 f8 23          	cmp    $0x23,%ax
  8207c9:	77 2a                	ja     8207f5 <icmp_time_exceeded+0x72>
  8207cb:	48 ba a8 3b 82 00 00 	movabs $0x823ba8,%rdx
  8207d2:	00 00 00 
  8207d5:	be 1e 01 00 00       	mov    $0x11e,%esi
  8207da:	48 bf cb 3a 82 00 00 	movabs $0x823acb,%rdi
  8207e1:	00 00 00 
  8207e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8207e9:	48 b9 4e 11 80 00 00 	movabs $0x80114e,%rcx
  8207f0:	00 00 00 
  8207f3:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8207f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8207f9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8207fd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  820801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820805:	48 8b 40 08          	mov    0x8(%rax),%rax
  820809:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  82080d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820811:	0f b7 00             	movzwl (%rax),%eax
  820814:	0f b7 c0             	movzwl %ax,%eax
  820817:	89 c7                	mov    %eax,%edi
  820819:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  820820:	00 00 00 
  820823:	ff d0                	callq  *%rax
  820825:	0f b6 c0             	movzbl %al,%eax
  820828:	80 cc 0b             	or     $0xb,%ah
  82082b:	0f b7 c0             	movzwl %ax,%eax
  82082e:	89 c7                	mov    %eax,%edi
  820830:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  820837:	00 00 00 
  82083a:	ff d0                	callq  *%rax
  82083c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820840:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(tehdr, t);
  820843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820847:	0f b7 00             	movzwl (%rax),%eax
  82084a:	0f b7 c0             	movzwl %ax,%eax
  82084d:	89 c7                	mov    %eax,%edi
  82084f:	48 b8 11 2f 81 00 00 	movabs $0x812f11,%rax
  820856:	00 00 00 
  820859:	ff d0                	callq  *%rax
  82085b:	b0 00                	mov    $0x0,%al
  82085d:	89 c2                	mov    %eax,%edx
  82085f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820862:	09 d0                	or     %edx,%eax
  820864:	0f b7 c0             	movzwl %ax,%eax
  820867:	89 c7                	mov    %eax,%edi
  820869:	48 b8 ee 2e 81 00 00 	movabs $0x812eee,%rax
  820870:	00 00 00 
  820873:	ff d0                	callq  *%rax
  820875:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820879:	66 89 02             	mov    %ax,(%rdx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  82087c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820880:	48 8b 40 08          	mov    0x8(%rax),%rax
  820884:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820888:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  82088c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820890:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820895:	48 89 c6             	mov    %rax,%rsi
  820898:	48 89 cf             	mov    %rcx,%rdi
  82089b:	48 b8 77 23 80 00 00 	movabs $0x802377,%rax
  8208a2:	00 00 00 
  8208a5:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  8208a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8208ab:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8208b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8208b5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8208b9:	0f b7 d0             	movzwl %ax,%edx
  8208bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8208c0:	89 d6                	mov    %edx,%esi
  8208c2:	48 89 c7             	mov    %rax,%rdi
  8208c5:	48 b8 e0 29 81 00 00 	movabs $0x8129e0,%rax
  8208cc:	00 00 00 
  8208cf:	ff d0                	callq  *%rax
  8208d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8208d5:	66 89 42 02          	mov    %ax,0x2(%rdx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8208d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8208dd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8208e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8208e5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8208eb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8208f1:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8208f6:	be 00 00 00 00       	mov    $0x0,%esi
  8208fb:	48 89 c7             	mov    %rax,%rdi
  8208fe:	48 b8 a8 14 81 00 00 	movabs $0x8114a8,%rax
  820905:	00 00 00 
  820908:	ff d0                	callq  *%rax
  pbuf_free(q);
  82090a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82090e:	48 89 c7             	mov    %rax,%rdi
  820911:	48 b8 1f dc 80 00 00 	movabs $0x80dc1f,%rax
  820918:	00 00 00 
  82091b:	ff d0                	callq  *%rax
}
  82091d:	c9                   	leaveq 
  82091e:	c3                   	retq   
